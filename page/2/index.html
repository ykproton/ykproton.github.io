<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat-logo.jpg">
  <link rel="mask-icon" href="/images/cat-logo.jpg" color="#222">






  
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="ykproton">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="ykproton">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chenyk">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;2&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>ykproton</title>
  




  <noscript>
    
  </noscript>
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ykproton</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chenyk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ykproton" title="GitHub → https://github.com/ykproton" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/24567.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/24567.html" class="post-title-link" itemprop="url">4.7 Acuator: 审计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:25:00 / 修改时间：13:05:50" itemprop="dateCreated datePublished" datetime="2021-06-10T12:25:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/24567.html" class="post-meta-item leancloud_visitors" data-flag-title="4.7 Acuator: 审计" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>598</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol start="7">
<li><h5 id="审计-Auditing"><a href="#审计-Auditing" class="headerlink" title="审计(Auditing)"></a>审计(Auditing)</h5><p>一旦 Spring Security 发挥作用,Spring Boot Actuator 就有一个灵活的审计框架来发布事件( 默认情况下,”authentication success”,”failure”和”access denied”异常).此功能对于报告和实施基于身份验证失败的锁定策略非常有用.</p>
<p>可以通过在应用配置中提供类型为 <code>AuditEventRepository</code> 的 bean 来启用审计.为方便起见,Spring Boot 提供了一个 <code>InMemoryAuditEventRepository</code>.<code>InMemoryAuditEventRepository</code> 的功能有限,建议仅将其用于开发环境.对于生产环境,请考虑创建自己的替代 <code>AuditEventRepository</code> 实现.</p>
<ol>
<li><h6 id="Custom-Auditing"><a href="#Custom-Auditing" class="headerlink" title="Custom Auditing"></a>Custom Auditing</h6><p>要自定义发布的安全事件,可以提供自己的 <code>AbstractAuthenticationAuditListener</code> 和 <code>AbstractAuthorizationAuditListener</code> 实现.</p>
<p>还可以将审计服务用于自己的业务事件.为此,请将 <code>AuditEventRepository</code> bean 注入自己的组件并直接使用它,或者使用 Spring <code>ApplicationEventPublisher</code>( 通过实现 <code>ApplicationEventPublisherAware</code>)发布 <code>AuditApplicationEvent</code>.</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/47604.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/47604.html" class="post-title-link" itemprop="url">4.6 Acuator: Metrics</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:23:58 / 修改时间：12:50:57" itemprop="dateCreated datePublished" datetime="2021-06-10T12:23:58+08:00">2021-06-10</time>
    </span>

  
    <span id="/posts/47604.html" class="post-meta-item leancloud_visitors" data-flag-title="4.6 Acuator: Metrics" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol start="6">
<li><h5 id="检测-Metrics"><a href="#检测-Metrics" class="headerlink" title="检测(Metrics)"></a>检测(Metrics)</h5><p>Spring Boot Actuator 为 <code>Micrometer</code> 提供依赖管理和自动配置,支持众多监控系统的应用Metrics facade ,包括:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.appoptics">AppOptics</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.atlas">Atlas</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.datadog">Datadog</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.dynatrace">Dynatrace</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.elastic">Elastic</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.ganglia">Ganglia</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.graphite">Graphite</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.humio">Humio</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.influx">Influx</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.jmx">JMX</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.kairos">KairosDB</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.newrelic">New Relic</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.prometheus">Prometheus</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.signalfx">SignalFx</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.simple">Simple (in-memory)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.stackdriver">Stackdriver</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.statsd">StatsD</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.wavefront">Wavefront</a></p>
<blockquote>
<p>建议:</p>
<p>​    要了解有关 Micrometer 功能的更多信息,请参阅其 <a target="_blank" rel="noopener" href="https://micrometer.io/docs">参考文档</a>,尤其是 <a target="_blank" rel="noopener" href="https://micrometer.io/docs/concepts">概念部分</a>.</p>
</blockquote>
</li>
</ul>
<ol>
<li><h6 id="开始-Getting-started"><a href="#开始-Getting-started" class="headerlink" title="开始(Getting started)"></a>开始(Getting started)</h6><p>Spring Boot 自动配置一个复合 <code>MeterRegistry</code> ,并为类路径上每个受支持的实现注册到复合中.在运行时classpath中依赖 <code>micrometer-registry-{system}</code> 足以让 Spring Boot 配置registry.</p>
<p>大多数注册中心都有共同的特征. 例如,即使 <code>Micrometer</code> registry实现在类路径上,也可以禁用特定registry. 例如,禁用 Datadog:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.datadog.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>还可以禁用所有registry,除非registry特定属性另有说明,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.defaults.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>Spring Boot 还将所有自动配置的registry添加到 <code>Metrics</code> 类上的全局静态复合registry,除非明确告诉它不要:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.use-global-registry</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以注册任意数量的 <code>MeterRegistryCustomizer</code> bean 以进一步配置registry,例如应用公共标签,然后再向registry注册任何meters:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMeterRegistryConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MeterRegistryCustomizer&lt;MeterRegistry&gt; <span class="title">metricsCommonTags</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (registry) -&gt; registry.config().commonTags(<span class="string">"region"</span>, <span class="string">"us-east-1"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以通过更具体地了解泛型类型,将自定义应用于特定的registry实现:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMeterRegistryConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MeterRegistryCustomizer&lt;GraphiteMeterRegistry&gt; <span class="title">graphiteMetricsNamingConvention</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (registry) -&gt; registry.config().namingConvention(<span class="keyword">this</span>::name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">name</span><span class="params">(String name, Meter.Type type, String baseUnit)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Spring Boot 还配置了可以通过配置或专用注解标记控制的 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.supported">built-in instrumentation</a>.</p>
</li>
<li><h6 id="支持的监控系统-Supported-Monitoring-Systems"><a href="#支持的监控系统-Supported-Monitoring-Systems" class="headerlink" title="支持的监控系统(Supported Monitoring Systems)"></a>支持的监控系统(Supported Monitoring Systems)</h6><ol>
<li><h6 id="AppOptics"><a href="#AppOptics" class="headerlink" title="AppOptics"></a>AppOptics</h6><p>默认情况下,AppOptics registry会定期将metric推送到 <code>api.appoptics.com/v1/measurements</code>. 要将指标导出到 SaaS AppOptics,必须提供 API token :</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.appoptics.api-token</span>=<span class="string">YOUR_TOKEN</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h6><p>默认情况下,metrics会导出到在本地机器上运行的 Atlas. 可以使用以下命令提供要使用的 Atlas 服务器的位置:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.atlas.uri</span>=<span class="string">https://atlas.example.com:7101/api/v1/publish</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Datadog"><a href="#Datadog" class="headerlink" title="Datadog"></a>Datadog</h6><p>Datadog registry定期将指标推送到 datadoghq. 要将指标导出到 Datadog,必须提供 API key :</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.datadog.api-key</span>=<span class="string">YOUR_KEY</span></span><br></pre></td></tr></tbody></table></figure>

<p>还可以更改指标发送到 Datadog 的时间间隔:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.datadog.step</span>=<span class="string">30s</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Dynatrace"><a href="#Dynatrace" class="headerlink" title="Dynatrace"></a>Dynatrace</h6><p>Dynatrace registry 定期将metrics 推送到配置的 URI. 要将指标导出到 Dynatrace,必须提供 API token,设备 ID 和 URI:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.dynatrace.api-token</span>=<span class="string">YOUR_TOKEN</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.device-id</span>=<span class="string">YOUR_DEVICE_ID</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.uri</span>=<span class="string">YOUR_URI</span></span><br></pre></td></tr></tbody></table></figure>

<p>还可以更改指标发送到 Dynatrace 的时间间隔:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.dynatrace.step</span>=<span class="string">30s</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Elastic"><a href="#Elastic" class="headerlink" title="Elastic"></a>Elastic</h6><p>默认情况下,指标会导出到在本地机器上运行的 Elastic. 可以使用以下属性提供要使用的Elastic 服务器的位置:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.elastic.host</span>=<span class="string">https://elastic.example.com:8086</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Ganglia"><a href="#Ganglia" class="headerlink" title="Ganglia"></a>Ganglia</h6><p>默认情况下,metrics会导出到在本地计算机上运行的 Ganglia. 要使用的 Ganglia 服务器主机和端口可以通过以下方式提供:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.ganglia.host</span>=<span class="string">ganglia.example.com</span></span><br><span class="line"><span class="meta">management.metrics.export.ganglia.port</span>=<span class="string">9649</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Graphite"><a href="#Graphite" class="headerlink" title="Graphite"></a>Graphite</h6><p>默认情况下,metrics会导出到在本地计算机上运行的 Graphite. 可以使用以下方式提供要使用的 Graphite 服务器主机和端口:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.graphite.host</span>=<span class="string">graphite.example.com</span></span><br><span class="line"><span class="meta">management.metrics.export.graphite.port</span>=<span class="string">9004</span></span><br></pre></td></tr></tbody></table></figure>

<p>Micrometer 提供了一个默认的 <code>HierarchicalNameMapper</code>,用于管理维度仪表 ID 如何映射到平面层次名称.</p>
<blockquote>
<p>建议:</p>
<p>​    要控制此行为,请定义 <code>GraphiteMeterRegistry</code> 并提供自己的 <code>HierarchicalNameMapper</code>.除非定义自己的,否则提供自动配置的 <code>GraphiteConfig</code> 和 <code>Clock bean</code>:</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGraphiteConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GraphiteMeterRegistry <span class="title">graphiteMeterRegistry</span><span class="params">(GraphiteConfig config, Clock clock)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GraphiteMeterRegistry(config, clock, <span class="keyword">this</span>::toHierarchicalName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toHierarchicalName</span><span class="params">(Meter.Id id, NamingConvention convention)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Humio"><a href="#Humio" class="headerlink" title="Humio"></a>Humio</h6><p>默认情况下,Humio registry会定期将指标推送到 <code>cloud.humio.com</code>. 要将指标导出到 SaaS Humio,必须提供 API token:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.humio.api-token</span>=<span class="string">YOUR_TOKEN</span></span><br></pre></td></tr></tbody></table></figure>

<p>还应该配置一个或多个标签来识别指标将被推送到的数据源:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.humio.tags.alpha</span>=<span class="string">a</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.tags.bravo</span>=<span class="string">b</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Influx"><a href="#Influx" class="headerlink" title="Influx"></a>Influx</h6><p>默认情况下,指标会导出到使用默认配置在本地计算机上运行的 Influx v1 实例.要将指标导出到 InfluxDB v2,请配置用于写入指标的<code>org</code>,<code>bucket</code>和身份验证<code>token</code>.可以使用以下方法提供要使用的 Influx 服务器的位置:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.influx.uri</span>=<span class="string">https://influx.example.com:8086</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h6><p>Micrometer 提供了到 JMX 的分层映射,主要是作为一种廉价且可移植的本地查看metrics的方式.默认情况下,指标导出到指标 JMX 域. 可以使用以下方式提供要使用的域:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.jmx.domain</span>=<span class="string">com.example.app.metrics</span></span><br></pre></td></tr></tbody></table></figure>

<p>Micrometer 提供了一个默认的 <code>HierarchicalNameMapper</code>,用于管理维度仪表 ID 如何映射到平面层次名称.</p>
<blockquote>
<p>建议:</p>
<p>​    要控制此行为,请定义 <code>JmxMeterRegistry</code> 并提供自己的 <code>HierarchicalNameMapper</code>.除非自己定义,否则会提供自动配置的 <code>JmxConfig </code>和 <code>Clock</code> bean:</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJmxConfiguration</span> </span>{    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> JmxMeterRegistry <span class="title">jmxMeterRegistry</span><span class="params">(JmxConfig config, Clock clock)</span> </span>{        <span class="keyword">return</span> <span class="keyword">new</span> JmxMeterRegistry(config, clock, <span class="keyword">this</span>::toHierarchicalName);    }    <span class="function"><span class="keyword">private</span> String <span class="title">toHierarchicalName</span><span class="params">(Meter.Id id, NamingConvention convention)</span> </span>{        <span class="keyword">return</span> ...    }}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="KairosDB"><a href="#KairosDB" class="headerlink" title="KairosDB"></a>KairosDB</h6><p>默认情况下,指标会导出到在本地计算机上运行的 KairosDB. 可以使用以下命令提供要使用的 KairosDB 服务器的位置:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.kairos.uri</span>=<span class="string">https://kairosdb.example.com:8080/api/v1/datapoints</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="New-Relic"><a href="#New-Relic" class="headerlink" title="New Relic"></a>New Relic</h6><p>New Relic registry定期将指标推送到 New Relic. 要将指标导出到 New Relic,必须提供 API key和帐户 ID:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.newrelic.api-key</span>=<span class="string">YOUR_KEY</span></span><br><span class="line"><span class="meta">management.metrics.export.newrelic.account-id</span>=<span class="string">YOUR_ACCOUNT_ID</span></span><br></pre></td></tr></tbody></table></figure>

<p>还可以更改指标发送到 New Relic 的时间间隔:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.newrelic.step</span>=<span class="string">30s</span></span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下,metrics 是通过 REST 调用发布的,但也可以使用 Java 代理 API,如果在类路径上有它:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.newrelic.client-provider-type</span>=<span class="string">insights-agent</span></span><br></pre></td></tr></tbody></table></figure>

<p>最后,可以通过定义自己的 <code>NewRelicClientProvider</code> bean 来完全控制.</p>
</li>
<li><h6 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h6><p>Prometheus 期望抓取或轮询单个应用程序实例以获取metrics.Spring Boot 在 <code>/actuator/prometheus</code> 提供了一个可用的actuator endpoint,以显示具有适当格式的 <code>Prometheus</code> 抓取.</p>
<blockquote>
<p>建议:</p>
<p>​    endpoint默认不可用,必须公开.</p>
</blockquote>
<p>这是添加到 <code>prometheus.yml</code> 的 <code>scrape_config</code>示例:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'spring'</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">'/actuator/prometheus'</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">'HOST:PORT'</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>对于可能存在时间不够长而无法抓取的临时或批处理作业,可以使用 Prometheus Pushgateway 将其metrics 公开给 Prometheus.要启用 Prometheus Pushgateway 支持,将以下依赖项添加到项目中:</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_pushgateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>当类路径上存在 Prometheus Pushgateway 依赖项并且 <code>management.metrics.export.prometheus.pushgateway.enabled</code> 属性设置为 <code>true</code> 时,会自动配置 <code>PrometheusPushGatewayManager</code> bean.这管理将指标推送到 Prometheus Pushgateway.</p>
<p><code>PrometheusPushGatewayManager</code> 可以使用 <code>management.metrics.export.prometheus.pushgateway</code> 下的属性进行调整.对于高级配置,还可以提供自己的 <code>PrometheusPushGatewayManager</code> bean.</p>
</li>
<li><h6 id="SignalFx"><a href="#SignalFx" class="headerlink" title="SignalFx"></a>SignalFx</h6><p>SignalFx registry定期将指标推送到 SignalFx. 要将指标导出到 SignalFx,必须提供的access token:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.signalfx.access-token</span>=<span class="string">YOUR_ACCESS_TOKEN</span></span><br></pre></td></tr></tbody></table></figure>

<p>还可以更改指标发送到 SignalFx 的时间间隔:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.signalfx.step</span>=<span class="string">30s</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h6><p>Micrometer 附带一个简单的内存后端,如果没有配置其他registry,它会自动作为备用. 这使可以查看<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.endpoint">metrics endpoint</a>中收集了哪些metrics .</p>
<p>只要使用任何其他可用后端,内存后端就会自行禁用. 还可以明确禁用它:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.simple.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Stackdriver"><a href="#Stackdriver" class="headerlink" title="Stackdriver"></a>Stackdriver</h6><p>Stackdriver registry会定期将指标推送到 Stackdriver. 要将指标导出到 SaaS Stackdriver,必须提供 Google Cloud project  ID:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.stackdriver.project-id</span>=<span class="string">my-project</span></span><br></pre></td></tr></tbody></table></figure>

<p>还可以更改指标发送到 Stackdriver 的时间间隔:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.stackdriver.step</span>=<span class="string">30s</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="StatsD"><a href="#StatsD" class="headerlink" title="StatsD"></a>StatsD</h6><p>StatsD registry地通过 UDP 将指标快速地推送到 StatsD 代理.默认情况下,指标会导出到在本地计算机上运行的 StatsD 代理. 要使用的 StatsD 代理主机,端口和协议可以通过以下方式提供:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.statsd.host</span>=<span class="string">statsd.example.com</span></span><br><span class="line"><span class="meta">management.metrics.export.statsd.port</span>=<span class="string">9125</span></span><br><span class="line"><span class="meta">management.metrics.export.statsd.protocol</span>=<span class="string">udp</span></span><br></pre></td></tr></tbody></table></figure>

<p>还可以更改要使用的 StatsD 线路协议(默认为 Datadog):</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.statsd.flavor</span>=<span class="string">etsy</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Wavefront"><a href="#Wavefront" class="headerlink" title="Wavefront"></a>Wavefront</h6><p>Wavefront registry定期将指标推送到 Wavefront. 如果直接将指标导出到 Wavefront,则必须提供 API token :</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.wavefront.api-token</span>=<span class="string">YOUR_API_TOKEN</span></span><br></pre></td></tr></tbody></table></figure>

<p>或者,可以使用 Wavefront sidecar 或在环境中设置的内部代理,将指标数据转发到 Wavefront API 主机:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.wavefront.uri</span>=<span class="string">proxy://localhost:2878</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果将指标发布到 Wavefront 代理,则主机必须采用 <code>proxy://HOST:PORT</code> 格式.</p>
</blockquote>
<p>还可以更改指标发送到 Wavefront 的时间间隔:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.wavefront.step</span>=<span class="string">30s</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><h6 id="支持的Metrics和Meters-Supported-Metrics-and-Meters"><a href="#支持的Metrics和Meters-Supported-Metrics-and-Meters" class="headerlink" title="支持的Metrics和Meters(Supported Metrics and Meters)"></a>支持的Metrics和Meters(Supported Metrics and Meters)</h6><p>Spring Boot 为各种技术提供自动仪表注册.在大多数情况下,开箱即用的默认值将提供可发布的合理指标给到所有支持的监控系统.</p>
<ol>
<li><h6 id="JVM-Metrics"><a href="#JVM-Metrics" class="headerlink" title="JVM Metrics"></a>JVM Metrics</h6><p>自动配置将使用核心 Micrometer 类启用 JVM 指标. JVM 指标发布在 <code>jvm.</code> meter名下.</p>
<p>提供了以下 JVM 指标:</p>
<ul>
<li>各种内存和缓冲池详细信息</li>
<li>与垃圾回收相关的统计信息</li>
<li>线程利用率</li>
<li>加载/卸载的类数</li>
</ul>
</li>
<li><h6 id="System-Metrics"><a href="#System-Metrics" class="headerlink" title="System Metrics"></a>System Metrics</h6><p>自动配置将使用核心 Micrometer 类启用系统指标. 系统指标在<code>system.</code>和<code>process.</code>meter names下发布.</p>
<p>提供了以下系统指标:</p>
<ul>
<li>CPU 指标</li>
<li>文件描述符指标</li>
<li>正常运行时间指标(应用程序运行的时间量以及绝对启动时间的固定量表)</li>
</ul>
</li>
<li><h6 id="Logger-Metrics"><a href="#Logger-Metrics" class="headerlink" title="Logger Metrics"></a>Logger Metrics</h6><p>自动配置为 Logback 和 Log4J2 启用事件指标. 详细信息发布在 <code>log4j2.events.</code> 或 <code>logback.events.</code> meter 名下.</p>
</li>
<li><h6 id="Spring-MVC-Metrics"><a href="#Spring-MVC-Metrics" class="headerlink" title="Spring MVC Metrics"></a>Spring MVC Metrics</h6><p>自动配置启用对 Spring MVC controller和函数式程序处理的所有请求的检测.默认情况下,metric生成的名称为 <code>http.server.requests</code>.可以通过设置 <code>management.metrics.web.server.request.metric-name</code> 属性来自定义名称.</p>
<p><code>@Controller</code> 类和 <code>@RequestMapping</code> 方法支持 <code>@Timed</code> 注解.如果不想记录所有 Spring MVC 请求的指标,可以将 <code>management.metrics.web.server.request.autotime.enabled</code> 设置为 <code>false</code> 并使用 <code>@Timed</code> 注解.</p>
<p>默认情况下,Spring MVC 相关metrics标记有以下信息:</p>
<table>
<thead>
<tr>
<th><strong>Tag</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>exception</code></td>
<td>处理请求时抛出的任何异常的简单类名。</td>
</tr>
<tr>
<td><code>method</code></td>
<td>请求的方法（例如，<code>GET</code> 或 <code>POST</code>）</td>
</tr>
<tr>
<td><code>outcome</code></td>
<td>请求的结果基于响应的状态代码。 1xx 是“<code>INFORMATIONAL</code>”，2xx 是“<code>SUCCESS</code>”，3xx 是“<code>REDIRECTION</code>”，4xx 是“<code>CLIENT_ERROR</code>”，5xx 是“<code>SERVER_ERROR</code>”</td>
</tr>
<tr>
<td><code>status</code></td>
<td>响应的 HTTP 状态代码（例如，<code>200</code> 或 <code>500</code>）</td>
</tr>
<tr>
<td><code>uri</code></td>
<td>如果可能，在变量替换之前请求的 URI 模板（例如，<code>/api/person/{id}</code>）</td>
</tr>
</tbody></table>
<p>要添加到默认标签,请提供一个或多个实现 <code>WebMvcTagsContributor</code> 的 <code>@Bean</code>.要替换默认标签,请提供一个实现 <code>WebMvcTagsProvider</code> 的 <code>@Bean</code>.</p>
<blockquote>
<p>建议:</p>
<p>​    在某些情况下,Web 控制器中处理的异常不会记录为请求指标标记.应用可以通过将处理的异常设置为请求属性来选择加入和记录异常.</p>
</blockquote>
</li>
<li><h6 id="Spring-WebFlux-Metrics"><a href="#Spring-WebFlux-Metrics" class="headerlink" title="Spring WebFlux Metrics"></a>Spring WebFlux Metrics</h6><p>自动配置启用对 Spring WebFlux controller和functional handler的所有请求的检测.默认情况下,metrics生成的名称为 <code>http.server.requests</code>.可以通过设置 <code>management.metrics.web.server.request.metric-name</code> 属性来自定义名称.</p>
<p><code>@Controller</code> 类和 <code>@RequestMapping</code> 方法支持 <code>@Timed</code> 注解.如果不想记录所有 Spring WebFlux 请求的metrics ,可以将 <code>management.metrics.web.server.request.autotime.enabled</code> 设置为 <code>false</code> 并使用 <code>@Timed</code> 注解.</p>
<p>默认情况下,WebFlux 相关metrics 标记有以下信息:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>exception</code></td>
<td>处理请求时抛出的任何异常的简单类名。</td>
<td></td>
</tr>
<tr>
<td><code>method</code></td>
<td>请求的方法（例如，<code>GET</code> 或 <code>POST</code>）</td>
<td></td>
</tr>
<tr>
<td><code>outcome</code></td>
<td>请求的结果基于响应的状态代码。 1xx 是“<code>INFORMATIONAL</code>”，2xx 是“<code>SUCCESS</code>”，3xx 是“<code>REDIRECTION</code>”，4xx 是“<code>CLIENT_ERROR</code>”，5xx 是“<code>SERVER_ERROR</code>”</td>
<td></td>
</tr>
<tr>
<td><code>status</code></td>
<td>响应的 HTTP 状态代码（例如，<code>200</code> 或 <code>500</code>）</td>
<td></td>
</tr>
<tr>
<td><code>uri</code></td>
<td>如果可能，在变量替换之前请求的 URI 模板（例如，<code>/api/person/{id}</code>）</td>
<td></td>
</tr>
</tbody></table>
<p>要添加到默认标签,提供一个或多个实现 <code>WebFluxTagsContributor</code> 的 <code>@Bean</code>. 要替换默认标签,提供一个实现 <code>WebFluxTagsProvider</code> 的 <code>@Bean</code>.</p>
<blockquote>
<p>建议:</p>
<p>​    在某些情况下,controller和handler函数中处理的异常不会作为request metrics tags 记录.应用程序可以将异常设为请求属性来选择加入和记录异常.</p>
</blockquote>
</li>
<li><h6 id="Jersey-Server-Metrics"><a href="#Jersey-Server-Metrics" class="headerlink" title="Jersey Server Metrics"></a>Jersey Server Metrics</h6><p>只要 Micrometer 的 <code>micrometer-jersey2</code> 模块在类路径上,自动配置就会启用检测Jersey JAX-RS 实现所处理的所有请求的.默认情况下,metrics 生成的名称为 <code>http.server.requests</code>. 可以通过设置 <code>management.metrics.web.server.request.metric-name</code> 属性来自定义名称.</p>
<p>请求处理类和方法支持<code>@Timed</code> 注解.如果不想记录所有 Jersey 请求的指标,可以将 <code>management.metrics.web.server.request.autotime.enabled</code> 设置为 <code>false</code> 并专门使用 <code>@Timed</code> 注解.</p>
<p>默认情况下,Jersey 服务器指标标记有以下信息:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>exception</code></td>
<td>处理请求时抛出的任何异常的简单类名。</td>
</tr>
<tr>
<td><code>method</code></td>
<td>请求的方法（例如，<code>GET</code> 或 <code>POST</code>）</td>
</tr>
<tr>
<td><code>outcome</code></td>
<td>请求的结果基于响应的状态代码。 1xx 是“<code>INFORMATIONAL</code>”，2xx 是“<code>SUCCESS</code>”，3xx 是“<code>REDIRECTION</code>”，4xx 是“<code>CLIENT_ERROR</code>”，5xx 是“<code>SERVER_ERROR</code>”</td>
</tr>
<tr>
<td><code>status</code></td>
<td>响应的 HTTP 状态代码（例如，<code>200</code> 或 <code>500</code>）</td>
</tr>
<tr>
<td><code>uri</code></td>
<td>如果可能，在变量替换之前请求的 URI 模板（例如，<code>/api/person/{id}</code>）</td>
</tr>
</tbody></table>
<p>要自定义标签,请提供一个实现 JerseyTagsProvider 的 <code>@Bean</code>.</p>
</li>
<li><h6 id="HTTP-Client-Metrics"><a href="#HTTP-Client-Metrics" class="headerlink" title="HTTP Client Metrics"></a>HTTP Client Metrics</h6><p>Spring Boot Actuator 管理 <code>RestTemplate</code> 和 <code>WebClient</code> 的检测.为此,必须注入自动配置的builder并使用它来创建实例:</p>
<ul>
<li><code>RestTemplateBuilder</code> 用于 <code>RestTemplate</code></li>
<li><code>WebClient.Builder</code> 用于 <code>WebClient</code></li>
</ul>
<p>也可以手动应用负责此检测的定制器,即 <code>MetricsRestTemplateCustomizer</code> 和 <code>MetricsWebClientCustomizer</code>.</p>
<p>默认情况下,metrics生成的名称为 <code>http.client.requests</code>. 可以通过设置 <code>management.metrics.web.client.request.metric-name</code> 属性来自定义名称.</p>
<p>默认情况下,由检测客户端生成的metrics 标记有以下信息:</p>
<table>
<thead>
<tr>
<th><strong>Tag</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>exception</code></td>
<td>处理请求时抛出的任何异常的简单类名。</td>
</tr>
<tr>
<td><code>method</code></td>
<td>请求的方法（例如，<code>GET</code> 或 <code>POST</code>）</td>
</tr>
<tr>
<td><code>outcome</code></td>
<td>请求的结果基于响应的状态代码。 1xx 是“<code>INFORMATIONAL</code>”，2xx 是“<code>SUCCESS</code>”，3xx 是“<code>REDIRECTION</code>”，4xx 是“<code>CLIENT_ERROR</code>”，5xx 是“<code>SERVER_ERROR</code>”</td>
</tr>
<tr>
<td><code>status</code></td>
<td>响应的 HTTP 状态代码（例如，<code>200</code> 或 <code>500</code>）</td>
</tr>
<tr>
<td><code>uri</code></td>
<td>如果可能，在变量替换之前请求的 URI 模板（例如，<code>/api/person/{id}</code>）</td>
</tr>
</tbody></table>
<p>要自定义标签,并根据客户端,可以提供一个实现 <code>RestTemplateExchangeTagsProvider</code> 或 <code>WebClientExchangeTagsProvider</code> 的 <code>@Bean</code>.<code>RestTemplateExchangeTags</code> 和 <code>WebClientExchangeTags</code> 中提供有方便的静态函数.</p>
</li>
<li><h6 id="Tomcat-Metrics"><a href="#Tomcat-Metrics" class="headerlink" title="Tomcat Metrics"></a>Tomcat Metrics</h6><p>仅当启用 <code>MBeanRegistry</code> 时,自动配置才会启用 Tomcat 的检测.默认情况下,<code>MBeanRegistry</code> 是禁用的,但可以通过将 <code>server.tomcat.mbeanregistry.enabled</code> 设置为 <code>true</code> 来启用它.</p>
<p>metric tomcat的发布在<code>tomcat.</code> meter名下.</p>
</li>
<li><h6 id="Cache-Metrics"><a href="#Cache-Metrics" class="headerlink" title="Cache Metrics"></a>Cache Metrics</h6><p>使用<code>cache</code>为前缀的metrics 启动时,自动配置在启动时启用所有可用的<code>Cache</code>的检测.缓存检测是针对基本metric进行标准化的. 还可以使用其他特定于缓存的指标.</p>
<p>支持以下缓存库:</p>
<ul>
<li>Caffeine</li>
<li>EhCache 2</li>
<li>Hazelcast</li>
<li>Any compliant JCache (JSR-107) implementation</li>
<li>Redis</li>
</ul>
<p>Metrics 由缓存的名称和从 bean name派生的 <code>CacheManager</code> 的名称标记.</p>
<blockquote>
<p>注意:</p>
<p>​    只有在启动时配置的缓存才会绑定到registry.对于缓存配置中未定义的缓存,例如 在启动阶段后即时或以编程方式创建的缓存,需要显式注册.<code>CacheMetricsRegistrar</code> bean 可用于简化该过程.</p>
</blockquote>
</li>
<li><h6 id="DataSource-Metrics"><a href="#DataSource-Metrics" class="headerlink" title="DataSource Metrics"></a>DataSource Metrics</h6><p>自动配置启用对所有可用 <code>DataSource</code> 对象的检测,其metrics 以 <code>jdbc.connections</code> 为前缀.数据源检测会产生表示池中当前活动,空闲,最大允许和最小允许连接的仪表.</p>
<p>Metrics 也由基于 bean 名称计算得出的 <code>DataSource</code> 的名称标记.</p>
<blockquote>
<p>建议:</p>
<p>​    默认情况下,Spring Boot 为所有支持的数据源提供元数据； 如果最喜欢的数据源不支持开箱即用,可以添加额外的 <code>DataSourcePoolMetadataProvider</code>bean. 有关示例,请参阅 <code>DataSourcePoolMetadataProvidersConfiguration</code>.</p>
</blockquote>
<p>此外,特定于 Hikari 的metrics以 <code>hikaricp</code> 前缀公开. 每个指标都由池的名称标记(可以用 <code>spring.datasource.name</code> 控制).</p>
</li>
<li><h6 id="Hibernate-Metrics"><a href="#Hibernate-Metrics" class="headerlink" title="Hibernate Metrics"></a>Hibernate Metrics</h6><p>如果 <code>org.hibernate:hibernate-micrometer</code> 在类路径上,则所有启用了统计信息的可用 Hibernate <code>EntityManagerFactory</code> 实例都使用名为 <code>hibernate</code> 的metric 进行检测.</p>
<p>Metrics 也由从 bean 名称派生的 <code>EntityManagerFactory</code> 的名称标记.</p>
<p>要启用统计信息,标准 JPA 属性 <code>hibernate.generate_statistics</code> 必须设置为 <code>true</code>. 可以在自动配置的 <code>EntityManagerFactory</code> 上启用它,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jpa.properties[hibernate.generate_statistics]</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Spring-Data-Repository-Metrics"><a href="#Spring-Data-Repository-Metrics" class="headerlink" title="Spring Data Repository Metrics"></a>Spring Data Repository Metrics</h6><p>自动配置启用检测,来检测所有对 Spring Data <code>Repository</code> 方法的调用.默认情况下,metrics生成的名称为 <code>spring.data.repository.invocations</code>.可以通过设置 <code>management.metrics.data.repository.metric-name</code> 属性来自定义名称.</p>
<p><code>Repository</code> 类和方法支持 <code>@Timed</code> 注解. 如果不想记录所有的 <code>Repository</code> 调用的metrics ,可以将 <code>management.metrics.data.repository.autotime.enabled</code> 设置为 <code>false</code> 并使用独有的 <code>@Timed</code> 注解.</p>
<p>默认情况下,存储库调用相关metrics标记有以下信息:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>repository</code></td>
<td>源 <code>Repository</code> 的简单类名.</td>
</tr>
<tr>
<td><code>method</code></td>
<td>被调用的 <code>Repository</code> 方法的名称.</td>
</tr>
<tr>
<td><code>state</code></td>
<td>结果状态(<code>SUCCESS</code>,<code>ERROR</code>,<code>CANCELED</code> 或<code>RUNNING</code>).</td>
</tr>
<tr>
<td><code>exception</code></td>
<td>从调用中抛出的任何异常的简单类名.</td>
</tr>
</tbody></table>
<p>要替换默认标签,请提供一个实现 <code>RepositoryTagsProvider</code> 的 <code>@Bean</code>.</p>
</li>
<li><h6 id="RabbitMQ-Metrics"><a href="#RabbitMQ-Metrics" class="headerlink" title="RabbitMQ Metrics"></a>RabbitMQ Metrics</h6><p>自动配置将使用名为 <code>rabbitmq</code> 的metric,从而来启用所有可用 RabbitMQ 连接工厂的instrumentation.</p>
</li>
<li><h6 id="Spring-Integration-Metrics"><a href="#Spring-Integration-Metrics" class="headerlink" title="Spring Integration Metrics"></a>Spring Integration Metrics</h6><p>只要 <code>MeterRegistry</code> bean 可用,Spring Integration 就会自动提供 Micrometer 支持. Metrics 发布在 <code>spring.integration.</code> 下meter name名.</p>
</li>
<li><h6 id="Kafka-Metrics"><a href="#Kafka-Metrics" class="headerlink" title="Kafka Metrics"></a>Kafka Metrics</h6><p>自动配置会分别为自动配置的consumer factory和producer factory注册一个 <code>MicrometerConsumerListener</code> 和 MicrometerProducerListener<code>.还将为</code>StreamsBuilderFactoryBean<code>注册一个</code>KafkaStreamsMicrometerListener`.</p>
</li>
<li><h6 id="MongoDB-Metrics"><a href="#MongoDB-Metrics" class="headerlink" title="MongoDB Metrics"></a>MongoDB Metrics</h6><h6 id="Command-Metrics"><a href="#Command-Metrics" class="headerlink" title="Command Metrics"></a>Command Metrics</h6><p>自动配置将向自动配置的 <code>MongoClient</code> 注册一个 <code>MongoMetricsCommandListener</code>.</p>
<p>为将命令发送给 MongoDB 的底层驱动,会创建一个名为 <code>mongodb.driver.commands</code> 的计时器metric .默认情况下,每个metric 都标有以下信息:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>command</code></td>
<td>发出的命令名称</td>
</tr>
<tr>
<td><code>cluster.id</code></td>
<td>命令被发送到的集群的标识符</td>
</tr>
<tr>
<td><code>server.address</code></td>
<td>命令发送到的服务器地址</td>
</tr>
<tr>
<td><code>status</code></td>
<td>命令的结果 - (<code>SUCCESS</code>, <code>FAILED</code>) 之一</td>
</tr>
</tbody></table>
<p>要替换默认metric标签,定义一个 <code>MongoCommandTagsProvider</code> bean,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommandTagsProviderConfiguration</span> </span>{    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> MongoCommandTagsProvider <span class="title">customCommandTagsProvider</span><span class="params">()</span> </span>{        <span class="keyword">return</span> <span class="keyword">new</span> CustomCommandTagsProvider();    }}</span><br></pre></td></tr></tbody></table></figure>

<p>要禁用自动配置的command metrics,请设置以下属性:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.mongo.command.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure>

<h6 id="Connection-Pool-Metrics"><a href="#Connection-Pool-Metrics" class="headerlink" title="Connection Pool Metrics"></a>Connection Pool Metrics</h6><p>自动配置将向自动配置的 <code>MongoClient</code> 注册一个 <code>MongoMetricsConnectionPoolListener</code>.</p>
<p>为连接池创建了以下仪表metrics :</p>
<ul>
<li><code>mongodb.driver.pool.size</code> 报告连接池的当前大小,包括空闲和使用中的成员</li>
<li><code>mongodb.driver.pool.checkedout</code> 报告当前使用的连接数</li>
<li><code>mongodb.driver.pool.waitqueuesize</code> 报告池中连接的等待队列的当前大小</li>
</ul>
<p>默认情况下,每个metric 都标有以下信息:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>cluster.id</code></td>
<td>连接池对应的集群标识</td>
</tr>
<tr>
<td><code>server.address</code></td>
<td>连接池对应的服务器地址</td>
</tr>
</tbody></table>
<p>要替换默认metric 标签,定义一个 <code>MongoConnectionPoolTagsProvider</code> bean,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConnectionPoolTagsProviderConfiguration</span> </span>{    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> MongoConnectionPoolTagsProvider <span class="title">customConnectionPoolTagsProvider</span><span class="params">()</span> </span>{        <span class="keyword">return</span> <span class="keyword">new</span> CustomConnectionPoolTagsProvider();    }}</span><br></pre></td></tr></tbody></table></figure>

<p>要禁用自动配置的连接池metrics,设置以下属性:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.mongo.connectionpool.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Timed-注解支持"><a href="#Timed-注解支持" class="headerlink" title="@Timed 注解支持"></a>@Timed 注解支持</h6><p><code>io.micrometer.core.annotation</code> 包中的<code>@Timed</code> 注解可以与上面列出的几种支持的技术一起使用.如果支持,注解可以在类级别或方法级别使用.</p>
<p>例如,以下代码显示了如何使用注解来检测 <code>@RestController</code> 中的所有请求映射:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="meta">@Timedpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>{    <span class="meta">@GetMapping("/api/addresses")</span>    <span class="function"><span class="keyword">public</span> List&lt;Address&gt; <span class="title">listAddress</span><span class="params">()</span> </span>{        <span class="keyword">return</span> ...    }    <span class="meta">@GetMapping("/api/people")</span>    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">listPeople</span><span class="params">()</span> </span>{        <span class="keyword">return</span> ...    }}</span><br></pre></td></tr></tbody></table></figure>

<p>如果只想检测单个映射,则可以在方法上使用注解而不是类:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>{    <span class="meta">@GetMapping("/api/addresses")</span>    <span class="function"><span class="keyword">public</span> List&lt;Address&gt; <span class="title">listAddress</span><span class="params">()</span> </span>{        <span class="keyword">return</span> ...    }    <span class="meta">@GetMapping("/api/people")</span>    <span class="meta">@Timed</span>    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">listPeople</span><span class="params">()</span> </span>{        <span class="keyword">return</span> ...    }}</span><br></pre></td></tr></tbody></table></figure>

<p>如果想更改特定方法的计时细节,还可以组合类级别和方法级别的注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="meta">@Timedpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>{    <span class="meta">@GetMapping("/api/addresses")</span>    <span class="function"><span class="keyword">public</span> List&lt;Address&gt; <span class="title">listAddress</span><span class="params">()</span> </span>{        <span class="keyword">return</span> ...    }    <span class="meta">@GetMapping("/api/people")</span>    <span class="meta">@Timed(extraTags = { "region", "us-east-1" })</span>    <span class="meta">@Timed(value = "all.people", longTask = true)</span>    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">listPeople</span><span class="params">()</span> </span>{        <span class="keyword">return</span> ...    }}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    带有 <code>longTask = true</code> 的 <code>@Timed</code> 注解将为该方法启用长任务计时器.长任务计时器需要单独的metric名称,并且可以与短任务计时器堆叠.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="注册自定义Metrics"><a href="#注册自定义Metrics" class="headerlink" title="注册自定义Metrics"></a>注册自定义Metrics</h6><p>要注册自定义指标,请将 <code>MeterRegistry</code> 注入组件,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MeterRegistry registry)</span> </span>{        <span class="keyword">this</span>.dictionary = Dictionary.load();        registry.gauge(<span class="string">"dictionary.size"</span>, Tags.empty(), <span class="keyword">this</span>.dictionary.getWords().size());    }}</span><br></pre></td></tr></tbody></table></figure>

<p>如果metrics依赖于其他 bean,建议使用 <code>MeterBinder</code> 来注册它们,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMeterBinderConfiguration</span> </span>{    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> MeterBinder <span class="title">queueSize</span><span class="params">(Queue queue)</span> </span>{        <span class="keyword">return</span> (registry) -&gt; Gauge.builder(<span class="string">"queueSize"</span>, queue::size).register(registry);    }}</span><br></pre></td></tr></tbody></table></figure>

<p>使用 <code>MeterBinder</code> 可确保设置正确的依赖关系,并且在检索metric’值时,该 bean 可用.如果发现跨组件或应用重复检测一组metrics ,则 <code>MeterBinder</code> 实现也很有用.</p>
<blockquote>
<p>注意:</p>
<p>​    默认情况下,来自所有 <code>MeterBinder</code> bean 的metric将自动绑定到 Spring 管理的 <code>MeterRegistry</code>.</p>
</blockquote>
</li>
<li><h6 id="自定义单个Metrics"><a href="#自定义单个Metrics" class="headerlink" title="自定义单个Metrics"></a>自定义单个Metrics</h6><p>如果需要将自定义应用到特定 <code>Meter</code> 实例,可以使用 <code>io.micrometer.core.instrument.config.MeterFilter</code> 接口.</p>
<p>例如,如果要将所有以 <code>com.example</code> 开头的仪表 ID 的 <code>mytag.region</code> tag重命名为 <code>mytag.area</code>,则可以执行以下操作:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetricsFilterConfiguration</span> </span>{    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> MeterFilter <span class="title">renameRegionTagMeterFilter</span><span class="params">()</span> </span>{        <span class="keyword">return</span> MeterFilter.renameTag(<span class="string">"com.example"</span>, <span class="string">"mytag.region"</span>, <span class="string">"mytag.area"</span>);    }}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    默认情况下,所有 <code>MeterFilter</code> bean 将自动绑定到 Spring 管理的 <code>MeterRegistry</code>.确保使用 Spring 管理的 <code>MeterRegistry</code> 注册自己的metrics,而不是使用 <code>Metrics</code> 上的任何静态方法.这些使用非 Spring 管理的全局registry.</p>
</blockquote>
<ol>
<li><h6 id="Common-Tags"><a href="#Common-Tags" class="headerlink" title="Common Tags"></a>Common Tags</h6><p>常用标签一般用于对主机,实例,区域,堆栈等操作环境进行维度进行深度探讨.Commons 标签适用于所有meters,可以按照以下示例进行配置:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.tags.region</span>=<span class="string">us-east-1management.metrics.tags.stack=prod</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面的示例分别为所有值为 <code>us-east-1</code> 和 <code>prod</code> 的meter添加了 <code>region</code> 和 <code>stack</code> 标签.</p>
<blockquote>
<p>注意:</p>
<p>​    如果使用 Graphite,公共标签的顺序很重要.由于使用这种方法无法保证常用标签的顺序,建议 Graphite 用户定义自定义 <code>MeterFilter</code>.</p>
</blockquote>
</li>
<li><h6 id="Per-meter-Properties"><a href="#Per-meter-Properties" class="headerlink" title="Per-meter Properties"></a>Per-meter Properties</h6><p>除了 <code>MeterFilter</code> bean,还可以使用属性在每个meter的基础上应用有限的自定义.每个meter自定义适用于任何以给定名称开头的所有meter ID.例如,以下将禁用 ID 以 <code>example.remote</code> 开头的所有meter.</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.metrics.enable.example.remote</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>以下属性允许单一meter自定义:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>management.metrics.enable</code></td>
<td>是否拒绝仪表发出任何指标.</td>
</tr>
<tr>
<td><code>management.metrics.distribution.percentiles-histogram</code></td>
<td>是否发布适用于计算可聚合(跨维度)百分位数近似值的直方图.</td>
</tr>
<tr>
<td><code>management.metrics.distribution.minimum-expected-value</code>, <code>management.metrics.distribution.maximum-expected-value</code></td>
<td>通过限制预期值的范围来发布更少的直方图桶.</td>
</tr>
<tr>
<td><code>management.metrics.distribution.percentiles</code></td>
<td>发布在您的应用程序中计算的百分位值</td>
</tr>
<tr>
<td><code>management.metrics.distribution.slo</code></td>
<td>使用由您的服务级别目标定义的存储桶发布累积直方图.</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><h6 id="Metrics-Endpoint"><a href="#Metrics-Endpoint" class="headerlink" title="Metrics Endpoint"></a>Metrics Endpoint</h6><p>Spring Boot 提供了一个<code>metrics</code>endpoint,可用于诊断检查应用程序收集的metrics.endpoint默认不可用,必须公开,公开后才可以使用.</p>
<p>导航到 <code>/actuator/metrics</code> 会显示可用meter名的列表.可以将名称作为选择器来深入查看有关meter的信息,例如 <code>/actuator/metrics/jvm.memory.max</code>.</p>
<blockquote>
<p>建议:</p>
<p>​    在此处使用的名称应该与代码中使用的名称相匹配,而不是为监视系统而进行命名约定规范化后所得到的名称.换句话说,如果 <code>jvm.memory.max</code> 在 Prometheus 中显示为 <code>jvm_memory_max</code> 因为它的蛇形命名规范,在检查metricsendpoint中的meter时,仍然应该使用 <code>jvm.memory.max</code> 作为选择器.</p>
</blockquote>
<p>还可以将任意数量的 <code>tag=KEY:VALUE</code> 查询参数添加到 URL 的末尾,以按维度向下获取仪表,例如 <code>/actuator/metrics/jvm.memory.max?tag=area:nonheap</code>.</p>
<blockquote>
<p>建议:</p>
<p>​    报告的测量值是与meter name和标签匹配的所有meters的统计数据的总和.所以在上面的例子中,返回的”Value”统计信息是堆的”Code Cache”,”Compressed Class Space”和”Metaspace”区域的最大内存占用的总和.如果只想查看”Metaspace”的最大值,可以添加一个额外的 <code>tag=id:Metaspace</code>,即 <code>/actuator/metrics/jvm.memory.max?tag=area:nonheap&amp;tag=id:Metaspace</code>.</p>
</blockquote>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/48342.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/48342.html" class="post-title-link" itemprop="url">4.5 Acuator: 日志</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:22:00 / 修改时间：12:50:22" itemprop="dateCreated datePublished" datetime="2021-06-10T12:22:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/48342.html" class="post-meta-item leancloud_visitors" data-flag-title="4.5 Acuator: 日志" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>346</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="日志-Loggers"><a href="#日志-Loggers" class="headerlink" title="日志(Loggers)"></a>日志(Loggers)</h5><p>Spring Boot Actuator 具有在运行时查看和配置应用程序日志级别的能力。可以查看整个列表或单个记录器的配置，它由显式配置的日志记录级别以及日志记录框架为其提供的有效日志记录级别组成。 这些级别可以是以下级别之一：</p>
<ul>
<li><p><code>TRACE</code></p>
</li>
<li><p><code>DEBUG</code></p>
</li>
<li><p><code>INFO</code></p>
</li>
<li><p><code>WARN</code></p>
</li>
<li><p><code>ERROR</code></p>
</li>
<li><p><code>FATAL</code></p>
</li>
<li><p><code>OFF</code></p>
</li>
<li><p><code>null</code></p>
</li>
</ul>
<p><code>null</code> 表示没有显式配置。</p>
<ol>
<li><h6 id="配置日志器-Configure-a-Logger"><a href="#配置日志器-Configure-a-Logger" class="headerlink" title="配置日志器(Configure a Logger)"></a>配置日志器(Configure a Logger)</h6><p>要配置给定的logger，请将部分实体 <code>POST</code> 到资源的 URI，如以下示例所示：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"configuredLevel"</span>: <span class="string">"DEBUG"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>   要“重置”记录器的指定级别（并改用默认配置），您可以传递一个 <code>null</code> 作为<code>configuredLevel</code>。</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/64967.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/64967.html" class="post-title-link" itemprop="url">4.4 Acuator:  通过 JMX 进行监控和管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:21:49 / 修改时间：12:51:13" itemprop="dateCreated datePublished" datetime="2021-06-10T12:21:49+08:00">2021-06-10</time>
    </span>

  
    <span id="/posts/64967.html" class="post-meta-item leancloud_visitors" data-flag-title="4.4 Acuator:  通过 JMX 进行监控和管理" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX"><a href="#通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX" class="headerlink" title="通过 JMX 进行监控和管理(Monitoring and Management over JMX)"></a>通过 JMX 进行监控和管理(Monitoring and Management over JMX)</h5><p>Java 管理扩展 (JMX) 提供了一种标准机制来监视和管理应用程序。默认情况下，此功能未启用，可以通过将配置属性 <code>spring.jmx.enabled</code> 设置为 <code>true</code> 来开启。默认情况下，Spring Boot 将管理endpoint公开为 <code>org.springframework.boot</code> 域下的 JMX MBean。要完全控制 JMX 域中的endpoint注册，考虑注册自己的 <code>EndpointObjectNameFactory</code> 实现。</p>
<ol>
<li><h6 id="自定义-MBean-名称-Customizing-MBean-Names"><a href="#自定义-MBean-名称-Customizing-MBean-Names" class="headerlink" title="自定义 MBean 名称(Customizing MBean Names)"></a>自定义 MBean 名称(Customizing MBean Names)</h6><p>MBean 的名称通常从endpoint的 id 生成。例如，<code>health</code>endpoint公开为<code>org.springframework.boot:type=Endpoint,name=Health</code>。</p>
<p>如果应用包含多个 Spring <code>ApplicationContext</code>，可能会发现名称冲突。要解决此问题，可以将 <code>spring.jmx.unique-names</code> 属性设置为 <code>true</code>，以便 MBean 名称始终唯一。</p>
<p>还可以自定义公开endpoint的 JMX 域。 以下设置显示了在 <code>application.properties</code> 中执行此操作的示例：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jmx.unique-names</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">management.endpoints.jmx.domain</span>=<span class="string">com.example.myapp</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="禁用-JMX-Endpoint-Disabling-JMX-Endpoints"><a href="#禁用-JMX-Endpoint-Disabling-JMX-Endpoints" class="headerlink" title="禁用 JMX Endpoint(Disabling JMX Endpoints)"></a>禁用 JMX Endpoint(Disabling JMX Endpoints)</h6><p>如果不想通过 JMX 公开endpoint，可以将 <code>management.endpoints.jmx.exposure.exclude</code> 属性设置为 <code>*</code>，如下例所示：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoints.jmx.exposure.exclude</span>=<span class="string">*</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="将-Jolokia-用于基于-HTTP-的-JMX-Using-Jolokia-for-JMX-over-HTTP"><a href="#将-Jolokia-用于基于-HTTP-的-JMX-Using-Jolokia-for-JMX-over-HTTP" class="headerlink" title="将 Jolokia 用于基于 HTTP 的 JMX(Using Jolokia for JMX over HTTP)"></a>将 Jolokia 用于基于 HTTP 的 JMX(Using Jolokia for JMX over HTTP)</h6><p>Jolokia 是一个 JMX-HTTP 桥，它提供了一种访问 JMX bean 的替代方法。要使用 Jolokia，要包含对 <code>org.jolokia:jolokia-core</code> 的依赖项。 例如，使用 Maven，将添加以下依赖项：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jolokia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jolokia-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后可以通过将 <code>jolokia</code> 或 <code>*</code> 添加到 <code>management.endpoints.web.exposure.include</code> 属性来公开 Jolokia endpoint。然后，可以通过在管理 HTTP 服务器上使用 <code>/actuator/jolokia</code> 来访问。</p>
<blockquote>
<p>注意:</p>
<p>   Jolokia endpoint将 Jolokia 的 servlet 作为actuatorendpoint公开。因此，它特定于 servlet 环境，例如 Spring MVC 和 Jersey。该endpoint在 WebFlux 应用中不可用。</p>
</blockquote>
<ol>
<li><h6 id="自定义-Jolokia-Customizing-Jolokia"><a href="#自定义-Jolokia-Customizing-Jolokia" class="headerlink" title="自定义 Jolokia(Customizing Jolokia)"></a>自定义 Jolokia(Customizing Jolokia)</h6><p>Jolokia 有许多设置，通常会通过设置 servlet 参数来配置这些设置。通过 Spring Boot，可以使用 <code>application.properties</code> 文件。为此，请使用 <code>management.endpoint.jolokia.config.</code> 作为参数的前缀，如以下示例所示：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoint.jolokia.config.debug</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="禁用-Jolokia-Disabling-Jolokia"><a href="#禁用-Jolokia-Disabling-Jolokia" class="headerlink" title="禁用 Jolokia(Disabling Jolokia)"></a>禁用 Jolokia(Disabling Jolokia)</h6><p>如果使用 Jolokia 但不希望 Spring Boot 对其进行配置，请将 <code>management.endpoint.jolokia.enabled</code> 属性设置为 <code>false</code>，如下所示：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoint.jolokia.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/42024.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/42024.html" class="post-title-link" itemprop="url">4.3 Acuator:  通过 HTTP 进行监控和管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:20:00 / 修改时间：12:51:23" itemprop="dateCreated datePublished" datetime="2021-06-10T12:20:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/42024.html" class="post-meta-item leancloud_visitors" data-flag-title="4.3 Acuator:  通过 HTTP 进行监控和管理" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="通过-HTTP-进行监控和管理-Monitoring-and-Management-over-HTTP"><a href="#通过-HTTP-进行监控和管理-Monitoring-and-Management-over-HTTP" class="headerlink" title="通过 HTTP 进行监控和管理(Monitoring and Management over HTTP)"></a>通过 HTTP 进行监控和管理(Monitoring and Management over HTTP)</h5><p>如果正在开发 Web 应用程序，Spring Boot Actuator 会自动配置所有启用的endpoint来通过 HTTP 公开。默认约定是使用endpoint的 <code>id</code> 和前缀 <code>/actuator</code> 作为 URL 路径。例如，<code>health</code>暴露为 <code>/actuator/health</code>。</p>
<blockquote>
<p>建议:</p>
<p>   Actuator 由 Spring MVC、Spring WebFlux 和 Jersey 原生支持。 如果 Jersey 和 Spring MVC 都可用，则将使用 Spring MVC。</p>
<p>注意:</p>
<p>   为了获得正确的 JSON 响应，Jackson 是必需的依赖项。</p>
</blockquote>
<ol>
<li><h6 id="自定义管理Endpoint路径-Customizing-the-Management-Endpoint-Paths"><a href="#自定义管理Endpoint路径-Customizing-the-Management-Endpoint-Paths" class="headerlink" title="自定义管理Endpoint路径(Customizing the Management Endpoint Paths)"></a>自定义管理Endpoint路径(Customizing the Management Endpoint Paths)</h6><p>有时，自定义Management endpoint的前缀很有用。例如，应用程序可能已经将 <code>/actuator</code> 用于其他目的。可以使用 <code>management.endpoints.web.base-path</code> 属性来更改管理endpoint的前缀，如以下示例所示：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.base-path</span>=<span class="string">/manage</span></span><br></pre></td></tr></tbody></table></figure>

<p>前面的 <code>application.properties</code> 示例将endpoint从 <code>/actuator/{id}</code> 更改为 <code>/manage/{id}</code>（例如，<code>/manage/info</code>）。</p>
<blockquote>
<p>注意:</p>
<p>   除非已将管理端口配置为使用不同的 HTTP 端口公开endpoint，否则 <code>management.endpoints.web.base-path</code> 相关与 <code>server.servlet.context-path</code>（Servlet Web 应用）或 <code>spring.webflux.base-path</code>（ 响应式 Web 应用）。如果配置了 <code>management.server.port</code>，则 <code>management.endpoints.web.base-path</code> 关联与 <code>management.server.base-path</code>。</p>
</blockquote>
<p>如果要将endpoint映射到不同的路径，可以使用 <code>management.endpoints.web.path-mapping</code> 属性。</p>
<p>以下示例将 <code>/actuator/health</code> 重新映射到 <code>/healthcheck</code>：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.base-path</span>=<span class="string">/</span></span><br><span class="line"><span class="meta">management.endpoints.web.path-mapping.health</span>=<span class="string">healthcheck</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自定义管理服务器端口-Customizing-the-Management-Server-Port"><a href="#自定义管理服务器端口-Customizing-the-Management-Server-Port" class="headerlink" title="自定义管理服务器端口(Customizing the Management Server Port)"></a>自定义管理服务器端口(Customizing the Management Server Port)</h6><p>使用默认 HTTP 端口公开管理endpoint是基于云的部署的明智选择。但是，如果应用在自己的数据中心内运行，可能更愿意使用不同的 HTTP 端口来公开endpoint。</p>
<p>可以设置 <code>management.server.port</code> 属性来更改 HTTP 端口，如以下示例所示：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>   在 Cloud Foundry 上，默认情况下，应用仅接收端口 8080 上的 HTTP 和 TCP 路由请求。如果要在 Cloud Foundry 上使用自定义管理端口，则需要明确设置应用的路由以将流量转发到自定义端口。</p>
</blockquote>
</li>
<li><h6 id="配置针对管理的-SSL-Configuring-Management-specific-SSL"><a href="#配置针对管理的-SSL-Configuring-Management-specific-SSL" class="headerlink" title="配置针对管理的 SSL(Configuring Management-specific SSL)"></a>配置针对管理的 SSL(Configuring Management-specific SSL)</h6><p>当配置为使用自定义端口时，还可以使用各种 <code>management.server.ssl.*</code> 属性为管理服务器配置自己的 SSL。例如，这样做可以让管理服务器通过 HTTP 可用，而主应用程序使用 HTTPS，如以下属性设置所示：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8443</span></span><br><span class="line"><span class="meta">server.ssl.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">server.ssl.key-store</span>=<span class="string">classpath:store.jks</span></span><br><span class="line"><span class="meta">server.ssl.key-password</span>=<span class="string">secret</span></span><br><span class="line"><span class="meta">management.server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="meta">management.server.ssl.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>或者，主服务器和管理服务器都可以使用 SSL，但使用不同的密钥存储，如下所示：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8443server.ssl.enabled=trueserver.ssl.key-store=classpath:main.jksserver.ssl.key-password=secretmanagement.server.port=8080management.server.ssl.enabled=truemanagement.server.ssl.key-store=classpath:management.jksmanagement.server.ssl.key-password=secret</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自定义管理服务器地址-Customizing-the-Management-Server-Address"><a href="#自定义管理服务器地址-Customizing-the-Management-Server-Address" class="headerlink" title="自定义管理服务器地址(Customizing the Management Server Address)"></a>自定义管理服务器地址(Customizing the Management Server Address)</h6><p>可以通过设置 <code>management.server.address</code> 属性来自定义管理endpoint可用的地址。如果只想在内部或面向 ops 的网络上侦听，或者只想侦听来自 localhost 的连接，那么这样做会很有用。</p>
<blockquote>
<p>注意:</p>
<p>   只有当端口与主服务器端口不同时，才能侦听不同的地址。</p>
</blockquote>
<p>以下示例 <code>application.properties</code> 不允许远程管理连接：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.server.port</span>=<span class="string">8081management.server.address=127.0.0.1</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="禁用HTTP-Endpoint-Disabling-HTTP-Endpoints"><a href="#禁用HTTP-Endpoint-Disabling-HTTP-Endpoints" class="headerlink" title="禁用HTTP Endpoint(Disabling HTTP Endpoints)"></a>禁用HTTP Endpoint(Disabling HTTP Endpoints)</h6><p>如果不想通过 HTTP 公开endpoint，可以将管理端口设置为 <code>-1</code>，如下例所示：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.server.port</span>=<span class="string">-1</span></span><br></pre></td></tr></tbody></table></figure>

<p>这也可以使用 <code>management.endpoints.web.exposure.exclude</code> 属性来实现，如以下示例所示：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.exclude</span>=<span class="string">*</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/40082.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/40082.html" class="post-title-link" itemprop="url">4.2 Actuator:  Endpoints</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:19:00 / 修改时间：12:51:34" itemprop="dateCreated datePublished" datetime="2021-06-10T12:19:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/40082.html" class="post-meta-item leancloud_visitors" data-flag-title="4.2 Actuator:  Endpoints" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="Endpoints"><a href="#Endpoints" class="headerlink" title="Endpoints"></a>Endpoints</h5><p>Actuator endpoint 可以用来监控应用并与之交互。 Spring Boot 包含许多内置endpoint，并允许添加自己的endpoint。例如，<code>health</code>endpoint提供基本的应用程序健康信息。</p>
<p>每个单独的endpoint都可以通过 HTTP 或 JMX 启用或禁用和公开（远程访问）。当启用和公开endpoint时，它是可用的。内置endpoint只有在可用时才会自动配置。大多数应用程序通过 HTTP 公开，其中endpoint 的 ID 以及 <code>/actuator</code> 的前缀映射到 URL。例如，默认情况下，<code>health</code> endpoint映射到<code>/actuator/health</code>.</p>
<p>以下与技术无关的endpoint可用：</p>
<table>
<thead>
<tr>
<th><strong>ID</strong></th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>auditevents</code></td>
<td>公开当前应用程序的audit 事件信息。 需要一个 <code>AuditEventRepository</code> bean。</td>
</tr>
<tr>
<td><code>beans</code></td>
<td>显示应用程序中所有 Spring bean 的完整列表。</td>
</tr>
<tr>
<td><code>caches</code></td>
<td>公开可用的缓存。</td>
</tr>
<tr>
<td><code>conditions</code></td>
<td>显示在配置和自动配置类上评估的conditions ,以及匹配或不匹配的原因。</td>
</tr>
<tr>
<td><code>configprops</code></td>
<td>显示所有<code>@ConfigurationProperties</code> 的列表。</td>
</tr>
<tr>
<td><code>env</code></td>
<td>从 Spring 的 <code>ConfigurableEnvironment</code> 公开属性。</td>
</tr>
<tr>
<td><code>flyway</code></td>
<td>显示已经应用的所有 <code>Flyway</code> 数据库迁移。 需要一个或多个 <code>Flyway</code> bean。</td>
</tr>
<tr>
<td><code>health</code></td>
<td>显示应用程序运行状况信息。</td>
</tr>
<tr>
<td><code>httptrace</code></td>
<td>显示 HTTP 跟踪信息（默认情况下，最后 100 个 HTTP 请求-响应交换）。需要一个 <code>HttpTraceRepository</code> bean。</td>
</tr>
<tr>
<td><code>info</code></td>
<td>显示任意应用程序信息。</td>
</tr>
<tr>
<td><code>integrationgraph</code></td>
<td>显示 Spring 集成图。 需要依赖 <code>spring-integration-core</code>。</td>
</tr>
<tr>
<td><code>loggers</code></td>
<td>显示和修改应用程序中loggers的配置。</td>
</tr>
<tr>
<td><code>liquibase</code></td>
<td>显示已应用的所有的 Liquibase 数据库迁移。 需要一个或多个 <code>Liquibase</code> bean。</td>
</tr>
<tr>
<td><code>metrics</code></td>
<td>显示当前应用程序的“metrics”信息。</td>
</tr>
<tr>
<td><code>mappings</code></td>
<td>显示所有 <code>@RequestMapping</code> 路径的整理列表。</td>
</tr>
<tr>
<td><code>quartz</code></td>
<td>显示有关 Quartz 调度程序作业的信息。</td>
</tr>
<tr>
<td><code>scheduledtasks</code></td>
<td>显示应用程序中的计划任务。</td>
</tr>
<tr>
<td><code>sessions</code></td>
<td>允许从 Spring Session 支持的会话存储中检索和删除用户会话。需要使用 Spring Session 的基于 Servlet 的 Web 应用程序。</td>
</tr>
<tr>
<td>shutdown</td>
<td>让应用程序正常关闭。 默认禁用。</td>
</tr>
<tr>
<td>startup</td>
<td>显示 <code>ApplicationStartup</code> 收集的启动步骤数据.需要使用 <code>BufferingApplicationStartup</code> 配置 <code>SpringApplication</code>。</td>
</tr>
<tr>
<td><code>threaddump</code></td>
<td>执行线程转储。</td>
</tr>
</tbody></table>
<p>如果应用程序是 Web 应用程序（Spring MVC、Spring WebFlux 或 Jersey），可以使用以下附加endpoint：</p>
<table>
<thead>
<tr>
<th><strong>ID</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>heapdump</code></td>
<td>返回一个 <code>hprof</code> 堆转储文件。 要求 HotSpot JVM。</td>
</tr>
<tr>
<td><code>jolokia</code></td>
<td>通过 HTTP 公开 JMX bean（当classpath上Jolokia 在时，不适用于 WebFlux）。</td>
</tr>
<tr>
<td><code>logfile</code></td>
<td>返回日志文件的内容（如果已设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性）.支持使用 HTTP <code>Range</code> header来检索日志文件的部分内容。</td>
</tr>
<tr>
<td><code>prometheus</code></td>
<td>以 Prometheus 服务器可以抓取的格式公开指标。需要依赖 <code>micrometer-registry-prometheus</code>.</td>
</tr>
</tbody></table>
<ol>
<li><h6 id="开启-Endpoints-Enabling-Endpoints"><a href="#开启-Endpoints-Enabling-Endpoints" class="headerlink" title="开启 Endpoints(Enabling Endpoints)"></a>开启 Endpoints(Enabling Endpoints)</h6><p>默认情况下，除<code>shutdown</code>之外的所有endpoint都处于启用状态。要启用endpoint，请使用其 <code>management.endpoint.&lt;id&gt;.enabled</code> 属性。以下示例启用关闭endpoint：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoint.shutdown.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果希望endpoint启用是opt-in而不是opt-out，将 <code>management.endpoints.enabled-by-default</code> 属性设置为 <code>false</code> 并使用endpoint的<code>enabled</code>选择重新加入。以下示例启用 <code>info</code> endpoint并禁用所有其他endpoint：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoints.enabled-by-default</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">management.endpoint.info.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>   禁用的endpoint从应用context中完全删除。如果只想改变endpoint公开的技术，请改用 <code>include</code> 和 <code>exclude</code> 属性。</p>
</blockquote>
</li>
<li><h6 id="暴露-Endpoints-Exposing-Endpoints"><a href="#暴露-Endpoints-Exposing-Endpoints" class="headerlink" title="暴露 Endpoints(Exposing Endpoints)"></a>暴露 Endpoints(Exposing Endpoints)</h6><p>由于Endpoints 可能包含敏感信息，因此应仔细考虑何时公开它们。下表显示了内置endpoint的默认暴露：</p>
<table>
<thead>
<tr>
<th><strong>ID</strong></th>
<th><strong>JMX</strong></th>
<th><strong>Web</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>auditevents</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>beans</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>caches</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>conditions</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>configprops</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>env</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>flyway</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>health</code></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><code>heapdump</code></td>
<td>N/A</td>
<td>No</td>
</tr>
<tr>
<td><code>httptrace</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>info</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>integrationgraph</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>jolokia</code></td>
<td>N/A</td>
<td>No</td>
</tr>
<tr>
<td><code>logfile</code></td>
<td>N/A</td>
<td>No</td>
</tr>
<tr>
<td><code>loggers</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>liquibase</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>metrics</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>mappings</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>prometheus</code></td>
<td>N/A</td>
<td>No</td>
</tr>
<tr>
<td><code>quartz</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>scheduledtasks</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>sessions</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>shutdown</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>startup</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>threaddump</code></td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody></table>
<p>要更改公开的endpoint，请使用以下特定于技术的<code>include</code>和<code>exclude</code>属性：</p>
<table>
<thead>
<tr>
<th><strong>Property</strong></th>
<th><strong>Default</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>management.endpoints.jmx.exposure.exclude</code></td>
<td></td>
</tr>
<tr>
<td><code>management.endpoints.jmx.exposure.include</code></td>
<td><code>*</code></td>
</tr>
<tr>
<td><code>management.endpoints.web.exposure.exclude</code></td>
<td></td>
</tr>
<tr>
<td><code>management.endpoints.web.exposure.include</code></td>
<td><code>health</code></td>
</tr>
</tbody></table>
<p><code>include</code> 属性列出了公开的endpoint的 ID。<code>exclude</code> 属性列出不应公开的endpoint的 ID。<code>exclude</code> 属性优先于 <code>include</code> 属性。<code>include</code>和<code>exclude</code>属性都可以使用endpoint ID 列表进行配置。</p>
<p>例如，要停止通过 JMX 公开所有endpoint并仅公开 <code>health</code> 和 <code>info</code> endpoint，请使用以下属性：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoints.jmx.exposure.include</span>=<span class="string">health,info</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>*</code> 可用于选择所有endpoint。例如，要通过 HTTP 公开除了 <code>env</code> 和 <code>beans</code> endpoint之外的所有内容，请使用以下属性：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.exclude</span>=<span class="string">env,beans</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>   <code>*</code> 在 YAML 中具有特殊含义，因此如果要包含（或排除）所有endpoint，请务必添加引号。</p>
<p>注意:</p>
<p>   如果应用公开，强烈建议也保护您的endpoint(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.endpoints.security">secure your endpoints</a>)。</p>
<p>建议:</p>
<p>   如果想实现自己的endpoint何时公开策略，可以注册一个 <code>EndpointFilter</code> bean。</p>
</blockquote>
</li>
<li><h6 id="保护-HTTP-endpoint-Securing-HTTP-Endpoints"><a href="#保护-HTTP-endpoint-Securing-HTTP-Endpoints" class="headerlink" title="保护 HTTP endpoint(Securing HTTP Endpoints)"></a>保护 HTTP endpoint(Securing HTTP Endpoints)</h6><p>应该像保护任何其他敏感 URL 一样注意保护 HTTP endpoint。如果存在 Spring Security，则默认情况下使用 Spring Security 的内容协商策略来保护endpoint。如果存在 Spring Security，则默认情况下使用 Spring Security 的内容协商策略来保护endpoint。如果希望为 HTTP endpoint配置自定义安全性，例如只允许具有特定角色的用户访问它们，Spring Boot 提供了一些方便的 <code>RequestMatcher</code> 对象，可以与 Spring Security 结合使用。</p>
<p>典型的 Spring Security 配置可能类似于以下示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySecurityConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityFilterChain <span class="title">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint())</span><br><span class="line">                .authorizeRequests((requests) -&gt; requests.anyRequest().hasRole(<span class="string">"ENDPOINT_ADMIN"</span>));</span><br><span class="line">        http.httpBasic();</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>前面的示例使用 <code>EndpointRequest.toAnyEndpoint()</code> 将请求匹配到任何endpoint，然后确保所有endpoint都具有 <code>ENDPOINT_ADMIN</code> 角色。<code>EndpointRequest</code> 上还提供了其他几种匹配器方法。</p>
<p>如果想要在防火墙后面部署应用程序，可能希望无需身份验证即可访问所有执行器endpoint。可以通过更改 <code>management.endpoints.web.exposure.include</code> 属性来实现，如下所示：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br></pre></td></tr></tbody></table></figure>

<p>此外，如果存在 Spring Security，需要添加自定义安全配置，以允许对endpoint进行未经身份验证的访问，如以下示例所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySecurityConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityFilterChain <span class="title">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint())</span><br><span class="line">                .authorizeRequests((requests) -&gt; requests.anyRequest().permitAll());</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>   在上面的两个示例中，配置仅适用于actuator endpoints。由于 Spring Boot 的安全配置会在 <code>SecurityFilterChain</code> bean 存在时完全退出，因此需要配置一个额外的 <code>SecurityFilterChain</code> bean，其规则适用于应用程序的其余部分。</p>
</blockquote>
</li>
<li><h6 id="配置-Endpoints-Configuring-Endpoints"><a href="#配置-Endpoints-Configuring-Endpoints" class="headerlink" title="配置 Endpoints(Configuring Endpoints)"></a>配置 Endpoints(Configuring Endpoints)</h6><p>endpoint自动缓存那些无参读取操作的响应。要配置endpoint缓存响应的时间量，请使用其 <code>cache.time-to-live</code> 属性。以下示例将 beans endpoint的缓存的生存时间设置为 10 秒：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoint.beans.cache.time-to-live</span>=<span class="string">10s</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>   前缀 <code>management.endpoint.&lt;name&gt;</code> 用于配置标识唯一的endpoint。</p>
</blockquote>
</li>
<li><h6 id="Actuator-Web-endpoint的超媒体-Hypermedia-for-Actuator-Web-Endpoints"><a href="#Actuator-Web-endpoint的超媒体-Hypermedia-for-Actuator-Web-Endpoints" class="headerlink" title="Actuator Web endpoint的超媒体(Hypermedia for Actuator Web Endpoints)"></a>Actuator Web endpoint的超媒体(Hypermedia for Actuator Web Endpoints)</h6><p>添加了“discovery page”，其中包含指向所有endpoint的链接。 默认情况下，“discovery page”在 <code>/actuator</code> 上可用。</p>
<p>要禁用“discovery page”，请将以下属性添加到应用属性中：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.discovery.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>配置自定义管理context路径后，“discovery page”会自动从 <code>/actuator</code> 移动到管理context的根目录。例如，如果管理上下文路径是 <code>/management</code>，则可从 <code>/management</code>获取发现页面.当管理上下文路径设置为 <code>/</code> 时，将禁用发现页面来防止与其他映射发生冲突。</p>
</li>
<li><h6 id="CORS-Support"><a href="#CORS-Support" class="headerlink" title="CORS Support"></a>CORS Support</h6><p>跨域资源共享 (CORS) 是一种 W3C 规范，可以以灵活的方式指定哪些类型的跨域请求被授权。如果使用 Spring MVC 或 Spring WebFlux，则可以配置 Actuator 的 Web endpoint以支持此类场景。</p>
<p>默认情况下禁用 CORS 支持，并且只有设置 <code>management.endpoints.web.cors.allowed-origins</code> 属性后开启。以下配置允许来自 <code>example.com</code> 域的 <code>GET</code> 和 <code>POST</code> 调用：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.cors.allowed-origins</span>=<span class="string">https://example.com</span></span><br><span class="line"><span class="meta">management.endpoints.web.cors.allowed-methods</span>=<span class="string">GET,POST</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="实现自定义Endpoint-Implementing-Custom-Endpoints"><a href="#实现自定义Endpoint-Implementing-Custom-Endpoints" class="headerlink" title="实现自定义Endpoint(Implementing Custom Endpoints)"></a>实现自定义Endpoint(Implementing Custom Endpoints)</h6><p>如果添加一个用<code>@Endpoint</code> 注解的<code>@Bean</code>，任何用<code>@ReadOperation</code>、<code>@WriteOperation</code> 或<code>@DeleteOperation</code> 注解标注的方法都会自动通过JMX 公开，在Web 应用程序中，也通过HTTP 公开。endpoint可以使用 Jersey、Spring MVC 或 Spring WebFlux 通过 HTTP 公开。 如果 Jersey 和 Spring MVC 都可用，则将使用 Spring MVC。</p>
<p>以下示例公开了一个返回自定义对象的读取操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReadOperation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CustomData <span class="title">getData</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomData(<span class="string">"test"</span>, <span class="number">5</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还可以使用<code>@JmxEndpoint</code> 或<code>@WebEndpoint</code> 编写特定于技术的endpoint。这些endpoint仅限于它们各自的技术。例如，<code>@WebEndpoint</code> 仅通过 HTTP 而不是通过 JMX 公开。</p>
<p>可以使用 <code>@EndpointWebExtension</code> 和 <code>@EndpointJmxExtension</code> 编写特定于技术的扩展.这些注解可以提供特定于技术来扩充现有endpoint。</p>
<p>最后，如果需要访问特定于 web 框架的功能，可以实现 Servlet 或 Spring <code>@Controller</code> 和 <code>@RestController</code> endpoint，但代价是它们无法通过 JMX 或在使用不同的 web 框架时可用。</p>
<ol>
<li><h6 id="接收输入-Receiving-Input"><a href="#接收输入-Receiving-Input" class="headerlink" title="接收输入(Receiving Input)"></a>接收输入(Receiving Input)</h6><p>endpoint上的操作通过其参数接收输入。当通过 Web 公开时，这些参数的值取自 URL 的请求参数和 JSON 请求体。当通过 JMX 公开时，参数被映射到 MBean 操作的参数。 默认需要参数。可以通过使用<code>@javax.annotation.Nullable</code> 或<code>@org.springframework.lang.Nullable</code> 来使它们成为optional。</p>
<p>JSON 请求体中的每个根属性都可以映射到endpoint的一个参数。 考虑以下 JSON 请求正文：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"test"</span>,</span><br><span class="line">    <span class="attr">"counter"</span>: <span class="number">42</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这可用于调用采用 <code>String name</code> 和 <code>int counter</code> 参数的写操作，如以下示例所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WriteOperation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateData</span><span class="params">(String name, <span class="keyword">int</span> counter)</span> </span>{</span><br><span class="line">    <span class="comment">// injects "test" and 42</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>   由于endpoint与技术无关，因此只能在方法签名中指定简单类型。特别是使用<code>CustomData</code>类型定义一个<code>name</code>来声明参数和<code>counter</code>属性不被支持. </p>
<p>注意:  </p>
<p>   为了允许将输入映射到操作方法的参数，实现endpoint的 Java 代码应该使用 <code>-parameters</code> 编译，实现endpoint的 Kotlin 代码应该使用 <code>-java-parameters</code> 编译.如果使用 Spring Boot 的 Gradle 插件或使用 Maven 和 <code>spring-boot-starter-parent</code>，这将自动进行。</p>
</blockquote>
<h6 id="输入类型转换"><a href="#输入类型转换" class="headerlink" title="输入类型转换"></a>输入类型转换</h6><p>如有必要，传递给endpoint操作方法的参数会自动转换为所需的类型。在调用操作方法之前，通过 JMX 或 HTTP 请求接收的输入将使用 <code>ApplicationConversionService</code> 的实例以及通过 <code>@EndpointConverter</code> 限定的任何 <code>Converter</code> 或 <code>GenericConverter</code> bean 转换为所需的类型。</p>
</li>
<li><h6 id="自定义-Web-endpoint-Custom-Web-Endpoints"><a href="#自定义-Web-endpoint-Custom-Web-Endpoints" class="headerlink" title="自定义 Web endpoint(Custom Web Endpoints)"></a>自定义 Web endpoint(Custom Web Endpoints)</h6><p><code>@Endpoint</code>、<code>@WebEndpoint</code> 或 <code>@EndpointWebExtension</code> 上的操作都会使用 Jersey、Spring MVC 或 Spring WebFlux 通过 HTTP 自动公开。如果 Jersey 和 Spring MVC 都可用，则将使用 Spring MVC。</p>
<h6 id="Web-endpoint请求谓词-Web-Endpoint-Request-Predicates"><a href="#Web-endpoint请求谓词-Web-Endpoint-Request-Predicates" class="headerlink" title="Web endpoint请求谓词(Web Endpoint Request Predicates)"></a>Web endpoint请求谓词(Web Endpoint Request Predicates)</h6><p>在 Web 公开endpoint上的每个操作,都会自动生成请求谓词。</p>
<h6 id="路径-Path"><a href="#路径-Path" class="headerlink" title="路径(Path)"></a>路径(Path)</h6><p>谓词的路径由endpoint的 ID 和在网络公开上的endpoint的基本路径决定。默认的基本路径是 <code>/actuator</code>。例如，具有 ID <code>sessions</code>的endpoint将使用 <code>/actuator/sessions</code> 作为谓词中的路径。</p>
<p>通过<code>@Selector</code>标注操作方法的一个或多个参数，可以进一步自定义路径.这样的参数作为路径变量添加到路径谓词中。当调用endpoint操作时，变量的值被传递到操作方法中。如果要捕获所有剩余的路径元素，可以将<code>@Selector(Match=ALL_REMAINING) </code>添加到最后一个参数并使其成为与 <code>String[]</code> 转换为兼容的类型.</p>
<h6 id="HTTP-方法-HTTP-method"><a href="#HTTP-方法-HTTP-method" class="headerlink" title="HTTP 方法(HTTP method)"></a>HTTP 方法(HTTP method)</h6><p>谓词的HTTP方法由操作类型决定，如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>Operation</strong></th>
<th><strong>HTTP method</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>@ReadOperation</code></td>
<td><code>GET</code></td>
</tr>
<tr>
<td><code>@WriteOperation</code></td>
<td><code>POST</code></td>
</tr>
<tr>
<td><code>@DeleteOperation</code></td>
<td><code>DELETE</code></td>
</tr>
</tbody></table>
<h6 id="Consumes"><a href="#Consumes" class="headerlink" title="Consumes"></a>Consumes</h6><p>对于使用请求体的<code>@WriteOperation</code>（HTTP <code>POST</code>），谓词的consumes 子句是<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>.对于所有其他操作，consumes 子句为空。</p>
<h6 id="Produces"><a href="#Produces" class="headerlink" title="Produces"></a>Produces</h6><p>谓词的produces 子句可以由<code>@DeleteOperation</code>、<code>@ReadOperation</code> 和<code>@WriteOperation</code> 注解的<code>produces</code>属性确定。该属性是可选的。 如果未使用，则生产子句会自动确定。</p>
<p>如果操作方法返回 <code>void</code> 或 <code>Void</code>，那么produces 子句为空。如果操作方法返回<code>org.springframework.core.io.Resource</code>，那么produces子句就是<code>application/octet-stream</code>.对于所有其他操作，生产子句是 <code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。</p>
<h6 id="Web-Endpoint-响应状态-Web-Endpoint-Response-Status"><a href="#Web-Endpoint-响应状态-Web-Endpoint-Response-Status" class="headerlink" title="Web Endpoint 响应状态(Web Endpoint Response Status)"></a>Web Endpoint 响应状态(Web Endpoint Response Status)</h6><p>endpoint 操作的默认响应状态取决于操作类型（读取、写入或删除）以及操作返回的内容（如果有）。</p>
<p><code>@ReadOperation</code> 返回一个值，响应状态将为 200 (OK)。 如果它没有返回值，则响应状态将为 404（未找到）。</p>
<p>如果<code>@WriteOperation</code> 或<code>@DeleteOperation</code> 返回一个值，则响应状态将为 200（OK）。 如果它没有返回值，则响应状态将为 204（无内容）。</p>
<p>如果在没有必需参数的情况下调用操作，或者带有无法转换为必需类型的参数，则操作方法不会被调用并且响应状态为 400（Bad Request）。</p>
<h6 id="Web-Endpoint-范围请求-Web-Endpoint-Range-Requests"><a href="#Web-Endpoint-范围请求-Web-Endpoint-Range-Requests" class="headerlink" title="Web Endpoint 范围请求(Web Endpoint Range Requests)"></a>Web Endpoint 范围请求(Web Endpoint Range Requests)</h6><p>HTTP 范围请求可用于请求部分 HTTP 资源。使用 Spring MVC 或 Spring Web Flux 时，返回 <code>org.springframework.core.io.Resource</code> 的操作会自动支持范围请求。</p>
<blockquote>
<p>注意:</p>
<p>   使用 Jersey 时不支持范围请求。</p>
</blockquote>
<h6 id="Web-Endpoint安全"><a href="#Web-Endpoint安全" class="headerlink" title="Web Endpoint安全"></a>Web Endpoint安全</h6><p>Web endpoint或特定于 Web 的endpoint扩展上的操作可以接收当前 <code>java.security.Principal</code> 或 <code>org.springframework.boot.actuate.endpoint.SecurityContext</code> 作为方法参数。前者通常与<code>@Nullable</code> 结合使用，为经过身份验证和未经身份验证的用户提供不同的行为。后者通常用于使用 <code>isUserInRole(String)</code>方法来执行授权检查。</p>
</li>
<li><h6 id="Servlet-Endpoints"><a href="#Servlet-Endpoints" class="headerlink" title="Servlet Endpoints"></a>Servlet Endpoints</h6><p>通过实现一个用 <code>@ServletEndpoint</code> 注解的类，同时实现了<code>Supplier&lt;EndpointServlet&gt;</code>，可以将 Servlet 作为Endpoint公开. Servlet endpoint提供了与 Servlet 容器的更深层次的集成，但以可移植性为代价。旨在用于将现有 Servlet 作为endpoint公开。对于新endpoint，应尽可能首选 <code>@Endpoint</code> 和 <code>@WebEndpoint</code> 注解。</p>
</li>
<li><h6 id="Controller-Endpoint"><a href="#Controller-Endpoint" class="headerlink" title="Controller Endpoint"></a>Controller Endpoint</h6><p><code>@ControllerEndpoint</code> 和 <code>@RestControllerEndpoint</code> 可用于实现那些仅由 Spring MVC 或 Spring WebFlux 公开的endpoint。方法使用 Spring MVC 和 Spring WebFlux 的标准注解（例如 <code>@RequestMapping</code> 和 <code>@GetMapping</code>）进行映射，endpoint的 ID 用作路径的前缀。Controller endpoint提供了与 Spring 的 Web 框架更深入的集成，但以可移植性为代价。应尽可能首选<code>@Endpoint</code> 和<code>@WebEndpoint</code> 注解。</p>
</li>
</ol>
</li>
<li><h6 id="健康信息-Health-Information"><a href="#健康信息-Health-Information" class="headerlink" title="健康信息(Health Information)"></a>健康信息(Health Information)</h6><p>可以使用健康信息来检查正在运行的应用的状态。 当生产系统出现故障时，监控软件通常使用它来提醒。健康endpoint公开的信息取决于 <code>management.endpoint.health.show-details</code> 和 <code>management.endpoint.health.show-components</code> 属性，可以使用以下值之一进行配置：</p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>never</code></td>
<td>永远不会显示详细信息。</td>
</tr>
<tr>
<td><code>when-authorized</code></td>
<td>仅向授权用户显示详细信息。 可以使用<code>management.endpoint.health.roles</code> 配置授权角色。</td>
</tr>
<tr>
<td><code>always</code></td>
<td>给所有用户显示详细信息。</td>
</tr>
</tbody></table>
<p>默认值是<code>never</code>。 当一个用户担任一个或多个endpoint角色时，被认为是被授权的。如果endpoint没有配置角色（默认），所有通过身份验证的用户都被认为是授权的。可以使用 <code>management.endpoint.health.roles</code> 属性配置角色。</p>
<blockquote>
<p>注意:</p>
<p>   如果已保护应用并希望始终使用，安全配置必须允许经过身份验证和未经身份验证的用户访问health endpoint。</p>
</blockquote>
<p>Health information是从 <code>HealthContributorRegistry</code> 的内容中收集的（默认情况下， <code>ApplicationContext</code>中定义的所有 <code>HealthContributor</code> 实例）。Spring Boot 包含许多自动配置的 <code>HealthContributor</code>，也可以编写自己的。</p>
<p><code>HealthContributor</code> 可以是 <code>HealthIndicator</code> 或 <code>CompositeHealthContributor</code>. <code>HealthIndicator</code> 提供实际的健康信息，包括<code>Status</code>. <code>CompositeHealthContributor</code> 提供了其他 <code>HealthContributor</code> 的组合.总之，参与者形成了一个树结构来表示整个系统的健康状况。</p>
<p>默认情况下，最终系统运行状况由 <code>StatusAggregator</code> 派生，它根据状态的列表,对来自每个 <code>HealthIndicator</code> 的状态进行排序。排序列表中的第一个状态用作整体健康状态。如果没有 <code>HealthIndicator</code> 返回 <code>StatusAggregator</code> 已知的状态，则使用 <code>UNKNOWN</code> 状态。</p>
<blockquote>
<p>建议:</p>
<p>   <code>HealthContributorRegistry</code> 可用于在运行时注册和取消注册health indicator。</p>
</blockquote>
<ol>
<li><h6 id="自动配置的health-indicator-Auto-configured-HealthIndicators"><a href="#自动配置的health-indicator-Auto-configured-HealthIndicators" class="headerlink" title="自动配置的health indicator(Auto-configured HealthIndicators)"></a>自动配置的health indicator(Auto-configured HealthIndicators)</h6><p>Spring Boot 会在适当的时候自动配置以下 <code>HealthIndicator</code>。还可以通过使用下表中列出的key配置 <code>management.health.key.enabled</code> 来启用/禁用选定的指标。</p>
<table>
<thead>
<tr>
<th><strong>Key</strong></th>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>cassandra</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraDriverHealthIndicator.java"><code>CassandraDriverHealthIndicator</code></a></td>
<td>检查 Cassandra 数据库是否已启动。</td>
</tr>
<tr>
<td><code>couchbase</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseHealthIndicator.java"><code>CouchbaseHealthIndicator</code></a></td>
<td>检查 Couchbase 集群是否已启动。</td>
</tr>
<tr>
<td><code>db</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jdbc/DataSourceHealthIndicator.java"><code>DataSourceHealthIndicator</code></a></td>
<td>检查是否可以获得到“DataSource”的连接。</td>
</tr>
<tr>
<td><code>diskspace</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/system/DiskSpaceHealthIndicator.java"><code>DiskSpaceHealthIndicator</code></a></td>
<td>检查磁盘空间不足。</td>
</tr>
<tr>
<td><code>elasticsearch</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/elasticsearch/ElasticsearchRestHealthIndicator.java"><code>ElasticsearchRestHealthIndicator</code></a></td>
<td>检查 Elasticsearch 集群是否已启动。</td>
</tr>
<tr>
<td><code>hazelcast</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/hazelcast/HazelcastHealthIndicator.java"><code>HazelcastHealthIndicator</code></a></td>
<td>检查 Hazelcast 服务器是否已启动。</td>
</tr>
<tr>
<td><code>influxdb</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/influx/InfluxDbHealthIndicator.java"><code>InfluxDbHealthIndicator</code></a></td>
<td>检查 InfluxDB 服务器是否已启动。</td>
</tr>
<tr>
<td><code>jms</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jms/JmsHealthIndicator.java"><code>JmsHealthIndicator</code></a></td>
<td>检查 JMS 代理是否已启动。</td>
</tr>
<tr>
<td><code>ldap</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/ldap/LdapHealthIndicator.java"><code>LdapHealthIndicator</code></a></td>
<td>检查 LDAP 服务器是否已启动。</td>
</tr>
<tr>
<td><code>mail</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mail/MailHealthIndicator.java"><code>MailHealthIndicator</code></a></td>
<td>检查邮件服务器是否已启动。</td>
</tr>
<tr>
<td><code>mongo</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoHealthIndicator.java"><code>MongoHealthIndicator</code></a></td>
<td>检查 Mongo 数据库是否已启动。</td>
</tr>
<tr>
<td><code>neo4j</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/neo4j/Neo4jHealthIndicator.java"><code>Neo4jHealthIndicator</code></a></td>
<td>检查 Neo4j 数据库是否已启动。</td>
</tr>
<tr>
<td><code>ping</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/PingHealthIndicator.java"><code>PingHealthIndicator</code></a></td>
<td>始终以“<code>UP</code>”响应。</td>
</tr>
<tr>
<td><code>rabbit</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/amqp/RabbitHealthIndicator.java"><code>RabbitHealthIndicator</code></a></td>
<td>检查 Rabbit 服务器是否已启动。</td>
</tr>
<tr>
<td><code>redis</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisHealthIndicator.java"><code>RedisHealthIndicator</code></a></td>
<td>检查 Redis 服务器是否已启动。</td>
</tr>
<tr>
<td><code>solr</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/solr/SolrHealthIndicator.java"><code>SolrHealthIndicator</code></a></td>
<td>检查 Solr 服务器是否已启动。</td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>   可以通过设置 <code>management.health.defaults.enabled</code> 属性来禁用它们。</p>
</blockquote>
<p>其他 <code>HealthIndicators</code> 可用,但默认情况下没有启用：</p>
<table>
<thead>
<tr>
<th><strong>Key</strong></th>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>livenessstate</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/availability/LivenessStateHealthIndicator.java"><code>LivenessStateHealthIndicator</code></a></td>
<td>公开“Liveness”应用程序可用性状态。</td>
</tr>
<tr>
<td><code>readinessstate</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/availability/ReadinessStateHealthIndicator.java"><code>ReadinessStateHealthIndicator</code></a></td>
<td>公开“Readiness”应用程序可用性状态。</td>
</tr>
</tbody></table>
</li>
<li><h6 id="编写自定义HealthIndicators-Writing-Custom-HealthIndicators"><a href="#编写自定义HealthIndicators-Writing-Custom-HealthIndicators" class="headerlink" title="编写自定义HealthIndicators(Writing Custom HealthIndicators)"></a>编写自定义HealthIndicators(Writing Custom HealthIndicators)</h6><p>要提供自定义健康信息，可以注册实现 <code>HealthIndicator</code> 接口的 Spring bean。需要提供 <code>health()</code> 方法的实现并返回 <code>Health</code> 响应。<code>Health</code> 响应应包括状态，并且可以包括可选显示的其他详细信息。以下代码显示了一个示例 <code>HealthIndicator</code> 实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>{        <span class="keyword">int</span> errorCode = check();        <span class="keyword">if</span> (errorCode != <span class="number">0</span>) {            <span class="keyword">return</span> Health.down().withDetail(<span class="string">"Error Code"</span>, errorCode).build();        }        <span class="keyword">return</span> Health.up().build();    }    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">()</span> </span>{        <span class="comment">// perform some specific health check        return ...    }}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>   给定 <code>HealthIndicator</code> 的标识符是不带 <code>HealthIndicator</code> 后缀的 bean 的名称（如果存在）。 在前面的示例中，健康信息在名为 <code>my</code> 的条目中可用。</p>
</blockquote>
<p>除了 Spring Boot 预定义的 <code>Status</code> 类型之外，<code>Health</code> 还可以返回一个自定义 <code>Status</code> 来表示新的系统状态。在这种情况下，还需要提供 <code>StatusAggregator</code> 接口的自定义实现，或者必须使用 <code>management.endpoint.health.status.order</code> 配置属性来配置默认实现。</p>
<p>例如，假设 <code>HealthIndicator</code> 实现正在使用code为 <code>FATAL</code> 的新的<code>Status</code>。要配置严重性顺序，请将以下属性添加到您的应用程序属性：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.status.order</span>=<span class="string">fatal,down,out-of-service,unknown,up</span></span><br></pre></td></tr></tbody></table></figure>

<p>响应中的 HTTP 状态代码反映了整体健康状况。默认情况下，<code>OUT_OF_SERVICE</code> 和 <code>DOWN</code> 映射到 503。任何未映射的健康状态（包括 <code>UP</code>）映射到 200。如果通过 HTTP 访问health endpoint，可能还想注册自定义状态映射.配置自定义映射会禁用 <code>DOWN</code> 和 <code>OUT_OF_SERVICE</code> 的默认映射。如果要保留默认映射，则必须与所有自定义映射一起显式配置。例如，以下属性将 <code>FATAL</code> 映射到 503（服务不可用）并保留 <code>DOWN</code> 和 <code>OUT_OF_SERVICE</code> 的默认映射：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.status.http-mapping.down</span>=<span class="string">503management.endpoint.health.status.http-mapping.fatal=503management.endpoint.health.status.http-mapping.out-of-service=503</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>   如果需要更多控制，可以定义自己的 <code>HttpCodeStatusMapper</code> bean。</p>
</blockquote>
<p>下表显示了内置状态的默认状态映射：</p>
<table>
<thead>
<tr>
<th><strong>Status</strong></th>
<th><strong>Mapping</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>DOWN</code></td>
<td><code>SERVICE_UNAVAILABLE</code> (<code>503</code>)</td>
</tr>
<tr>
<td><code>OUT_OF_SERVICE</code></td>
<td><code>SERVICE_UNAVAILABLE</code> (<code>503</code>)</td>
</tr>
<tr>
<td><code>UP</code></td>
<td>默认没有映射，所以 HTTP 状态是 200</td>
</tr>
<tr>
<td><code>UNKNOWN</code></td>
<td>默认没有映射，所以 HTTP 状态是 200</td>
</tr>
</tbody></table>
</li>
<li><h6 id="响应式健康指示器-Reactive-Health-Indicators"><a href="#响应式健康指示器-Reactive-Health-Indicators" class="headerlink" title="响应式健康指示器(Reactive Health Indicators)"></a>响应式健康指示器(Reactive Health Indicators)</h6><p>对于响应式应用程序，例如使用 Spring WebFlux 的应用程序，<code>ReactiveHealthContributor</code> 提供了一个非阻塞方式来获取应用程序健康状况。与传统的 <code>HealthContributor</code> 类似，健康信息是从 <code>ReactiveHealthContributorRegistry</code> 的内容中收集的（默认情况下，您<code>ApplicationContext</code> 中定义的所有 <code>HealthContributor</code> 和 <code>ReactiveHealthContributor</code> 实例）。在弹性调度器上执行的响应式 API的常规 <code>HealthContributor</code>不被检查。</p>
<blockquote>
<p>建议:</p>
<p>   在响应式应用程序中，应使用 <code>ReactiveHealthContributorRegistry</code> 在运行时注册和取消注册健康指示器。如果需要注册一个普通的 <code>HealthContributor</code>，应该使用 <code>ReactiveHealthContributor#adapt</code> 来包装它。</p>
</blockquote>
<p>要从响应式 API 提供自定义健康信息，可以注册实<code>ReactiveHealthIndicator</code> 接口的 Spring bean。以下代码显示了一个示例 <code>ReactiveHealthIndicator</code> 实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactiveHealthIndicator</span> <span class="keyword">implements</span> <span class="title">ReactiveHealthIndicator</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> Mono&lt;Health&gt; <span class="title">health</span><span class="params">()</span> </span>{        <span class="keyword">return</span> doHealthCheck().onErrorResume((exception) -&gt;            Mono.just(<span class="keyword">new</span> Health.Builder().down(exception).build()));    }    <span class="function"><span class="keyword">private</span> Mono&lt;Health&gt; <span class="title">doHealthCheck</span><span class="params">()</span> </span>{        <span class="comment">// perform some specific health check        return ...    }}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>   要自动处理错误，考虑从 <code>AbstractReactiveHealthIndicator</code> 扩展。</p>
</blockquote>
</li>
<li><h6 id="自动配置的-ReactiveHealthIndicators-Auto-configured-ReactiveHealthIndicators"><a href="#自动配置的-ReactiveHealthIndicators-Auto-configured-ReactiveHealthIndicators" class="headerlink" title="自动配置的 ReactiveHealthIndicators(Auto-configured ReactiveHealthIndicators)"></a>自动配置的 ReactiveHealthIndicators(Auto-configured ReactiveHealthIndicators)</h6><p>在适当的时候，Spring Boot 会自动配置以下 <code>ReactiveHealthIndicators</code>：</p>
<table>
<thead>
<tr>
<th><strong>Key</strong></th>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>cassandra</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraDriverReactiveHealthIndicator.java"><code>CassandraDriverReactiveHealthIndicator</code></a></td>
<td>检查 Cassandra 数据库是否已启动。</td>
</tr>
<tr>
<td><code>couchbase</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseReactiveHealthIndicator.java"><code>CouchbaseReactiveHealthIndicator</code></a></td>
<td>检查 Couchbase 集群是否已启动。</td>
</tr>
<tr>
<td><code>elasticsearch</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/elasticsearch/ElasticsearchReactiveHealthIndicator.java"><code>ElasticsearchReactiveHealthIndicator</code></a></td>
<td>检查 Elasticsearch 集群是否已启动。</td>
</tr>
<tr>
<td><code>mongo</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoReactiveHealthIndicator.java"><code>MongoReactiveHealthIndicator</code></a></td>
<td>检查 Mongo 数据库是否已启动。</td>
</tr>
<tr>
<td><code>neo4j</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/neo4j/Neo4jReactiveHealthIndicator.java"><code>Neo4jReactiveHealthIndicator</code></a></td>
<td>检查 Neo4j 数据库是否已启动。</td>
</tr>
<tr>
<td><code>redis</code></td>
<td><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisReactiveHealthIndicator.java"><code>RedisReactiveHealthIndicator</code></a></td>
<td>检查 Redis 服务器是否已启动。</td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<pre><code>如有必要，响应式indicator会取代常规indicator。 此外，任何未明确处理的 `HealthIndicator` 都会自动包装。
</code></pre>
</blockquote>
</li>
<li><h6 id="健康组-Health-Groups"><a href="#健康组-Health-Groups" class="headerlink" title="健康组(Health Groups)"></a>健康组(Health Groups)</h6><p>将健康indicator根据使用目的编成不同的组,这个有时候会很有用。</p>
<p>要创建health indicator group，可以使用 <code>management.endpoint.health.group.&lt;name&gt;</code> 属性并指定要包含或排除的health indicator ID 列表。例如，要创建仅包含database indicator的组，可以定义以下内容：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.group.custom.include</span>=<span class="string">db</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后，可以通过点击 <code>localhost:8080/actuator/health/custom</code> 来检查结果.</p>
<p>同样，要创建一个组,从组中排除数据库指标并包括所有其他指标，可以定义以下内容：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.group.custom.exclude</span>=<span class="string">db</span></span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下，组将继承与系统运行状况相同的 <code>StatusAggregator</code> 和 <code>HttpCodeStatusMapper</code> 设置，但是，也可以在每个组的基础上定义这些设置。如果需要，也可以覆盖 <code>show-details</code> 和 <code>roles</code> 属性：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.group.custom.show-details</span>=<span class="string">when-authorizedmanagement.endpoint.health.group.custom.roles=adminmanagement.endpoint.health.group.custom.status.order=fatal,upmanagement.endpoint.health.group.custom.status.http-mapping.fatal=500management.endpoint.health.group.custom.status.http-mapping.out-of-service=500</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>   如果需要注册自定义 <code>StatusAggregator</code> 或 <code>HttpCodeStatusMapper</code> bean 以与组一起使用，则可以使用 <code>@Qualifier("groupname")</code>。</p>
</blockquote>
</li>
<li><h6 id="数据源安全-DataSource-Health"><a href="#数据源安全-DataSource-Health" class="headerlink" title="数据源安全(DataSource Health)"></a>数据源安全(DataSource Health)</h6><p><code>DataSource</code> 健康指示器显示标准数据源和路由数据源 bean 的健康状况。路由数据源的健康状况包括其每个目标数据源的健康状况。在health endpoint的响应中，每个路由数据源的目标都使用其路由key命名。如果不想在指标的输出中包含路由数据源，请将 <code>management.health.db.ignore-routing-data-sources</code> 设置为 true。</p>
</li>
</ol>
</li>
<li><h6 id="Kubernetes-探测器-Kubernetes-Probes"><a href="#Kubernetes-探测器-Kubernetes-Probes" class="headerlink" title="Kubernetes 探测器(Kubernetes Probes)"></a>Kubernetes 探测器(Kubernetes Probes)</h6><p>部署在 Kubernetes 上的应用程序可以通过 Container Probes 提供有关其内部状态的信息。根据 Kubernetes 配置，kubelet 将调用这些探测器并对结果做出反应。</p>
<p>Spring Boot 开箱即用地管理应用程序可用性状态。如果部署在 Kubernetes 环境中，执行器将从 <code>ApplicationAvailability</code> 接口收集“Liveness”和“Readiness”信息，并在专用健康指示器中使用该信息：<code>LivenessStateHealthIndicator</code> 和 <code>ReadinessStateHealthIndicator</code>。这些indicator将显示在全局health endpoint（<code>“/actuator/health”</code>）上。 将使用健康组将它们作为单独的 HTTP 探测器公开：<code>“/actuator/health/liveness”</code>和<code>“/actuator/health/readiness”</code>。</p>
<p>然后，可以使用以下endpoint信息配置您的 Kubernetes infrastructure：</p>
<figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ivenessProbe:  httpGet:    path: /actuator/health/liveness    port:</span> <span class="string">&lt;actuator-port&gt;</span>  <span class="attr">failureThreshold: ...  periodSeconds: ...readinessProbe:  httpGet:    path: /actuator/health/readiness    port:</span> <span class="string">&lt;actuator-port&gt;</span>  <span class="attr">failureThreshold: ...  periodSeconds:</span> <span class="string">...</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>   <code>&lt;actuator-port&gt;</code> 应设置为执行器endpoint可用的端口。如果设置了<code>“management.server.port”</code>属性，它可能是主要的 Web 服务器端口，或者一个单独的管理端口。</p>
</blockquote>
<p>仅当应用程序在 Kubernetes 环境中运行时才会自动启用这些健康组。可以使用 <code>management.endpoint.health.probes.enabled</code> 配置属性在任何环境中启用它们。</p>
<blockquote>
<p>注意:</p>
<p>   如果应用的启动时间比配置的活跃期长，Kubernetes 会提到<code>“startupProbe”</code>作为可能的解决方案。这里不一定需要<code>“startupProbe”</code>，因为<code>“readinessProbe”</code>会一直失败直到在所有启动任务完成，请查看 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.endpoints.kubernetes-probes.lifecycle">how Probes behave during the application lifecycle</a>。</p>
<p>警告:</p>
<p>   如果 Actuator endpoint部署在单独的管理context中，请注意endpoint不会使用与主应用程序相同的 Web 基础设施（端口、连接池、框架组件）。在这种情况下，即使主应用程序不能正常工作（例如，它不能接受新连接），探测检查也可能成功。</p>
</blockquote>
<ol>
<li><h6 id="使用-Kubernetes-探测器检查外部状态-Checking-External-State-with-Kubernetes-Probes"><a href="#使用-Kubernetes-探测器检查外部状态-Checking-External-State-with-Kubernetes-Probes" class="headerlink" title="使用 Kubernetes 探测器检查外部状态(Checking External State with Kubernetes Probes)"></a>使用 Kubernetes 探测器检查外部状态(Checking External State with Kubernetes Probes)</h6><p>Actuator 将“liveness”和“readiness”探测器配置为健康组；这意味着他们可以使用所有健康组功能。例如，可以配置额外的health indicator：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.group.readiness.include</span>=<span class="string">readinessState,customCheck</span></span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下，Spring Boot 不会向这些组添加其他health indicator。</p>
<p>“liveness”探测器不应依赖于外部系统的健康检查。如果应用的 Liveness State 被破坏，Kubernetes 将尝试通过重新启动应用程序实例来解决该问题。这意味着如果外部系统出现故障（例如数据库、Web API、外部缓存），Kubernetes 可能会重新启动所有应用程序实例并造成级联故障。</p>
<p>至于“readiness”探测器，应用程序开发人员必须谨慎选择检查外部系统，即 Spring Boot 在“readiness”探测器中不包含任何额外的健康检查。如果应用实例的状态是未就绪，Kubernetes 不会将流量路由到该实例。一些外部系统可能不会被应用程序实例共享，在这种情况下，它们可以很自然地包含在就绪探测中。其他外部系统可能对应用程序不是必需的（应用程序可能有断路器和回退），在这种情况下，它们绝对不应该被包含在内。不幸的是，外部系统被所有应用程序实例共享是很常见的，并且必须做出判断调用：将其包含在readiness probe中，并期望在外部服务关闭时应用程序停止服务，或者忽略它并处理堆栈更高层的故障，例如 在调用者中使用断路器。</p>
<blockquote>
<p>注意:</p>
<p>   如果应用的所有实例都未就绪，则 <code>type=ClusterIP</code> 或 <code>NodePort</code> 的 Kubernetes 服务将不接受任何传入连接。由于没有连接，因此没有 HTTP 错误响应（503 等）。<code>type=LoadBalancer</code> 的服务可能接受也可能不接受连接，具体取决于provider。具有显式 Ingress 的 Service 也会以依赖于实现的方式进行响应 - Ingress 服务本身必须决定如何处理来自下游的“connection refused”。很可能在负载均衡器和入口的情况下,可能出现HTTP 503 。</p>
</blockquote>
<p>此外，如果应用使用 Kubernetes 自动缩放，它可能会对被从负载均衡器中取出的应用做出不同的反应，具体取决于其自动缩放器配置。</p>
</li>
<li><h6 id="应用程序生命周期和探测状态-Application-Lifecycle-and-Probe-States"><a href="#应用程序生命周期和探测状态-Application-Lifecycle-and-Probe-States" class="headerlink" title="应用程序生命周期和探测状态(Application Lifecycle and Probe States)"></a>应用程序生命周期和探测状态(Application Lifecycle and Probe States)</h6><p>Kubernetes Probes 支持的一个重要方面是它与应用程序生命周期的一致性。<code>AvailabilityState</code> 是应用在内存中的内部状态，与公开该状态的实际探测器之间存在显着差异：根据应用程序生命周期的阶段，探测器可能不可用。</p>
<p>Spring Boot 在启动和关闭期间发布 Application Events，Probes 可以监听此类事件并暴露 <code>AvailabilityState</code> 信息。</p>
<p>下表显示了不同阶段的 <code>AvailabilityState</code> 和 HTTP 连接器的状态。</p>
<p>当 Spring Boot 应用程序启动时：</p>
<table>
<thead>
<tr>
<th><strong>Startup phase</strong></th>
<th><strong>LivenessState</strong></th>
<th><strong>ReadinessState</strong></th>
<th><strong>HTTP server</strong></th>
<th><strong>Notes</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Starting</td>
<td><code>BROKEN</code></td>
<td><code>REFUSING_TRAFFIC</code></td>
<td>Not started</td>
<td>Kubernetes 会检查“活跃度”探测器，如果时间过长，则重新启动应用程序。</td>
</tr>
<tr>
<td>Started</td>
<td><code>CORRECT</code></td>
<td><code>REFUSING_TRAFFIC</code></td>
<td>Refuses requests</td>
<td>应用程序上下文被刷新。 应用程序执行启动任务，但尚未接收流量。</td>
</tr>
<tr>
<td>Ready</td>
<td><code>CORRECT</code></td>
<td><code>ACCEPTING_TRAFFIC</code></td>
<td>Accepts requests</td>
<td>启动任务完成。 应用程序正在接收流量。</td>
</tr>
</tbody></table>
<p>当 Spring Boot 应用程序关闭时：</p>
<table>
<thead>
<tr>
<th>Shutdown phase</th>
<th>Liveness State</th>
<th>Readiness State</th>
<th>HTTP server</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>Running</td>
<td><code>CORRECT</code></td>
<td><code>ACCEPTING_TRAFFIC</code></td>
<td>Accepts requests</td>
<td>已请求关闭。</td>
</tr>
<tr>
<td>Graceful shutdown</td>
<td><code>CORRECT</code></td>
<td><code>REFUSING_TRAFFIC</code></td>
<td>New requests are rejected</td>
<td>如果启用，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.graceful-shutdown">正常关闭处理正在进行的请求</a>。</td>
</tr>
<tr>
<td>Shutdown complete</td>
<td>N/A</td>
<td>N/A</td>
<td>Server is shut down</td>
<td>应用程序上下文关闭，应用程序关闭。</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><h6 id="应用信息-Application-Information"><a href="#应用信息-Application-Information" class="headerlink" title="应用信息(Application Information)"></a>应用信息(Application Information)</h6><p>应用程序信息公开从 <code>ApplicationContext</code> 中定义的所有 <code>InfoContributor</code> bean 收集的各种信息.Spring Boot 包含许多自动配置的 <code>InfoContributor</code> bean，可以编写自己的 bean。</p>
<ol>
<li><h6 id="自动配置的-InfoContributors-Auto-configured-InfoContributors"><a href="#自动配置的-InfoContributors-Auto-configured-InfoContributors" class="headerlink" title="自动配置的 InfoContributors(Auto-configured InfoContributors)"></a>自动配置的 InfoContributors(Auto-configured InfoContributors)</h6><p>在适当的时候，Spring Boot 会自动配置以下 <code>InfoContributor</code> bean：</p>
<table>
<thead>
<tr>
<th align="center">Name</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.java"><code>EnvironmentInfoContributor</code></a></td>
<td align="center">在 <code>info</code> 键下暴露 <code>Environment</code> 中的所有键。</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/GitInfoContributor.java"><code>GitInfoContributor</code></a></td>
<td align="center">如果 <code>git.properties</code> 文件可用，则公开 git 信息。</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/BuildInfoContributor.java"><code>BuildInfoContributor</code></a></td>
<td align="center">如果<code>META-INF/build-info.properties</code>文件可用，则公开构建信息。</td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>   可以通过设置 <code>management.info.defaults.enabled</code> 属性来禁用它们。</p>
</blockquote>
</li>
<li><h6 id="自定义应用信息-Custom-Application-Information"><a href="#自定义应用信息-Custom-Application-Information" class="headerlink" title="自定义应用信息(Custom Application Information)"></a>自定义应用信息(Custom Application Information)</h6><p>可以通过设置 <code>info.*</code> Spring 属性来自定义 info endpoint公开的数据。<code>info</code> key下的所有 <code>Environment</code> 属性都会自动公开。例如，可以将以下设置添加到 <code>application.properties</code> 文件中：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">info.app.encoding</span>=<span class="string">UTF-8info.app.java.source=11info.app.java.target=11</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>   还可以在构建时展开信息属性，而不是对这些值进行硬编码。假设使用 Maven，可以按如下方式重写前面的示例：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;info.app.encoding</span>=<span class="string">@project.build.sourceEncoding@info.app.java.source=@java.version@info.app.java.target=@java.version@</span></span><br></pre></td></tr></tbody></table></figure></blockquote>
</li>
<li><h6 id="Git提交信息-Git-Commit-Information"><a href="#Git提交信息-Git-Commit-Information" class="headerlink" title="Git提交信息(Git Commit Information)"></a>Git提交信息(Git Commit Information)</h6><p><code>info</code> endpoint的另一个有用功能是它能够在构建项目时发布有关 <code>git</code> 源代码存储库状态的信息。如果 <code>GitProperties</code> bean 可用，则可以使用 <code>info</code> endpoint来公开这些属性。</p>
<blockquote>
<p>建议:</p>
<p>   如果 <code>git.properties</code> 文件在类路径的根目录下可用，则 <code>GitProperties</code> bean 是自动配置的。</p>
</blockquote>
<p>默认情况下，endpoint公开 <code>git.branch</code>、<code>git.commit.id</code> 和 <code>git.commit.time</code> 属性（如果存在）。如果不希望endpoint响应中出现这些属性中的任何一个，则需要将它们从 <code>git.properties</code> 文件中排除。如果要显示完整的git信息（即<code>git.properties</code>的全部内容），使用<code>management.info.git.mode</code>属性，如下：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.info.git.mode</span>=<span class="string">full</span></span><br></pre></td></tr></tbody></table></figure>

<p>要完全禁用 <code>info</code> endpoint的 git commit 信息，请将 <code>management.info.git.enabled</code> 属性设置为 <code>false</code>，如下所示：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.info.git.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="构建信息-Build-Information"><a href="#构建信息-Build-Information" class="headerlink" title="构建信息(Build Information)"></a>构建信息(Build Information)</h6><p>如果 <code>BuildProperties</code> bean 可用，则 <code>info</code> endpoint还可以发布有关您建的信息。如果类路径中有 <code>META-INF/build-info.properties</code> 文件，就会发生这种情况。</p>
<blockquote>
<p>建议:</p>
<p>   Maven 和 Gradle 插件都可以生成该文件。</p>
</blockquote>
</li>
<li><h6 id="编写自定义-InfoContributor-Writing-Custom-InfoContributors"><a href="#编写自定义-InfoContributor-Writing-Custom-InfoContributors" class="headerlink" title="编写自定义 InfoContributor(Writing Custom InfoContributors)"></a>编写自定义 InfoContributor(Writing Custom InfoContributors)</h6><p>要提供自定义应用信息，可以注册实现 <code>InfoContributor</code> 接口的 Spring bean。</p>
<p>以下示例提供了一个具有单个值的<code>example</code>条目：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInfoContributor</span> <span class="keyword">implements</span> <span class="title">InfoContributor</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contribute</span><span class="params">(Info.Builder builder)</span> </span>{        builder.withDetail(<span class="string">"example"</span>, Collections.singletonMap(<span class="string">"key"</span>, <span class="string">"value"</span>));    }}</span><br></pre></td></tr></tbody></table></figure>

<p>如果访问 <code>info</code> endpoint，应该会看到包含以下附加条目的响应：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{    <span class="attr">"example"</span>: {        <span class="attr">"key"</span> : <span class="string">"value"</span>    }}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/4391.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/4391.html" class="post-title-link" itemprop="url">4.1 Actuator:  启用生产就绪功能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:18:00 / 修改时间：12:51:45" itemprop="dateCreated datePublished" datetime="2021-06-10T12:18:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/4391.html" class="post-meta-item leancloud_visitors" data-flag-title="4.1 Actuator:  启用生产就绪功能" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>710</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Spring-Boot-Actuator：生产就绪功能"><a href="#Spring-Boot-Actuator：生产就绪功能" class="headerlink" title="Spring Boot Actuator：生产就绪功能"></a>Spring Boot Actuator：生产就绪功能</h4><p>Spring Boot 包含许多附加功能，应用程序发布到生产环境后,可以帮助监控和管理应用。可以选择使用 HTTP endpoints 或 JMX 来管理和监控应用程序。审计、健康和指标收集也可以自动应用到应用上。</p>
<ol>
<li><h5 id="启用生产就绪功能-Enabling-Production-ready-Features"><a href="#启用生产就绪功能-Enabling-Production-ready-Features" class="headerlink" title="启用生产就绪功能(Enabling Production-ready Features)"></a>启用生产就绪功能(Enabling Production-ready Features)</h5><p><code>spring-boot-actuator</code> 模块提供 Spring Boot 的所有Production-ready功能。启用功能的方法是添加 <code>spring-boot-starter-actuator</code> ‘Starter’的依赖。</p>
<blockquote>
<p>Actuator的定义:</p>
<p>actuator 是一个制造术语，指的是用于移动或控制某物的机械装置。执行器可以从一个小的修改中产生大量的运动。</p>
</blockquote>
<p>要将actuator 添加到基于 Maven 的项目，请添加以下“Starter”依赖项：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>对于 Gradle，请使用以下声明：</p>
<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> {</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/29720.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/29720.html" class="post-title-link" itemprop="url">3.31 Feature:  容器镜像</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:13:07 / 修改时间：12:51:56" itemprop="dateCreated datePublished" datetime="2021-06-10T12:13:07+08:00">2021-06-10</time>
    </span>

  
    <span id="/posts/29720.html" class="post-meta-item leancloud_visitors" data-flag-title="3.31 Feature:  容器镜像" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-31-容器镜像-Container-Images"><a href="#3-31-容器镜像-Container-Images" class="headerlink" title="3.31 容器镜像(Container Images)"></a>3.31 容器镜像(Container Images)</h5><ol start="31">
<li><h5 id="容器镜像-Container-Images"><a href="#容器镜像-Container-Images" class="headerlink" title="容器镜像(Container Images)"></a>容器镜像(Container Images)</h5><p>很容易将 Spring Boot fat jar 打包为 docker 镜像.然而,复制和运行 docker 镜像中的 fat jar 有很多缺点.在不拆包的情况下运行一个fat jar时总是会有一定的开销,而在容器化环境中,这可能会很明显.另一个问题是将应用的代码及其所有依赖项放在 Docker 镜像的一层中是次选的.由于与升级所使用的 Spring Boot 版本相比,可能更频繁地重新编译代码,因此最好将内容分开一些.如果在应用程序类之前将 jar 文件放在层中,Docker 通常只需要更改最底层,并且可以从其缓存中提取其他层.</p>
<ol>
<li><h6 id="分层-Docker-镜像"><a href="#分层-Docker-镜像" class="headerlink" title="分层 Docker 镜像"></a>分层 Docker 镜像</h6><p>为了更轻松地创建优化的 Docker 镜像,Spring Boot 支持向 jar 添加层索引文件.它提供了一个层列表以及部分能够包含一部分jar.索引中的层列表排序和添加到 Docker/OCI 镜像的顺序相同.支持以下开箱即用的层:</p>
<ul>
<li><code>dependencies</code>(用于常规发布的依赖项)</li>
<li><code>spring-boot-loader</code>(适用于 <code>org/springframework/boot/loader</code> 下的所有内容)</li>
<li><code>snapshot-dependencies</code>(用于快照依赖)</li>
<li><code>application</code>(用于应用程序类和资源)</li>
</ul>
<p>下面显示了一个 <code>layers.idx</code> 文件的例子:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">"dependencies":</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BOOT-INF/lib/library1.jar</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BOOT-INF/lib/library2.jar</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">"spring-boot-loader":</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">org/springframework/boot/loader/JarLauncher.class</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">org/springframework/boot/loader/jar/JarEntry.class</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">"snapshot-dependencies":</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BOOT-INF/lib/library3-SNAPSHOT.jar</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">"application":</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">META-INF/MANIFEST.MF</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BOOT-INF/classes/a/b/C.class</span></span><br></pre></td></tr></tbody></table></figure>

<p>这种分层根据应用程序的构建可能会改变分隔代码.库代码不太可能在构建时发生变化,因此它被放置在自己的层中,以允许工具重新使用缓存中的层.应用程序更有可能在构建时发生变化,因此它被隔离在一个单独的层中.</p>
<p>Spring Boot 还支持使用<code>layers.idx</code> 对war 文件进行分层.</p>
<p>对于 Maven,请参阅 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/reference/htmlsingle/#repackage-layers">packaging layered jar or war section</a>以获取有关向存档添加层索引的更多详细信息.对于 Gradle,请参阅 Gradle 插件文档的打包分层 jar 或 war 部分( <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#packaging-layered-archives">packaging layered jar or war section</a>).</p>
</li>
<li><h6 id="Building-Container-Images"><a href="#Building-Container-Images" class="headerlink" title="Building Container Images"></a>Building Container Images</h6><p>Spring Boot 应用程序可以使用 Dockerfiles 进行容器化,或者使用 Cloud Native Buildpacks 来创建可以在任何地方运行的与 docker 兼容的容器镜像.</p>
<ol>
<li><h6 id="Dockerfiles"><a href="#Dockerfiles" class="headerlink" title="Dockerfiles"></a>Dockerfiles</h6><p>虽然可以通过 <code>Dockerfile</code> 中的几行代码将 Spring Boot fat jar 转换为 docker 镜像,但我们将使用分层功能来创建优化的 docker 镜像.当创建一个包含layer索引文件的 jar 时,<code>spring-boot-jarmode-layertools</code> jar 将作为依赖添加到 jar 中.当类路径上有这个jar时,可以以一种特殊的模式启动应用,允许引导代码运行与应用程序完全不同的内容,例如,提取layer的内容.</p>
<blockquote>
<p>Caution:</p>
<p>​    <code>layertools</code> 模式不能与包含启动脚本的完全可执行的 Spring Boot 存档一起使用.想要构建一个可以使用<code>layertools </code>的jar时,要禁用启动脚本.</p>
</blockquote>
<p>以下是使用 <code>layertools</code> jar 模式启动 jar 的方法:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -Djarmode=layertools -jar my-app.jar</span></span><br></pre></td></tr></tbody></table></figure>

<p>这将提供以下输出:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  java -Djarmode=layertools -jar my-app.jar</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line">  list     List layers from the jar that can be extracted</span><br><span class="line">  extract  Extracts layers from the jar for image creation</span><br><span class="line">  help     Help about any command</span><br></pre></td></tr></tbody></table></figure>

<p><code>extract</code>命令可用于轻松地将应用程序拆分为层,然后这些层可以添加到 dockerfile .这是一个使用 <code>jarmode</code> 的 Dockerfile 示例.</p>
<figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> adoptopenjdk:<span class="number">11</span>-jre-hotspot as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> application</span></span><br><span class="line"><span class="keyword">ARG</span> JAR_FILE=target/*.jar</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">${JAR_FILE}</span> application.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> java -Djarmode=layertools -jar application.jar extract</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> adoptopenjdk:<span class="number">11</span>-jre-hotspot</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> application</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/dependencies/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/spring-boot-loader/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/snapshot-dependencies/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/application/ ./</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>, <span class="string">"org.springframework.boot.loader.JarLauncher"</span>]</span></span><br></pre></td></tr></tbody></table></figure>

<p>假设上述 <code>Dockerfile</code> 位于当前目录中, docker 镜像可以使用 <code>docker build</code> . 构建,或者可以选择指定应用程序 jar 的路径,如下例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build --build-arg JAR_FILE=path/to/myapp.jar .</span></span><br></pre></td></tr></tbody></table></figure>

<p>这是一个多stage的 dockerfile.builder stage 提取以后需要的目录.每个 <code>COPY</code> 命令都与 jarmode 提取的层相关.</p>
<p>当然,不使用jarmode也可以写一个Dockerfile.可以使用 <code>unzip</code> 和 <code>mv</code> 的组合将内容移动到正确的层,但 jarmode 简化了这一点.</p>
</li>
<li><h6 id="云本地Buildpacks-Cloud-Native-Buildpacks"><a href="#云本地Buildpacks-Cloud-Native-Buildpacks" class="headerlink" title="云本地Buildpacks(Cloud Native Buildpacks)"></a>云本地Buildpacks(Cloud Native Buildpacks)</h6><p>Dockerfiles 只是构建 docker 镜像的一种方式. 另一种构建 docker 镜像的方法是直接从你的 Maven 或 Gradle 插件中使用 buildpacks.如果曾经使用过 Cloud Foundry 或 Heroku 等应用平台,那么可能已经使用过 buildpack.Buildpacks 是平台的一部分,它将应用转换为平台可以实际运行的东西.例如,Cloud Foundry 的 Java buildpack 会发现正在推送的 <code>.jar</code> 文件并自动添加相关的 JRE.</p>
<p>使用 Cloud Native Buildpacks,可以创建可在任何地方运行的 Docker 兼容镜像.Spring Boot 包括直接支持 Maven 和 Gradle 的 buildpack.这意味着只需输入一个命令,即可快速将合理的映像放入本地运行的 Docker 守护程序中.</p>
<p>请参阅有关如何在 Maven(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/reference/htmlsingle/#build-image">Maven</a>) 和 Gradle(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#build-image">Gradle</a>) 中使用 buildpack 的各个插件文档.</p>
<blockquote>
<p>注意:</p>
<p>​    Paketo Spring Boot buildpack 也已更新以支持 <code>layer.idx</code> 文件,因此对它的任何自定义都将反映在 buildpack 创建的image中.</p>
<p>注意:</p>
<p>​    为了实现可重现的构建和容器镜像缓存,Buildpacks 可以操作应用程序资源元数据(例如文件”last modified”的信息).应该确保应用程序在运行时不依赖该元数据.Spring Boot 可以在提供静态资源时使用该信息,但这可以通过 <code>spring.web.resources.cache.use-last-modified</code> 禁用.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/11629.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/11629.html" class="post-title-link" itemprop="url">3.30 Feature: Kotlin 支持</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:11:00 / 修改时间：12:52:03" itemprop="dateCreated datePublished" datetime="2021-06-10T12:11:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/11629.html" class="post-meta-item leancloud_visitors" data-flag-title="3.30 Feature: Kotlin 支持" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-30-Kotlin-支持"><a href="#3-30-Kotlin-支持" class="headerlink" title="3.30 Kotlin 支持"></a>3.30 Kotlin 支持</h5><ol start="30">
<li><h6 id="3-30-Kotlin-支持-Kotlin-support"><a href="#3-30-Kotlin-支持-Kotlin-support" class="headerlink" title="3.30 Kotlin 支持(Kotlin support)"></a>3.30 Kotlin 支持(Kotlin support)</h6><p>Kotlin 是一种面向 JVM(和其他平台)的静态类型语言,它允许编写简洁优雅的代码,同时提供与用 Java 编写的现有库的互操作性.</p>
<p>Spring Boot 通过利用其他 Spring 项目(如 Spring Framework,Spring Data 和 Reactor)中的支持来提供 Kotlin 支持.</p>
<p>开始使用 Spring Boot 和 Kotlin 的最简单方法是遵循这个综合教程(<a target="_blank" rel="noopener" href="https://spring.io/guides/tutorials/spring-boot-kotlin/">this comprehensive tutorial</a>). 可以通过 start.spring.io 创建新的 Kotlin 项目. 如果需要支持,请随时加入 Kotlin Slack 的 #spring 频道或在 Stack Overflow 上提出有关 spring 和 kotlin 标签的问题.</p>
<ol>
<li><h6 id="要求-Requirements"><a href="#要求-Requirements" class="headerlink" title="要求(Requirements)"></a>要求(Requirements)</h6><p>Spring Boot 支持 Kotlin 1.3.x. 要使用 Kotlin,类路径中必须存在 <code>org.jetbrains.kotlin:kotlin-stdlib</code> 和 <code>org.jetbrains.kotlin:kotlin-reflect</code>.也可以使用 <code>kotlin-stdlib</code> 变体 <code>kotlin-stdlib-jdk7</code> 和 <code>kotlin-stdlib-jdk8</code>.</p>
<p>由于 Kotlin 类在默认情况下是 final 的,可能希望配置 kotlin-spring 插件以自动打开 Spring 注解标注的的类,以便它们可以被代理.</p>
<p>在 Kotlin 中序列化/反序列化 JSON 数据需要 Jackson 的 Kotlin 模块.在classpath中找到它时会自动注册.如果 Jackson 和 Kotlin 存在但 Jackson Kotlin 模块不存在,则会记录一条警告消息.</p>
<blockquote>
<p>建议:</p>
<p>​    如果在 start.spring.io 上引导 Kotlin 项目,则默认提供这些依赖项和插件.</p>
</blockquote>
</li>
<li><h6 id="Null-safety"><a href="#Null-safety" class="headerlink" title="Null-safety"></a>Null-safety</h6><p>Kotlin 的主要特性之一是空值安全性.它在编译时处<code>null</code>,而不是将问题推迟到运行时并遇到 <code>NullPointerException</code>.这有助于消除常见的错误来源,而无需耗费 <code>Optional</code> 等包装器的成本.Kotlin 还允许使用具有可为空值的函数构造,如 Kotlin 中的空值安全综合指南(<a target="_blank" rel="noopener" href="https://www.baeldung.com/kotlin-null-safety">comprehensive guide to null-safety in Kotlin</a>)中所述.</p>
<p>尽管 Java 不允许在其类型系统中表达null-safety,但 Spring Framework,Spring Data 和 Reactor 现在通过工具友好型注解提供其 API 的null-safety.默认情况下, Kotlin 中使用的 Java API 的类型被识别为平台类型,并且relax null-checks.Kotlin 对 JSR 305 注解的支持与nullability注解相结合,为 Kotlin 中的相关 Spring API 提供了空安全性.</p>
<p>可以通过添加带有以下选项的 <code>-Xjsr305</code> 编译器标志来配置 JSR 305 检查: <code>-Xjsr305={strict|warn|ignore}</code>.默认行为与 <code>-Xjsr305=warn</code> 相同.在从 Spring API 推断出的 Kotlin 类型中,需要使用 <code>strict</code> 值来考虑null-safety,但也应该要知道,使用 Spring API nullability声明即使在次要版本之间也可以发展,并且将来可能会添加更多.</p>
<blockquote>
<p>警告:</p>
<p>​    尚不支持Generic类型参数,可变参数和数组元素nullability.</p>
</blockquote>
</li>
<li><h6 id="Kotlin-API"><a href="#Kotlin-API" class="headerlink" title="Kotlin API"></a>Kotlin API</h6><p>[[features.kotlin.api.?run-application]] ==== runApplication Spring Boot 提供了一种使用 <code>runApplication&lt;MyApplication&gt;(*args) </code>运行应用程序的方法,如下例所示:</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.runApplication</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">    runApplication&lt;MyApplication&gt;(*args)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是 <code>SpringApplication.run(MyApplication::class.java, *args)</code> 的替代品.它还允许自定义应用程序,如以下示例所示:</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runApplication&lt;MyApplication&gt;(*args) {</span><br><span class="line">    setBannerMode(OFF)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><h6 id="扩展-Extensions"><a href="#扩展-Extensions" class="headerlink" title="扩展(Extensions)"></a>扩展(Extensions)</h6><p>Kotlin 扩展提供了使用额外功能扩展现有类的能力.Spring Boot Kotlin API 利用这些扩展为现有 API 添加新的特定 Kotlin 的 conveniences .</p>
<p>提供了 <code>TestRestTemplate</code> 扩展,类似于 Spring Framew          ork 为 Spring Framework 中的 <code>RestOperations</code> 提供的扩展.除其他外,这些扩展利用 Kotlin 实体化类型参数.</p>
</li>
</ol>
</li>
<li><h6 id="依赖管理-Dependency-management"><a href="#依赖管理-Dependency-management" class="headerlink" title="依赖管理(Dependency management)"></a>依赖管理(Dependency management)</h6><p>为了避免在类路径上混合不同版本的 Kotlin 依赖,Spring Boot 导入了 Kotlin BOM.</p>
<p>使用 Maven,可以通过 <code>kotlin.version</code> 属性自定义 Kotlin 版本,并为 <code>kotlin-maven-plugin</code> 提供插件管理.使用 Gradle,Spring Boot 插件会自动将 <code>kotlin.version</code> 与 Kotlin 插件的版本对齐.</p>
<p>Spring Boot 还通过导入 Kotlin 协程 BOM 来管理协程依赖的版本.可以通过 <code>kotlin-coroutines.version</code> 属性自定义版本.</p>
<blockquote>
<p>建议:</p>
<p>​    <code>org.jetbrains.kotlinx:kotlinx-coroutines-reactor</code> 依赖项是默认提供的,如果引导一个 Kotlin 项目在 <code>start.spring.io</code> 至少有一个响应式依赖项.</p>
</blockquote>
</li>
<li><h6 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h6><p><code>@ConfigurationProperties</code> 与 <code>@ConstructorBinding</code> 结合使用时支持不可变 <code>val</code> 属性的类,如下例所示:</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(<span class="meta-string">"example.kotlin"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinExampleProperties</span></span>(</span><br><span class="line">        <span class="keyword">val</span> name: String,</span><br><span class="line">        <span class="keyword">val</span> description: String,</span><br><span class="line">        <span class="keyword">val</span> myService: MyService) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span></span>(</span><br><span class="line">            <span class="keyword">val</span> apiToken: String,</span><br><span class="line">            <span class="keyword">val</span> uri: URI</span><br><span class="line">    )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    要使用注释处理器生成您自己的元数据,应该使用 <code>spring-boot-configuration-processor</code> 依赖项配置 <code>kapt</code>.请注意,由于 <code>kapt </code>提供模型的限制,某些功能(例如检测default 值或deprecated 项目)无法正常工作.</p>
</blockquote>
</li>
<li><h6 id="测试-Testing"><a href="#测试-Testing" class="headerlink" title="测试(Testing)"></a>测试(Testing)</h6><p>虽然可以使用 JUnit 4 来测试 Kotlin 代码,但默认情况下提供并推荐使用 JUnit 5.这使得在非静态方法上可以使用 <code>@BeforeAll</code> 和 <code>@AfterAll</code> 注解,非常适合 Kotlin.</p>
<p>要模拟 Kotlin 类,建议使用 MockK.如果需要类似于 <code>Mockito</code> 特有的 <code>@MockBean</code> 和 <code>@SpyBean</code> 注解的 <code>Mockk</code> 等效项,可以使用提供类似 <code>@MockkBean</code> 和 <code>@SpykBean</code> 注解的 SpringMockK.</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/53310.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/53310.html" class="post-title-link" itemprop="url">3.29 Feature: 创建自己的自动配置 </a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:10:00 / 修改时间：12:52:14" itemprop="dateCreated datePublished" datetime="2021-06-10T12:10:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/53310.html" class="post-meta-item leancloud_visitors" data-flag-title="3.29 Feature: 创建自己的自动配置 " title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-29-创建自己的自动配置-Creating-Your-Own-Auto-configuration"><a href="#3-29-创建自己的自动配置-Creating-Your-Own-Auto-configuration" class="headerlink" title="3.29 创建自己的自动配置(Creating Your Own Auto-configuration)"></a>3.29 创建自己的自动配置(Creating Your Own Auto-configuration)</h5><ol start="29">
<li><h5 id="创建自己的自动配置-Creating-Your-Own-Auto-configuration"><a href="#创建自己的自动配置-Creating-Your-Own-Auto-configuration" class="headerlink" title="创建自己的自动配置(Creating Your Own Auto-configuration)"></a>创建自己的自动配置(Creating Your Own Auto-configuration)</h5><p>如果在开发共享库的公司工作,或者正在开发开源或商业库,可能希望开发自己的自动配置.自动配置类可以捆绑在外部 jar 中,并且仍然可以由 Spring Boot 获取.</p>
<p>自动配置可以与”starter”相关联, 启动器提供自动配置代码以及典型的库.</p>
<ol>
<li><h6 id="了解自动配置的-Bean-Understanding-Auto-configured-Beans"><a href="#了解自动配置的-Bean-Understanding-Auto-configured-Beans" class="headerlink" title="了解自动配置的 Bean (Understanding Auto-configured Beans)"></a>了解自动配置的 Bean (Understanding Auto-configured Beans)</h6><p>自动配置是使用标准 <code>@Configuration</code> 类实现的.<code>@Conditional</code> 注解用于限制何时应应用自动配置.通常,自动配置类使用 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingBean</code> 注解.这确保自动配置仅在找到相关类并且尚未声明自己的 <code>@Configuration</code> 时才应用.</p>
<p>可以浏览 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure"><code>spring-boot-autoconfigure</code></a> 的源代码以查看 Spring 提供的 <code>@Configuration</code> 类(请参阅 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories"><code>META-INF/spring.factories</code></a> 文件).</p>
</li>
<li><h6 id="定位自动配置Candidates-Locating-Auto-configuration-Candidates"><a href="#定位自动配置Candidates-Locating-Auto-configuration-Candidates" class="headerlink" title="定位自动配置Candidates (Locating Auto-configuration Candidates)"></a>定位自动配置Candidates (Locating Auto-configuration Candidates)</h6><p>Spring Boot 检查发布的 jar 中是否存在 <code>META-INF/spring.factories</code> 文件.该文件应在 <code>EnableAutoConfiguration</code> key下列出配置类,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    必须<strong>仅</strong>以这种方式加载自动配置. 确保它们是在特定的package空间中定义的,并且它们永远不会成为组件扫描的目标.此外,自动配置类不应启用组件扫描以查找其他组件. 应该使用特定的<code>@Imports</code>.</p>
</blockquote>
<p>如果配置需要按特定顺序应用,可以使用 <code>@AutoConfigureAfter</code> 或 <code>@AutoConfigureBefore</code> 注解.例如,如果提供特定于 Web 的配置,则类可能需要在 <code>WebMvcAutoConfiguration</code> 之后应用.</p>
<p>如果想指定某些互不直接了解的自动配置的顺序,还可以使用 <code>@AutoConfigureOrder</code>.该注解与常规的 <code>@Order</code> 注解具有相同的语义,但为自动配置类提供指定顺序.</p>
<p>与标准<code>@Configuration</code> 类一样,应用自动配置类的顺序仅影响定义它们的 bean 的顺序.随后这些 bean 的创建顺序不受影响,并由每个 bean 的依赖项和任何 <code>@DependsOn</code> 关系决定.</p>
</li>
<li><h6 id="条件注解-Condition-Annotations"><a href="#条件注解-Condition-Annotations" class="headerlink" title="条件注解(Condition Annotations)"></a>条件注解(Condition Annotations)</h6><p>几乎总是希望在自动配置类中包含一个或多个 <code>@Conditional</code> 注解.<code>@ConditionalOnMissingBean</code> 注解是一个常见示例,如果开发人员对默认设置不满意,则可以使用它来覆盖自动配置.</p>
<p>Spring Boot 包含许多 <code>@Conditional</code> 注解,可以通过 <code>@Configuration</code> 注解或单个 <code>@Bean</code> 方法在自己的代码中重用这些注解. 这些注解包括:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.class-conditions">Class Conditions</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.bean-conditions">Bean Conditions</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.property-conditions">Property Conditions</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.resource-conditions">Resource Conditions</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.web-application-conditions">Web Application Conditions</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.spel-conditions">SpEL Expression Conditions</a></li>
</ul>
<ol>
<li><h6 id="Class条件-Class-Conditions"><a href="#Class条件-Class-Conditions" class="headerlink" title="Class条件(Class Conditions)"></a>Class条件(Class Conditions)</h6><p><code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingClass</code> 注解让 <code>@Configuration</code> 类根据指定类的存在或不存在来确定是否被包含.由于注解元数据是使用 ASM 解析的,因此可以使用 <code>value</code> 属性来引用真实的类,即使该类实际上可能不会出现在正在运行的应用程序类路径中.如果更喜欢使用 <code>String</code> 值指定类名,也可以使用 <code>name</code> 属性.</p>
<p>此机制不适用于 <code>@Bean</code> 方法,其中通常返回类型是条件的target:在方法的condition应用前,JVM 将加载类和可能会处理方法引用,如果类不存在,这些引用将失败.</p>
<p>为了处理这种情况,可以使用单独的 <code>@Configuration</code> 类来隔离条件,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// Some conditions ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Auto-configured beans ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(SomeService.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServiceConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SomeService <span class="title">someService</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SomeService();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果使用 <code>@ConditionalOnClass</code> 或 <code>@ConditionalOnMissingClass</code> 作为元注释的一部分来组成自己的组合注解,则必须使用<code>name</code>作为引用类的名称,在这种情况下不会被处理.</p>
</blockquote>
</li>
<li><h6 id="Bean-条件-Bean-Conditions"><a href="#Bean-条件-Bean-Conditions" class="headerlink" title="Bean 条件(Bean Conditions)"></a>Bean 条件(Bean Conditions)</h6><p><code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解允许根据特定 bean 的存在或不存在来确定是否要包含 bean.可以使用 <code>value</code> 属性按类型指定 bean 或 使用<code>name</code> 以按 name 指定 beans.<code>search</code> 属性允许让开发者限制<code>ApplicationContext</code> 层次结构, 这在搜索 bean 时应考虑的.</p>
<p>当放在<code>@Bean</code>方法上时,目标类型默为该方法的返回类型,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SomeService <span class="title">someService</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SomeService();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在前面的示例中,如果 <code>ApplicationContext</code> 中尚未包含 <code>MyService</code> 类型的 bean,则将创建 <code>myService</code> bean.</p>
<blockquote>
<p>建议:</p>
<p>​    需要非常小心指定 bean 定义的顺序,因为这些条件是根据目前已处理的内容进行评估的.出于这个原因,我们建议在自动配置类上仅使用 <code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解(在用户定义的bean添加后,这些注解会能够保证加载).</p>
<p>注意:</p>
<p>​    <code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 不会阻止创建 <code>@Configuration</code> 类.在class level使用这些condition与使用注解标记每个包含的 <code>@Bean</code> 方法之间的唯一区别是,如果条件不匹配,前者会阻止将 <code>@Configuration</code> 类注册为 bean.</p>
<p>建议:</p>
<p>​    在声明 <code>@Bean</code> 方法时,在方法的返回类型中提供尽可能多的类型信息.例如,如果你的 bean 的实体类实现了一个接口,那么 bean 方法的返回类型应该是具体的类而不是接口.在使用 bean 条件时,在 <code>@Bean</code> 方法中提供尽可能多的类型信息,因为它们的evaluation只能依赖于方法签名中可用的类型信息.</p>
</blockquote>
</li>
<li><h6 id="Property-条件-Property-Conditions"><a href="#Property-条件-Property-Conditions" class="headerlink" title="Property 条件(Property Conditions)"></a>Property 条件(Property Conditions)</h6><p><code>@ConditionalOnProperty</code> 注解允许根据 Spring Environment 属性来决定是否包含配置.使用 <code>prefix</code> 和 <code>name</code> 属性来指定那些属性应该被检查.默认情况下,存在且不等于 <code>false</code> 的属性才会被匹配.还可以通过使用 <code>havingValue</code> 和 <code>matchIfMissing</code> 属性创建更高级的检查.</p>
</li>
<li><h6 id="Resource-条件-Resource-Conditions"><a href="#Resource-条件-Resource-Conditions" class="headerlink" title="Resource 条件(Resource Conditions)"></a>Resource 条件(Resource Conditions)</h6><p><code>@ConditionalOnResource</code> 注解允许仅在存在特定资源时才包含配置.可以使用通常的 Spring 风格指定资源,如下例所示:<code>file:/home/user/test.dat</code></p>
</li>
<li><h6 id="Web-Application-条件-Web-Application-Conditions"><a href="#Web-Application-条件-Web-Application-Conditions" class="headerlink" title="Web Application 条件(Web Application Conditions)"></a>Web Application 条件(Web Application Conditions)</h6><p><code>@ConditionalOnWebApplication</code> 和 <code>@ConditionalOnNotWebApplication</code> 注解允许根据应用程序是否为”Web 应用程序”来包含配置.基于 servlet 的 Web 应用程序可以是任何使用<code>WebApplicationContext</code>, 定义<code>session</code>范围或具有 <code>ConfigurableWebEnvironment</code>的应用.响应式 Web 应用是任何使用 <code>ReactiveWebApplicationContext</code> 或具有 <code>ConfigurableReactiveWebEnvironment</code> 的应用.</p>
<p><code>@ConditionalOnWarDeployment</code> 注解允许根据应用程序是否是部署到容器的传统 WAR 应用程序来包含配置.此Condition与使用嵌入式服务器运行的应用不匹配.</p>
</li>
<li><h6 id="SpEL-表达式条件-SpEL-Expression-Conditions"><a href="#SpEL-表达式条件-SpEL-Expression-Conditions" class="headerlink" title="SpEL  表达式条件(SpEL Expression Conditions)"></a>SpEL  表达式条件(SpEL Expression Conditions)</h6><p><code>@ConditionalOnExpression</code> 注解允许根据<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/core.html#expressions">SpEL expression</a>的结果包含配置.</p>
</li>
</ol>
</li>
<li><h6 id="测试自己的自动配置-Testing-your-Auto-configuration"><a href="#测试自己的自动配置-Testing-your-Auto-configuration" class="headerlink" title="测试自己的自动配置(Testing your Auto-configuration)"></a>测试自己的自动配置(Testing your Auto-configuration)</h6><p>自动配置会受到许多因素的影响:用户配置(<code>@Bean</code> 定义和<code>Environment</code>自定义),条件评估(特定库的存在)等.具体来说,每个测试都应该创建一个定义良好的 <code>ApplicationContext</code> 来表示这些自定义的组合. <code>ApplicationContextRunner</code> 提供了一种很好的方法来实现这一点.</p>
<p><code>ApplicationContextRunner</code> 通常被定义为测试类的一个字段,用于获得基本的通用配置.以下示例确保始终调用 <code>MyServiceAutoConfiguration</code>:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApplicationContextRunner contextRunner = <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">   .withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration.class));</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果必须定义多个自动配置,则无需对它们的声明进行排序,因为它们的调用顺序与运行应用程序时的顺序完全相同.</p>
</blockquote>
<p>每个测试都可以使用runner来表示特定的用例. 例如,下面的示例调用用户配置 (<code>UserConfiguration</code>) 并检查自动配置是否正确回退. 调用 <code>run</code> 提供了一个可以与 <code>AssertJ</code> 一起使用的回调context.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defaultServiceBacksOff</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.contextRunner.withUserConfiguration(UserConfiguration.class).run((context) -&gt; {</span><br><span class="line">        assertThat(context).hasSingleBean(MyService.class);</span><br><span class="line">        assertThat(context).getBean(<span class="string">"myCustomService"</span>).isSameAs(context.getBean(MyService.class));</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MyService <span class="title">myCustomService</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyService(<span class="string">"mine"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还可以轻松定制环境,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceNameCanBeConfigured</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.contextRunner.withPropertyValues(<span class="string">"user.name=test123"</span>).run((context) -&gt; {</span><br><span class="line">        assertThat(context).hasSingleBean(MyService.class);</span><br><span class="line">        assertThat(context.getBean(MyService.class).getName()).isEqualTo(<span class="string">"test123"</span>);</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>runner 也可以用来显示 <code>ConditionEvaluationReport</code>.报告可以在 <code>INFO</code> 或 <code>DEBUG</code> 级别打印.以下示例显示如何使用 <code>ConditionEvaluationReportLoggingListener</code> 在自动配置测试中打印报告.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConditionEvaluationReportingTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">autoConfigTest</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">            .withInitializer(<span class="keyword">new</span> ConditionEvaluationReportLoggingListener(LogLevel.INFO))</span><br><span class="line">            .run((context) -&gt; {</span><br><span class="line">                    <span class="comment">// Test something...</span></span><br><span class="line">            });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><h6 id="模拟-Web-Context-Simulating-a-Web-Context"><a href="#模拟-Web-Context-Simulating-a-Web-Context" class="headerlink" title="模拟 Web Context(Simulating a Web Context)"></a>模拟 Web Context(Simulating a Web Context)</h6><p>如果需要测试仅在 Servlet 或 Reactive Web 应用上下文中运行的自动配置,请分别使用 <code>WebApplicationContextRunner</code> 或 <code>ReactiveWebApplicationContextRunner</code>.</p>
</li>
<li><h6 id="覆盖类路径-Overriding-the-Classpath"><a href="#覆盖类路径-Overriding-the-Classpath" class="headerlink" title="覆盖类路径(Overriding the Classpath)"></a>覆盖类路径(Overriding the Classpath)</h6><p>还可以测试在运行时不存在特定类和/或包时会发生什么.Spring Boot 附带了一个 <code>FilteredClassLoader</code>,可以很容易地被runner调用.在以下示例中,我们断言如果 <code>MyService</code> 不存在,则正确禁用自动配置:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceIsIgnoredIfLibraryIsNotPresent</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.contextRunner.withClassLoader(<span class="keyword">new</span> FilteredClassLoader(MyService.class))</span><br><span class="line">            .run((context) -&gt; assertThat(context).doesNotHaveBean(<span class="string">"myService"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><h6 id="创建自己的启动器-Creating-Your-Own-Starter"><a href="#创建自己的启动器-Creating-Your-Own-Starter" class="headerlink" title="创建自己的启动器(Creating Your Own Starter)"></a>创建自己的启动器(Creating Your Own Starter)</h6><p>一个典型的 Spring Boot starter 包含自动配置和自定义给定技术的infrastructure的代码,我们称之为”acme”.为了使其易于扩展,可以将专用命名空间中的许多配置key暴露给环境.最后,提供了一个”starter”依赖项,以帮助用户尽可能轻松地入门.</p>
<p>具体来说,自定义启动器可以包含以下内容:</p>
<ul>
<li>包含”acme”自动配置代码的<code>autoconfigure</code>模块.</li>
<li><code>starter</code>模块提供对<code>autoconfigure</code>模块和”acme”和其他有用的依赖.简而言之,添加 “starter” ,应该提供使用该库所需的一切.</li>
</ul>
<p>简而言之,添加 starter 应该提供开始使用该库所需的一切.如果”acme”有多种偏好,选项或可选功能,那么最好将自动配置分开,因为可以清楚地表达某些功能是可选的.此外,还可以创建一个启动器,提供有关这些可选依赖项的意见.同时,其他人也能只依靠<code>autoconfigure</code>模块,根据各自不同的选择,来创建启动器.</p>
<p>如果自动配置比较简单,没有可选功能,可以选择将两个模块合并到一个starter.</p>
<ol>
<li><h6 id="命名空间-Naming"><a href="#命名空间-Naming" class="headerlink" title="命名空间(Naming)"></a>命名空间(Naming)</h6><p>应该确保为自己的 starter 提供一个合适的命名空间. 不要用 <code>spring-boot</code> 用作模块名称的开始,即使你使用不同的 Maven <code>groupId</code>.将来可能会为你自动配置的东西提供官方支持.</p>
<p>根据经验,应该在 starter 之后命名一个组合模块.例如,假设正在为”acme”创建一个启动器,并将自动配置模块命名为 <code>acme-spring-boot</code> 和starter <code>acme-spring-boot-starter</code>.</p>
</li>
<li><h6 id="配置键-Configuration-keys"><a href="#配置键-Configuration-keys" class="headerlink" title="配置键(Configuration keys)"></a>配置键(Configuration keys)</h6><p>如果 starter 提供配置keys,请为它们使用唯一的命名空间.特别是,不要在 Spring Boot 使用的命名空间(例如<code>server</code>,<code>management</code>,<code>spring</code>等)中包含自己的key.如果使用相同的命名空间,官方可能会修改这些命名空间,可能会以破坏自定义的模块.根据经验,用自己的命名空间(例如 <code>acme</code>)作为所有key的前缀.</p>
<p>确保通过为每个属性添加字段 javadoc 来记录配置key,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties("acme")</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>{    <span class="comment">/**     * Whether to check the location of acme resources.     */</span>    <span class="keyword">private</span> <span class="keyword">boolean</span> checkLocation = <span class="keyword">true</span>;    <span class="comment">/**     * Timeout for establishing a connection to the acme server.     */</span>    <span class="keyword">private</span> Duration loginTimeout = Duration.ofSeconds(<span class="number">3</span>);    <span class="comment">// getters/setters ...}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    应该只使用带有 <code>@ConfigurationProperties</code> 字段 Javadoc 的纯文本,因为它们在被添加到 JSON 之前不会被处理.</p>
</blockquote>
<p>以下是官方在内部遵循的一些规则,以确保描述一致:</p>
<ul>
<li>不要以”The”或”A”开头.</li>
<li>对于<code>boolean</code>类型,以”Whether”或”Enable”开始描述.</li>
<li>对于基于集合的类型,以”Comma-separated list”开头的描述</li>
<li>如果不使用毫秒,请使用 <code>java.time.Duration</code> 而不是 <code>long</code> 并描述默认单位,例如 “如果未指定持续时间后缀,则将使用秒”.</li>
<li>不要在描述中提供默认值,除非它必须在运行时确定.</li>
</ul>
<p>确保触发元数据生成,以便 IDE 帮助也可用于自己的keys.可能需要查看生成的元数据 (<code>META-INF/spring-configuration-metadata.json</code>) 以确保您自己的key被正确记录.在兼容的 IDE 中使用自己的启动器也是验证元数据好主意.</p>
</li>
<li><h6 id="“自动配置”模块-The-“autoconfigure”-Module"><a href="#“自动配置”模块-The-“autoconfigure”-Module" class="headerlink" title="“自动配置”模块(The “autoconfigure” Module)"></a>“自动配置”模块(The “autoconfigure” Module)</h6><p><code>autoconfigure</code>模块包含使用库所需的一切.它还可能包含配置key定义(例如<code>@ConfigurationProperties</code>)和任何可用于进一步自定义组件初始化方式的回调接口.</p>
<blockquote>
<p>建议:</p>
<p>​    应该将库的依赖项标记为可选,以便可以更轻松地在项目中包含<code>autoconfigure</code>模块.如果这样做,则该不会被提供库,并且默认情况下,Spring Boot 会退出.</p>
</blockquote>
<p>Spring Boot 使用注解处理器来收集元数据文件 (<code>META-INF/spring-autoconfigure-metadata.properties</code>) 中自动配置的条件.如果该文件存在,则用于过滤不匹配的自动配置,这将缩短启动时间.建议在包含自动配置的模块中添加以下依赖项:</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果在应用程序中直接定义了自动配置,请确保配置 <code>spring-boot-maven-plugin</code> 以防止<code>repackage</code>目标将依赖项添加到胖 jar 中:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                            &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>对于 Gradle 4.5 及更早版本,应在 <code>compileOnly</code> 配置中声明依赖项,如以下示例所示:</p>
<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> {    compileOnly <span class="string">"org.springframework.boot:spring-boot-autoconfigure-processor"</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>对于 Gradle 4.6 及更高版本,应在 <code>annotationProcessor</code> 配置中声明依赖项,如以下示例所示:</p>
<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> {    annotationProcessor <span class="string">"org.springframework.boot:spring-boot-autoconfigure-processor"</span>}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Starter-模块-Starter-Module"><a href="#Starter-模块-Starter-Module" class="headerlink" title="Starter 模块(Starter Module)"></a>Starter 模块(Starter Module)</h6><p>starter 实际上是一个空jar. 它的唯一目的是提供必要的依赖来使用库.可以将其视为对入门所需内容的必不可少的内容.</p>
<p>不要对添加启动器的项目做出假设.如果自己的自动配置的库通常需要其他启动器,也请提及它们.如果可选依赖的数量很多,则提供一组正确的默认依赖可能会很困难,因为应该避免包含对于库的不必要的依赖项.换句话说,不应该包含optional依赖项.</p>
<blockquote>
<p>注意:</p>
<p>​    无论哪种方式,starter 都必须直接或间接引用core Spring Boot starter (<code>spring-boot-starter</code>)(间接引用:即,如果自己的 starter 依赖于另一个 starter,则无需添加它).如果一个项目仅使用自定义启动器创建,则 Spring Boot 的核心功能将因核心启动器的存在而启用.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">…</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  © 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenyk</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">337k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:06</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>


  





  
  

  
  <script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  
  


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.1.0/dist/quicklink.umd.js"></script>
  
  



<script src="/bundle.js"></script><script>{&quot;enable&quot;:true,&quot;spinner&quot;:true};
{&quot;enable&quot;:true,&quot;app_id&quot;:null,&quot;app_key&quot;:null,&quot;server_url&quot;:null,&quot;security&quot;:true};
{&quot;enable&quot;:true,&quot;home&quot;:true,&quot;archive&quot;:true,&quot;delay&quot;:true,&quot;timeout&quot;:3000,&quot;priority&quot;:true,&quot;ignores&quot;:null,&quot;url&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;page&#x2F;2&#x2F;&quot;}</script></body></html>