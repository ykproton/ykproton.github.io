<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat-logo.jpg">
  <link rel="mask-icon" href="/images/cat-logo.jpg" color="#222">






  
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="ykproton">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="ykproton">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chenyk">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;3&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>ykproton</title>
  




  <noscript>
    
  </noscript>
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ykproton</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chenyk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ykproton" title="GitHub → https://github.com/ykproton" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/51065.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/51065.html" class="post-title-link" itemprop="url">3.28 Feature: Web Service</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:09:00 / 修改时间：12:52:25" itemprop="dateCreated datePublished" datetime="2021-06-10T12:09:00+08:00">2021-06-10</time>
    </span>

  
    <span id="/posts/51065.html" class="post-meta-item leancloud_visitors" data-flag-title="3.28 Feature: Web Service" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-28-Web-服务"><a href="#3-28-Web-服务" class="headerlink" title="3.28 Web 服务"></a>3.28 Web 服务</h5><ol start="28">
<li><h5 id="Web-服务-Web-Services"><a href="#Web-服务-Web-Services" class="headerlink" title="Web 服务(Web Services)"></a>Web 服务(Web Services)</h5><p>Spring Boot 提供 Web 服务自动配置,因此所需要做的就是定义<code>Endpoints</code>.</p>
<p>使用 <code>spring-boot-starter-webservices</code> 模块可以轻松访问 Spring Web 服务功能.</p>
<p><code>SimpleWsdl11Definition</code> 和 <code>SimpleXsdSchema</code> bean 可以分别为 WSDL 和 XSD 自动创建. 为此,要配置它们的路径,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.webservices.wsdl-locations</span>=<span class="string">classpath:/wsdl</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><h6 id="使用-WebServiceTemplate-调用-Web-服务-Calling-Web-Services-with-WebServiceTemplate"><a href="#使用-WebServiceTemplate-调用-Web-服务-Calling-Web-Services-with-WebServiceTemplate" class="headerlink" title="使用 WebServiceTemplate 调用 Web 服务(Calling Web Services with WebServiceTemplate)"></a>使用 WebServiceTemplate 调用 Web 服务(Calling Web Services with WebServiceTemplate)</h6><p>如果需要从应用调用远程 Web 服务,可以使用 <code>WebServiceTemplate</code> 类.由于 <code>WebServiceTemplate</code> 实例在使用前通常需要自定义,因此 Spring Boot 不提供任何单个自动配置的 <code>WebServiceT</code></p>
<p><code>emplate</code> bean.但是,它会自动配置一个 <code>WebServiceTemplateBuilder</code>,它可以在需要时用于创建 <code>WebServiceTemplate</code> 实例.</p>
<p>以下代码显示了一个典型示例:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebServiceTemplate webServiceTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebServiceTemplateBuilder webServiceTemplateBuilder)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.webServiceTemplate = webServiceTemplateBuilder.build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SomeResponse <span class="title">someWsCall</span><span class="params">(SomeRequest detailsReq)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (SomeResponse) <span class="keyword">this</span>.webServiceTemplate.marshalSendAndReceive(detailsReq,</span><br><span class="line">                <span class="keyword">new</span> SoapActionCallback(<span class="string">"https://ws.example.com/action"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下,<code>WebServiceTemplateBuilder</code> 使用classpath上可用的 HTTP 客户端库来检测合适的基于 HTTP 的 <code>WebServiceMessageSender</code>.还可以按如下方式自定义读取和连接超时:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebServiceTemplateConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebServiceTemplate <span class="title">webServiceTemplate</span><span class="params">(WebServiceTemplateBuilder builder)</span> </span>{</span><br><span class="line">        WebServiceMessageSender sender = <span class="keyword">new</span> HttpWebServiceMessageSenderBuilder()</span><br><span class="line">                .setConnectTimeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                .setReadTimeout(Duration.ofSeconds(<span class="number">2</span>))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> builder.messageSenders(sender).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/14496.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/14496.html" class="post-title-link" itemprop="url">3.27 Feature: WebSockets</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:07:00 / 修改时间：12:52:35" itemprop="dateCreated datePublished" datetime="2021-06-10T12:07:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/14496.html" class="post-meta-item leancloud_visitors" data-flag-title="3.27 Feature: WebSockets" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>431</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-27-WebSockets"><a href="#3-27-WebSockets" class="headerlink" title="3.27 WebSockets"></a>3.27 WebSockets</h5><ol start="27">
<li><h5 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h5><p>Spring Boot 为嵌入式 Tomcat,Jetty 和 Undertow 提供了 WebSockets 自动配置.如果你将一个 war 文件部署到一个独立的容器中,Spring Boot 会假设容器负责其 WebSocket 支持的配置.</p>
<p>Spring Framework 为 MVC web 应用程序提供了丰富的 WebSocket 支持,可以通过 <code>spring-boot-starter-websocket</code> 模块轻松访问.</p>
<p>WebSocket 也可用于响应式 Web 应用程序,并且需要包含 <code>spring-boot-starter-webflux</code>  和 WebSocket API:</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/27280.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/27280.html" class="post-title-link" itemprop="url">3.26 Feature: 测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:06:00 / 修改时间：12:52:46" itemprop="dateCreated datePublished" datetime="2021-06-10T12:06:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/27280.html" class="post-meta-item leancloud_visitors" data-flag-title="3.26 Feature: 测试" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>29k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>26 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-26-测试-Testing"><a href="#3-26-测试-Testing" class="headerlink" title="3.26 测试(Testing)"></a>3.26 测试(Testing)</h5><ol start="26">
<li><h5 id="测试-Testing"><a href="#测试-Testing" class="headerlink" title="测试(Testing)"></a>测试(Testing)</h5><p>Spring Boot 提供了许多工具和注解来帮助测试应用.测试支持由两个模块提供:<code>spring-boot-test</code> 包含核心项,<code>spring-boot-test-autoconfigure</code> 支持自动配置测试.</p>
<p>大多数开发人员使用 <code>spring-boot-starter-test</code> “Starter”,它导入 Spring Boot 测试模块以及 JUnit Jupiter,AssertJ,Hamcrest 和许多其他有用的库.</p>
<blockquote>
<p>建议:</p>
<p>​    如果有使用 JUnit 4 的测试,则可以使用 JUnit 5 的vintage引擎来运行它们.要使用vintage引擎,添加对 <code>junit-vintage-engine</code> 的依赖,如以下示例所示:</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &gt;<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p><code>hamcrest-core</code> 被排除在 <code>org.hamcrest:hamcrest</code> 之外,它是 <code>spring-boot-starter-test</code> 的一部分.</p>
<ol>
<li><h6 id="测试范围依赖-Test-Scope-Dependencies"><a href="#测试范围依赖-Test-Scope-Dependencies" class="headerlink" title="测试范围依赖(Test Scope Dependencies)"></a>测试范围依赖(Test Scope Dependencies)</h6><p><code>spring-boot-starter-test</code> “Starter”(在<code>test</code> <code>scope</code>内)包含以下提供的库:</p>
<ul>
<li>JUnit 5:用于Java 应用单元测试标准.</li>
<li>Spring Test &amp; Spring Boot Test:对 Spring Boot 应用提供的工具和集成测试.</li>
<li>AssertJ:流式的断言库.</li>
<li>Hamcrest:匹配器对象库(也称为约束或谓词).</li>
<li>Mockito: Java 模拟框架.</li>
<li>JSONassert:JSON 的断言库.</li>
<li>JsonPath:JSON 的 XPath.</li>
</ul>
<p>通常发现这些公共库在编写测试时很有用.如果这些库不适合需要,可以添加自己的其他测试依赖项.</p>
</li>
<li><h6 id="测试-Spring-应用程序-Testing-Spring-Applications"><a href="#测试-Spring-应用程序-Testing-Spring-Applications" class="headerlink" title="测试 Spring 应用程序(Testing Spring Applications)"></a>测试 Spring 应用程序(Testing Spring Applications)</h6><p>依赖注入的主要优点之一是它应该使代码更容易进行单元测试.可以使用 <code>new</code> 运算符实例化对象,甚至无需涉及 Spring. 还可以使用模拟对象(<em>mock objects</em>)而不是真正的依赖项.</p>
<p>通常,不仅需要单元测试,还需要集成测试(使用 Spring <code>ApplicationContext</code>).不需要部署应用程序或连接到其他infrastructure就可以执行集成测试,这会非常有用.</p>
<p>Spring Framework 包括一个专门的测试模块,用于此类集成测试.可以直接声明依赖项 <code>org.springframework:spring-test</code> ,或者通过 <code>spring-boot-starter-test</code>“Starter” 的传递性,将其拉取.</p>
<p>如果之前没有使用过 <code>spring-test</code> 模块,您应该首先阅读 Spring Framework 参考文档(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testing">relevant section</a>)的相关部分.</p>
</li>
<li><h6 id="测试-Spring-Boot-应用程序-Testing-Spring-Boot-Applications"><a href="#测试-Spring-Boot-应用程序-Testing-Spring-Boot-Applications" class="headerlink" title="测试 Spring Boot 应用程序(Testing Spring Boot Applications)"></a>测试 Spring Boot 应用程序(Testing Spring Boot Applications)</h6><p>Spring Boot 应用程序是一个 Spring <code>ApplicationContext</code>,因此通常除了使用 vanilla Spring context执行的测试之外,不需要做任何特别的事情来测试它.</p>
<blockquote>
<p>注意:</p>
<p>​    只有使用 <code>SpringApplication</code> 创建它时,Spring Boot 的外部属配置,日志和其他功能会默认地安装在context中.</p>
</blockquote>
<p>Spring Boot 提供了一个 <code>@SpringBootTest</code> 注解,当需要 Spring Boot 测试功能时,它可以替代 <code>spring-test</code> <code>@ContextConfiguration</code> 注解.注解的工作原理是通过 <code>SpringApplication</code> 创建测试中需要使用的 <code>ApplicationContext</code>.除了<code>@SpringBootTest</code>之外,还提供了许多其他注解,来测试应用程序的更具体的切片.</p>
<blockquote>
<p>建议:</p>
<p>​    如果使用的是 JUnit 4,不要忘记将 <code>@RunWith(SpringRunner.class) </code>添加到测试中,否则注解将被忽略.如果使用的是 JUnit 5,则无需添加 <code>@ExtendWith(SpringExtension.class) </code>作为 <code>@SpringBootTest</code> ,并且其他 <code>@… Test</code> 注解已经用它进行了标注.</p>
</blockquote>
<p>默认情况下,<code>@SpringBootTest</code> 不会启动服务器. 您可以使用 <code>@SpringBootTest</code> 的 <code>webEnvironmen</code>t 属性来进一步优化测试的运行方式:</p>
<ul>
<li><code>MOCK</code>(Default) : 加载一个 web <code>ApplicationContext</code> 并提供web模拟环境.使用此注解时不会启动嵌入式服务器.如果classpath上没有 Web 环境,则此模式会创建普通的的非 Web <code>ApplicationContext</code>.它可以与 <code>@AutoConfigureMockMvc</code> 或 <code>@AutoConfigureWebTestClient</code> 结合使用,用于对 Web 应用进行模拟测试.</li>
<li><code>RANDOM_PORT</code>:加载一个 <code>WebServerApplicationContext</code> 并提供一个真实的 Web 环境. 嵌入式服务器启动并监听随机端口.</li>
<li><code>DEFINED_PORT</code>:加载一个 <code>WebServerApplicationContext</code> 并提供一个真实的 Web 环境.嵌入式服务器启动并监听指定的端口(来自 <code>application.properties</code>)或默认端口 <code>8080</code>.</li>
<li><code>NONE</code>:使用 <code>SpringApplication</code> 加载 <code>ApplicationContext</code> 但不提供任何 web 环境(模拟或其他).</li>
</ul>
<blockquote>
<p>注意:</p>
<p>​    如果测试是<code>@Transactional</code>,它默认在每个测试方法结束时回滚事务.然而,使用带有 <code>RANDOM_PORT</code> 或 <code>DEFINED_PORT</code> ,这种方式隐式地提供了一个真正的 servlet 环境,HTTP 客户端和服务器运行在单独的线程中,因此在事务也在单独的线程中运行.在这种情况下,在服务器上启动的任何事务都不会回滚.</p>
<p>注意:</p>
<p>​    如果应用管理服务器时使用不同的端口,带有 <code>webEnvironment = WebEnvironment.RANDOM_PORT</code> 的 <code>@SpringBootTest</code> 还将在单独的随机端口上启动管理服务器.</p>
</blockquote>
<ol>
<li><h6 id="检测-Web-应用程序类型-Detecting-Web-Application-Type"><a href="#检测-Web-应用程序类型-Detecting-Web-Application-Type" class="headerlink" title="检测 Web 应用程序类型(Detecting Web Application Type)"></a>检测 Web 应用程序类型(Detecting Web Application Type)</h6><p>如果 Spring MVC 可用,则会配置常规的基于 MVC 的应用context. 如果只有 Spring WebFlux,将检测到并配置基于 WebFlux 的应用context.</p>
<p>如果两者都存在,则 Spring MVC 优先.如果要在此场景中测试响应式 Web 应用程序,则必须设置 <code>spring.main.web-application-type</code> 属性:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(properties = "spring.main.web-application-type=reactive")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWebFluxTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="检测测试配置-Detecting-Test-Configuration"><a href="#检测测试配置-Detecting-Test-Configuration" class="headerlink" title="检测测试配置(Detecting Test Configuration)"></a>检测测试配置(Detecting Test Configuration)</h6><p>如果熟悉 Spring 测试框架,可能习惯使用 <code>@ContextConfiguration(classes=… )</code>来指定要加载哪个 Spring <code>@Configuration</code>.或者,可能经常在测试中使用嵌套的 <code>@Configuration</code> 类.</p>
<p>在测试 Spring Boot 应用时,这通常不是必需的. 如果没有明确定义配置时,Spring Boot 的 <code>@*Test</code> 注解就会自动搜索基本配置.</p>
<p>搜索算法从包含测试的包开始工作,直到找到用 <code>@SpringBootApplication</code> 或 <code>@SpringBootConfiguration</code> 标注的类.只要合理构建代码,通常会找到主要配置.</p>
<blockquote>
<p>建议:</p>
<p>​    如果使用测试注解来测试应用的更具体部分,则应避免在主方法的应用类上添加特定于特定区域的配置设置.</p>
<p>​    <code>@SpringBootApplication</code> 的底层组件扫描配置定义了排除过滤器,用于确保切片按预期工作.如果在 <code>@SpringBootApplication</code> 标注的类上使用显式 <code>@ComponentScan</code> 指令,请注意这些过滤器将被禁用.如果正在使用切片,应该再次定义它们.</p>
</blockquote>
<p>如果要自定义主要配置,可以使用嵌套的 <code>@TestConfiguration</code> 类.与替代应用基本配置的嵌套 <code>@Configuration</code> 类不同,除了应用程序的基本配置之外,还要使用嵌套的 <code>@TestConfiguration</code> 类.</p>
<blockquote>
<p>注意:</p>
<p>​    Spring 测试框架在测试中间缓存context.因此,只要测试共享相同的配置(无论怎样被发现),加载上下文的耗时过程只会发生一次.</p>
</blockquote>
</li>
<li><h6 id="排除测试配置-Excluding-Test-Configuration"><a href="#排除测试配置-Excluding-Test-Configuration" class="headerlink" title="排除测试配置(Excluding Test Configuration)"></a>排除测试配置(Excluding Test Configuration)</h6><p>如果应用使用组件扫描(例如,如果使用<code>@SpringBootApplication</code> 或<code>@ComponentScan</code>),可能会发现仅为特定测试创建的top-level配置类意外地随处可见.</p>
<p>正如我们之前看到的,<code>@TestConfiguration</code> 可以用于测试的内部类来自定义主要配置.<code>@TestConfiguration</code>放在顶级类时,表示<code>src/test/java</code>中的类不应该通过扫描获取.然后,可以在需要的地方显式导入该类,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Import(MyTestsConfiguration.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    如果直接使用<code>@ComponentScan</code>(即不通过<code>@SpringBootApplication</code>),则需要使用它注册<code>TypeExcludeFilter</code>. 有关详细信息,参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/context/TypeExcludeFilter.html">the Javadoc</a>.</p>
</blockquote>
</li>
<li><h6 id="使用应用参数-Using-Application-Arguments"><a href="#使用应用参数-Using-Application-Arguments" class="headerlink" title="使用应用参数(Using Application Arguments)"></a>使用应用参数(Using Application Arguments)</h6><p>如果应用需要参数,可以让 <code>@SpringBootTest</code> 使用 <code>args</code> 属性注入它们.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(args = "--app.test=one")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplicationArgumentTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applicationArgumentsPopulated</span><span class="params">(<span class="meta">@Autowired</span> ApplicationArguments args)</span> </span>{</span><br><span class="line">        assertThat(args.getOptionNames()).containsOnly(<span class="string">"app.test"</span>);</span><br><span class="line">        assertThat(args.getOptionValues(<span class="string">"app.test"</span>)).containsOnly(<span class="string">"one"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="使用模拟环境进行测试-Testing-with-a-mock-environment"><a href="#使用模拟环境进行测试-Testing-with-a-mock-environment" class="headerlink" title="使用模拟环境进行测试(Testing with a mock environment)"></a>使用模拟环境进行测试(Testing with a mock environment)</h6><p>默认情况下,<code>@SpringBootTest</code> 不启动服务器.如果有针对此模拟环境进行测试的 Web 端点,则可以另外配置 <code>MockMvc</code>,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMockMvcTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> MockMvc mvc)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        mvc.perform(get(<span class="string">"/"</span>)).andExpect(status().isOk()).andExpect(content().string(<span class="string">"Hello World"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果只想专注于 web 层而不是启动完整的 <code>ApplicationContext</code>,请考虑使用 <code>@WebMvcTest</code> 代替.</p>
</blockquote>
<p>或者,可以配置 <code>WebTestClient</code>,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureWebTestClient</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMockWebTestClientTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> WebTestClient webClient)</span> </span>{</span><br><span class="line">        webClient</span><br><span class="line">            .get().uri(<span class="string">"/"</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectBody(String.class).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    在模拟环境中进行测试通常比在完整的 Servlet 容器中运行要快.但是,由于模拟发生在 Spring MVC 层,因此无法直接使用 MockMvc 来测试那些依赖于较低级别 Servlet 容器行为的代码.</p>
<p>例如,Spring Boot 的错误处理是基于 Servlet 容器提供的”错误页面”支持.这意味着,虽然可以按预期测试 MVC 层抛出和处理异常,但您无法直接测试是否呈现了特定的自定义错误页面.如果需要测试这些较低级别的问题,可以启动一个完整运行的服务器,如下一节所述.</p>
</blockquote>
</li>
<li><h6 id="使用正在运行的服务器进行测试-Testing-with-a-running-server"><a href="#使用正在运行的服务器进行测试-Testing-with-a-running-server" class="headerlink" title="使用正在运行的服务器进行测试(Testing with a running server)"></a>使用正在运行的服务器进行测试(Testing with a running server)</h6><p>如果需要启动一个完整运行的服务器,建议使用随机端口.如果使用<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>,则每次测试运行时都会随机选择一个可用端口.</p>
<p><code>@LocalServerPort</code> 注释可用来将实际使用的端口注入到您的测试中.为方便起见,需要对启动的服务器进行 REST 调用的测试可以 <code>@Autowire</code> 一个 <code>WebTestClient</code>,它解析发送到运行中服务器的相关链接,并带有用于验证响应的专用 API,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRandomPortWebTestClientTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> WebTestClient webClient)</span> </span>{</span><br><span class="line">        webClient</span><br><span class="line">            .get().uri(<span class="string">"/"</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectBody(String.class).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个设置需要在classpath上使用 <code>spring-webflux</code>. 如果不能或不会添加 webflux,Spring Boot 还提供了一个 <code>TestRestTemplate</code> 工具:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRandomPortTestRestTemplateTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> TestRestTemplate restTemplate)</span> </span>{</span><br><span class="line">        String body = restTemplate.getForObject(<span class="string">"/"</span>, String.class);</span><br><span class="line">        assertThat(body).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自定义-WebTestClient-Customizing-WebTestClient"><a href="#自定义-WebTestClient-Customizing-WebTestClient" class="headerlink" title="自定义 WebTestClient(Customizing WebTestClient)"></a>自定义 WebTestClient(Customizing WebTestClient)</h6><p>要自定义 <code>WebTestClient</code> bean,请配置 <code>WebTestClientBuilderCustomizer</code> bean.调用<code>WebTestClient.Builder</code>来创建<code>WebTestClient</code>.</p>
</li>
<li><h6 id="使用JMX-Using-JMX"><a href="#使用JMX-Using-JMX" class="headerlink" title="使用JMX(Using JMX)"></a>使用JMX(Using JMX)</h6><p>由于测试context框架缓存context,JMX默认下禁用来防止在同一域上注册相同组件.如果此类测试需要访问 <code>MBeanServer</code>,请考虑将其标记为<code>dirty </code>:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span><span class="meta">@SpringBootTest(properties = "spring.jmx.enabled=true")</span><span class="meta">@DirtiesContextclass</span> MyJmxTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MBeanServer mBeanServer;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> <span class="keyword">throws</span> MalformedObjectNameException </span>{        assertThat(<span class="keyword">this</span>.mBeanServer.getDomains()).contains(<span class="string">"java.lang"</span>);        <span class="comment">// ...    }}</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="使用Metrics-Using-Metrics"><a href="#使用Metrics-Using-Metrics" class="headerlink" title="使用Metrics(Using Metrics)"></a>使用Metrics(Using Metrics)</h6><p>无论classpath如何,使用<code>@SpringBootTest</code> 时,除内存支持外的meter registries都不会自动配置.</p>
<p>如果需要将metrics作为集成测试的一部分导出到不同的后端,请使用 <code>@AutoConfigureMetrics</code> 对其进行标注.</p>
</li>
<li><h6 id="模拟和监视Bean-Mocking-and-Spying-Beans"><a href="#模拟和监视Bean-Mocking-and-Spying-Beans" class="headerlink" title="模拟和监视Bean(Mocking and Spying Beans)"></a>模拟和监视Bean(Mocking and Spying Beans)</h6><p>运行测试时,有时需要在应用context中模拟某些组件.例如,可能有一个在开发过程中不可用的远程服务的facade.当想要模拟在真实环境中可能难以触发的故障时,Mocking会很有用.</p>
<p>Spring Boot 包含一个 <code>@MockBean</code> 注解,可用于为 <code>ApplicationContext</code> 中的 bean 定义 Mockito 模拟.可以使用注解添加新 bean 或替换单个现有 bean 定义.注解可以直接用于测试类,测试中的字段或<code>@Configuration</code> 类和字段.在字段上使用时,还会注入创建的模拟实例. Mock bean 在每个测试方法后自动重置.</p>
<blockquote>
<p>注意:</p>
<p>​    如果测试使用 Spring Boot 的测试注解(例如 <code>@SpringBootTest</code>),则会自动启用此功能.要以不同的方式使用此功能,必须显式添加监听器,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@ContextConfiguration(classes = MyConfig.class)</span><span class="meta">@TestExecutionListeners({ MockitoTestExecutionListener.class, ResetMocksTestExecutionListener.class })</span><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>{<span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>以下示例用mock implementation替换现有的 <code>RemoteService</code> bean:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTestclass</span> MyTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> Reverser reverser;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> RemoteService remoteService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>{        given(<span class="keyword">this</span>.remoteService.getValue()).willReturn(<span class="string">"spring"</span>);        String reverse = <span class="keyword">this</span>.reverser.getReverseValue(); <span class="comment">// Calls injected RemoteService        assertThat(reverse).isEqualTo("gnirps");    }}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    <code>@MockBean</code> 不能用于模拟在应用context刷新期间 bean 的执行行为.到执行测试时,应用context 刷新已完成,配置模拟行为为时已晚.在这种情况下,建议使用 <code>@Bean</code> 方法来创建和配置模拟.</p>
</blockquote>
<p>此外,可以使用 <code>@SpyBean</code>来包装任何使用 Mockito <code>spy</code> 的bean. 有关完整的详细信息,请参阅 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/test/mock/mockito/SpyBean.html">Javadoc</a>.</p>
<blockquote>
<p>注意:</p>
<p>​    CGLib 代理,例如为作用域 bean 创建的代理,将代理方法声明为 <code>final</code>.这会阻止 Mockito 正常运行,因为默认情况下,它无法模拟或监视<code>final</code>方法.如果想模拟或监视此类 bean,通过将 <code>org.mockito:mockito-inline</code> 添加到应用的测试依赖项来配置 Mockito 从而使用其内联模拟生成器.这允许 Mockito 模拟和监视<code>final</code>方法.</p>
<p>注意:</p>
<p>​    虽然 Spring 的测试框架在测试之间缓存应用context,并为了共享配置复用context,但使用 <code>@MockBean</code> 或 <code>@SpyBean</code> 会影响缓存key,这很可能会增加上下文的数量.</p>
<p>建议:</p>
<p>​    如果使用<code>@SpyBean</code> 来监视带有按名称引用参数的<code>@Cacheable</code> 方法的bean,则应用必须使用<code>-parameters</code> 进行编译.这保证了一旦 bean 被监视,参数名称就可用于缓存infrastructure .</p>
<p>建议:</p>
<p>​    当使用<code>@SpyBean</code> 来监视由 Spring 代理的 bean 时,可能在某些情况下需要移除 Spring 的代理,例如在使用 <code>given</code> 或 <code>when</code> 设置expectation时.使用 <code>AopTestUtils.getTargetObject(yourProxiedSpy)</code>来这样做.</p>
</blockquote>
</li>
<li><h6 id="自动配置测试-Auto-configured-Tests"><a href="#自动配置测试-Auto-configured-Tests" class="headerlink" title="自动配置测试(Auto-configured Tests)"></a>自动配置测试(Auto-configured Tests)</h6><p>Spring Boot 的自动配置系统适用于应用,但有时对于测试来说可能有点太多了.它通常有助于仅加载测试应用”slice”所需的配置部分.例如,测试运行时,可能想要测试 Spring MVC 控制器是否正确映射 URL,并且不想在这些测试中涉及数据库调用,或者可能想要测试 JPA entities,并且对 web 层不感兴趣.</p>
<p><code>spring-boot-test-autoconfigure</code> 模块包含许多注解,可用于自动配置此类”切片”.它们中的每一个都以类似的方式工作,提供一个加载 <code>ApplicationContext</code> 的 <code>@… Test</code> 注解和一个或多个可用于自定义自动配置的 <code>@AutoConfigure…</code> 注解.</p>
<blockquote>
<p>注意:</p>
<p>​    每个slice将组件扫描范围限制为适当的组件并加载一组非常有限的自动配置类.如果需要排除其中之一,大多数<code>@… Test</code> 注解都提供 <code>excludeAutoConfiguration</code> 属性.或者,可以使用<code>@ImportAutoConfiguration#exclude</code>.</p>
<p>注意:</p>
<p>​    不支持在一个测试中使用多个 <code>@… Test</code> 注注解包含多个”slices”.如果需要多个”slices”,请选择其中一个 <code>@… Test</code> 注解并手动包含其他”slices”的 <code>@AutoConfigure</code>… 注解.</p>
<p>建议:</p>
<p>​    也可以将<code>@AutoConfigure…</code> 注解与标准<code>@SpringBootTest</code> 注解一起使用.如果对将应用”切片”不感兴趣,但想要一些自动配置的测试 bean,则可以使用此组合.</p>
</blockquote>
</li>
<li><h6 id="自动配置的-JSON-测试-Auto-configured-JSON-Tests"><a href="#自动配置的-JSON-测试-Auto-configured-JSON-Tests" class="headerlink" title="自动配置的 JSON 测试(Auto-configured JSON Tests)"></a>自动配置的 JSON 测试(Auto-configured JSON Tests)</h6><p>要测试该对象 JSON 序列化和反序列化是否按预期工作,可以使用 <code>@JsonTest</code> 注解.<code>@JsonTest</code> 自动配置支持的 JSON 映射器,它可以是以下库之一:</p>
<ul>
<li>Jackson <code>ObjectMapper</code>,任何<code>@JsonComponent</code> bean 和任何 Jackson <code>Module</code></li>
<li><code>Gson</code></li>
<li><code>Jsonb</code></li>
</ul>
<p>如果需要配置自动配置的元素,可以使用<code>@AutoConfigureJsonTesters</code>注解.Spring Boot 包括基于 AssertJ 的helpers ,它们与 JSONAssert 和 JsonPath 库一起工作,从而检查 JSON 是否按预期显示.<code>JacksonTester</code>,<code>GsonTester</code>,<code>JsonbTester</code> 和 <code>BasicJsonTester</code> 类可分别用于 Jackson,Gson,Jsonb 和 Strings.使用<code>@JsonTest</code> 时,测试类上的任何helper 字段都可以<code>@Autowired</code>.以下示例显示了 Jackson 的测试类:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTestclass</span> MyJsonTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> JacksonTester&lt;VehicleDetails&gt; json;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        VehicleDetails details = <span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>);        <span class="comment">// Assert against a `.json` file in the same package as the test        assertThat(this.json.write(details)).isEqualToJson("expected.json");        // Or use JSON path based assertions        assertThat(this.json.write(details)).hasJsonPathStringValue("@.make");        assertThat(this.json.write(details)).extractingJsonPathStringValue("@.make").isEqualTo("Honda");    }    @Test    void deserialize() throws Exception {        String content = "{\"make\":\"Ford\",\"model\":\"Focus\"}";        assertThat(this.json.parse(content)).isEqualTo(new VehicleDetails("Ford", "Focus"));        assertThat(this.json.parseObject(content).getMake()).isEqualTo("Ford");    }}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    JSON helper 类也可以直接在标准的单元测试中使用. 为此,如果不使用 <code>@JsonTest</code>,请在 <code>@Before</code> 方法中调用helper的 <code>initFields</code> 方法.</p>
</blockquote>
<p>如果使用 Spring Boot 的基于 AssertJ 的helpers 来断言给定 JSON 路径上的数字值,则可能无法使用具体取决于类型的 <code>isEqualTo</code>.相反,您可以使用 AssertJ 的<code>satisfies</code>来断言该值与给定条件匹配.例如,以下示例断言实际数字是浮点值,接近 <code>0.15</code> ,偏移量在 <code>0.01</code> 内.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Testvoid</span> someTest() <span class="keyword">throws</span> Exception {    SomeObject value = <span class="keyword">new</span> SomeObject(<span class="number">0.152f</span>);    assertThat(<span class="keyword">this</span>.json.write(value)).extractingJsonPathNumberValue(<span class="string">"@.test.numberValue"</span>)            .satisfies((number) -&gt; assertThat(number.floatValue()).isCloseTo(<span class="number">0.15f</span>, within(<span class="number">0.01f</span>)));}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置-Spring-MVC-测试-Auto-configured-Spring-MVC-Tests"><a href="#自动配置-Spring-MVC-测试-Auto-configured-Spring-MVC-Tests" class="headerlink" title="自动配置 Spring MVC 测试(Auto-configured Spring MVC Tests)"></a>自动配置 Spring MVC 测试(Auto-configured Spring MVC Tests)</h6><p>要测试 Spring MVC controller 是否按预期工作,请使用 <code>@WebMvcTest</code> 注解.<code>@WebMvcTest</code> 自动配置 Spring MVC infrastructure 并将扫描的 bean 限制为 <code>@Controller</code>,<code>@ControllerAdvice</code>,<code>@JsonComponent</code>,<code>Converter</code>,<code>GenericConverter</code>,<code>Filter</code>,<code>HandlerInterceptor</code>,<code>WebMvcConfigurer</code> 和 <code>HandlerMethodArgumentResolver</code>.. 使用 <code>@WebMvcTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code>bean.</p>
<blockquote>
<p>建议:</p>
<p>​    如果需要注册额外的组件,例如 Jackson <code>Module</code>,可以通过在测试中使用 <code>@Import</code> 来导入额外的配置类.</p>
</blockquote>
<p>通常,<code>@WebMvcTest</code> 仅限于单个controller,并与 <code>@MockBean</code> 结合使用为所需的协作者提供模拟实现.</p>
<p><code>@WebMvcTest</code> 还自动配置 <code>MockMvc</code>.Mock MVC 提供了一种强大的方法来快速测试 MVC controller,而无需启动完整的 HTTP 服务器.</p>
<blockquote>
<p>建议:</p>
<p>​    还可以通过使用<code>@AutoConfigureMockMvc</code> 对其进行标注,在非<code>@WebMvcTest</code>(例如<code>@SpringBootTest</code>)中自动配置<code>MockMvc</code>.以下示例使用 <code>MockMvc</code>:</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockMvc mvc;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> UserVehicleService userVehicleService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>))            .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));        <span class="keyword">this</span>.mvc.perform(get(<span class="string">"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN))            .andExpect(status().isOk())            .andExpect(content().string(<span class="string">"Honda Civic"</span>));    }}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果需要配置自动配置的元素(例如,何时应应用 servlet 过滤器),可以使用 <code>@AutoConfigureMockMvc</code> 注解中的属性.</p>
</blockquote>
<p>如果使用 HtmlUnit 或 Selenium,自动配置还会提供 HtmlUnit <code>WebClient</code> bean 和/或 Selenium <code>WebDriver</code> bean. 以下示例使用 HtmlUnit:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyHtmlUnitTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> WebClient webClient;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> UserVehicleService userVehicleService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>)).willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));        HtmlPage page = <span class="keyword">this</span>.webClient.getPage(<span class="string">"/sboot/vehicle.html"</span>);        assertThat(page.getBody().getTextContent()).isEqualTo(<span class="string">"Honda Civic"</span>);    }}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:    </p>
<p>​    默认情况下,Spring Boot 将 <code>WebDriver</code> bean 放在一个特殊的”scope”中,以确保驱动程序在每次测试后退出并注入新实例.如果不想要这种行为,可以将 <code>@Scope("singleton")</code> 添加到 <code>WebDriver</code> @Bean 定义中.</p>
<p>警告:</p>
<p>​    Spring Boot 创建的 <code>webDriver</code> scope 将替换所有的用户定义的同名作用域.如果定义自己的 <code>webDriver</code> scope ,可能会发现它在使用 <code>@WebMvcTest</code> 时停止工作.</p>
</blockquote>
<p>如果classpath上有 Spring Security,<code>@WebMvcTest</code> 也会扫描 <code>WebSecurityConfigurer</code> bean.可以使用 Spring Security 的测试支持,而不是为了测试完全禁用安全功能.有关如何使用 Spring Security 的 <code>MockMvc</code> 支持的更多详细信息,请参见 <em><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.testing.with-spring-security">howto.html</a></em>  how-to 部分.</p>
</li>
<li><h6 id="自动配置的-Spring-WebFlux-测试-Auto-configured-Spring-WebFlux-Tests"><a href="#自动配置的-Spring-WebFlux-测试-Auto-configured-Spring-WebFlux-Tests" class="headerlink" title="自动配置的 Spring WebFlux 测试(Auto-configured Spring WebFlux Tests)"></a>自动配置的 Spring WebFlux 测试(Auto-configured Spring WebFlux Tests)</h6><p>要测试 Spring WebFlux controller是否按预期工作,可以使用 <code>@WebFluxTest</code> 注解.<code>@WebFluxTest</code> 自动配置 Spring WebFlux infrastructure 并将扫描的 bean 限制为 <code>@Controller</code>,<code>@ControllerAdvice</code>,<code>@JsonComponent</code>,<code>Converter</code>,<code>GenericConverter</code>,<code>WebFilter</code> 和 <code>WebFluxConfigurer</code>.使用<code>@WebFluxTest</code> 注解时不会扫描常规的<code>@Component</code> 和<code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<blockquote>
<p>建议:</p>
<p>​    如果需要注册额外的组件,比如 Jackson <code>Module</code>,可以在测试中使用 <code>@Import</code> 导入额外的配置类.</p>
</blockquote>
<p>通常,<code>@WebFluxTest</code> 仅限于单个controller,并与 <code>@MockBean</code> 注解结合使用,为所需的协作者提供模拟实现.</p>
<p><code>@WebFluxTest</code> 还自动配置 <code>WebTestClient</code>,它提供了一种强大的方法来快速测试 WebFlux controller,而无需启动完整的 HTTP 服务器.</p>
<blockquote>
<p>建议:</p>
<p>​    还可以通过使用 <code>@AutoConfigureWebTestClient</code> 注解在非<code>@WebFluxTest</code>(例如<code>@SpringBootTest</code>)中自动配置<code>WebTestClient</code>.以下示例显示了一个同时使用 <code>@WebFluxTest</code> 和 <code>WebTestClient</code> 的类:</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFluxTest(UserVehicleController.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> WebTestClient webClient;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> UserVehicleService userVehicleService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>))            .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));        <span class="keyword">this</span>.webClient.get().uri(<span class="string">"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN).exchange()            .expectStatus().isOk()            .expectBody(String.class).isEqualTo(<span class="string">"Honda Civic"</span>);    }}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    这个设置仅受 WebFlux 应用支持,因为在模拟 Web 应用中使用 <code>WebTestClient</code> 目前仅适用于 WebFlux.</p>
<p>注意:</p>
<p>​    <code>@WebFluxTest</code> 无法检测通过函数式 Web 框架注册的route.要在context中测试 <code>RouterFunction</code> beans,请考虑通过 <code>@Import</code> 或使用 <code>@SpringBootTest</code> 自己导入 <code>RouterFunction</code>.</p>
<p>注意:</p>
<p>​    <code>@WebFluxTest</code> 无法检测通过 <code>SecurityWebFilterChain</code> 类型的 <code>@Bean</code> 注册的自定义安全配置.要将其包含在测试中,需要通过<code>@Import</code> 或使用<code>@SpringBootTest</code> 导入注册 bean 的配置.</p>
</blockquote>
</li>
<li><h6 id="自动配置的数据-Cassandra-测试-Auto-configured-Data-Cassandra-Tests"><a href="#自动配置的数据-Cassandra-测试-Auto-configured-Data-Cassandra-Tests" class="headerlink" title="自动配置的数据 Cassandra 测试(Auto-configured Data Cassandra Tests)"></a>自动配置的数据 Cassandra 测试(Auto-configured Data Cassandra Tests)</h6><p>可以使用 <code>@DataCassandraTest</code> 来测试 Cassandra 应用程序.默认情况下,它配置一个 <code>CassandraTemplate</code>,扫描 <code>@Table</code> 类,并配置 Spring Data Cassandra 存储库.使用 <code>@DataCassandraTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean. </p>
<p>以下示例显示了在 Spring Boot 中使用 Cassandra 测试的典型设置:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataCassandraTestclass</span> MyDataCassandraTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeRepository repository;}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的数据-JPA-测试-Auto-configured-Data-JPA-Tests"><a href="#自动配置的数据-JPA-测试-Auto-configured-Data-JPA-Tests" class="headerlink" title="自动配置的数据 JPA 测试(Auto-configured Data JPA Tests)"></a>自动配置的数据 JPA 测试(Auto-configured Data JPA Tests)</h6><p>可以使用 <code>@DataJpaTest</code> 注解来测试 JPA 应用程序.默认情况下,它会扫描 <code>@Entity</code> 类并配置 Spring Data JPA 存储库.如果在classpath上有一个嵌入式数据库可用,它也会配置一个.默认情况下,通过将 <code>spring.jpa.show-sql</code> 属性设置为 <code>true</code> 来记录 SQL 查询.这可以使用注解的 <code>showSql()</code> 属性禁用.</p>
<p>使用 <code>@DataJpaTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>默认情况下,数据 JPA 测试是事务性的,并在每次测试结束时回滚.有关详细信息,请参阅 Spring 框架 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a> 中的相关部分.如果这不是想要的,可以为测试或整个class禁用事务,如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><span class="class"><span class="keyword">class</span> <span class="title">MyNonTransactionalTests</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>数据 JPA 测试还可以注入一个 <code>TestEntityManager</code> bean,它提供了标准 JPA <code>EntityManager</code> 的替代方案,专为测试而设计.如果要在 <code>@DataJpaTest</code> 实例之外使用 <code>TestEntityManager</code>,还可以使用 <code>@AutoConfigureTestEntityManager</code> 注解.如果需要,也可以使用 JdbcTemplate. 以下示例显示了正在使用的 <code>@DataJpaTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataJpaTestclass</span> MyRepositoryTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> TestEntityManager entityManager;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> UserRepository repository;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        <span class="keyword">this</span>.entityManager.persist(<span class="keyword">new</span> User(<span class="string">"sboot"</span>, <span class="string">"1234"</span>));        User user = <span class="keyword">this</span>.repository.findByUsername(<span class="string">"sboot"</span>);        assertThat(user.getUsername()).isEqualTo(<span class="string">"sboot"</span>);        assertThat(user.getEmployeeNumber()).isEqualTo(<span class="string">"1234"</span>);    }}</span><br></pre></td></tr></tbody></table></figure>

<p>内存嵌入式数据库通常适用于测试,因为它们速度快且不需要任何安装.但是,如果更喜欢用真实数据库运行测试,则可以使用 <code>@AutoConfigureTestDatabase</code> 注解,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span><span class="meta">@AutoConfigureTestDatabase(replace = Replace.NONE)</span><span class="class"><span class="keyword">class</span> <span class="title">MyRepositoryTests</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的-JDBC-测试-Auto-configured-JDBC-Tests"><a href="#自动配置的-JDBC-测试-Auto-configured-JDBC-Tests" class="headerlink" title="自动配置的 JDBC 测试(Auto-configured JDBC Tests)"></a>自动配置的 JDBC 测试(Auto-configured JDBC Tests)</h6><p><code>@JdbcTest</code> 类似于 <code>@DataJpaTest</code>, 但用于只需要数据源而不使用 Spring Data JDBC 的测试.默认情况下,它配置一个内存嵌入式数据库和一个 <code>JdbcTemplate</code>.使用 <code>@JdbcTest</code> 注解时,不会扫描常规的 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>默认情况下,JDBC 测试是事务性的,并在每个测试结束时回滚. 有关详细信息,请参阅 Spring 框架<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a>中的相关部分.如果这不是想要的,可以为测试或整个班级禁用事务管理,如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JdbcTest</span><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><span class="class"><span class="keyword">class</span> <span class="title">MyTransactionalTests</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>

<p>如果更喜欢针对真实数据库运行测试,则可以像使用 <code>DataJpaTest</code> 一样使用 <code>@AutoConfigureTestDatabase</code> 注解.</p>
</li>
<li><h6 id="自动配置的Data-JDBC-测试-Auto-configured-Data-JDBC-Tests"><a href="#自动配置的Data-JDBC-测试-Auto-configured-Data-JDBC-Tests" class="headerlink" title="自动配置的Data JDBC 测试 (Auto-configured Data JDBC Tests)"></a>自动配置的Data JDBC 测试 (Auto-configured Data JDBC Tests)</h6><p><code>@DataJdbcTest</code> 与 <code>@JdbcTest</code> 类似,但用于使用 Spring Data JDBC 存储库的测试.默认情况下,它会配置一个内存嵌入式数据库,一个 <code>JdbcTemplate</code> 和 Spring Data JDBC 存储库.使用 <code>@DataJdbcTest</code> 注解时,不会扫描常规的 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>默认情况下,数据 JDBC 测试是事务性的,并在每个测试结束时回滚. 有关详细信息,请参阅 Spring 框架<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a>中的相关部分.如果这不是想要的,您可以禁用测试或整个测试类的事务管理,如 JDBC 示例中所示.</p>
<p>如果更喜欢针对真实数据库运行测试,则可以像使用 <code>DataJpaTest</code> 一样使用 <code>@AutoConfigureTestDatabase</code> 注解.</p>
</li>
<li><h6 id="自动配置的-jOOQ-测试-Auto-configured-jOOQ-Tests"><a href="#自动配置的-jOOQ-测试-Auto-configured-jOOQ-Tests" class="headerlink" title="自动配置的 jOOQ 测试 (Auto-configured jOOQ Tests)"></a>自动配置的 jOOQ 测试 (Auto-configured jOOQ Tests)</h6><p>可以类似于使用<code>@JdbcTest</code>的方式,来使用<code>@JooqTest</code>,但用于jOOQ 相关的测试.由于 jOOQ 严重依赖于与数据库schema对应的基于 Java 的schema ,因此使用现有的 <code>DataSource</code>.如果想用内存数据库替换它,你可以使用<code>@AutoConfigureTestDatabase</code> 来覆盖这些设置.使用 <code>@JooqTest</code> 注解时不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p><code>@JooqTest</code> 配置一个 <code>DSLContext</code>. 以下示例显示了正在使用的 <code>@JooqTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JooqTestclass</span> MyJooqTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DSLContext dslContext;    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>JOOQ 测试是事务性的,默认情况下在每个测试结束时回滚.如果这不是想要的,可以禁用测试或整个测试类的事务管理,如 JDBC 示例中所示.</p>
</li>
<li><h6 id="自动配置的-Data-MongoDB-测试-Auto-configured-Data-MongoDB-Tests"><a href="#自动配置的-Data-MongoDB-测试-Auto-configured-Data-MongoDB-Tests" class="headerlink" title="自动配置的 Data  MongoDB 测试 (Auto-configured Data MongoDB Tests)"></a>自动配置的 Data  MongoDB 测试 (Auto-configured Data MongoDB Tests)</h6><p>可以使用<code>@DataMongoTest</code> 来测试 MongoDB 应用.默认情况下,它配置内存中嵌入式 MongoDB(如果可用),配置 <code>MongoTemplate</code>,扫描 <code>@Document</code> 类并配置 Spring Data MongoDB 存储库.使用 <code>@DataMongoTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下类显示了正在使用的 <code>@DataMongoTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataMongoTestclass</span> MyDataMongoDbTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MongoTemplate mongoTemplate;    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>内存嵌入式 MongoDB 通常适合用来测试,因为它速度快且不需要任何开发人员安装.但是,如果更喜欢针对真实的 MongoDB 服务器运行测试,则应排除嵌入式 MongoDB 自动配置,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyDataMongoDbTests</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的-Data-Neo4j-测试-Auto-configured-Data-Neo4j-Tests"><a href="#自动配置的-Data-Neo4j-测试-Auto-configured-Data-Neo4j-Tests" class="headerlink" title="自动配置的 Data  Neo4j 测试(Auto-configured Data Neo4j Tests)"></a>自动配置的 Data  Neo4j 测试(Auto-configured Data Neo4j Tests)</h6><p>可以使用 <code>@DataNeo4jTest</code> 来测试 Neo4j 应用程序.默认情况下,它会扫描 <code>@Node</code> 类,并配置 Spring Data Neo4j 存储库.使用 <code>@DataNeo4jTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下示例显示了在 Spring Boot 中使用 Neo4J 测试的典型设置:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataNeo4jTestclass</span> MyDataNeo4jTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeRepository repository;    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下,Data Neo4j 测试是事务性的,并在每次测试结束时回滚.有关详细信息,请参阅 Spring 框架参考文档中的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a>.如果这不是想要的,可以为测试或整个班级禁用事务管理,如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataNeo4jTest</span><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><span class="class"><span class="keyword">class</span> <span class="title">MyDataNeo4jTests</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    响应式访问不支持事务性测试. 如果使用这个风格,则必须如上所述配置 <code>@DataNeo4jTest</code> 测试.</p>
</blockquote>
</li>
<li><h6 id="自动配置的Data-Redis-测试-Auto-configured-Data-Redis-Tests"><a href="#自动配置的Data-Redis-测试-Auto-configured-Data-Redis-Tests" class="headerlink" title="自动配置的Data  Redis 测试(Auto-configured Data Redis Tests)"></a>自动配置的Data  Redis 测试(Auto-configured Data Redis Tests)</h6><p>可以使用<code>@DataRedisTest</code> 来测试Redis 应用.默认情况下,它会扫描 <code>@RedisHash</code> 类并配置 Spring Data Redis 存储库.使用<code>@DataRedisTest</code> 注解时,不会扫描常规的<code>@Component</code> 和<code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下示例显示了正在使用的 <code>@DataRedisTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataRedisTestclass</span> MyDataRedisTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeRepository repository;    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的Data-LDAP-测试-Auto-configured-Data-LDAP-Tests"><a href="#自动配置的Data-LDAP-测试-Auto-configured-Data-LDAP-Tests" class="headerlink" title="自动配置的Data LDAP 测试(Auto-configured Data LDAP Tests)"></a>自动配置的Data LDAP 测试(Auto-configured Data LDAP Tests)</h6><p>可以使用 <code>@DataLdapTest</code> 来测试 LDAP 应用.默认情况下,它会配置内存中的嵌入式 LDAP(如果可用),配置 <code>LdapTemplate</code>,扫描 <code>@Entry</code> 类并配置 Spring Data LDAP 存储库.使用 <code>@DataLdapTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下示例显示了正在使用的 <code>@DataLdapTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataLdapTestclass</span> MyDataLdapTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> LdapTemplate ldapTemplate;    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>内存嵌入式 LDAP 通常适合用来测试,因为它速度快且不需要任何开发人员安装.但是,如果更喜欢针对真实 LDAP 服务器运行测试,则应排除嵌入式 LDAP 自动配置,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyDataLdapTests</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的-REST-客户端-Auto-configured-REST-Clients"><a href="#自动配置的-REST-客户端-Auto-configured-REST-Clients" class="headerlink" title="自动配置的 REST 客户端(Auto-configured REST Clients)"></a>自动配置的 REST 客户端(Auto-configured REST Clients)</h6><p>可以使用 <code>@RestClientTest</code> 注解来测试 REST 客户端.默认情况下,它会自动配置 Jackson,GSON 和 Jsonb 支持,配置 <code>RestTemplateBuilder</code>,并添加对 <code>MockRestServiceServer</code> 的支持.使用 <code>@RestClientTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean. <code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>应使用<code>@RestClientTest</code> 的 <code>value</code> 或 <code>components</code> 属性指定要测试的特定 bean,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestClientTest(RemoteVehicleDetailsService.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyRestClientTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RemoteVehicleDetailsService service;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockRestServiceServer server;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">getVehicleDetailsWhenResultIsSuccessShouldReturnDetails</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        <span class="keyword">this</span>.server.expect(requestTo(<span class="string">"/greet/details"</span>)).andRespond(withSuccess(<span class="string">"hello"</span>, MediaType.TEXT_PLAIN));        String greeting = <span class="keyword">this</span>.service.callRestService();        assertThat(greeting).isEqualTo(<span class="string">"hello"</span>);    }}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的-Spring-REST-文档测试-Auto-configured-Spring-REST-Docs-Tests"><a href="#自动配置的-Spring-REST-文档测试-Auto-configured-Spring-REST-Docs-Tests" class="headerlink" title="自动配置的 Spring REST 文档测试(Auto-configured Spring REST Docs Tests)"></a>自动配置的 Spring REST 文档测试(Auto-configured Spring REST Docs Tests)</h6><p>可以使用 <code>@AutoConfigureRestDocs</code> 标注在 Mock MVC,REST Assured 或 WebTestClient上,从而在测试中使用 Spring REST Docs.这样, Spring REST Docs 就不需要 JUnit 扩展.</p>
<p><code>@AutoConfigureRestDocs</code> 可用于覆盖默认输出目录(如果使用 Maven,则为 <code>target/generated-snippets</code>,如果您使用 Gradle,则为 <code>build/generated-snippets</code>).它还可以用于配置出现在任何记录的 URI 中的host,scheme和port .</p>
<h6 id="使用-Mock-MVC-自动配置-Spring-REST-Docs-测试-Auto-configured-Spring-REST-Docs-Tests-with-Mock-MVC"><a href="#使用-Mock-MVC-自动配置-Spring-REST-Docs-测试-Auto-configured-Spring-REST-Docs-Tests-with-Mock-MVC" class="headerlink" title="使用 Mock MVC 自动配置 Spring REST Docs 测试(Auto-configured Spring REST Docs Tests with Mock MVC)"></a>使用 Mock MVC 自动配置 Spring REST Docs 测试(Auto-configured Spring REST Docs Tests with Mock MVC)</h6><p><code>@AutoConfigureRestDocs</code> 自定义 <code>MockMvc</code> bean 从而在测试基于 Servlet 的 Web 应用时,使用 Spring REST Docs.可以使用 <code>@Autowired</code> 注入它,并像使用 Mock MVC 和 Spring REST Docs 时通常那样在测试中使用它,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(UserController.class)</span><span class="meta">@AutoConfigureRestDocsclass</span> MyUserDocumentationTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockMvc mvc;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">listUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        <span class="keyword">this</span>.mvc.perform(get(<span class="string">"/users"</span>).accept(MediaType.TEXT_PLAIN))            .andExpect(status().isOk())            .andDo(document(<span class="string">"list-users"</span>));    }}</span><br></pre></td></tr></tbody></table></figure>

<p>如果需要更多地控制 Spring REST Docs 配置,比 <code>@AutoConfigureRestDocs</code> 所提供的属性更多,可以使用 <code>RestDocsMockMvcConfigurationCustomizer</code> bean,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestDocsConfiguration</span> <span class="keyword">implements</span> <span class="title">RestDocsMockMvcConfigurationCustomizer</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(MockMvcRestDocumentationConfigurer configurer)</span> </span>{        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());    }}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的-Spring-Web-服务测试-Auto-configured-Spring-Web-Services-Tests"><a href="#自动配置的-Spring-Web-服务测试-Auto-configured-Spring-Web-Services-Tests" class="headerlink" title="自动配置的 Spring Web 服务测试(Auto-configured Spring Web Services Tests)"></a>自动配置的 Spring Web 服务测试(Auto-configured Spring Web Services Tests)</h6><p>可以使用 <code>@WebServiceClientTest</code> 来测试那些使用 Spring Web Services project调用 Web 服务的应用.默认情况下,它配置一个模拟 <code>WebServiceServer</code> bean 并自动自定义 <code>WebServiceTemplateBuilder</code>.</p>
<p>以下示例显示了正在使用的 <code>@WebServiceClientTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServiceClientTest(SomeWebService.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyWebServiceClientTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockWebServiceServer server;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeWebService someWebService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">mockServerCall</span><span class="params">()</span> </span>{        <span class="keyword">this</span>.server            .expect(payload(<span class="keyword">new</span> StringSource(<span class="string">"&lt;request/&gt;"</span>)))            .andRespond(withPayload(<span class="keyword">new</span> StringSource(<span class="string">"&lt;response&gt;&lt;status&gt;200&lt;/status&gt;&lt;/response&gt;"</span>)));        assertThat(<span class="keyword">this</span>.someWebService.test())            .extracting(Response::getStatus)            .isEqualTo(<span class="number">200</span>);    }}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="额外的自动配置和切片-Additional-Auto-configuration-and-Slicing"><a href="#额外的自动配置和切片-Additional-Auto-configuration-and-Slicing" class="headerlink" title="额外的自动配置和切片(Additional Auto-configuration and Slicing)"></a>额外的自动配置和切片(Additional Auto-configuration and Slicing)</h6><p>每个slice提供一个或多个 <code>@AutoConfigure...</code> 注解,这些注解定义作为切片的一部分的自动配置.可以通过创建自定义 <code>@AutoConfigure…</code> 注解或将 <code>@ImportAutoConfiguration</code> 添加到测试中,逐个测试地添加其他自动配置,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JdbcTest</span><span class="meta">@ImportAutoConfiguration(IntegrationAutoConfiguration.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyJdbcTests</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    确保不要使用常规的 <code>@Import</code> 注解来导入自动配置,因为它们是由 Spring Boot 以特定方式处理的.</p>
</blockquote>
<p>或者,对于使用的任何的切片注解,都可以通过在 <code>META-INF/spring.factories</code> 中注册,来添加额外的自动配置,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.test.autoconfigure.jdbc.JdbcTest</span>=<span class="string">com.example.IntegrationAutoConfiguration</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    切片或@<code>AutoConfigure… </code>注解可以通过这种方式自定义,只要它使用<code>@ImportAutoConfiguration</code> 进行元注解.</p>
</blockquote>
</li>
<li><h6 id="用户配置和切片-User-Configuration-and-Slicing"><a href="#用户配置和切片-User-Configuration-and-Slicing" class="headerlink" title="用户配置和切片 (User Configuration and Slicing)"></a>用户配置和切片 (User Configuration and Slicing)</h6><p>如果以合理的方式构建代码,默认情况下将使用 <code>@SpringBootApplication</code> 类作为测试的配置.</p>
<p>然后,重要的是不要在应用程序的主类中使用特定于其功能特定区域的配置设置.</p>
<p>假设使用的是 Spring Batch 并且依赖于它的自动配置. 可以定义 <code>@SpringBootApplication</code> 如下:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableBatchProcessingpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>因为这个类是测试的源配置,所以任何切片测试实际上都是尝试启动Spring Batch,这绝对不是你想要的.</p>
<p>推荐的方法是将特定于区域的配置移动到与应用程序相同级别的单独 <code>@Configuration</code> 类中,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="meta">@EnableBatchProcessingpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatchConfiguration</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    根据应用程序的复杂性,可能有一个用于自定义的 <code>@Configuration</code> 类,或者每个域区域有一个类.后一种方法允许在其中一个测试中启用它,如有必要,使用 <code>@Import</code> 注解.</p>
</blockquote>
<p>测试切片从扫描中排除 <code>@Configuration</code> 类.例如,对于<code>@WebMvcTest</code>,以下配置不会包含由测试切片加载的应用程序context中给定的 <code>WebMvcConfigurer</code> bean:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebConfiguration</span> </span>{    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">testConfigurer</span><span class="params">()</span> </span>{        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() {            <span class="comment">// ...        };    }}</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是,下面的配置将导致测试切片加载自定义 <code>WebMvcConfigurer</code>.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>另一个混淆源是classpath扫描.假设,当以合理的方式构建代码时,需要扫描一个额外的包.应用可能类似于以下代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="meta">@ComponentScan({ "com.example.app", "com.example.another" })</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样做有效地覆盖了默认的组件扫描指令,但会有副作用,而不管选择哪个切片,都会扫描这两个包.例如,<code>@DataJpaTest</code> 似乎突然扫描应用程序的组件和用户配置.同样,将自定义指令移至单独的类是解决此问题的好方法.</p>
<blockquote>
<p>建议:</p>
<p>​    如果想要的不是这个,可以在测试层次结构中的某处创建一个 <code>@SpringBootConfiguration</code> 来使用.或者,可以为测试指定一个源,这将禁用查找默认源的行为.</p>
</blockquote>
</li>
<li><h6 id="使用-Spock-测试-Spring-Boot-应用程序-Using-Spock-to-Test-Spring-Boot-Applications"><a href="#使用-Spock-测试-Spring-Boot-应用程序-Using-Spock-to-Test-Spring-Boot-Applications" class="headerlink" title="使用 Spock 测试 Spring Boot 应用程序 (Using Spock to Test Spring Boot Applications)"></a>使用 Spock 测试 Spring Boot 应用程序 (Using Spock to Test Spring Boot Applications)</h6><p>Spock 2.x 可用于测试 Spring Boot 应用程序.为此,请在应用程序的构建中添加对 Spock 的 <code>spock-spring</code> 模块的依赖.<code>spock-spring</code> 将 Spring 的测试框架集成到 Spock 中.</p>
</li>
</ol>
</li>
<li><h6 id="测试工具-Test-Utilities"><a href="#测试工具-Test-Utilities" class="headerlink" title="测试工具(Test Utilities)"></a>测试工具(Test Utilities)</h6><p>有一些实用程序类被打包为 <code>spring-boot</code> 的一部分,在测试时通常会很有用.</p>
<ol>
<li><h6 id="ConfigDataApplicationContextInitializer"><a href="#ConfigDataApplicationContextInitializer" class="headerlink" title="ConfigDataApplicationContextInitializer"></a>ConfigDataApplicationContextInitializer</h6><p><code>ConfigDataApplicationContextInitializer</code> 是一个 <code>ApplicationContextInitializer</code>,可以将其应用于测试,用来加载 Spring Boot 的<code>application.properties</code> 文件.当不需要<code>@SpringBootTest</code> 提供的完整功能时,可以使用它,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(classes = Config.class, initializers = ConfigDataApplicationContextInitializer.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyConfigFileTests</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    单独使用 <code>ConfigDataApplicationContextInitializer</code> 不支持 <code>@Value("${… }")</code> 注入.它唯一的工作是确保 <code>application.properties</code> 文件加载到 Spring 的<code>Environment</code>中.对于<code>@Value</code> 支持,需要另外配置一个 <code>PropertySourcesPlaceholderConfigurer</code> 或使用 <code>@SpringBootTest</code>,它会为自动配置一个.</p>
</blockquote>
</li>
<li><h6 id="TestPropertyValues"><a href="#TestPropertyValues" class="headerlink" title="TestPropertyValues"></a>TestPropertyValues</h6><p><code>TestPropertyValues</code> 允许您快速将属性添加到 <code>ConfigurableEnvironment</code> 或 <code>ConfigurableApplicationContext</code>. 可以使用 <code>key=value</code> 字符串调用它,如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEnvironmentTests</span> </span>{    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testPropertySources</span><span class="params">()</span> </span>{        MockEnvironment environment = <span class="keyword">new</span> MockEnvironment();        TestPropertyValues.of(<span class="string">"org=Spring"</span>, <span class="string">"name=Boot"</span>).applyTo(environment);        assertThat(environment.getProperty(<span class="string">"name"</span>)).isEqualTo(<span class="string">"Boot"</span>);    }}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="OutputCapture"><a href="#OutputCapture" class="headerlink" title="OutputCapture"></a>OutputCapture</h6><p><code>OutputCapture</code> 是一个 <code>JUnit</code> 扩展,可用于捕获 <code>System.out</code> 和 <code>System.err</code> 输出.要使用 add <code>@ExtendWith(OutputCaptureExtension.class)</code> 并将 <code>CapturedOutput</code> 作为参数注入测试类构造函数或测试方法,如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(OutputCaptureExtension.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyOutputCaptureTests</span> </span>{    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testName</span><span class="params">(CapturedOutput output)</span> </span>{        System.out.println(<span class="string">"Hello World!"</span>);        assertThat(output).contains(<span class="string">"World"</span>);    }}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="TestRestTemplate"><a href="#TestRestTemplate" class="headerlink" title="TestRestTemplate"></a>TestRestTemplate</h6><p><code>TestRestTemplate</code> 是 Spring 的 <code>RestTemplate</code> 的便捷替代品,在集成测试中很有用.可以获得一个vanilla 模板或一个发送基本 HTTP 身份验证(使用用户名和密码)的模板.在任何一种情况下,模板都是容错的.这意味着它不会在 4xx 和 5xx 错误上引发异常,从而以测试友好的方式运行.相反,可以通过返回的 <code>ResponseEntity</code> 及其状态代码检测此类错误.</p>
<blockquote>
<p>建议:</p>
<p>​    Spring Framework 5.0 提供了一个新的 <code>WebTestClient</code>,适用于 WebFlux 集成测试以及 WebFlux 和 MVC 端到端测试.与 <code>TestRestTemplate</code> 不同,它为断言提供了流式 API.</p>
</blockquote>
<p>建议但不强制使用 Apache HTTP 客户端(4.3.2 或更高版本).如果classpath中有它,<code>TestRestTemplate</code> 会通过适当配置客户端来响应.如果确实使用 Apache 的 HTTP 客户端,则会启用一些额外的对测试友好的功能:</p>
<ul>
<li>不遵循Redirect(因此可以断言响应位置).</li>
<li>Cookie 被忽略(因此模板是无状态的).</li>
</ul>
<p><code>TestRestTemplate</code> 可以直接在集成测试中实例化,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>{    <span class="keyword">private</span> TestRestTemplate template = <span class="keyword">new</span> TestRestTemplate();    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        ResponseEntity&lt;String&gt; headers = <span class="keyword">this</span>.template.getForEntity(<span class="string">"https://myhost.example.com/example"</span>, String.class);        assertThat(headers.getHeaders().getLocation()).hasHost(<span class="string">"other.example.com"</span>);    }}</span><br></pre></td></tr></tbody></table></figure>

<p>或者,如果将 <code>@SpringBootTest</code> 注解与 <code>WebEnvironment.RANDOM_PORT</code> 或 <code>WebEnvironment.DEFINED_PORT</code> 一起使用,可以注入一个完全配置的 <code>TestRestTemplate</code> 并开始使用它.如有必要,可以通过 <code>RestTemplateBuilder </code>bean 应用其他自定义.任何未指定host和port的 URL 都会自动连接到嵌入式服务器,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span><span class="class"><span class="keyword">class</span> <span class="title">MySpringBootTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> TestRestTemplate template;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> </span>{        HttpHeaders headers = <span class="keyword">this</span>.template.getForEntity(<span class="string">"/example"</span>, String.class).getHeaders();        assertThat(headers.getLocation()).hasHost(<span class="string">"other.example.com"</span>);    }    <span class="meta">@TestConfiguration(proxyBeanMethods = false)</span>    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateBuilderConfiguration</span> </span>{        <span class="meta">@Bean</span>        <span class="function">RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">()</span> </span>{            <span class="keyword">return</span> <span class="keyword">new</span> RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(<span class="number">1</span>))                    .setReadTimeout(Duration.ofSeconds(<span class="number">1</span>));        }    }}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/45790.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/45790.html" class="post-title-link" itemprop="url">3.25 Feature : 通过 JMX 进行监控和管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:05:00 / 修改时间：12:52:56" itemprop="dateCreated datePublished" datetime="2021-06-10T12:05:00+08:00">2021-06-10</time>
    </span>

  
    <span id="/posts/45790.html" class="post-meta-item leancloud_visitors" data-flag-title="3.25 Feature : 通过 JMX 进行监控和管理" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>383</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-25-通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX"><a href="#3-25-通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX" class="headerlink" title="3.25 通过 JMX 进行监控和管理 (Monitoring and Management over JMX)"></a>3.25 通过 JMX 进行监控和管理 (Monitoring and Management over JMX)</h5><ol start="25">
<li><h6 id="通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX"><a href="#通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX" class="headerlink" title="通过 JMX 进行监控和管理 (Monitoring and Management over JMX)"></a>通过 JMX 进行监控和管理 (Monitoring and Management over JMX)</h6><p>Java 管理扩展 (JMX) 提供了一种标准机制来监视和管理应用程序.Spring Boot 将最合适的 <code>MBeanServer</code> 暴露为bean, ID 为 <code>mbeanServer</code>.任何用 Spring JMX 注解的(<code>@ManagedResource</code>,<code>@ManagedAttribute</code> 或 <code>@ManagedOperation</code>)标注的 bean 都会暴露给它.</p>
<p>如果平台提供标准的 <code>MBeanServer</code>,Spring Boot 将使用它,并在必要时候,将其默认为 VM <code>MBeanServer</code>. 如果所有这些都失败了,将会创建一个新的 <code>MBeanServer</code>.</p>
<p>有关更多详细信息,参阅  <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java"><code>JmxAutoConfiguration</code></a> 类.</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/45154.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/45154.html" class="post-title-link" itemprop="url">3.24 Feature: Spring Session</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:03:00 / 修改时间：12:53:08" itemprop="dateCreated datePublished" datetime="2021-06-10T12:03:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/45154.html" class="post-meta-item leancloud_visitors" data-flag-title="3.24 Feature: Spring Session" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>739</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h5><ol start="24">
<li><h5 id="Spring-Session-1"><a href="#Spring-Session-1" class="headerlink" title="Spring Session"></a>Spring Session</h5><p>Spring Boot 为很多数据存储提供 Spring Session 自动配置. 在构建 Servlet Web 应用程序时,可以自动配置以下存储:</p>
<ul>
<li>JDBC</li>
<li>Redis</li>
<li>Hazelcast</li>
<li>MongoDB</li>
</ul>
<p>Servlet 自动配置取代了必须使用<code>@Enable*HttpSession</code>.</p>
<p>在构建响应式 Web 应用程序时,可以自动配置以下存储:</p>
<ul>
<li>Redis</li>
<li>MongoDB</li>
</ul>
<p>响应式自动配置取代了必须使用<code>@Enable*WebSession</code> .</p>
<p>如果classpath上存在单个 Spring Session 模块,则 Spring Boot 会自动使用该存储实现.如果有多个实现,则必须选择要用于存储会话的 <code>StoreType</code>.例如,要使用 JDBC 作为后端存储,可以按如下方式配置您的应用:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.session.store-type</span>=<span class="string">jdbc</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    可以通过将 <code>store-type</code> 设置为 <code>none</code> 来禁用 Spring Session.</p>
</blockquote>
<p>每个store都有特定的额外设置. 例如,可以为 JDBC 存储自定义表的名称,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.session.jdbc.table-name</span>=<span class="string">SESSIONS</span></span><br></pre></td></tr></tbody></table></figure>

<p>要设置会话超时,可以使用 <code>spring.session.timeout</code> 属性.如果没有使用 Servlet Web 应用程序设置该属性,则自动配置将回退到 <code>server.servlet.session.timeout</code> 的值.</p>
<p>可以使用 <code>@Enable*HttpSession</code> (Servlet) 或 <code>@Enable*WebSession</code> (Reactive) 来控制 Spring Session 的配置.这将导致自动配置退出. 然后可以使用注解的属性而不是之前描述的配置属性来配置 Spring Session.</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/18723.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/18723.html" class="post-title-link" itemprop="url">3.23 Feature: Spring Integration</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:02:00 / 修改时间：12:53:19" itemprop="dateCreated datePublished" datetime="2021-06-10T12:02:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/18723.html" class="post-meta-item leancloud_visitors" data-flag-title="3.23 Feature: Spring Integration" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="Spring-Integration"><a href="#Spring-Integration" class="headerlink" title="Spring Integration"></a>Spring Integration</h5><ol start="23">
<li><h5 id="Spring-Integration-1"><a href="#Spring-Integration-1" class="headerlink" title="Spring Integration"></a>Spring Integration</h5><p>Spring Boot 为使用 Spring Integration 提供了多种便利,包括 spring-boot-starter-integration “Starter”.Spring Integration 提供了对消息和其他传输(如 HTTP,TCP 等)的抽象.如果 Spring Integration 在classpath上可用,则通过 <code>@EnableIntegration</code> 注解对其进行初始化.</p>
<p>Spring Integration 轮询逻辑依赖于自动配置的 <code>TaskScheduler</code>.</p>
<p>Spring Boot 还配置了一些功能,由 Spring Integration 模块存在时触发. 如果 <code>spring-integration-jmx</code> 也在classpath上,则消息处理统计信息通过 JMX 发布.如果 <code>spring-integration-jdbc</code> 可用,则可以在启动时创建默认数据库schema,如下行所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.integration.jdbc.initialize-schema</span>=<span class="string">always</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果 <code>spring-integration-rsocket</code> 可用,开发人员可以使用”<code>spring.rsocket.server.</code>*”属性配置 RSocket 服务器,并让它使用 <code>IntegrationRSocketEndpoint</code> 或 <code>RSocketOutboundGateway</code> 组件来处理传入的 RSocket 消息.这个基础设施可以处理 Spring Integration RSocket 通道适配器和 <code>@MessageMapping</code> 处理程序(假设配置了<code>"spring.integration.rsocket.server.message-mapping-enabled"</code>).</p>
<p>Spring Boot 还可以使用配置属性自动配置 <code>ClientRSocketConnector</code>:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Connecting to a RSocket server over TCP</span></span><br><span class="line"><span class="meta">spring.integration.rsocket.client.host</span>=<span class="string">example.org</span></span><br><span class="line"><span class="meta">spring.integration.rsocket.client.port</span>=<span class="string">9898</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Connecting to a RSocket Server over WebSocket</span></span><br><span class="line"><span class="meta">spring.integration.rsocket.client.uri</span>=<span class="string">ws://example.org</span></span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下,如果存在 Micrometer <code>meterRegistry</code> bean,则 Spring Integration metrics 将由 Micrometer 管理.如果希望使用旧的 Spring Integration metrics,将 <code>DefaultMetricsFactory</code> bean 添加到应用上下文.</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/12903.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/12903.html" class="post-title-link" itemprop="url">3.21 Feature: Quartz调度器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 13:02:00" itemprop="dateCreated datePublished" datetime="2021-06-04T13:02:00+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:54:00" itemprop="dateModified" datetime="2021-06-10T12:54:00+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/12903.html" class="post-meta-item leancloud_visitors" data-flag-title="3.21 Feature: Quartz调度器" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-21-Quartz调度器-Quartz-Scheduler"><a href="#3-21-Quartz调度器-Quartz-Scheduler" class="headerlink" title="3.21 Quartz调度器 (Quartz Scheduler)"></a>3.21 Quartz调度器 (Quartz Scheduler)</h5><ol start="21">
<li><h5 id="Quartz调度器-Quartz-Scheduler"><a href="#Quartz调度器-Quartz-Scheduler" class="headerlink" title="Quartz调度器 (Quartz Scheduler)"></a>Quartz调度器 (Quartz Scheduler)</h5><p>Spring Boot 为使用 Quartz 调度程序提供了多种便利,包括 <code>spring-boot-starter-quartz</code> “Starter”.如果 Quartz 可用,则自动配置<code>Scheduler</code>(通过 <code>SchedulerFactoryBean</code> 抽象).</p>
<p>以下类型的 Bean 会被自动获取并与 <code>Scheduler</code> 关联:</p>
<ul>
<li><code>JobDetail</code>:定义特定Job. 可以使用 <code>JobBuilder</code> API 构建 <code>JobDetail</code> 实例.</li>
<li><code>Calendar</code></li>
<li><code>Trigger</code>:定义何时触发特定Job.</li>
</ul>
<p>默认情况下,使用内存中<code>JobStore</code>. 但是,如果 <code>DataSource</code> bean 在您的应用中可用并且相应地配置了 <code>spring.quartz.job-store-type</code> 属性,则可以配置基于 JDBC 的存储,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.quartz.job-store-type</span>=<span class="string">jdbc</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用 JDBC 存储时,可以在启动时初始化schema,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.quartz.jdbc.initialize-schema</span>=<span class="string">always</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>警告:</p>
<p>​    默认情况下,使用 Quartz 库提供的标准脚本来检测和初始化数据库.这些脚本删除现有表,在每次重新启动时删除所有触发器. 也可以通过设置 <code>spring.quartz.jdbc.schema</code> 属性来提供自定义脚本.</p>
</blockquote>
<p>要让 Quartz 不使用应用程序主<code>DataSource</code>,而是指定的<code>DataSource</code>,声明一个 <code>DataSource</code> bean,使用 <code>@QuartzDataSource</code> 标注其 <code>@Bean</code> 方法.这样做可以让Quartz专用的DataSource同时被 <code>SchedulerFactoryBean</code>使用和初始化schema.类似地,要让 Quartz 使用非应用程序主 <code>TransactionManager</code> 之外的 <code>TransactionManager</code>, 声明一个 <code>TransactionManager</code> bean,使用 <code>@QuartzTransactionManager</code> 标注其 <code>@Bean</code> 方法.</p>
<p>默认情况下,配置创建的jobs不会覆盖,从持久job 存储中读取的已注册作业.要启用覆盖现有job,设置 <code>spring.quartz.overwrite-existing-jobs</code> 属性.</p>
<p>Quartz Scheduler 配置可以使用 <code>spring.quartz</code> 属性和 <code>SchedulerFactoryBeanCustomizer</code> bean 进行自定义,这允许以编程的形式来自定义<code>SchedulerFactoryBean</code>.可以使用 <code>spring.quartz.properties.*</code> 自定义Quartz的高级配置.</p>
<blockquote>
<p>注意:</p>
<p>​    特别是,<code>Executor</code> bean 与<code>scheduler</code>无关,因为 Quartz 提供了一种通过 <code>spring.quartz.properties</code> 配置scheduler的方法.如果需要自定义任务executor,可以考虑实现<code>SchedulerFactoryBeanCustomizer</code>.</p>
</blockquote>
<p>Jobs可以定义 setter 来注入数据映射属性. 也可以用类似的方式注入普通 bean,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySampleJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fields ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject "MyService" bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyService</span><span class="params">(MyService myService)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.myService = myService;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject the "name" job data property</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>{</span><br><span class="line">        <span class="keyword">this</span>.myService.someMethod(context.getFireTime(), <span class="keyword">this</span>.name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/53415.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/53415.html" class="post-title-link" itemprop="url">3.22 Feature: 任务执行与调度</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 13:02:00" itemprop="dateCreated datePublished" datetime="2021-06-04T13:02:00+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:53:39" itemprop="dateModified" datetime="2021-06-10T12:53:39+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/53415.html" class="post-meta-item leancloud_visitors" data-flag-title="3.22 Feature: 任务执行与调度" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-22-任务执行与调度-Task-Execution-and-Scheduling"><a href="#3-22-任务执行与调度-Task-Execution-and-Scheduling" class="headerlink" title="3.22 任务执行与调度 (Task Execution and Scheduling)"></a>3.22 任务执行与调度 (Task Execution and Scheduling)</h5><ol start="22">
<li><h5 id="任务执行与调度-Task-Execution-and-Scheduling"><a href="#任务执行与调度-Task-Execution-and-Scheduling" class="headerlink" title="任务执行与调度 (Task Execution and Scheduling)"></a>任务执行与调度 (Task Execution and Scheduling)</h5><p>在context中没有 <code>Executor</code> bean 的情况下,Spring Boot 自动配置了一个具有合理默认值的 <code>ThreadPoolTaskExecutor</code>,可以自动关联到异步任务执行(<code>@EnableAsync</code>)和 Spring MVC 异步请求处理.</p>
<blockquote>
<p>建议:</p>
<p>​    如果在context中添加了自定义的 <code>Executor</code>,常规任务执行(即<code>@EnableAsync</code>)将透明地使用它,但不会配置对 Spring MVC 支持,因为它需要 <code>AsyncTaskExecutor</code> 实现(名为 <code>applicationTaskExecutor</code>).根据的目标安排,可以将 <code>Executor</code> 更改为 <code>ThreadPoolTaskExecutor</code> 或同时定义 <code>ThreadPoolTaskExecutor </code>和 <code>AsyncConfigurer</code> 包装自定义的 <code>Executor</code>.</p>
<p>自动配置的 <code>TaskExecutorBuilder</code> 允许开发者轻松创建实例, 也是重现默认情况下自动配置所做的事情.</p>
</blockquote>
<p>线程池使用8个核心线程,可以根据负载增减. 这些默认设置可以使用 <code>spring.task.execution</code> 命名空间进行调整,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.task.execution.pool.max-size</span>=<span class="string">16</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.queue-capacity</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.keep-alive</span>=<span class="string">10s</span></span><br></pre></td></tr></tbody></table></figure>

<p>这会将线程池更改为使用有界队列,以便当队列已满(100 个任务)时,线程池增加到最多 16 个线程.池的收缩更加积极,如果线程空闲 10 秒(而不是默认情况下为 60 秒),将被回收.</p>
<p>如果需要与计划任务执行相关联(例如 <code>@EnableScheduling</code>),也可以自动配置 <code>ThreadPoolTaskScheduler</code>. 线程池默认使用一个线程,其设置可以使用 <code>spring.task.scheduling</code> 命名空间进行微调,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.task.scheduling.thread-name-prefix</span>=<span class="string">scheduling-</span></span><br><span class="line"><span class="meta">spring.task.scheduling.pool.size</span>=<span class="string">2</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果需要创建自定义executor或scheduler,则 <code>TaskExecutorBuilder</code> bean 和 <code>TaskSchedulerBuilder</code> bean 在context中都可用.</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/55600.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/55600.html" class="post-title-link" itemprop="url">3.20 Feature: Hazelcast</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 13:01:00" itemprop="dateCreated datePublished" datetime="2021-06-04T13:01:00+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:54:18" itemprop="dateModified" datetime="2021-06-10T12:54:18+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/55600.html" class="post-meta-item leancloud_visitors" data-flag-title="3.20 Feature: Hazelcast" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>861</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-20-Hazelcast"><a href="#3-20-Hazelcast" class="headerlink" title="3.20 Hazelcast"></a>3.20 Hazelcast</h5><ol start="20">
<li><h5 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h5><p>如果 Hazelcast 在classpath上并且找到了合适的配置,Spring Boot 会自动配置一个 <code>HazelcastInstance</code>,可以将它注入到应用中.</p>
<p>Spring Boot 首先尝试检查以下配置选项来创建客户端:</p>
<ul>
<li><code>com.hazelcast.client.config.ClientConfig</code> bean 的存在.</li>
<li><code>spring.hazelcast.config</code> 属性定义的配置文件</li>
<li><code>hazelcast.client.config</code> 系统属性的存在.</li>
<li>工作目录或classpath根目录中的 <code>hazelcast-client.xml</code>.</li>
<li>工作目录或classpath根目录中的 <code>hazelcast-client.yaml</code>.</li>
</ul>
<blockquote>
<p>注意:</p>
<p>​    Spring Boot 支持 Hazelcast 4 和 Hazelcast 3.如果你降级到 Hazelcast 3,应该将 <code>hazelcast-client</code> 添加到classpath中来配置客户端.</p>
</blockquote>
<p>如果无法创建客户端,Spring Boot 会尝试配置嵌入式服务器.如果定义了一个 <code>com.hazelcast.config.Config</code> bean,Spring Boot 会使用它.如果配置定义了一个实例名称,Spring Boot 会尝试定位现有实例而不是创建新实例.</p>
<p>还可以通过配置指定 Hazelcast 配置文件,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.hazelcast.config</span>=<span class="string">classpath:config/my-hazelcast.xml</span></span><br></pre></td></tr></tbody></table></figure>

<p>否则,Spring Boot 会尝试从默认位置查找 Hazelcast 配置:工作目录或classpath根目录中的 <code>hazelcast.xml</code>,或相同位置的<code>.yaml</code>对应文件.还检查是否设置了 <code>hazelcast.config</code> 系统属性. 有关更多详细信息,请参阅 <a target="_blank" rel="noopener" href="https://docs.hazelcast.org/docs/latest/manual/html-single/">Hazelcast documentation</a>.</p>
<blockquote>
<p>注意:</p>
<p>​    Spring Boot 也对 Hazelcast 有显式的缓存支持. 如果启用缓存,<code>HazelcastInstance</code>会自动包装在 <code>CacheManager</code> 实现中.</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/16277.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/16277.html" class="post-title-link" itemprop="url">3.19 Feature: 使用 JTA 的分布式事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 13:00:00" itemprop="dateCreated datePublished" datetime="2021-06-04T13:00:00+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:54:49" itemprop="dateModified" datetime="2021-06-10T12:54:49+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/16277.html" class="post-meta-item leancloud_visitors" data-flag-title="3.19 Feature: 使用 JTA 的分布式事务" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-19-使用-JTA-的分布式事务-Distributed-Transactions-with-JTA"><a href="#3-19-使用-JTA-的分布式事务-Distributed-Transactions-with-JTA" class="headerlink" title="3.19 使用 JTA 的分布式事务(Distributed Transactions with JTA)"></a>3.19 使用 JTA 的分布式事务(Distributed Transactions with JTA)</h5><ol start="19">
<li><h6 id="使用-JTA-的分布式事务-Distributed-Transactions-with-JTA"><a href="#使用-JTA-的分布式事务-Distributed-Transactions-with-JTA" class="headerlink" title="使用 JTA 的分布式事务(Distributed Transactions with JTA)"></a>使用 JTA 的分布式事务(Distributed Transactions with JTA)</h6><p>Spring Boot 通过使用 Atomikos 嵌入式事务管理器支持跨多个 XA 资源的分布式 JTA 事务.部署到合适的 Java EE 应用服务器时, JTA 事务也受支持.</p>
<p>当检测到 JTA 环境时,Spring 的<code> JtaTransactionManager</code> 将用于管理事务.自动配置的 JMS,数据源和 JPA bean 会被升级以支持 XA 事务.可以使用标准的 Spring 习惯用法,例如 <code>@Transactional</code>,来参与分布式事务. 如果在 JTA 环境中并且仍想使用本地事务,则可以将 <code>spring.jta.enabled</code> 属性设置为 <code>false</code> 以禁用 JTA 自动配置.</p>
<ol>
<li><h6 id="使用Atomikos事务管理器-Using-an-Atomikos-Transaction-Manager"><a href="#使用Atomikos事务管理器-Using-an-Atomikos-Transaction-Manager" class="headerlink" title="使用Atomikos事务管理器(Using an Atomikos Transaction Manager)"></a>使用Atomikos事务管理器(Using an Atomikos Transaction Manager)</h6><p>Atomikos 是一个流行的开源事务管理器,可以嵌入到 Spring Boot 应用程序中.可以使用 <code>spring-boot-starter-jta-atomikos</code> starter来拉取 Atomikos 库.Spring Boot 自动配置 Atomikos 并将适当的<code>depends-on</code>应用于 Spring bean 以实现正确的启动和关闭顺序.</p>
<p>默认情况下,Atomikos 事务日志被写入应用主目录(应用程序 jar 文件所在的目录)中的<code>transaction-logs</code>目录.可以通过在 <code>application.properties</code> 文件中设置 <code>spring.jta.log-dir</code> 属性来自定义此目录的位置.以 <code>spring.jta.atomikos.properties</code> 开头的属性也可用于自定义 Atomikos <code>UserTransactionServiceImp</code>.有关完整的详细信息,请参阅 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html"><code>AtomikosProperties</code> Javadoc</a> .</p>
<blockquote>
<p>注意:</p>
<p>​    为了保证多个事务管理器可以安全地协调同一个资源管理器,每个 Atomikos 实例必须配置一个唯一的 ID.默认情况下,此 ID 是运行 Atomikos 的机器的 IP 地址.为了保证生产环境中的唯一性,应该为应用程序的每个实例配置 <code>spring.jta.transaction-manager-id</code> 属性配置不同的值.</p>
</blockquote>
</li>
<li><h6 id="使用-Java-EE-托管事务管理器-Using-a-Java-EE-Managed-Transaction-Manager"><a href="#使用-Java-EE-托管事务管理器-Using-a-Java-EE-Managed-Transaction-Manager" class="headerlink" title="使用 Java EE 托管事务管理器 (Using a Java EE Managed Transaction Manager)"></a>使用 Java EE 托管事务管理器 (Using a Java EE Managed Transaction Manager)</h6><p>如果将 Spring Boot 应用打包为 <code>war</code> 或 <code>ear</code> 文件并将其部署到 Java EE 应用服务器,则可以使用应用服务器的内置事务管理器.Spring Boot 尝试通过查看常见的 JNDI 位置(<code>java:comp/UserTransaction</code>,<code>java:comp/TransactionManager</code> 等)来自动配置事务管理器.如果使用应用服务器提供的事务服务,通常还希望确保所有资源都由服务器管理并通过 JNDI 公开.Spring Boot 尝试通过在 JNDI 路径(<code>java:/JmsXA</code> 或 <code>java:/XAConnectionFactory</code>)中查找 <code>ConnectionFactory</code> 来自动配置 JMS,可以使用 <code>spring.datasource.jndi-name</code> 属性来配置数据源.</p>
</li>
<li><h6 id="混合-XA-和非-XA-JMS-连接"><a href="#混合-XA-和非-XA-JMS-连接" class="headerlink" title="混合 XA 和非 XA JMS 连接"></a>混合 XA 和非 XA JMS 连接</h6><p>使用 JTA 时,主要的 JMS <code>ConnectionFactory</code> bean 是 XA-aware 并参与分布式事务.可以注入到 bean 中,而无需使用任何 <code>@Qualifier</code>.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在某些情况下,可能希望使用非 XA的<code>ConnectionFactory</code> 来处理一些 JMS 消息.例如, JMS 处理逻辑可能需要时间比 XA 超时时间更长.</p>
<p>如果要使用非 XA <code>ConnectionFactory</code>,可以使用 <code>nonXaJmsConnectionFactory</code> bean:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(<span class="meta">@Qualifier("nonXaJmsConnectionFactory")</span> ConnectionFactory connectionFactory)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为了一致性, <code>jmsConnectionFactory</code> bean还被使用 bean 别名 <code>xaJmsConnectionFactory </code>提供.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(<span class="meta">@Qualifier("xaJmsConnectionFactory")</span> ConnectionFactory connectionFactory)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="支持替代嵌入式事务管理器-Supporting-an-Alternative-Embedded-Transaction-Manager"><a href="#支持替代嵌入式事务管理器-Supporting-an-Alternative-Embedded-Transaction-Manager" class="headerlink" title="支持替代嵌入式事务管理器 (Supporting an Alternative Embedded Transaction Manager)"></a>支持替代嵌入式事务管理器 (Supporting an Alternative Embedded Transaction Manager)</h6><p><code>XAConnectionFactoryWrapper</code> 和 <code>XADataSourceWrapper</code> 接口可用于支持替代的嵌入式事务管理器.接口负责包装 <code>XAConnectionFactory</code> 和 <code>XADataSource</code> bean 并将它们公开为常规的<code>ConnectionFactory</code> 和 <code>DataSource</code> bean,它们透明地注册到分布式事务中.数据源和 JMS 自动配置使用 JTA 变体,前提是在 <code>ApplicationContext</code> 中注册了 <code>JtaTransactionManager</code> bean 和适当的 XA 包装 bean.</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/atomikos/AtomikosXAConnectionFactoryWrapper.java">AtomikosXAConnectionFactoryWrapper</a> 和 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/atomikos/AtomikosXADataSourceWrapper.java">AtomikosXADataSourceWrapper</a> 提供了如何编写 XA 包装器的例子.</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">…</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  © 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenyk</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">337k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:06</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>


  





  
  

  
  <script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  
  


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.1.0/dist/quicklink.umd.js"></script>
  
  



<script src="/bundle.js"></script><script>{&quot;enable&quot;:true,&quot;spinner&quot;:true};
{&quot;enable&quot;:true,&quot;app_id&quot;:null,&quot;app_key&quot;:null,&quot;server_url&quot;:null,&quot;security&quot;:true};
{&quot;enable&quot;:true,&quot;home&quot;:true,&quot;archive&quot;:true,&quot;delay&quot;:true,&quot;timeout&quot;:3000,&quot;priority&quot;:true,&quot;ignores&quot;:null,&quot;url&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;page&#x2F;3&#x2F;&quot;}</script></body></html>