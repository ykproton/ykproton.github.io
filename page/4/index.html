<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat-logo.jpg">
  <link rel="mask-icon" href="/images/cat-logo.jpg" color="#222">






  
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="ykproton">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="ykproton">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chenyk">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;4&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>ykproton</title>
  




  <noscript>
    
  </noscript>
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ykproton</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chenyk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ykproton" title="GitHub → https://github.com/ykproton" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/34767.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/34767.html" class="post-title-link" itemprop="url">3.18 Feature: 发送邮件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 12:58:00" itemprop="dateCreated datePublished" datetime="2021-06-04T12:58:00+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 13:06:19" itemprop="dateModified" datetime="2021-06-10T13:06:19+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/34767.html" class="post-meta-item leancloud_visitors" data-flag-title="3.18 Feature: 发送邮件" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>646</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-18-发送邮件-Sending-Email"><a href="#3-18-发送邮件-Sending-Email" class="headerlink" title="3.18 发送邮件 (Sending Email)"></a>3.18 发送邮件 (Sending Email)</h5><ol start="18">
<li><h5 id="发送邮件-Sending-Email"><a href="#发送邮件-Sending-Email" class="headerlink" title="发送邮件 (Sending Email)"></a>发送邮件 (Sending Email)</h5><p>Spring Framework 提供了使用 <code>JavaMailSender</code> 接口发送电子邮件的抽象,Spring Boot 为其提供了自动配置以及 starter 模块.</p>
<blockquote>
<p>建议:</p>
<p>​    有关如何使用 JavaMailSender 的详细说明,请参阅参考文档(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#mail">reference documentation</a>).</p>
</blockquote>
<p>如果 <code>spring.mail.host</code> 和相关库(由 <code>spring-boot-starter-mail</code> 定义)可用,如果<code>JavaMailSender</code>不存在,则会创建默认的 <code>JavaMailSender</code>.可以通过 <code>spring.mail</code> 命名空间中的配置项进一步自定义sender . 有关更多详细信息,参阅 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java"><code>MailProperties</code></a>.</p>
<p>特别是,某些默认超时值是无限的,可能希望更改该值以避免线程被无响应的邮件服务器所阻塞,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mail.properties[mail.smtp.connectiontimeout]</span>=<span class="string">5000</span></span><br><span class="line"><span class="meta">spring.mail.properties[mail.smtp.timeout]</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">spring.mail.properties[mail.smtp.writetimeout]</span>=<span class="string">5000</span></span><br></pre></td></tr></tbody></table></figure>

<p>还可以使用来自 JNDI 的现有<code>Session</code>配置 <code>JavaMailSender</code>:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mail.jndi-name</span>=<span class="string">mail/Session</span></span><br></pre></td></tr></tbody></table></figure>

<p>设置 <code>jndi-name</code> 时,它优先于所有其他与会话相关的设置.</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/45647.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/45647.html" class="post-title-link" itemprop="url">3.17 Feature: 校验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 12:57:00" itemprop="dateCreated datePublished" datetime="2021-06-04T12:57:00+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:55:28" itemprop="dateModified" datetime="2021-06-10T12:55:28+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/45647.html" class="post-meta-item leancloud_visitors" data-flag-title="3.17 Feature: 校验" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>392</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-17-校验-Validation"><a href="#3-17-校验-Validation" class="headerlink" title="3.17 校验(Validation)"></a>3.17 校验(Validation)</h5><ol start="17">
<li><h6 id="校验-Validation"><a href="#校验-Validation" class="headerlink" title="校验(Validation)"></a>校验(Validation)</h6><p>只要 JSR-303 实现(例如 Hibernate 验证器)在classpath上,Bean Validation 1.1 支持的方法验证功能就会自动启用.这让 bean 方法可以使用 <code>javax.validation</code> 注解对其参数和/或返回值的进行约束.带有这种注解标注的方法的目标类需要在类型级别使用 <code>@Validated</code> 注解进行标注,以便在类内方法中搜索内联约束注解.</p>
<p>例如,以下服务触发第一个参数的验证,确保其大小在 8 到 10 之间:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Archive <span class="title">findByCodeAndAuthor</span><span class="params">(<span class="meta">@Size(min = 8, max = 10)</span> String code, Author author)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/64077.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/64077.html" class="post-title-link" itemprop="url">3.16 Feature: 使用 WebClient 调用 REST 服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 12:56:00" itemprop="dateCreated datePublished" datetime="2021-06-04T12:56:00+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:56:10" itemprop="dateModified" datetime="2021-06-10T12:56:10+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/64077.html" class="post-meta-item leancloud_visitors" data-flag-title="3.16 Feature: 使用 WebClient 调用 REST 服务" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-16-使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient"><a href="#3-16-使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient" class="headerlink" title="3.16 使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)"></a>3.16 使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)</h5><ol start="16">
<li><h6 id="使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient"><a href="#使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient" class="headerlink" title="使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)"></a>使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)</h6><p>如果classpath上有 Spring WebFlux,也可以选择使用 <code>WebClient</code> 来调用远程 REST 服务.与 <code>RestTemplate</code> 相比,这个客户端更加函数式,并且是完全响应式的.可以在 Spring Framework 文档的专门部分中了解有关 WebClient 的更多信息.</p>
<p>Spring Boot 为创建并预配置了一个 <code>WebClient.Builder</code>. 强烈建议将其注入到组件中并使用它来创建 <code>WebClient</code> 实例.Spring Boot 正在配置该构建器以共享 HTTP 资源,以与服务器相同的方式反映编解码器设置(请参阅 WebFlux HTTP 编解码器自动配置 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-web-applications.spring-webflux.httpcodecs">WebFlux HTTP codecs auto-configuration</a>)等等.</p>
<p>以下代码显示了一个典型示例:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebClient.Builder webClientBuilder)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.webClient = webClientBuilder.baseUrl(<span class="string">"https://example.org"</span>).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Details&gt; <span class="title">someRestCall</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.webClient.get().uri(<span class="string">"/{name}/details"</span>, name).retrieve().bodyToMono(Details.class);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><h6 id="WebClient-运行时-WebClient-Runtime"><a href="#WebClient-运行时-WebClient-Runtime" class="headerlink" title="WebClient 运行时 (WebClient Runtime)"></a>WebClient 运行时 (WebClient Runtime)</h6><p>Spring Boot 将自动检测使用哪个 <code>ClientHttpConnector</code> 来驱动 <code>WebClient</code>,具体取决于应用程序classpath上可用的库.目前,支持 Reactor Netty 和 Jetty RS 客户端.<code>spring-boot-starter-webflux</code> “starter” 默认依赖于 <code>io.projectreactor.netty:reactor-netty</code>,它带来了服务端和客户端的实现.如果您选择使用 Jetty 作为响应式服务器,则应添加对 Jetty Reactive HTTP 客户端库的依赖 <code>org.eclipse.jetty:jetty-reactive-httpclient</code>.服务器和客户端使用相同的技术有其优势,因为它会自动在客户端和服务器之间共享 HTTP 资源.</p>
<p>开发人员可以通过提供自定义的 <code>ReactorResourceFactory</code> 或 <code>JettyResourceFactory</code> bean 来覆盖 Jetty 和 Reactor Netty 的资源配置 - 这将应用于客户端和服务器.</p>
<p>如果希望覆盖客户端该选择,可以定义自己的 <code>ClientHttpConnector</code> bean 并完全控制客户端配置.</p>
<p>可以在 Spring Framework 参考文档中了解有关 <code>WebClient</code> 配置选项的更多信息(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/web-reactive.html#webflux-client-builder"><code>WebClient</code> configuration options in the Spring Framework reference documentation</a>).</p>
</li>
<li><h6 id="自定义WebClient-WebClient-Customization"><a href="#自定义WebClient-WebClient-Customization" class="headerlink" title="自定义WebClient (WebClient Customization)"></a>自定义WebClient (WebClient Customization)</h6><p> 自定义<code>WebClient</code>有三种方法,具体取决于希望自定义应用的范围.</p>
<p>为了尽可能缩小任何自定义的范围,注入自动配置的 <code>WebClient.Builder</code>,然后根据需要调用其方法.<code>WebClient.Builder</code> 实例是有状态的:Builder上的任何更改都会反映在随后使用它创建的所有客户端中.如果想用同一个构建器创建多个客户端,也可以考虑使用 <code>WebClient.Builder other = builder.clone();</code> 克隆构建器.</p>
<p>要对所有 <code>WebClient.Builder</code> 实例进行应用范围的,额外的自定义,可以声明 <code>WebClientCustomizer</code> bean 并在注入点本地更改 <code>WebClient.Builder</code>.</p>
<p>最后,可以回退到原始 API, 使用 <code>WebClient.create()</code>. 在这种情况下,不会应用自动配置或 <code>WebClientCustomizer</code>.</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/54638.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/54638.html" class="post-title-link" itemprop="url">3.15 Feature: 使用RestTemplate 调用 REST 服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 12:55:00" itemprop="dateCreated datePublished" datetime="2021-06-04T12:55:00+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:56:35" itemprop="dateModified" datetime="2021-06-10T12:56:35+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/54638.html" class="post-meta-item leancloud_visitors" data-flag-title="3.15 Feature: 使用RestTemplate 调用 REST 服务" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="3-15-使用-RestTemplate-调用-REST-服务"><a href="#3-15-使用-RestTemplate-调用-REST-服务" class="headerlink" title="3.15 使用 RestTemplate 调用 REST 服务"></a>3.15 使用 RestTemplate 调用 REST 服务</h5><ol start="15">
<li><h5 id="使用-RestTemplate-调用-REST-服务-Calling-REST-Services-with-RestTemplate"><a href="#使用-RestTemplate-调用-REST-服务-Calling-REST-Services-with-RestTemplate" class="headerlink" title="使用 RestTemplate 调用 REST 服务(Calling REST Services with RestTemplate)"></a>使用 RestTemplate 调用 REST 服务(Calling REST Services with RestTemplate)</h5><p>如果需要从应用中调用远程 REST 服务,可以使用 Spring Framework 的 <code>RestTemplate</code> 类.由于 <code>RestTemplate</code> 实例在使用前经常需要自定义,因此 Spring Boot 没有提供任何单个自动配置的 <code>RestTemplate</code> bean.然而,它会自动配置一个 <code>RestTemplateBuilder</code>,它可以在需要时用于创建 <code>RestTemplate</code> 实例.自动配置的 <code>RestTemplateBuilder</code> 确保将合适的 <code>HttpMessageConverters</code>应用于 <code>RestTemplate</code> 实例.</p>
<p>以下代码显示了一个典型示例:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Details <span class="title">someRestCall</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"/{name}/details"</span>, Details.class, name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    <code>RestTemplateBuilder</code> 包含许多有用的方法,可用于快速配置 <code>RestTemplate</code>.例如,要添加 BASIC 身份验证支持,您可以使用 <code>builder.basicAuthentication("user", "password").build()</code>.</p>
</blockquote>
<ol>
<li><h6 id="自定义RestTemplate-RestTemplate-Customization"><a href="#自定义RestTemplate-RestTemplate-Customization" class="headerlink" title="自定义RestTemplate (RestTemplate Customization)"></a>自定义RestTemplate (RestTemplate Customization)</h6><p>自定义<code>RestTemplate</code> 有三种主要方法,具体取决于自定义应用的范围.</p>
<p>为了尽可能缩小任何自定义的范围,注入自动配置的 <code>RestTemplateBuilder</code>,然后根据需要调用其方法.每个方法调用都会返回一个新的 <code>RestTemplateBuilder</code> 实例,因此自定义值影响构建器的使用.</p>
<p>要进行应用范围上的的,额外的自定义,使用 <code>RestTemplateCustomizer</code> bean.所有这些 bean 都会自动注册到自动配置的 <code>RestTemplateBuilder</code> 并应用于使用它构建的任何模板.</p>
<p>以下示例显示了一个定制器,它为除 <code>192.168.0.5</code> 之外的所有主机配置代理的使用:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestTemplateCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>{</span><br><span class="line">        HttpRoutePlanner routePlanner = <span class="keyword">new</span> CustomRoutePlanner(<span class="keyword">new</span> HttpHost(<span class="string">"proxy.example.com"</span>));</span><br><span class="line">        HttpClient httpClient = HttpClientBuilder.create().setRoutePlanner(routePlanner).build();</span><br><span class="line">        restTemplate.setRequestFactory(<span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRoutePlanner</span> <span class="keyword">extends</span> <span class="title">DefaultProxyRoutePlanner</span> </span>{</span><br><span class="line"></span><br><span class="line">        CustomRoutePlanner(HttpHost proxy) {</span><br><span class="line">            <span class="keyword">super</span>(proxy);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> HttpHost <span class="title">determineProxy</span><span class="params">(HttpHost target, HttpRequest request, HttpContext context)</span> <span class="keyword">throws</span> HttpException </span>{</span><br><span class="line">            <span class="keyword">if</span> (target.getHostName().equals(<span class="string">"192.168.0.5"</span>)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.determineProxy(target, request, context);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后,还可以创建自己的 <code>RestTemplateBuilder</code> bean.为了防止关闭 <code>RestTemplateBuilder </code>的自动配置,并防止使用任何 <code>RestTemplateCustomizer</code> bean,确保使用 <code>RestTemplateBuilderConfigurer</code> 配置自定义实例.下面的示例公开了一个Spring Boot 自动配置的 <code>RestTemplateBuilder</code>,还指定了自定义连接和读取超时:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestTemplateBuilderConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">(RestTemplateBuilderConfigurer configurer)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> configurer.configure(<span class="keyword">new</span> RestTemplateBuilder()).setConnectTimeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                .setReadTimeout(Duration.ofSeconds(<span class="number">2</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最极端(也很少使用)的选项是在不使用配置器,创建自己的 <code>RestTemplateBuilder</code> bean.这样做会关闭 <code>RestTemplateBuilder</code> 的自动配置并禁用任何的 <code>RestTemplateCustomizer</code> bean.</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/10287.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/10287.html" class="post-title-link" itemprop="url">3.14 Feature: 消息中间件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 12:52:00" itemprop="dateCreated datePublished" datetime="2021-06-04T12:52:00+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:56:52" itemprop="dateModified" datetime="2021-06-10T12:56:52+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/10287.html" class="post-meta-item leancloud_visitors" data-flag-title="3.14 Feature: 消息中间件" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h6 id="3-14-Messaging-消息中间件"><a href="#3-14-Messaging-消息中间件" class="headerlink" title="3.14 Messaging(消息中间件)"></a>3.14 Messaging(消息中间件)</h6><ol start="14">
<li><h6 id="Messaging-消息中间件"><a href="#Messaging-消息中间件" class="headerlink" title="Messaging(消息中间件)"></a>Messaging(消息中间件)</h6><p>Spring Framework 对集成消息中间件系统提供了大量支持,从使用<code>JmsTemplate</code>的 JMS API 的简单使用到异步接收消息的完整基础架构.Spring AMQP 为高级消息队列协议提供了类似的功能集.Spring Boot 还为 <code>RabbitTemplate</code> 和 RabbitMQ 提供了自动配置选项.Spring WebSocket 本身就包含对 STOMP 消息传递的支持,而 Spring Boot 通过starter和少量自动配置来实现支持.Spring Boot 还支持 Apache Kafka.</p>
<ol>
<li><h6 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h6><p><code>javax.jms.ConnectionFactory</code>接口提供了创建 <code>javax.jms.Connection</code> ,以用于 JMS broker交互的标准方法. 虽然Spring需要一个 <code>ConnectionFactory</code> 来与 JMS 一起工作,但通常不需要自己直接使用,而是可以依靠更高级别的消息传递抽象.(有关详细信息<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#jms">relevant section</a>,请参阅 Spring Framework 参考文档的相关部分).Spring Boot 还自动配置必要的infrastructure 来发送和接收消息.</p>
<ol>
<li><h6 id="ActiveMQ-Support"><a href="#ActiveMQ-Support" class="headerlink" title="ActiveMQ Support"></a>ActiveMQ Support</h6><p>当classpath上有 ActiveMQ 时,Spring Boot 也可以配置 <code>ConnectionFactory</code>.如果代理存在,则会自动启动和配置嵌入式代理(前提是没有通过配置指定代理 URL).</p>
<blockquote>
<p>注意:</p>
<p>​    如果使用<code>spring-boot-starter-activemq</code>,则提供了连接或嵌入 ActiveMQ 实例所需的依赖项,以及和JMS集成的 Spring infrastructure.</p>
</blockquote>
<p>可以使用<code>spring.activemq.*</code>中的外部配置属性来配置 ActiveMQ.例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.activemq.broker-url</span>=<span class="string">tcp://192.168.1.210:9876</span></span><br><span class="line"><span class="meta">spring.activemq.user</span>=<span class="string">admin </span></span><br><span class="line"><span class="meta">spring.activemq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下, <code>CachingConnectionFactory</code>使用合理的设置包装本地 <code>ConnectionFactory</code>,可以通过 <code>spring.jms.*</code> 中的外部配置属性来配置这些设置:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jms.cache.session-cache-size</span>=<span class="string">5</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果更想要使用本地池,可以添加依赖<code>org.messaginghub:pooled-jms</code> ,并相应地配置 <code>JmsPoolConnectionFactory</code> 来实现,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.activemq.pool.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.activemq.pool.max-connections</span>=<span class="string">50</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    有关更多支持的选项,参阅(<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java"><code>ActiveMQProperties</code></a>).可以注册任意数量的实现 <code>ActiveMQConnectionFactoryCustomizer</code> 的 bean 以进行更高级的自定义.</p>
</blockquote>
<p>默认情况下,如果目标尚不存在,ActiveMQ 会创建一个目标,以便根据名称解析目标.</p>
</li>
<li><h6 id="ActiveMQ-Artemis-Support-支持ActiveMQ-Artemis"><a href="#ActiveMQ-Artemis-Support-支持ActiveMQ-Artemis" class="headerlink" title="ActiveMQ Artemis Support (支持ActiveMQ Artemis)"></a>ActiveMQ Artemis Support (支持ActiveMQ Artemis)</h6><p>Spring Boot检测到ActiveMQ Artemis在classpath上可用时,自动配置 <code>ConnectionFactory</code>. 如果broker存在,则会自动启动和配置嵌入式broker(除非已显式设置模式属性).支持的模式是<code>embedded</code>(明确表明需要一个嵌入式代理,如果代理在类路径上不可用,则会发生错误)和<code>native</code>(使用 netty 传输协议连接到代理).配置后者时,Spring Boot 会配置一个 <code>ConnectionFactory</code>,它使用默认设置连接到在本地机器上运行的broker.</p>
<blockquote>
<p>注意:</p>
<p>​    如果使用 <code>spring-boot-starter-artemis</code>,则提供连接到ActiveMQ Artemis 实例所需的依赖,以及与 JMS 集成的 Spring infrastructure.将 <code>org.apache.activemq:artemis-jms-server</code> 添加到的应用中,可以使用嵌入模式.</p>
</blockquote>
<p>ActiveMQ Artemis 配置由 <code>spring.artemis.*</code> 中的外部配置属性控制. 例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.artemis.mode</span>=<span class="string">native</span></span><br><span class="line"><span class="meta">spring.artemis.broker-url</span>=<span class="string">tcp://192.168.1.210:9876</span></span><br><span class="line"><span class="meta">spring.artemis.user</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.artemis.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>

<p>嵌入broker时,可以选择是否要启用持久化并列出应该可用的destination.这些可以使用逗号分割的列表来指定,从而使用默认选项创建它们,或者可以定义 <code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code> 或 <code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>类型的bean,分别用于queue和configurations高级配置.</p>
<p>默认情况下, <code>CachingConnectionFactory</code> 使用合理的设置包装本地的<code>ConnectionFactory</code>,您可以通过 <code>spring.jms.*</code> 中的外部配置属性控制这些设置:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jms.cache.session-cache-size</span>=<span class="string">5</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果更愿意使用本地的池,可以通过向 <code>org.messaginghub:pooled-jms</code> 添加依赖,并配置 <code>JmsPoolConnectionFactory</code> 来实现,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.artemis.pool.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.artemis.pool.max-connections</span>=<span class="string">50</span></span><br></pre></td></tr></tbody></table></figure>

<p>有关更多支持的选项,请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java"><code>ArtemisProperties</code></a>.</p>
<p>不涉及 JNDI 查找,并且根据其名称解析destination, 使用 Artemis 配置中的 <code>name</code> 属性或通过配置提供的名称.</p>
</li>
<li><h6 id="使用-JNDI-连接工厂-Using-a-JNDI-ConnectionFactory"><a href="#使用-JNDI-连接工厂-Using-a-JNDI-ConnectionFactory" class="headerlink" title="使用 JNDI 连接工厂(Using a JNDI ConnectionFactory)"></a>使用 JNDI 连接工厂(Using a JNDI ConnectionFactory)</h6><p>如果在应用程序服务器中运行应用,Spring Boot 会尝试使用 JNDI 来定位 JMS <code>ConnectionFactory</code>.默认情况下,会检查 <code>java:/JmsXA</code> 和 <code>java:/XAConnectionFactory</code> 位置. 如果需要指定路径,可以使用 <code>spring.jms.jndi-name</code> 属性,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jms.jndi-name</span>=<span class="string">java:/MyConnectionFactory</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="发送消息-Sending-a-Message"><a href="#发送消息-Sending-a-Message" class="headerlink" title="发送消息(Sending a Message)"></a>发送消息(Sending a Message)</h6><p>Spring 的 <code>JmsTemplate</code> 是自动配置的,可以将其直接autowire到自己的 bean 中,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JmsTemplate jmsTemplate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.jmsTemplate = jmsTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    <code>JmsMessagingTemplate</code> 可以以类似的方式注入. 如果定义了 <code>DestinationResolver</code> 或 <code>MessageConverter</code> bean,它会自动关联到自动配置的 <code>JmsTemplate</code>.</p>
</blockquote>
</li>
<li><h6 id="接收消息-Receiving-a-Message"><a href="#接收消息-Receiving-a-Message" class="headerlink" title="接收消息(Receiving a Message)"></a>接收消息(Receiving a Message)</h6></li>
</ol>
</li>
</ol>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当 JMS infrastructure存在时,任何 bean 都可以使用 <code>@JmsListener</code> 进行标注以创建监听器端点.如果没有定义 <code>JmsListenerContainerFactory</code>,则会自动配置默认值. 如果定义了 <code>DestinationResolver</code>,<code>MessageConverter</code> 或 <code>javax.jms.ExceptionListener</code> bean,它们将自动与默认工厂关联.</p>
<pre><code>  默认情况下,默认工厂是事务性的. 如果infrastructure 中存在 `JtaTransactionManager` ,则默认情况下它会被关联到监听器容器.如果没有,则启用 `sessionTransacted` 标志. 在后一种情况下,可以通过在监听器方法(或其委托)上添加 `@Transactional` 将本地数据存储事务关联到对传入消息的处理上来.这可确保在本地事务完成后,acknowledge传入消息.这还包括发送响应消息,消息是已在同一 JMS 会话上执行的.

  以下组件在 `someQueue` 目标上创建一个监听器端点:

  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = "someQueue")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

  &gt;建议:
  &gt;
  &gt;​    有关更多详细信息,请参阅 `@EnableJms的Javadoc`([the Javadoc of `@EnableJms`](https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/jms/annotation/EnableJms.html).)

  如果需要创建更多 `JmsListenerContainerFactory` 实例或者如果想覆盖默认值,Spring Boot 提供了一个 `DefaultJmsListenerContainerFactoryConfigurer`,可以使用它来初始化 `DefaultJmsListenerContainerFactory` ,其设置与自动配置的设置相同.

  例如,以下示例暴露了另一个使用特定 `MessageConverter` 的工厂:

  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJmsConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">myFactory</span><span class="params">(DefaultJmsListenerContainerFactoryConfigurer configurer)</span> </span>{</span><br><span class="line">        DefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        ConnectionFactory connectionFactory = getCustomConnectionFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        factory.setMessageConverter(<span class="keyword">new</span> MyMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ConnectionFactory <span class="title">getCustomConnectionFactory</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

  然后可以在任何 `@JmsListener` 注释的方法中使用工厂,如下所示:

  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = "someQueue", containerFactory = "myFactory")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</code></pre>
<ol start="2">
<li><h6 id="AMQP-高级消息队列协议"><a href="#AMQP-高级消息队列协议" class="headerlink" title="AMQP(高级消息队列协议)"></a>AMQP(高级消息队列协议)</h6><p>高级消息队列协议 (AMQP) 是面向消息中间件的平台中立的线级协议.Spring AMQP 项目将核心 Spring 概念应用于基于 AMQP 的消息传递方案的开发.Spring Boot 为通过 RabbitMQ 使用 AMQP 提供了多种便利的方式,包括 <code>spring-boot-starter-amqp</code> “Starter”.</p>
<ol>
<li><h6 id="RabbitMQ-支持-RabbitMQ-support"><a href="#RabbitMQ-支持-RabbitMQ-support" class="headerlink" title="RabbitMQ 支持 (RabbitMQ support)"></a>RabbitMQ 支持 (RabbitMQ support)</h6><p>RabbitMQ 是一个基于 AMQP 协议的轻量级,可靠,可扩展和可移植的消息代理. Spring 使用 <code>RabbitMQ</code> 通过 AMQP 协议进行通信.</p>
<p>RabbitMQ 配置由 <code>spring.rabbitmq.*</code> 中的外部配置属性控制.例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>

<p>或者,可以使用 <code>address</code> 属性配置相同的连接:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.addresses</span>=<span class="string">amqp://admin:secret@localhost</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    以这种方式指定地址时,主机和端口属性将被忽略. 如果地址使用 <code>amqps</code> 协议,则自动启用 SSL 支持.</p>
</blockquote>
<p>有关更多受支持的基于属性的配置选项,参阅 RabbitProperties(<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java"><code>RabbitProperties</code></a>).要配置 Spring AMQP 使用的 RabbitMQ <code>ConnectionFactory</code> 的低级详细信息,定义 <code>ConnectionFactoryCustomizer</code> bean.</p>
<p>如果context中存在 <code>ConnectionNameStrategy</code> bean,它将自动用于命名由自动配置的 <code>CachingConnectionFactory</code> 创建的连接.</p>
<blockquote>
<p>建议:</p>
<p>​    有关更多详细信息,请参阅了解 RabbitMQ 使用的协议 AMQP( <a target="_blank" rel="noopener" href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">Understanding AMQP, the protocol used by RabbitMQ</a>).</p>
</blockquote>
</li>
<li><h6 id="发送消息-Sending-a-Message-1"><a href="#发送消息-Sending-a-Message-1" class="headerlink" title="发送消息(Sending a Message)"></a>发送消息(Sending a Message)</h6><p>Spring 的 <code>AmqpTemplate</code> 和 <code>AmqpAdmin</code> 是自动配置的,可以将它们直接自动装配到自己的 bean 中,如下例所示 :</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpAdmin amqpAdmin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.amqpAdmin = amqpAdmin;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate = amqpTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    <code>RabbitMessagingTemplate</code> 可以以类似的方式注入. 如果定义了 <code>MessageConverter</code> bean,它会自动关联到自动配置的 <code>AmqpTemplate</code>.</p>
</blockquote>
<p>如有必要,任何定义为 bean 的 <code>org.springframework.amqp.core.Queue</code> 都会自动用于在 RabbitMQ 实例上声明相应的队列.</p>
<p>要重试操作,可以在 <code>AmqpTemplate</code> 上启用重试(例如,在broker连接丢失的情况下):</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.template.retry.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.initial-interval</span>=<span class="string">2s</span></span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下禁用重试. 还可以通过声明 <code>RabbitRetryTemplateCustomizer</code> bean 以编程方式自定义 <code>RetryTemplate</code>.</p>
<p>如果需要创建更多 <code>RabbitTemplate</code> 实例或者如果想覆盖默认值,Spring Boot 提供了一个 <code>RabbitTemplateConfigurer</code> bean,可以使用它来初始化 <code>RabbitTemplate</code>,其设置与自动配置使用的工厂相同.</p>
</li>
<li><h6 id="接受消息-Receiving-a-Message"><a href="#接受消息-Receiving-a-Message" class="headerlink" title="接受消息(Receiving a Message)"></a>接受消息(Receiving a Message)</h6><p>当存在 Rabbit infrastructure时,任何 bean 都可以被 <code>@RabbitListener </code>标注以创建监听器端点.如果未定义 <code>RabbitListenerContainerFactory</code>,则会自动配置默认的 <code>SimpleRabbitListenerContainerFactory</code>,可以使用 <code>spring.rabbitmq.listener.type</code> 属性切换到直接容器.如果定义了 <code>MessageConverter</code> 或 <code>MessageRecoverer</code> bean,它会自动与默认工厂相关联.</p>
<p>以下示例组件在 <code>someQueue</code> 队列上创建一个监听器端点:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = "someQueue")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    有关更多详细信息,请参阅 <code>@EnableRabbit</code>的<code>Javadoc</code>(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-amqp/docs/2.3.7/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html">the Javadoc of <code>@EnableRabbit</code></a>).</p>
</blockquote>
<p>如果需要创建更多 <code>RabbitListenerContainerFactory</code> 实例或者如果想覆盖默认值,Spring Boot 提供了 <code>SimpleRabbitListenerContainerFactoryConfigurer</code> 和 <code>DirectRabbitListenerContainerFactoryConfigurer</code> 可用于初始化 <code>SimpleRabbitListenerContainerFactory</code> 和 <code>DirectRabbitListenerContainerFactory</code> ,其设置与自动配置使用的工厂相同.</p>
<blockquote>
<p>建议:</p>
<p>​    选择哪种容器类型并不重要. 这两个 bean 由自动配置公开.</p>
</blockquote>
<p>例如,以下配置类公开了另一个使用特定 <code>MessageConverter</code> 的工厂:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRabbitConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">myFactory</span><span class="params">(SimpleRabbitListenerContainerFactoryConfigurer configurer)</span> </span>{</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        ConnectionFactory connectionFactory = getCustomConnectionFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        factory.setMessageConverter(<span class="keyword">new</span> MyMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ConnectionFactory <span class="title">getCustomConnectionFactory</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后就可以在任何<code>@RabbitListener</code>标注方法中使用工厂了,如下:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{ublic <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = "someQueue", containerFactory = "myFactory")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以启用重试来处理监听器抛出异常的情况. 默认使用 <code>RejectAndDontRequeueRecoverer</code>,但可以定义自己的 <code>MessageRecoverer</code>.当重试次数用尽时,如果代理配置为此,消息将被拒绝并被丢弃或路由到死信交换.默认情况下,重试被禁用. 可以通过声明 <code>RabbitRetryTemplateCustomizer</code> bean 以编程方式自定义 <code>RetryTemplate</code>.</p>
<blockquote>
<p>重要:</p>
<p>​    默认情况下,如果禁用重试并且listener抛出异常,则将无限重试发送.可以通过两种方式修改此行为:将 <code>defaultRequeueRejected</code> 属性设置为 <code>false</code> 以便尝试零重新发送或抛出 <code>AmqpRejectAndDontRequeueException</code> 以表示应拒绝消息.后者是启用重试并达到最大传递尝试次数时使用的机制.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="Apache-Kafka-支持-Apache-Kafka-Support"><a href="#Apache-Kafka-支持-Apache-Kafka-Support" class="headerlink" title="Apache Kafka 支持(Apache Kafka Support)"></a>Apache Kafka 支持(Apache Kafka Support)</h6><p>通过提供 spring-kafka 项目的自动配置来支持 Apache Kafka.</p>
<p>Kafka 配置由 <code>spring.kafka.*</code> 中的外部配置属性控制. 例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>=<span class="string">localhost:9092</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.group-id</span>=<span class="string">myGroup</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    要在启动时创建topic,请添加 <code>NewTopic</code> 类型的 bean. 如果主题已存在,则忽略该 bean.</p>
</blockquote>
<p>有关更多支持的选项,请参阅 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java"><code>KafkaProperties</code></a>.</p>
<ol>
<li><h6 id="发送消息-Sending-a-Message-2"><a href="#发送消息-Sending-a-Message-2" class="headerlink" title="发送消息 (Sending a Message)"></a>发送消息 (Sending a Message)</h6><p>Spring 的 <code>KafkaTemplate</code> 是自动配置的,可以直接在自己的 bean 中自动装配,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(KafkaTemplate&lt;String, String&gt; kafkaTemplate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    如果定义了 <code>spring.kafka.producer.transaction-id-prefix</code> 属性,则会自动配置一个 <code>KafkaTransactionManager</code>.此外,如果定义了 <code>RecordMessageConverter</code> bean,它会自动关联到自动配置的 <code>KafkaTemplate</code>.</p>
</blockquote>
</li>
<li><h6 id="接受消息-Receiving-a-Message-1"><a href="#接受消息-Receiving-a-Message-1" class="headerlink" title="接受消息(Receiving a Message)"></a>接受消息(Receiving a Message)</h6><p>当存在 Apache Kafka infrastructure 时,任何 bean 都可以使用 <code>@KafkaListener</code> 进行标注以创建listener endpoint.如果未定义 <code>KafkaListenerContainerFactory</code>,则默认使用 <code>spring.kafka.listener.*</code> 中定义的键进行自动配置.</p>
<p>以下组件在 <code>someTopic</code> 主题上创建一个listener endpoint:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = "someTopic")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果定义了 <code>KafkaTransactionManager</code> bean,它会自动关联到容器工厂.同样,如果定义了 <code>RecordFilterStrategy</code>,<code>ErrorHandler</code>,<code>AfterRollbackProcessor</code> 或 <code>ConsumerAwareRebalanceListener</code> bean,它会自动关联到默认工厂.</p>
<p>根据listener类型,将 <code>RecordMessageConverter</code> 或 <code>BatchMessageConverter</code> bean 关联到默认工厂.如果只有<code>RecordMessageConverter</code> bean用于批监听器,则它被包装在 <code>BatchMessageConverter</code> 中.</p>
<blockquote>
<p>建议:</p>
<p>​    自定义 <code>ChainedKafkaTransactionManager</code> 必须标记为 <code>@Primary</code>,因为它通常引用自动配置的 <code>KafkaTransactionManager</code> bean.</p>
</blockquote>
</li>
<li><h6 id="Kafka-Streams"><a href="#Kafka-Streams" class="headerlink" title="Kafka Streams"></a>Kafka Streams</h6><p>Spring for Apache Kafka 提供了一个工厂 bean 来创建一个 <code>StreamsBuilder</code> 对象并管理流的生命周期.只要 <code>kafka-streams</code> 在classpath上并且使用 <code>@EnableKafkaStreams</code> 注解启用了 <code>Kafka Streams</code>,Spring Boot 就会自动配置所需的 <code>KafkaStreamsConfiguration</code> bean.</p>
<p>启用 Kafka Streams 意味着必须设置应用程序 ID 和引导服务器.前者可以使用 <code>spring.kafka.streams.application-id</code> 配置,如果没有设置默认为 <code>spring.application.name</code>. 后者可以全局设置或仅针对流专门覆盖.</p>
<p>使用专用属性可以使用多个附加属性.可以使用 <code>spring.kafka.streams.properties</code> 命名空间设置其他任意 Kafka 属性.另参阅其他 Kafka 属性以获取更多信息.(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.messaging.kafka.additional-properties">Additional Kafka Properties</a>).</p>
<p>要使用工厂 bean,将 <code>StreamsBuilder</code> 连接到 <code>@Bean</code> 中,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableKafkaStreams</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKafkaStreamsConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KStream&lt;Integer, String&gt; <span class="title">kStream</span><span class="params">(StreamsBuilder streamsBuilder)</span> </span>{</span><br><span class="line">        KStream&lt;Integer, String&gt; stream = streamsBuilder.stream(<span class="string">"ks1In"</span>);</span><br><span class="line">        stream.map(<span class="keyword">this</span>::uppercaseValue).to(<span class="string">"ks1Out"</span>, Produced.with(Serdes.Integer(), <span class="keyword">new</span> JsonSerde&lt;&gt;()));</span><br><span class="line">        <span class="keyword">return</span> stream;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> KeyValue&lt;Integer, String&gt; <span class="title">uppercaseValue</span><span class="params">(Integer key, String value)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyValue&lt;&gt;(key, value.toUpperCase());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下,由 <code>StreamBuilder</code> 对象管理的流会自动启动.可以使用 <code>spring.kafka.streams.auto-startup</code> 属性自定义此行为.</p>
</li>
<li><h6 id="其他-Kafka-属性-Additional-Kafka-Properties"><a href="#其他-Kafka-属性-Additional-Kafka-Properties" class="headerlink" title="其他 Kafka 属性 (Additional Kafka Properties)"></a>其他 Kafka 属性 (Additional Kafka Properties)</h6><p>自动配置支持的属性显示在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/application-properties.html#application-properties">application-properties.html</a> 中. 注意,在大多数情况下,这些属性(连字符或驼峰命名)直接映射到 Apache Kafka 虚线属性.有关详细信息,请参阅 Apache Kafka 文档.</p>
<p>这些属性中的前几个适用于所有组件(生产者,消费者,管理员和流),但如果希望使用不同的值,可以在组件级别指定.Apache Kafka 指定使用高,中或低重要性来指定属性.Spring Boot 自动配置支持所有 HIGH 重要性属性,一些特定的 MEDIUM 和 LOW 属性,以及任何没有默认值的属性.</p>
<p>只有 Kafka 支持属性的一个子集可以直接通过 <code>KafkaProperties</code> 类获得.如果希望使用那些没有直接支持的其他属性,来配置生产者或消费者,使用以下属性:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.properties[prop.one]</span>=<span class="string">first</span></span><br><span class="line"><span class="meta">spring.kafka.admin.properties[prop.two]</span>=<span class="string">second</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties[prop.three]</span>=<span class="string">third</span></span><br><span class="line"><span class="meta">spring.kafka.producer.properties[prop.four]</span>=<span class="string">fourth</span></span><br><span class="line"><span class="meta">spring.kafka.streams.properties[prop.five]</span>=<span class="string">fifth</span></span><br></pre></td></tr></tbody></table></figure>

<p>这将共通的 <code>prop.one</code> Kafka 属性设置为 <code>first</code>(适用于生产者,消费者和管理员),<code>prop.two admin</code> 属性设置为<code>second</code>,<code>prop.three</code>消费者属性设置为<code>third</code>,<code>prop.four</code> 生产者属性设置为<code>prop.four</code>和 <code>prop .five</code> 流属性为<code>fifth</code>.</p>
<p>还可以按如下方式配置 Spring Kafka <code>JsonDeserializer</code>:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.consumer.value-deserializer</span>=<span class="string">org.springframework.kafka.support.serializer.JsonDeserializer</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties[spring.json.value.default.type]</span>=<span class="string">com.example.Invoice</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties[spring.json.trusted.packages]</span>=<span class="string">com.example.main,com.example.another</span></span><br></pre></td></tr></tbody></table></figure>

<p>同样,可以禁用在header中发送类型信息的 <code>JsonSerializer</code> 默认行为:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.producer.value-serializer</span>=<span class="string">org.springframework.kafka.support.serializer.JsonSerializer</span></span><br><span class="line"><span class="meta">spring.kafka.producer.properties[spring.json.add.type.headers]</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>重要:</p>
<p>​    以这种方式设置的属性会覆盖 Spring Boot 显示支持的任何配置.</p>
</blockquote>
</li>
<li><h6 id="使用嵌入式-Kafka-进行测试-Testing-with-Embedded-Kafka"><a href="#使用嵌入式-Kafka-进行测试-Testing-with-Embedded-Kafka" class="headerlink" title="使用嵌入式 Kafka 进行测试 (Testing with Embedded Kafka)"></a>使用嵌入式 Kafka 进行测试 (Testing with Embedded Kafka)</h6><p>Spring 为 Apache Kafka 提供了一种使用嵌入式 Apache Kafka broker测试项目的便捷方法.要使用此功能,请使用 <code>spring-kafka-test</code> 模块中的 <code>@EmbeddedKafka</code> 注解来测试类.有关更多信息,请参阅 Spring for Apache Kafka 参考手册(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-kafka/docs/2.7.1/reference/html/#embedded-kafka-annotation">reference manual</a>).</p>
<p>要使 Spring Boot 自动配置与上述嵌入式 Apache Kafka broker一起工作,需要将嵌入式broker地址(由 <code>EmbeddedKafkaBroker</code> 填充)的系统属性重新映射到  Spring Boot为 Apache Kafka 设置的配置属性中.有几种方法可以做到这一点:</p>
<ul>
<li><p>提供一个系统属性将嵌入的broker地址映射到测试类中的 <code>spring.kafka.bootstrap-servers</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, <span class="string">"spring.kafka.bootstrap-servers"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在<code>@EmbeddedKafka</code> 注解上配置属性名:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@EmbeddedKafka(topics = "someTopic", bootstrapServersProperty = "spring.kafka.bootstrap-servers")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在配置属性中使用占位符:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>=<span class="string">${spring.embedded.kafka.brokers}</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/54951.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/54951.html" class="post-title-link" itemprop="url">3.13 Feature: 缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 12:45:00" itemprop="dateCreated datePublished" datetime="2021-06-04T12:45:00+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:57:06" itemprop="dateModified" datetime="2021-06-10T12:57:06+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/54951.html" class="post-meta-item leancloud_visitors" data-flag-title="3.13 Feature: 缓存" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="13-缓存-Caching"><a href="#13-缓存-Caching" class="headerlink" title="13 缓存(Caching)"></a>13 缓存(Caching)</h5><ol start="13">
<li><h5 id="缓存-Caching"><a href="#缓存-Caching" class="headerlink" title="缓存(Caching)"></a>缓存(Caching)</h5><p>Spring Framework 支持透明地向应用程序添加缓存. 在其核心,抽象上,对方法使用缓存,从而根据缓存中可用的信息,减少执行次数.缓存逻辑是透明化应用的,对调用者没有任何干扰. 只要通过<code>@EnableCaching</code> 注释启用缓存支持,Spring Boot 就会自动配置缓存基础结构.</p>
<blockquote>
<p>注意:</p>
<p>​    查看 Spring Framework 参考的相关部分(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#cache">relevant section</a>)以获取更多详细信息.</p>
</blockquote>
<p>简而言之,要将缓存添加到服务的操作中,在其方法中添加相关的注解,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMathService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable("piDecimals")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computePiDecimal</span><span class="params">(<span class="keyword">int</span> precision)</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此示例演示了对潜在代价高昂的操作使用缓存.在调用 <code>computePiDecimal</code> 之前,抽象会在 <code>piDecimals</code> 缓存中查找与 <code>i</code> 参数匹配的条目. 如果找到一个条目,缓存中的内容会立即返回给调用者,并且不会调用该方法. 否则,调用该方法,并在返回值之前更新缓存.</p>
<blockquote>
<p>警告:</p>
<p>​    还可以透明地使用标准 JSR-107 (JCache) 注释(例如 <code>@CacheResult</code>). 但是,强烈建议不要混合搭配 Spring Cache 和 JCache 注释.</p>
</blockquote>
<p>如果不添加任何特定的缓存库,Spring Boot 会自动配置一个在内存中使用concurrent  Map的简单provider.当需要缓存时(例如前面示例中的 <code>piDecimals</code>),provider会创建它.不建议将 simple provider 用于生产用途,但它非常适合入门并帮助了解这些功能.当决定要使用的缓存provider时,务必阅读其文档以了解如何配置应用所用的缓存.几乎所有provider都要求在应用中显式配置使用的每个缓存. 有些提供了一种自定义由 <code>spring.cache.cache-names</code> 属性定义的默认缓存的方法.  </p>
<blockquote>
<p>建议:</p>
<p>​    还可以从缓存中透明地更新或驱逐数据(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#cache-annotations-put">update</a> or <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#cache-annotations-evict">evict</a>).</p>
</blockquote>
<ol>
<li><h6 id="支持的缓存Provider-Supported-Cache-Providers"><a href="#支持的缓存Provider-Supported-Cache-Providers" class="headerlink" title="支持的缓存Provider(Supported Cache Providers)"></a>支持的缓存Provider(Supported Cache Providers)</h6><p>缓存抽象不提供实际存储,并且依赖于 <code>org.springframework.cache.Cache</code> 和 <code>org.springframework.cache.CacheManager</code> 接口具体化的抽象.</p>
<p>如果尚未定义 <code>CacheManager</code> 类型的 bean 或名为 <code>cacheResolver</code> 的 <code>CacheResolver</code>(参阅 <code>CachingConfigurer</code>),Spring Boot 会尝试检测以下提供程序(按指示的顺序):</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.generic">Generic</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.jcache">JCache (JSR-107)</a> (EhCache 3, Hazelcast, Infinispan, 和其他)</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.ehcache2">EhCache 2.x</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.hazelcast">Hazelcast</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.infinispan">Infinispan</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.couchbase">Couchbase</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.redis">Redis</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.caffeine">Caffeine</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.simple">Simple</a></li>
</ol>
<blockquote>
<p>建议:</p>
<p>​    也可以通过设置 <code>spring.cache.type</code> 属性来<strong>强制</strong>特定的cache provider.如果需要在某些环境(例如测试)中完全禁用缓存(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.none">disable caching altogether</a>),请使用此属性.</p>
<p>建议:</p>
<p>​    使用 <code>spring-boot-starter-cache</code> “Starter” 快速添加基本缓存依赖.starter 引入了 <code>spring-context-support</code>.如果手动添加依赖项,则必须包含 <code>spring-context-support</code> 才能使用 JCache,EhCache 2.x 或 Caffeine 支持.</p>
</blockquote>
<p>如果 <code>CacheManager</code> 是由 Spring Boot 自动配置的,可以在它完全初始化之前通过公开实现 <code>CacheManagerCustomizer</code> 接口的 bean 进一步调整其配置.以下示例设置了一个标志,表示应将<code>null</code>传递给底层映射:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheManagerConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (cacheManager) -&gt; cacheManager.setAllowNullValues(<span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    在前面的示例中,需要一个自动配置的 <code>ConcurrentMapCacheManager</code>. 如果不是这种情况(提供了自己的配置或自动配置了不同的缓存provider),则根本不会调用自定义程序. 可以根据需要,使用任意数量的customizers,也可以使用 <code>@Order</code> 或 <code>Ordered</code> 对它们进行排序.</p>
</blockquote>
<ol>
<li><h6 id="通用-Generic"><a href="#通用-Generic" class="headerlink" title="通用(Generic)"></a>通用(Generic)</h6><p>如果上下文<em><strong>至少</strong></em>定义了一个 <code>org.springframework.cache.Cache</code> bean,则使用通用缓存.创建了一个包装所有该类型 bean 的 <code>CacheManager</code>.</p>
</li>
<li><h6 id="JCache-JSR-107"><a href="#JCache-JSR-107" class="headerlink" title="JCache (JSR-107)"></a>JCache (JSR-107)</h6><p>JCache 通过classpath存在的 <code>javax.cache.spi.CachingProvider</code> 进行引导(即classpath上存在符合 JSR-107 的缓存库),而 <code>JCacheCacheManager</code> 由 <code>spring-boot-starter-cache</code> 提供 “Starter”.各种兼容库都可用,Spring Boot 为 Ehcache3,Hazelcast 和 Infinispan 提供依赖管理.也可以添加任何其他兼容的库.</p>
<p>可能会出现多个provider,在这种情况下,必须显式指定provider.即使 JSR-107 标准没有强制使用标准化的方式来指定配置文件的位置,Spring Boot 也会尽量设置缓存和实现细节,如下面的例子所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Only necessary if more than one provider is present</span></span><br><span class="line"><span class="meta">spring.cache.jcache.provider</span>=<span class="string">com.example.MyCachingProvider</span></span><br><span class="line"><span class="meta">spring.cache.jcache.config</span>=<span class="string">classpath:example.xml</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    当缓存库同时提供本地实现和 JSR-107支持时,Spring Boot 首选JSR-107 支持,以便在切换到不同的 JSR-107 实现时可以使用相同的功能.</p>
<p>建议:</p>
<p>​    Spring Boot 支持 Hazelcast.如果有一个<code>HazelcastInstance</code>可用,则它也会自动为 <code>CacheManager</code> 重用,除非指定了<code>spring.cache.jcache.config</code>属性</p>
</blockquote>
<p>有两种方式来自定义底层的<code>javax.cache.cacheManager</code>:</p>
<ul>
<li>可以通过设置 <code>spring.cache.cache-names</code> 属性在启动时创建缓存. 如果自定义了<code>javax.cache.configuration.Configuration</code> bean,则用于自定义属性.</li>
<li>使用 <code>CacheManager</code>的引用来调用<code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> bean 从而进行完全自定义.</li>
</ul>
<blockquote>
<p>建议:</p>
<p>​    如果定义了标准 <code>javax.cache.CacheManager</code> bean,会在<code>org.springframework.cache.CacheManager</code>实现(抽象所期望的)中自动包装,. 不会对其应用进一步的自定义.</p>
</blockquote>
</li>
<li><h6 id="EhCache-2-x"><a href="#EhCache-2-x" class="headerlink" title="EhCache 2.x"></a>EhCache 2.x</h6><p>如果可以在classpath的根目录找到名为<code>ehcache.xml</code>的文件,则使用 EhCache 2.x. 如果找到 EhCache 2.x,则使用 <code>spring-boot-starter-cache</code> “Starter” 提供的 <code>EhCacheCacheManager</code> 来引导缓存管理器.也可以提供备用配置文件,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.ehcache.config</span>=<span class="string">classpath:config/another-config.xml</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h6><p>Spring Boot 支持 Hazelcast. 如果 <code>HazelcastInstance</code> 已自动配置,则它会自动包装在 <code>CacheManager</code> 中.</p>
</li>
<li><h6 id="Infinispan"><a href="#Infinispan" class="headerlink" title="Infinispan"></a>Infinispan</h6><p>Infinispan 没有默认配置文件位置,因此必须显式指定. 否则,使用默认引导程序:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.infinispan.config</span>=<span class="string">infinispan.xml</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存.如果自定义了 <code>ConfigurationBuilder</code> bean,它将用于自定义缓存.</p>
<blockquote>
<p>建议:</p>
<p>​    Spring Boot 对 Infinispan 的支持仅限于嵌入式模式,并且非常基础.如果想要更多的选择,应该使用官方的 Infinispan Spring Boot starter. 有关更多详细信息,请参阅 Infinispan(<a target="_blank" rel="noopener" href="https://github.com/infinispan/infinispan-spring-boot">Infinispan’s documentation</a>) 的文档.</p>
</blockquote>
</li>
<li><h6 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h6><p>如果 Spring Data Couchbase 可用并且配置了 Couchbase,则<code>CouchbaseCacheManager</code>会自动配置.可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建额外的缓存,并且可以使用 <code>spring.cache.couchbase.*</code> 属性配置缓存默认值.例如,以下配置创建 <code>cache1</code> 和 <code>cache2</code> 缓存,条目过期时间为 10 分钟:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="meta">spring.cache.couchbase.expiration</span>=<span class="string">10m</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果需要对配置进行更多控制,请考虑注册 <code>CouchbaseCacheManagerBuilderCustomizer</code> bean.以下示例显示了为 <code>cache1</code> 和 <code>cache2</code> 配置特定条目到期时间的customizer:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCouchbaseCacheManagerConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CouchbaseCacheManagerBuilderCustomizer <span class="title">myCouchbaseCacheManagerBuilderCustomizer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (builder) -&gt; builder</span><br><span class="line">                .withCacheConfiguration(<span class="string">"cache1"</span>, CouchbaseCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryExpiry(Duration.ofSeconds(<span class="number">10</span>)))</span><br><span class="line">                .withCacheConfiguration(<span class="string">"cache2"</span>, CouchbaseCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryExpiry(Duration.ofMinutes(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><p>如果 Redis 可用并已配置,则自动配置 <code>RedisCacheManager</code>. 如果想要在启动时添加额外缓存, 可以设置<code>spring.cache.cache-names</code>属性,并且可以使用 <code>spring.cache.redis.*</code> 属性配置缓存默认值.例如,以下配置创建 <code>cache1</code> 和 <code>cache2</code> 缓存,生存时间为 10 分钟:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="meta">spring.cache.redis.time-to-live</span>=<span class="string">10m</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    默认情况下,添加了一个key前缀,这样,如果两个单独的缓存使用相同的key,Redis 不会有重叠的键,也不会返回无效值.如果创建自己的 <code>RedisCacheManager</code>,我们强烈建议您启用此设置.</p>
<p>建议:</p>
<p>​    可以通过添加自己的 <code>RedisCacheConfiguration</code> <code>@Bean</code> 来完全控制默认配置.如果自定义默认序列化策略,这会很有.</p>
</blockquote>
<p>如果需要对配置进行更多控制,可以考虑注册一个 <code>RedisCacheManagerBuilderCustomizer</code> bean.以下示例显示了为 <code>cache1</code> 和 <code>cache2</code> 配置特定生存时间的customizer:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisCacheManagerConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManagerBuilderCustomizer <span class="title">myRedisCacheManagerBuilderCustomizer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (builder) -&gt; builder</span><br><span class="line">                .withCacheConfiguration(<span class="string">"cache1"</span>, RedisCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryTtl(Duration.ofSeconds(<span class="number">10</span>)))</span><br><span class="line">                .withCacheConfiguration(<span class="string">"cache2"</span>, RedisCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryTtl(Duration.ofMinutes(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h6><p>Caffeine 是对 Guava 缓存的 Java 8 重写,取代了对 Guava 的支持.如果存在 Caffeine,则会自动配置 <code>CaffeineCacheManager</code>(由 <code>spring-boot-starter-cache</code> “Starter”提供). 可以通过设置 <code>spring.cache.cache-names</code> 属性, 在启动时创建缓存,并且可以通过以下之一(按指示的顺序)进行自定义:</p>
<ol>
<li>使用 <code>spring.cache.caffeine.spec</code> 定义的缓存规范</li>
<li>定义 <code>com.github.benmanes.caffeine.cache.CaffeineSpec</code> bean</li>
<li>定义 <code>com.github.benmanes.caffeine.cache.Caffeine</code> bean</li>
</ol>
<p>例如,以下配置创建 <code>cache1</code> 和 <code>cache2</code> 缓存,最大大小为 500,生存时间为 10 分钟:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="meta">spring.cache.caffeine.spec</span>=<span class="string">maximumSize=500,expireAfterAccess=600s</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果定义了 <code>com.github.benmanes.caffeine.cache.CacheLoader</code> bean,它会自动关联到 <code>CaffeineCacheManager</code>. 由于 <code>CacheLoader</code> 将与缓存管理器管理的<em><strong>所有</strong></em>缓存相关联,因此必须将其定义为 <code>CacheLoader&lt;Object, Object&gt;</code>. 自动配置忽略任何其他通用类型.</p>
</li>
<li><h6 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h6><p>如果找不到其他providers,则指定 <code>ConcurrentHashMap</code> 作为缓存存储.如果应用程序中不存在缓存库,则这是默认设置.默认情况下,会根据需要创建缓存,但可以通过设置 <code>cache-names</code> 属性来限制可用缓存的列表.例如,如果只想要 <code>cache1</code> 和 <code>cache2</code> 缓存,设置 <code>cache-names</code> 属性如下:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果这样做,并且应用使用了未列出的缓存,那么在使用缓存而缓存不存在时,会运行时失败,但不会在启动时失败.如果使用未声明的缓存,这类似于”真实”缓存providers的行为方式.</p>
</li>
<li><h6 id="None"><a href="#None" class="headerlink" title="None"></a>None</h6><p>当配置中存在 <code>@EnableCaching</code> 时,也需要合适的缓存配置.如果需要在某些环境中完全禁用缓存,可以将缓存类型强制为 <code>none</code> 以使用无操作实现,如下例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.type</span>=<span class="string">none</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/11539.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/11539.html" class="post-title-link" itemprop="url">3.12 Featue: NoSQL技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-04 12:26:57" itemprop="dateCreated datePublished" datetime="2021-06-04T12:26:57+08:00">2021-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:57:31" itemprop="dateModified" datetime="2021-06-10T12:57:31+08:00">2021-06-10</time>
      </span>

  
    <span id="/posts/11539.html" class="post-meta-item leancloud_visitors" data-flag-title="3.12 Featue: NoSQL技术" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="使用NoSQL技术-Working-with-NoSQL-Technologies"><a href="#使用NoSQL技术-Working-with-NoSQL-Technologies" class="headerlink" title="使用NoSQL技术( Working with NoSQL Technologies)"></a>使用NoSQL技术( Working with NoSQL Technologies)</h5><p>Spring Data提供了其他项目来帮助访问各种NoSQL 技术,包括:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-mongodb">MongoDB</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-neo4j">Neo4J</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-elasticsearch">Elasticsearch</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">Redis</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-gemfire">GemFire</a> 或者 <a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-geode">Geode</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-cassandra">Cassandra</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-couchbase">Couchbase</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-ldap">LDAP</a><br>Spring Boot为Redis,MongoDB,Neo4j,Solr,Elasticsearch,Cassandra,Couchbase,LDAP 和 InfluxDB 提供自动配置. 可以使用其他NoSQL项目,但必须自己配置它们.请参阅<code>spring.io/projects/spring-data</code>中的相应参考文档.</li>
</ul>
<ol>
<li><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><p>Redis 是一个缓存,消息代理和功能丰富的键值存储. Spring Boot 为 Lettuce 和 Jedis 客户端库以及由Spring Data Redis 提供的在他们之上的抽象提供了基本的自动配置.<br>有一个<code>spring-boot-starter-data-redis</code> “Starter” 可以方便地配置各个依赖项.默认情况下,使用<a target="_blank" rel="noopener" href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>. 该启动器处理传统和反应式应用程序.</p>
<blockquote>
<p>建议:</p>
<p>​    Spring Boot还提供了一个<code>spring-boot-starter-data-redis-reactive</code> “Starter”,用来和其他的具有响应式支持的存储保持一致.</p>
</blockquote>
<ol>
<li><h6 id="连接Redis-Connecting-to-Redis"><a href="#连接Redis-Connecting-to-Redis" class="headerlink" title="连接Redis(Connecting to Redis)"></a>连接Redis(Connecting to Redis)</h6>可以像注入任何其他Spring Bean一样注入自动配置的<code>RedisConnectionFactory</code>,<code>StringRedisTemplate</code>或 vanilla <code>RedisTemplate</code>实例.默认情况下,实例会尝试连接到<code>localhost:6379</code>的 Redis 服务器. 以下列表显示了此类 bean 的示例:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(StringRedisTemplate template)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.template = template;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>建议:</p>
<p>​    可以注册任意数量的,实现<code>LettuceClientConfigurationBuilderCustomizer </code>的bean来实现更高级的自定义.如果使用 Jedis,<code>JedisClientConfigurationBuilderCustomizer</code>也是可用的.<br>如果添加自己的任何自动配置类型的<code>@Bean</code>,它将替换默认值(<code>RedisTemplate</code>除外,当排除基于bean名称,<code>redisTemplate</code>而不是其类型时).默认情况下,如果 <code>commons-pool2</code>在类路径上,将获得一个池化连接工厂.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h6><p>MongoDB是一个开源的NoSQL文档数据库,它使用类似 JSON 的模式而不是传统的基于表的关系数据.Spring Boot为使用MongoDB提供了多种便利,包括<code>spring-boot-starter-data-mongodb</code>和<code>spring-boot-starter-data-mongodb-reactive</code> “Starters”.</p>
<ol>
<li><h6 id="连接到MongoDB-Connecting-to-a-MongoDB-Database"><a href="#连接到MongoDB-Connecting-to-a-MongoDB-Database" class="headerlink" title="连接到MongoDB(Connecting to a MongoDB Database)"></a>连接到MongoDB(Connecting to a MongoDB Database)</h6>要访问MongoDB数据库,可以注入自动配置的<code>org.springframework.data.mongodb.MongoDatabaseFactory</code>.默认情况下,实例会尝试连接到<code>mongodb://localhost/test</code>的MongoDB服务器.以下示例显示了如何连接到MongoDB数据库:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> MongoDatabaseFactory mongo;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoDatabaseFactory mongo)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.mongo = mongo;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
如果定义了<code>MongoClient</code>,它将用于合适的 <code>MongoDatabaseFactory</code>进行自动配置.<br>自动配置的<code>MongoClient</code>,是使用<code>MongoClientSettings</code>bean.如果定义了自己的<code>MongoClientSettings</code>,则无需修改即可使用,<code>spring.data.mongodb</code>属性会被自动忽略.否则<code>MongoClientSettings</code>将被自动配置,并将应用 <code>spring.data.mongodb</code>属性.在任一情况下,都可以声明一个或多个 <code>MongoClientSettingsBuilderCustomizer</code>bean来调整<code>MongoClientSettings</code>配置.每个都会被<code>MongoClientSettings.Builder</code>按顺序调用,<code>MongoClientSettings.Builder</code>是用来构建<code>MongoClientSettings</code>的.<br>您可以设置<code>spring.data.mongodb.uri</code>属性来更改URL并配置其他设置,例如<em>replica set</em>,如以下示例所示:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.data.mongodb.uri</span>=<span class="string">mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test</span></span><br></pre></td></tr></tbody></table></figure>
或者,您可以使用离散属性指定连接详细信息. 例如,您可以在 <code>application.properties</code>中声明以下设置:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.data.mongodb.host</span>=<span class="string">mongoserver.example.com</span></span><br><span class="line"><span class="meta">spring.data.mongodb.port</span>=<span class="string">27017</span></span><br><span class="line"><span class="meta">spring.data.mongodb.database</span>=<span class="string">test</span></span><br><span class="line"><span class="meta">spring.data.mongodb.username</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.data.mongodb.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>建议:</p>
<p>​    如果没有指定<code>spring.data.mongodb.port</code>,则使用默认值 <code>27017</code>. 可以从前面显示的示例中删除此行.</p>
<p>建议:</p>
<p>​    如果不使用Spring Data MongoDB,则可以注入<code>MongoClient</code> bean 而不是使用<code>MongoDatabaseFactory</code>.如果想完全控制MongoDB的连接建立,可以声明自己的<code>MongoDatabaseFactory</code>或<code>MongoClient</code>bean.</p>
<p>注意:</p>
<p>​    如果您使用的是响应式驱动程序,则SSL需要 Netty.如果 Netty 可用并且要使用的工厂尚未被自定义,则自动配置会自动配置此工厂.</p>
</blockquote>
</li>
<li><h6 id="MongoTemplate"><a href="#MongoTemplate" class="headerlink" title="MongoTemplate"></a>MongoTemplate</h6>Spring Data MongoDB提供了一个<code>MongoTemplate</code>类,它的设计与 Spring 的<code>JdbcTemplate</code>非常相似.和<code>JdbcTemplate</code>一样,Spring Boot自动配置了一个 bean供开发者注入模板,如下<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoTemplate mongoTemplate)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.mongoTemplate = mongoTemplate;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Spring-Data-MongoDB-Repositories"><a href="#Spring-Data-MongoDB-Repositories" class="headerlink" title="Spring Data MongoDB Repositories"></a>Spring Data MongoDB Repositories</h6>Spring Data 包括对 MongoDB 的存储库支持.与前面讨论的 JPA 存储库一样,基本理念是根据方法名称自动构造查询.<br>事实上,Spring Data JPA 和 Spring Data MongoDB 共享同样的公共基础架构.可以使用JPA示例,并假设<code>City</code>现在是MongoDB数据类,而不是JPA <code>@Entity</code>,它的工作方式相同,如以下示例所示:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line"> <span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    您可以使用<code>@EntityScan</code>注解自定义文档扫描位置.</p>
<p>建议:</p>
<p>​    有关 Spring Data MongoDB 的完整详细信息,包括其丰富的对象映射技术,请参阅其<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-mongodb">reference documentation</a>.</p>
</blockquote>
</li>
<li><h6 id="嵌入式Mongo"><a href="#嵌入式Mongo" class="headerlink" title="嵌入式Mongo"></a>嵌入式Mongo</h6>Spring Boot 为嵌入式 Mongo 提供了自动配置. 要在 Spring Boot 应用程序中使用它,请添加 <code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code> 依赖<br>可以通过设置<code>spring.data.mongodb.port</code>属性来配置 Mongo 监听端口.要使用随机分配的空闲端口,请使用值 0. <code>MongoAutoConfiguration</code>创建的<code>MongoClient</code>使用随机分配的端口进行自动配置.<blockquote>
<p>注意:</p>
<p>​    如果不配置自定义端口,嵌入式Mongo支持默认使用随机端口(而不是 27017).<br>如果类路径上有 SLF4J,Mongo 生成的输出会自动路由到名为 <code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code> 的logger上.<br>可以声明自己的<code>IMongodConfig</code>和<code>IRuntimeConfig</code> bean 来配置Mongo实例和日志路由.可以通过<code>DownloadConfigBuilderCustomizer</code>bean来自定义下载配置.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h6><p>Neo4j 是一个开源的 NoSQL 图数据库,它由first class relationships连接的,具有丰富数据模型,比传统的 RDBMS方案更适合连接大数据. Spring Boot 为使用 Neo4j 提供了多种便利,包括 <code>spring-boot-starter-data-neo4j</code> “Starter”.</p>
<ol>
<li><h6 id="连接到Neo4j数据库-Connecting-to-a-Neo4j-Database"><a href="#连接到Neo4j数据库-Connecting-to-a-Neo4j-Database" class="headerlink" title="连接到Neo4j数据库(Connecting to a Neo4j Database)"></a>连接到Neo4j数据库(Connecting to a Neo4j Database)</h6>要访问 Neo4j 服务器,可以注入一个自动配置的 <code>org.neo4j.driver.Driver</code>.默认情况下,实例尝试使用 Bolt 协议连接到 <code>localhost:7687</code> 的 Neo4j 服务器.以下示例显示了如何注入 Neo4j 驱动程序,该驱动程序可让访问 <code>Session</code>:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Driver driver;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(Driver driver)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.driver = driver;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
可以使用<code>spring.neo4j.*</code>属性配置驱动程序的各个部分. 以下示例显示了如何配置uri和凭据:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.neo4j.uri</span>=<span class="string">bolt://my-server:7687</span></span><br><span class="line"><span class="meta">spring.neo4j.authentication.username</span>=<span class="string">neo4j</span></span><br><span class="line"><span class="meta">spring.neo4j.authentication.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>
自动配置的驱动是使用<code>ConfigBuilder</code>来创建的.要调整配置,应该要声明一个或多个 <code>ConfigBuilderCustomizer</code>bean.每个将按顺序调用被<code>ConfigBuilder</code>调用,<code>ConfigBuilder</code>是用于构建驱动程序的 .</li>
<li><h6 id="Spring-Data-Neo4j-Repositories"><a href="#Spring-Data-Neo4j-Repositories" class="headerlink" title="Spring Data Neo4j Repositories"></a>Spring Data Neo4j Repositories</h6>Spring Data 包括对 Neo4j 的存储库支持. 有关 Spring Data Neo4j 的完整详细信息,请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/neo4j/docs/6.1.1/reference/html/">参考文档</a>.<br>就像许多其他 Spring Data 模块一样,Spring Data Neo4j 与 Spring Data JPA 共享公共基础设施.可以采用前面的 JPA 示例,并将<code>City</code>定义为 Spring Data Neo4j <code>@Node</code> 而不是 JPA <code>@Entity</code>,并且存储库抽象以相同的方式工作,如下面的示例所示:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Neo4jRepository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line"> <span class="function">Optional&lt;City&gt; <span class="title">findOneByNameAndState</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<code>spring-boot-starter-data-neo4j</code> “Starter”开启存储库支持以及事务管理.Spring Boot 支持经典和响应式 Neo4j 存储库,使用 <code>Neo4jTemplate</code> 或 <code>ReactiveNeo4jTemplate</code> bean.当Project Reactor在类路径上可用时,响应式风格也会被自动配置.<br>可以通过在<code>@Configuration</code> bean上使用<code>@EnableNeo4jRepositories</code>和<code>@EntityScan</code>来自定义存储库和实体的路径.<blockquote>
<p>注意:</p>
<p>​    在使用响应式风格的应用程序中,<code>ReactiveTransactionManager</code>不是自动配置的.要启用事务管理,必须在配置中定义以下 bean:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNeo4jConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ReactiveNeo4jTransactionManager <span class="title">reactiveTransactionManager</span><span class="params">(Driver driver,</span></span></span><br><span class="line"><span class="params"><span class="function">         ReactiveDatabaseSelectionProvider databaseNameProvider)</span> </span>{</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ReactiveNeo4jTransactionManager(driver, databaseNameProvider);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">&gt;}</span><br></pre></td></tr></tbody></table></figure></blockquote>
</li>
</ol>
</li>
<li><h6 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h6><p>Apache Solr是一个搜索引擎. Spring Boot 为 Solr 5 客户端库提供基本的自动配置.</p>
<ol>
<li><h6 id="连接到Solr"><a href="#连接到Solr" class="headerlink" title="连接到Solr"></a>连接到Solr</h6>可以像注入任何其他 Spring bean 一样注入自动配置的 <code>SolrClient</code> 实例.默认情况下,实例会尝试连接到位于 localhost:8983/solr 的服务器. 以下示例显示了如何注入 Solr bean:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> SolrClient solr;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(SolrClient solr)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.solr = solr;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
如果添加自己的<code>SolrClient</code>类型的<code>@Bean</code>,它将替换默认值.</li>
</ol>
</li>
<li><h6 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h6><p>Elasticsearch 是一个开源,分布式,RESTful 搜索和分析引擎.Spring Boot 为 Elasticsearch 提供了基本的自动配置.<br>Spring Boot 支持多种客户端:</p>
<ul>
<li>官方 Java”Low Level”和”High Level”REST 客户端</li>
<li>Spring Data Elasticsearch 提供的<code>ReactiveElasticsearchClient</code><br>Spring Boot 提供了一个专用的”Starter”,<code>spring-boot-starter-data-elasticsearch</code></li>
</ul>
<ol>
<li><h6 id="使用-REST-客户端连接到-Elasticsearch-Connecting-to-Elasticsearch-using-REST-clients"><a href="#使用-REST-客户端连接到-Elasticsearch-Connecting-to-Elasticsearch-using-REST-clients" class="headerlink" title="使用 REST 客户端连接到 Elasticsearch(Connecting to Elasticsearch using REST clients)"></a>使用 REST 客户端连接到 Elasticsearch(Connecting to Elasticsearch using REST clients)</h6>Elasticsearch 提供了两个不同的 REST 客户端,您可以使用它们来查询集群:”Low Level”客户端和”High Level”客户端.Spring Boot 提供对”High Level”客户端的支持,该客户端随<code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code>一起提供.<br>如果classpath中存在依赖时,Spring Boot 将自动配置并注册一个 <code>RestHighLevelClient</code> bean,默认情况下该 bean 以<code>localhost:9200</code>为targets.可以进一步调整<code>RestHighLevelClient</code>的配置方式,如下例所示:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.elasticsearch.rest.uris</span>=<span class="string">https://search.example.com:9200</span></span><br><span class="line"><span class="meta">spring.elasticsearch.rest.read-timeout</span>=<span class="string">10s</span></span><br><span class="line"><span class="meta">spring.elasticsearch.rest.username</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.elasticsearch.rest.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>
您还可以注册任意数量实现<code>RestClientBuilderCustomizer</code>的 bean,来进行更高级的自定义.要完全控制注册,请定义一个<code>RestClientBuilder</code> bean.<blockquote>
<p>建议:</p>
<p>​    如果应用程序需要访问”Low Level” <code>RestClient</code>,可以在自动配置的<code>RestHighLevelClient</code>上调用 <code>client.getLowLevelClient()</code> 来获取它.</p>
</blockquote>
另外,如果<code>elasticsearch-rest-client-sniffer</code>在类路径上,则自动配置的<code>Sniffer</code>会从当前正在运行的Elasticsearch集群中自动发现节点并将其设置为<code>RestHighLevelClient</code> Bean.可以进一步调整 <code>Sniffer</code> 的配置方式,如以下示例所示:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.elasticsearch.rest.sniffer.interval</span>=<span class="string">10m</span></span><br><span class="line"><span class="meta">spring.elasticsearch.rest.sniffer.delay-after-failure</span>=<span class="string">30s</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="使用响应式REST客户端连接到Elasticsearch-Connecting-to-Elasticsearch-using-Reactive-REST-clients"><a href="#使用响应式REST客户端连接到Elasticsearch-Connecting-to-Elasticsearch-using-Reactive-REST-clients" class="headerlink" title="使用响应式REST客户端连接到Elasticsearch(Connecting to Elasticsearch using Reactive REST clients)"></a>使用响应式REST客户端连接到Elasticsearch(Connecting to Elasticsearch using Reactive REST clients)</h6>Spring Data Elasticsearch 提供 <code>ReactiveElasticsearchClient</code> 以响应式方式来查询 Elasticsearch 实例.它建立在 WebFlux 的<code>WebClient</code>之上,因此 <code>spring-boot-starter-elasticsearch</code>和<code>spring-boot-starter-webflux</code>依赖项对于启用此支持很有用.<br>默认情况下,Spring Boot 会自动配置并注册一个<code>ReactiveElasticsearchClient</code>  bean,它以 <code>localhost:9200</code> 为目标.可以进一步调整它的配置方式,如以下示例所示:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.data.elasticsearch.client.reactive.endpoints</span>=<span class="string">search.example.com:9200</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.client.reactive.use-ssl</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.client.reactive.socket-timeout</span>=<span class="string">10s</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.client.reactive.username</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.client.reactive.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>
如果提供的配置属性不够,并且想完全控制客户端配置,则可以注册自定义<code>ClientConfiguration</code>bean.</li>
<li><h6 id="使用-Spring-Data-连接到-Elasticsearch-Connecting-to-Elasticsearch-by-Using-Spring-Data"><a href="#使用-Spring-Data-连接到-Elasticsearch-Connecting-to-Elasticsearch-by-Using-Spring-Data" class="headerlink" title="使用 Spring Data 连接到 Elasticsearch(Connecting to Elasticsearch by Using Spring Data)"></a>使用 Spring Data 连接到 Elasticsearch(Connecting to Elasticsearch by Using Spring Data)</h6>要连接到 Elasticsearch,必须定义一个 <code>RestHighLevelClient</code> bean,由 Spring Boot 自动配置或由应用程序手动提供(参见前面的部分).有了这个配置,一个 <code>ElasticsearchRestTemplate</code>可以像任何其他 Spring bean 一样注入,如下面的例子所示:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchRestTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ElasticsearchRestTemplate template)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.template = template;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
当存在<code>spring-data-elasticsearch</code>和使用<code>WebClient</code>(通常是<code>spring-boot-starter-webflux</code>)所需的依赖项的情况下,Spring Boot 还可以将<code>ReactiveElasticsearchClient</code>和<code>ReactiveElasticsearchTemplate</code>自动配置为 bean.它们是与其他REST 客户端相等同的响应式客户端.</li>
<li><h6 id="Spring-Data-Elasticsearch-存储库-Spring-Data-Elasticsearch-Repositories"><a href="#Spring-Data-Elasticsearch-存储库-Spring-Data-Elasticsearch-Repositories" class="headerlink" title="Spring Data Elasticsearch 存储库(Spring Data Elasticsearch Repositories)"></a>Spring Data Elasticsearch 存储库(Spring Data Elasticsearch Repositories)</h6>Spring Data 包括对 Elasticsearch 的存储库支持.与前面讨论的 JPA 存储库一样,基本原则是根据方法名称自动构造查询.<br>实际上,Spring Data JPA 和 Spring Data Elasticsearch 共享相同的公共基础架构.. 可以以前面的JPA示例为例,并假设<code>City</code>现在是Elasticsearch <code>@Document</code>类,而不是JPA <code>@Entity</code>,它的工作方式相同.<blockquote>
<p>建议:</p>
<p>​    有关 Spring Data Elasticsearch 的完整详细信息,请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/">参考文档</a>.</p>
</blockquote>
Spring Boot 支持经典和响应式 Elasticsearch 存储库,使用 <code>ElasticsearchRestTemplate</code> 或 <code>ReactiveElasticsearchTemplate</code> bean.根据存在所需的依赖项,这些bean很由 Spring Boot 自动配置的.<br>如果您希望使用自己的模板来支持 Elasticsearch 存储库,可以添加自己的 <code>ElasticsearchRestTemplate</code>或<code>ElasticsearchOperations</code>@Bean,只要它被命名为<code>"elasticsearchTemplate"</code>. 这个方式同样适用于<code>ReactiveElasticsearchTemplate</code>和<code>ReactiveElasticsearchOperations</code>,bean 名称为<code>"reactiveElasticsearchTemplate"</code>.<br>可以选择使用以下属性禁用存储库支持:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.data.elasticsearch.repositories.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><h6 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h6><p>Cassandra 是一个开源的分布式数据库管理系统,旨在处理跨许多商用服务器的大量数据.Spring Boot 为 Cassandra 和 Spring Data Cassandra 的基于Cassandra 的抽象提供了自动配置.有一个<code>spring-boot-starter-data-cassandra</code> “Starter” 可以方便地收集依赖项.</p>
<ol>
<li><h6 id="连接到Cassandra-Connecting-to-Cassandra"><a href="#连接到Cassandra-Connecting-to-Cassandra" class="headerlink" title="连接到Cassandra(Connecting to Cassandra)"></a>连接到Cassandra(Connecting to Cassandra)</h6>可以像使用任何其他 Spring Bean 一样注入自动配置的<code>CassandraTemplate</code>或Cassandra <code>CqlSession</code> 实例. <code>spring.data.cassandra.*</code>属性可用于自定义连接.<br>通常,提供<code>keyspace-name</code> 和 <code>contact-points</code> 以及本地数据中心名称,如以下示例所示:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.data.cassandra.keyspace-name</span>=<span class="string">mykeyspace</span></span><br><span class="line"><span class="meta">spring.data.cassandra.contact-points</span>=<span class="string">cassandrahost1:9042,cassandrahost2:9042</span></span><br><span class="line"><span class="meta">spring.data.cassandra.local-datacenter</span>=<span class="string">datacenter1</span></span><br></pre></td></tr></tbody></table></figure>
如果所有联系点的端口都相同,则可以使用快捷方式并仅指定主机名,如下例所示:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.data.cassandra.keyspace-name</span>=<span class="string">mykeyspace</span></span><br><span class="line"><span class="meta">spring.data.cassandra.contact-points</span>=<span class="string">cassandrahost1,cassandrahost2</span></span><br><span class="line"><span class="meta">spring.data.cassandra.local-datacenter</span>=<span class="string">datacenter1</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>建议:</p>
<p>​    这两个例子相同,端口默认为<code>9042</code>.如果需要配置端口,使用<code>spring.data.cassandra.port</code>.</p>
<p>建议:</p>
<p>​    Cassandra 驱动程序有自己的配置基础infrastructure,它在classpath的根路径加载一个<code>application.conf</code>.</p>
<p>​    Spring Boot 默认不会查找这样的文件,但可以使用 <code>spring.data.cassandra.config</code> 加载.如果一个属性同时存在于 <code>spring.data.cassandra.*</code> 和配置文件中,则 <code>spring.data.cassandra.*</code> 中的值优先.</p>
<p>​    对于更高级的自定义驱动程序,可以注册任意数量的实现 <code>DriverConfigLoaderBuilderCustomizer</code>的 bean.可以使用类型为 <code>CqlSessionBuilder</code> Customizer 的 bean 自定义 <code>CqlSession</code>.</p>
<p>注意:</p>
<p>​    如果您使用<code>CqlSessionBuilder</code>创建多<code>CqlSession bean</code>,要记住builder是可变的,因此请确保为每个会话注入一个新副本.</p>
</blockquote>
以下代码清单显示了如何注入 Cassandra bean:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> CassandraTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CassandraTemplate template)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.template = template;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
如果添加自己的 <code>CassandraTemplate</code> 类型的 <code>@Bean</code>,它将替换默认值.</li>
<li><h6 id="Spring-Data-Cassandra-Repositories"><a href="#Spring-Data-Cassandra-Repositories" class="headerlink" title="Spring Data Cassandra Repositories"></a>Spring Data Cassandra Repositories</h6>Spring Data 包括对 Cassandra 的基本存储库支持.目前,这比前面讨论的 JPA 存储库更受限制,需要使用<code>@Query</code>注释查找器方法.<blockquote>
<p>建议:</p>
<p>​    有关 Spring Data Cassandra 的完整详细信息,请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/cassandra/docs/">reference documentation</a>.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h6><p>Couchbase 是一个开源,分布式,多模型 NoSQL 面向文档的数据库,针对交互式应用程序进行了优化.Spring Boot 为 Couchbase 和 Spring Data Couchbase 提供的抽象提供了自动配置.有 <code>spring-boot-starter-data-couchbase</code>和<code>spring-boot-starter-data-couchbase-reactive</code>“Starters” 可以很方便地添加依赖.</p>
<ol>
<li><h6 id="连接到Couchbase-Connecting-to-Couchbase"><a href="#连接到Couchbase-Connecting-to-Couchbase" class="headerlink" title="连接到Couchbase(Connecting to Couchbase)"></a>连接到Couchbase(Connecting to Couchbase)</h6>你可以通过添加 Couchbase SDK 和一些配置来获得一个<code>Cluster</code>.<code>spring.couchbase.*</code>属性可以用来自定义连接.通常来说,连接字符串,用户名和密码,会如下例所示提供:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.couchbase.connection-string</span>=<span class="string">couchbase://192.168.1.123</span></span><br><span class="line"><span class="meta">spring.couchbase.username</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.couchbase.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>
也可以自定义一些 <code>ClusterEnvironment</code> 设置.例如,以下配置更改用于打开新<code>Bucket</code>的超时并启用 SSL 支持:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.couchbase.env.timeouts.connect</span>=<span class="string">3s</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.key-store</span>=<span class="string">/location/of/keystore.jks</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.key-store-password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>建议:</p>
<p>​    检查 <code>spring.couchbase.env.*</code> 属性以获取更多详细信息. 要进行更多控制,可以使用一个或多个<code>ClusterEnvironmentBuilderCustomizer</code> bean.</p>
</blockquote>
</li>
<li><h6 id="Spring-Data-Couchbase-Repositories"><a href="#Spring-Data-Couchbase-Repositories" class="headerlink" title="Spring Data Couchbase Repositories"></a>Spring Data Couchbase Repositories</h6>Spring Data 包括对 Couchbase 的存储库支持. 有关 Spring Data Couchbase 的完整详细信息,请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/couchbase/docs/4.2.1/reference/html/">reference documentation</a>.<br>可以像使用任何其他 Spring Bean一样注入自动配置的 <code>CouchbaseTemplate</code> 实例,前提是 <code>CouchbaseClientFactory</code> bean 可用.当使用集群是可能会发生这种情况,如上所述,并且指定存储桶名称:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.data.couchbase.bucket-name</span>=<span class="string">my-bucket</span></span><br></pre></td></tr></tbody></table></figure>
以下示例显示了如何注入<code>CouchbaseTemplate</code>bean:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> CouchbaseTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CouchbaseTemplate template)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.template = template;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
可以在自己的配置中定义一些 bean 来覆盖自动配置提供的那些 bean:<ul>
<li>名为 <code>couchbaseMappingContext</code> 的 <code>CouchbaseMappingContext</code> <code>@Bean</code></li>
<li>名为 <code>couchbaseCustomConversions</code> 的 <code>CustomConversions</code> <code>@Bean</code></li>
<li>名为 <code>couchbaseTemplate</code> 的 <code>CouchbaseTemplate</code> <code>@Bean</code><br>为了避免在自己的配置中硬编码这些名称,可以重用 Spring Data Couchbase 提供的 <code>BeanNames</code>. 例如,可以自定义要使用的转换器,如下所示:</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCouchbaseConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> CouchbaseCustomConversions <span class="title">myCustomConversions</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CouchbaseCustomConversions(Arrays.asList(<span class="keyword">new</span> MyConverter()));</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><h6 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h6><p>LDAP(轻型目录访问协议)是一种开放的,供应商中立的行业标准应用协议,用于通过 IP 网络访问和维护分布式目录信息服务.Spring Boot 为任何兼容的 LDAP 服务器提供自动配置,并支持来自 UnboundID 的嵌入式内存 LDAP 服务器.<br>LDAP 抽象由 Spring Data LDAP 提供.<code>spring-boot-starter-data-ldap</code> “Starter” 可以很方便地添加依赖项.</p>
<ol>
<li><h6 id="连接到-LDAP-服务器-Connecting-to-an-LDAP-Server"><a href="#连接到-LDAP-服务器-Connecting-to-an-LDAP-Server" class="headerlink" title="连接到 LDAP 服务器 (Connecting to an LDAP Server)"></a>连接到 LDAP 服务器 (Connecting to an LDAP Server)</h6>要连接到 LDAP 服务器,确保声明<code>spring-boot-starter-data-ldap</code> “Starter”或 <code>spring-ldap-core</code>的依赖,然后在 application.properties 中声明服务器的 URL,如下所示 下面的例子:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.ldap.urls</span>=<span class="string">ldap://myserver:1235</span></span><br><span class="line"><span class="meta">spring.ldap.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.ldap.password</span>=<span class="string">secret</span></span><br></pre></td></tr></tbody></table></figure>
如果需要自定义连接设置,可以使用 <code>spring.ldap.base</code> 和 <code>spring.ldap.base-environment</code> 属性.<br><code>LdapContextSource</code>是根据这些设置自动配置的. 如果 <code>DirContextAuthenticationStrategy</code> bean 可用,则它与自动配置的 <code>LdapContextSource</code> 相关联.如果需要自定义它,例如使用 <code>PooledContextSource</code>,仍然可以注入自动配置的 <code>LdapContextSource</code>.确保将自定义的 <code>ContextSource</code> 标记为 <code>@Primary</code>,从而让自动配置的 <code>LdapTemplate</code> 使用.</li>
<li><h6 id="Spring-Data-LDAP-Repositories"><a href="#Spring-Data-LDAP-Repositories" class="headerlink" title="Spring Data LDAP Repositories"></a>Spring Data LDAP Repositories</h6>Spring Data 支持 LDAP 的存储库. 有关 Spring Data LDAP 的完整详细信息,参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/">reference documentation</a>.<br>可以像使用任何其他 Spring Bean 一样注入自动配置的 <code>LdapTemplate</code> 实例,如下例所示:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> LdapTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(LdapTemplate template)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.template = template;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="嵌入式内存-LDAP-服务器-Embedded-In-memory-LDAP-Server"><a href="#嵌入式内存-LDAP-服务器-Embedded-In-memory-LDAP-Server" class="headerlink" title="嵌入式内存 LDAP 服务器(Embedded In-memory LDAP Server)"></a>嵌入式内存 LDAP 服务器(Embedded In-memory LDAP Server)</h6>出于测试目的,Spring Boot 支持从 UnboundID 自动配置内存中的 LDAP 服务器.配置服务器,添加依赖 <code>com.unboundid:unboundid-ldapsdk</code>, 并声明一个 <code>spring.ldap.embedded.base-dn</code> 属性,如下:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.ldap.embedded.base-dn</span>=<span class="string">dc=spring,dc=io</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意:</p>
<p>​    可以定义多个 base-dn 值,但是,由于专有名称通常包含逗号,因此必须使用正确的表示法定义它们.</p>
<p>在yaml文件中,您可以使用yaml列表表示法. 在属性文件中,必须包含索引作为属性名称的一部分:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.ldap.embedded.base-dn[0]</span>=<span class="string">dc=spring,dc=io</span></span><br><span class="line"><span class="meta">spring.ldap.embedded.base-dn[1]</span>=<span class="string">dc=pivotal,dc=io</span></span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下,服务器在随机端口上启动并触发常规 LDAP 支持. 无需指定 <code>spring.ldap.urls</code> 属性.<br>如果classpath上有 <code>schema.ldif</code> 文件,它将用于初始化服务器. 如果要从不同的资源中加载初始化脚本,也可以使用 <code>spring.ldap.embedded.ldif</code> 属性.<br>默认情况下,标准schema被用来验证 <code>LDIF</code> 文件. 可以通过设置 <code>spring.ldap.embedded.validation.enabled</code> 属性来完全关闭验证.如果有自定义属性,可以使用 <code>spring.ldap.embedded.validation.schema</code> 来定义自定义属性类型或对象类.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h6><p>InfluxDB 是一个开源时间序列数据库,针对操作监控,应用程序指标,物联网传感器数据和实时分析等领域的时间序列数据的快速,高可用性存储和检索进行了优化.</p>
<ol>
<li><h6 id="连接到-InfluxDB-Connecting-to-InfluxDB"><a href="#连接到-InfluxDB-Connecting-to-InfluxDB" class="headerlink" title="连接到 InfluxDB(Connecting to InfluxDB)"></a>连接到 InfluxDB(Connecting to InfluxDB)</h6>Spring Boot 会自动配置一个 <code>InfluxDB</code> 实例,前提是 <code>influxdb-java</code> 客户端在classpath上并且设置了数据库的 URL,如下例所示:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.influx.url</span>=<span class="string">https://172.0.0.1:8086</span></span><br></pre></td></tr></tbody></table></figure>
如果连接到 InfluxDB 需要用户和密码,可以相应地设置 <code>spring.influx.user</code> 和 <code>spring.influx.password</code> 属性.<br>InfluxDB 依赖 OkHttp. 如果需要调整 <code>InfluxDB</code> 背后使用的 http 客户端,可以注册一个 <code>InfluxDbOkHttpClientBuilderProvider</code> bean.<br>如果需要对配置进行更多控制,请考虑注册一个 <code>InfluxDbCustomizer</code> bean.</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/58530.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/58530.html" class="post-title-link" itemprop="url">3.11 Feature: 使用SQL数据库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-03 11:23:00" itemprop="dateCreated datePublished" datetime="2021-06-03T11:23:00+08:00">2021-06-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:57:46" itemprop="dateModified" datetime="2021-06-10T12:57:46+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/58530.html" class="post-meta-item leancloud_visitors" data-flag-title="3.11 Feature: 使用SQL数据库" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="使用SQL数据库"><a href="#使用SQL数据库" class="headerlink" title="使用SQL数据库"></a>使用SQL数据库</h5><p>Spring Framework 为使用 SQL 数据库提供了大量支持,从使用 JdbcTemplate 的直接 JDBC 访问到完整的”对象关系映射”技术,如 Hibernate.Spring Data 提供了新级别的个功能功能:直接从接口创建 <code>Repository </code>实现,并根据约定,使用方法名来生成查询.</p>
<ol>
<li><h6 id="配置数据源-Configure-a-DataSource"><a href="#配置数据源-Configure-a-DataSource" class="headerlink" title="配置数据源( Configure a DataSource)"></a>配置数据源( Configure a DataSource)</h6>Java 的<code>javax.sql.DataSource</code>接口提供了可以和数据库建立连接的标准方法. 传统上,”数据源”使用<code>URL</code>和一些凭据来建立数据库连接.<blockquote>
<p>建议:</p>
<p>​    有关更高级的示例,请参阅”<code>How to</code>“部分,通常是为了完全控制数据源的配置.</p>
</blockquote>
<ol>
<li><h6 id="对嵌入式数据库支持-Embedded-Database-Support"><a href="#对嵌入式数据库支持-Embedded-Database-Support" class="headerlink" title="对嵌入式数据库支持(Embedded Database Support)"></a>对嵌入式数据库支持(Embedded Database Support)</h6>使用内嵌内存数据库来开发应用更加方便.显然,内存数据库不提供持久化功能.在应用程序启动时需要填充数据库,并在应用程序结束时丢弃数据.<blockquote>
<p>建议:</p>
<p>​    “<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.data-initialization">section on how to initialize a database</a>“部分包括有关如何初始化数据库的部分.</p>
</blockquote>
Spring Boot支持内嵌的H2,HSQL和Derby数据库的自动配置.无需提供任何连接URL.只需添加嵌入式数据库依赖.如果编译路径内有多个嵌入式数据库,可以使用<code>spring.datasource.embedded-database-connection</code>来指定选择哪一个.将该属性设置为<code>none</code> 会禁用嵌入式数据库的自动配置.<blockquote>
<p>注意:</p>
<p>​    如果测试中使用这个功能,可以注意到,无论使用了多少个应用context,测试部分只会使用同一个数据库. 如果想要每个context都有各自的嵌入式数据库,则应将<code>spring.datasource.generate-unique-name</code> 设置为<code>true</code>.</p>
</blockquote>
例如,典型的 POM 依赖如下:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;</span><br><span class="line"> &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意:</p>
<p>​    您需要使用<code>spring-jdbc</code>才能够自动配置嵌入式数据库.在这个例子中,它是通过<code>spring-boot-starter-data-jpa</code>传递拉取的.</p>
<p>建议:</p>
<p>​    如果出于某种原因,确实需要为嵌入式数据库配置URL,确保禁用数据库的自动关闭.如果使用 H2,则应使用<code>DB_CLOSE_ON_EXIT=FALSE</code>来执行此操作. 如果使用 HSQLDB,则应确保不使用<code>shutdown=true</code>. 禁用数据库的自动关闭可以让 Spring Boot 控制何时关闭数据库,从而确保在不再需要访问数据库时,关闭数据库.</p>
</blockquote>
</li>
<li><h6 id="连接生产环境数据库-Connection-to-a-Production-Database"><a href="#连接生产环境数据库-Connection-to-a-Production-Database" class="headerlink" title="连接生产环境数据库(Connection to a Production Database)"></a>连接生产环境数据库(Connection to a Production Database)</h6>还可以使用池化<code>DataSource</code>来对生产环境数据库的连接进行自动配置.</li>
<li><h6 id="数据源配置-DataSource-Configuration"><a href="#数据源配置-DataSource-Configuration" class="headerlink" title="数据源配置(DataSource Configuration)"></a>数据源配置(DataSource Configuration)</h6>数据源配置由外部配置属性<code>spring.datasource.*</code>进行配置.例如,可以在<code>application.properties</code>中声明以下部分:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost/test</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">dbuser</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">dbpass</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意:</p>
<p>​    应该配置<code>spring.datasource.url</code>属性来指定URL. 否则,Spring Boot 会尝试自动配置嵌入式数据库.</p>
<p>建议:</p>
<p>​    Spring Boot 可以从URL推导出大多数数据库的 JDBC 驱动类.如果需要指定特定的类,可以使用<code>spring.datasource.driver-class-name</code>属性.</p>
<p>注意:</p>
<p>​    对于要创建的池化<code>DataSource</code>,需要验证<code>Driver</code>类是否可用,所以在任何动作前都会检查<code>Driver</code>.换句话说,可以设置<code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>,则该类会被加载.</p>
</blockquote>
有关更多支持的选项,请参阅  <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java"><code>DataSourceProperties</code></a>.无论实际的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.sql.datasource.connection-pool">implementation</a>.如何,这些都是标准选项.还可以通过使用各自的前缀(<code>spring.datasource.hikari.*</code>,<code>spring.datasource.tomcat.*</code>,<code>spring.datasource.dbcp2.*</code> 和 <code>spring.datasource.oracleucp.*</code>)来调整各自实现的设置 ).有关更多详细信息,请参阅相关连接池实现的文档.<br>例如,如果您使用 Tomcat 连接池,您可以自定义许多附加设置,如下例所示:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.tomcat.max-wait</span>=<span class="string">10000</span></span><br><span class="line"><span class="meta">spring.datasource.tomcat.max-active</span>=<span class="string">50</span></span><br><span class="line"><span class="meta">spring.datasource.tomcat.test-on-borrow</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure>
如果没有可用连接,在抛出异常前,会让连接池等待10000ms;将最大连接数限制为 50 ms;在从连接池中获取连接前验证连接.</li>
<li><h6 id="支持的连接池-Supported-Connection-Pools"><a href="#支持的连接池-Supported-Connection-Pools" class="headerlink" title="支持的连接池(Supported Connection Pools)"></a>支持的连接池(Supported Connection Pools)</h6>Spring Boot 使用以下算法来选择具体实现:<ol>
<li>首选HikariCP,因为它的高性能和高并发性. 如果 HikariCP 可用,则总是选用它.</li>
<li>否则,如果 Tomcat 池化<code>DataSource</code>可用,就使用它.</li>
<li>否则,如果 Commons DBCP2 可用,就使用它.</li>
<li>如果 HikariCP,Tomcat 和 DBCP2 都不可用,而 Oracle UCP 可用,就使用它.<blockquote>
<p>注意:</p>
<p>   如果你使用<code>spring-boot-starter-jdbc</code>或<code>spring-boot-starter-data-jpa</code> “starters”,你会自动获得<code>HikariCP</code>的依赖.</p>
</blockquote>
</li>
</ol>
可以使用<code>spring.datasource.type</code>属性来绕过算法,使用指定连接池. 在 Tomcat运行应用程序时,这一点尤其重要,因为默认情况下提供了<code>tomcat-jdbc</code>.<br>其他的连接池可以手动配置,使用<code>DataSourceBuilder</code>.如果自定义的<code>DataSource</code>bean,则不会发生自动配置.<code>DataSourceBuilder</code>支持以下连接池:<ul>
<li>HikariCP</li>
<li>Tomcat池化<code>Datasource</code></li>
<li>Commons DBCP2</li>
<li>Oracle UCP &amp; <code>OracleDataSource</code></li>
<li>Spring Framework的<code>SimpleDriverDataSource</code></li>
<li>H2<code>JdbcDataSource</code></li>
<li>PostgreSQL的<code>PGSimpleDataSource</code></li>
</ul>
</li>
<li><h6 id="连接到JNDI数据源-Connection-to-a-JNDI-DataSource"><a href="#连接到JNDI数据源-Connection-to-a-JNDI-DataSource" class="headerlink" title="连接到JNDI数据源(Connection to a JNDI DataSource)"></a>连接到JNDI数据源(Connection to a JNDI DataSource)</h6>如果要将Spring Boot应用部署到应用程序服务器上,可能会想要使用应用服务器内置功能和使用JNDI访问的方式来配置和管理数据源.<br>spring.datasource.jndi-name 属性可以用来替代<code>spring.datasource.url</code>,<code>spring.datasource.username</code>和<code>spring.datasource.password</code> 属性,来访问特定  位置的JNDI提供的数据源.例如,<code>application.properties</code>中的以下部分显示了如何访问 JBoss AS 定义的<code>DataSource</code>:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.jndi-name</span>=<span class="string">java:jboss/datasources/customers</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><h6 id="使用JdbcTemplate-Using-JdbcTemplate"><a href="#使用JdbcTemplate-Using-JdbcTemplate" class="headerlink" title="使用JdbcTemplate(Using JdbcTemplate)"></a>使用JdbcTemplate(Using JdbcTemplate)</h6>Spring 的 <code>JdbcTemplate</code> 和 <code>NamedParameterJdbcTemplate</code> 类是自动配置的,你可以直接将它们<code>@Autowire</code> 到自己的 bean 中,如下所示:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.jdbcTemplate ...</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
您可以使用<code>spring.jdbc.template.*</code>属性来自定义模板的属性,如下例所示:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jdbc.template.max-rows</span>=<span class="string">500</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意:</p>
<p>​    <code>NamedParameterJdbcTemplate</code>在背后重用 <code>JdbcTemplate</code>实例.如果定义了多个 <code>JdbcTemplate</code>并且不存在主要候选者,则<code>NamedParameterJdbcTemplate</code>不会自动配置.</p>
</blockquote>
</li>
<li><h6 id="JPA和Spring-Data-JPA-JPA-and-Spring-Data-JPA"><a href="#JPA和Spring-Data-JPA-JPA-and-Spring-Data-JPA" class="headerlink" title="JPA和Spring Data JPA( JPA and Spring Data JPA)"></a>JPA和Spring Data JPA( JPA and Spring Data JPA)</h6>Java Persistence API 是一种标准技术,可让将对象”映射”到关系数据库.<code>spring-boot-starter-data-jpa</code>POM提供了一种快速入门的方法. 它提供以下关键依赖项:<ul>
<li>Hibernate:最流行的 JPA 实现之一.</li>
<li>Spring Data JPA:帮助您实现基于 JPA 的repository.</li>
<li>Spring ORM:来自 Spring框架的支持核心ORM </li>
</ul>
<ol>
<li><h6 id="Entity-Classes"><a href="#Entity-Classes" class="headerlink" title="Entity Classes"></a>Entity Classes</h6>传统上,JPA”Entity”类在<code>persistence.xml</code>文件中指定.在Spring Boot中,此文件不是必需的,而是使用”Entity Scanning”.默认情况下,检索主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>标注的)下的所有包.<br>任何用<code>@Entity</code>,<code>@Embeddable</code>或<code>@MappedSuperclass</code>标注的类都会被考虑. 典型的实体类如下示例:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Id</span></span><br><span class="line"> <span class="meta">@GeneratedValue</span></span><br><span class="line"> <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Column(nullable = false)</span></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Column(nullable = false)</span></span><br><span class="line"> <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ... additional members, often include @OneToMany mappings</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">City</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// no-args constructor required by JPA spec</span></span><br><span class="line">  <span class="comment">// this one is protected since it shouldn't be used directly</span></span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(String name, String state)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.state = state;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ... etc</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>建议:</p>
<p>​    您可以使用<code>@EntityScan</code>注解自定义实体扫描位置. 参阅”how-to”.</p>
</blockquote>
</li>
<li><h6 id="Spring-Data-JPA-Repositories"><a href="#Spring-Data-JPA-Repositories" class="headerlink" title="Spring Data JPA Repositories"></a>Spring Data JPA Repositories</h6>Spring Data JPA repositories是可以用来定义来访问数据的接口.JPA查询是根据方法名自动创建的.例如,<code>CityRepository</code>接口可能会声明一个<code>findAllByState(String state) </code>方法来查找给定状态下的所有城市.<br>对于更复杂的查询,可以使用 Spring Data <code>Query</code> 注解来标注方法.<br>Spring Data repositories通常从<code>Repository</code>或<code>CrudRepository</code>接口扩展来的.如果使用自动配置,则从包含您的主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>标注的那个)的包中搜索repositories.<br>以下示例显示了典型的Spring Data存储库接口定义:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line"> <span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
Spring Data JPA 存储库支持三种不同的引导模式:默认,延迟和懒加载:<br>要启用deferred或lazy启动模式,将<code>spring.data.jpa.repositories.bootstrap-mode</code>属性分别设置为<code>deferred</code>或<code>lazy</code>.当使用deferred或lazy引导时,自动配置的 <code>EntityManagerFactoryBuilder</code>会使用context的<code>AsyncTaskExecutor</code>(如果有)作为引导执行程序.如果存在多个,将使用名为<code>applicationTaskExecutor</code>的一个.<blockquote>
<p>注意:</p>
<p>​    使用deferred或lazy启动时时,确保对JPA的任何访问都应该在应用context引导阶段再进行.可以使用<code>SmartInitializingSingleton</code>来调用任何需要 JPA的初始化.对于作为Spring bean形式创建的 JPA 组件(例如转换器),会使用<code>ObjectProvider</code>来延迟对依赖项的解析(如果有的话).</p>
<p>建议:</p>
<p>​    上面说的仅仅触及 Spring Data JPA 的皮毛. 有关完整的详细信息,参阅 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/2.2.1/reference/html/">Spring Data JPA reference documentation</a>.</p>
</blockquote>
</li>
<li><h6 id="创建和删除-JPA-数据库-Creating-and-Dropping-JPA-Databases"><a href="#创建和删除-JPA-数据库-Creating-and-Dropping-JPA-Databases" class="headerlink" title="创建和删除 JPA 数据库(Creating and Dropping JPA Databases)"></a>创建和删除 JPA 数据库(Creating and Dropping JPA Databases)</h6>默认情况下,只有在您使用嵌入式数据库(H2,HSQL 或 Derby)时才会自动创建 JPA 数据库.您可以使用<code>spring.jpa.*</code>属性显式配置 JPA 设置.例如,要创建和删除表,您可以在 application.properties 中添加以下行:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>=<span class="string">create-drop</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意:</p>
<p>​    Hibernate 自己的内部属性名称(如果您碰巧记得更好的话)是 <code>hibernate.hbm2ddl.auto</code>.可以使用<code>spring.jpa.properties.*</code>以及其他 Hibernate的自有属性(在将添加到实体管理器之前去除前缀)来设置.以下行显示了为 Hibernate 设置 JPA 属性的示例:</p>
</blockquote>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jpa.properties.hibernate[globally_quoted_identifiers]</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure>

前面示的例子中,将<code>hibernate.globally_quoted_identifiers</code>属性的<code>true</code>值传递给 Hibernate 实体管理器.<br>默认情况下,DDL 执行(或验证)被推迟到<code>ApplicationContext</code>已经启动后.还有一个<code>spring.jpa.generate-ddl</code>标志位,但如果 Hibernate 自动配置处于活动状态,则不会使用它,因为<code>ddl-auto</code>设置更细粒度.</li>
<li><h6 id="在视图中打开-EntityManager-Open-EntityManager-in-View"><a href="#在视图中打开-EntityManager-Open-EntityManager-in-View" class="headerlink" title="在视图中打开 EntityManager(Open EntityManager in View)"></a>在视图中打开 EntityManager(Open EntityManager in View)</h6>如果您正在运行 Web 应用程序,Spring Boot 默认注册 <code>OpenEntityManagerInViewInterceptor</code>来使用”在视图中打开 EntityManager”模式,从而允许在 Web 视图中延迟加载.如果不想要这种行为,可以在 <code>application.properties</code>中将<code>spring.jpa.open-in-view</code>设置为<code>false</code>.</li>
</ol>
</li>
<li><h6 id="Spring-Data-JDBC"><a href="#Spring-Data-JDBC" class="headerlink" title="Spring Data JDBC"></a>Spring Data JDBC</h6>Spring Data 包括对JDBC 的存储库支持,并将自动为<code>CrudRepository</code>上的方法生成 SQL.对于更高级的查询,提供了<code>@Query</code>注解.<br>当在classpath上有依赖项时,Spring Boot将自动配置 Spring Data 的 JDBC 存储库.可以通过对一个<code>spring-boot-starter-data-jdbc</code>依赖,将所有的依赖添加到的工程中.如有必要,您可以通过向应用添加<code>@EnableJdbcRepositories</code>注解或<code> JdbcConfiguration</code>子类来完全控制 Spring Data JDBC 的配置.</li>
<li><h6 id="使用H2的Web控制台-Using-H2’s-Web-Console"><a href="#使用H2的Web控制台-Using-H2’s-Web-Console" class="headerlink" title="使用H2的Web控制台(Using H2’s Web Console)"></a>使用H2的Web控制台(Using H2’s Web Console)</h6>H2 数据库提供了一个基于浏览器的控制台,Spring Boot 可以自动配置.当满足以下条件时,控制台会自动配置:<ul>
<li>正在开发一个基于servlet的Web应用程序.</li>
<li><code>com.h2database:h2</code>在类路径上.</li>
<li>您正在使用 Spring Boot 的开发人员工具<blockquote>
<p>建议:</p>
<p>   如果你没有使用Spring Boot的开发者工具,但仍想使用 H2 的控制台.您可以将 <code>spring.h2.console.enabled</code>属性配置为<code>true</code>.</p>
<p>注意:</p>
<p>​    H2 控制台仅用于开发期间,因此您应该注意确保<code>spring.h2.console.enabled</code>在生产中未设置为<code>true</code>.</p>
</blockquote>
</li>
</ul>
<ol>
<li><h6 id="更改-H2-控制台的路径-Changing-the-H2-Console’s-Path"><a href="#更改-H2-控制台的路径-Changing-the-H2-Console’s-Path" class="headerlink" title="更改 H2 控制台的路径(Changing the H2 Console’s Path)"></a>更改 H2 控制台的路径(Changing the H2 Console’s Path)</h6>默认情况下,控制台位于<code>/h2-console</code>. 可以使用 <code>spring.h2.console.path</code> 属性自定义控制台的路径.</li>
</ol>
</li>
</ol>
<ol start="6">
<li><h6 id="使用jOOQ-Using-jOOQ"><a href="#使用jOOQ-Using-jOOQ" class="headerlink" title="使用jOOQ(Using jOOQ)"></a>使用jOOQ(Using jOOQ)</h6>jOOQ Object Oriented Querying (jOOQ) 是 Data Geekery 的一款流行产品,根据数据库生成 Java 代码,并允许使用流式 API 构建类型安全的 SQL 查询.商业版和开源版都可以与Spring Boot一起使用.<ol>
<li><h6 id="代码生成-Code-Generation"><a href="#代码生成-Code-Generation" class="headerlink" title="代码生成(Code Generation)"></a>代码生成(Code Generation)</h6>为了使用 jOOQ 类型安全查询,您需要从数据库schema生成 Java 类.可以按照 jOOQ 用户手册中的说明进行操作.如果您使用<code>jooq-codegen-maven</code>插件,并且还使用<code>spring-boot-starter-parent</code>“父POM”,则可以很安全地忽略该插件的<code>&lt;version&gt;</code>标签.您还可以使用 Spring Boot 定义的版本变量(例如 <code>h2.version</code>)来声明插件的数据库依赖. 以下清单显示了一个示例:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line"> &lt;groupId&gt;org.jooq&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;</span><br><span class="line"> &lt;executions&gt;</span><br><span class="line">  ...</span><br><span class="line"> &lt;/executions&gt;</span><br><span class="line"> &lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">	  &lt;groupId&gt;com.h2database&lt;/groupId&gt;</span><br><span class="line">	  &lt;artifactId&gt;h2&lt;/artifactId&gt;</span><br><span class="line">	  &lt;version&gt;${h2.version}&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line"> &lt;/dependencies&gt;</span><br><span class="line"> &lt;configuration&gt;</span><br><span class="line">  &lt;jdbc&gt;</span><br><span class="line">	  &lt;driver&gt;org.h2.Driver&lt;/driver&gt;</span><br><span class="line">	  &lt;url&gt;jdbc:h2:~/yourdatabase&lt;/url&gt;</span><br><span class="line">  &lt;/jdbc&gt;</span><br><span class="line">  &lt;generator&gt;</span><br><span class="line">	  ...</span><br><span class="line">  &lt;/generator&gt;</span><br><span class="line"> &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="使用DSLContext-Using-DSLContext"><a href="#使用DSLContext-Using-DSLContext" class="headerlink" title="使用DSLContext(Using DSLContext)"></a>使用DSLContext(Using DSLContext)</h6>jOOQ 提供的流式API 是通过<code>org.jooq.DSLContext</code>接口初始化的.Spring Boot 将 <code>DSLContext</code> 自动配置成Spring Bean并将将其连接到应用的数据源<code>DataSource</code>.要使用<code>DSLContext</code>,可以如下注:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> DSLContext create;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(DSLContext dslContext)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.create = dslContext;</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>建议:</p>
<p>​    jOOQ 手册倾向于使用名为<code>create</code>的变量来保存<code>DSLContext</code>.<br>可以使用<code>DSLContext</code>去构建查询,如下所示;</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;GregorianCalendar&gt; <span class="title">authorsBornAfter1980</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.create.selectFrom(AUTHOR)</span><br><span class="line">	  .where(AUTHOR.DATE_OF_BIRTH.greaterThan(<span class="keyword">new</span> GregorianCalendar(<span class="number">1980</span>, <span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">	  .fetch(AUTHOR.DATE_OF_BIRTH);</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="jOOQ-SQL方言-jOOQ-SQL-Dialect"><a href="#jOOQ-SQL方言-jOOQ-SQL-Dialect" class="headerlink" title="jOOQ SQL方言(jOOQ SQL Dialect)"></a>jOOQ SQL方言(jOOQ SQL Dialect)</h6>除非已经配置了<code>spring.jooq.sql-dialect</code>属性,否则Spring Boot会决定用于数据源的 SQL 方言.如果 Spring Boot无法检测到方言,则使用<code>DEFAULT</code>.<blockquote>
<p>注意:</p>
<p>​    Spring Boot只能自动配置 jOOQ 开源版本支持的方言.</p>
</blockquote>
</li>
<li><h6 id="自定义jOOQ-Customizing-jOOQ"><a href="#自定义jOOQ-Customizing-jOOQ" class="headerlink" title="自定义jOOQ(Customizing jOOQ)"></a>自定义jOOQ(Customizing jOOQ)</h6>可以通过自定义<code>DefaultConfigurationCustomizer</code>bean来实现更高级的自定义,该 bean将在创建<code>org.jooq.Configuration</code> <code>@Bean</code>之前调用.这优先于任何自动配置的内容.<br>如果您想完全控制 jOOQ 配置,您还可以创建自己的<code>org.jooq.Configuration</code> <code>@Bean</code>.</li>
</ol>
</li>
<li><h6 id="使用R2DBC-Using-R2DBC"><a href="#使用R2DBC-Using-R2DBC" class="headerlink" title="使用R2DBC(Using R2DBC)"></a>使用R2DBC(Using R2DBC)</h6>响应式关系数据库连接(The Reactive Relational Database Connectivity ,R2DBC)项目将响应式编程API引入了关系数据库.R2DBC 的<code>io.r2dbc.spi.Connection</code>提供了一种标准方法来使用非阻塞数据库连接.连接是通过<code>ConnectionFactory</code>提供的,类似于带有jdbc的<code>DataSource</code>.<br><code>ConnectionFactory</code>配置由<code>spring.r2dbc.*</code>中的外部配置属性控制.例如,可以在 <code>application.properties</code>中声明以下部分:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.r2dbc.url</span>=<span class="string">r2dbc:postgresql://localhost/test</span></span><br><span class="line"><span class="meta">spring.r2dbc.username</span>=<span class="string">dbuser</span></span><br><span class="line"><span class="meta">spring.r2dbc.password</span>=<span class="string">dbpass</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>建议:</p>
<p>​    不需要指定驱动程序类名,因为Spring Boot从 R2DBC 的连接工厂发现中获取驱动程序.</p>
<p>注意:</p>
<p>​    至少应该提供网址. URL 中指定的信息优先于单个属性,即<code>name</code>,<code>username</code>,<code>password</code>和池选项.</p>
</blockquote>
可以自定义由<code>ConnectionFactory</code>创建的连接,即在中央数据库配置中设置不想(或不能)特定参数,您可以使用<code>ConnectionFactoryOptionsBuilderCustomizer</code> <code>@Bean</code>.以下示例显示了如何手动覆盖数据库端口,而其余选项来使用应用程序配置:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyR2dbcConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ConnectionFactoryOptionsBuilderCustomizer <span class="title">connectionFactoryPortCustomizer</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> (builder) -&gt; builder.option(ConnectionFactoryOptions.PORT, <span class="number">5432</span>);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
以下示例显示了如何设置PostgreSQL 连接选项:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPostgresR2dbcConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ConnectionFactoryOptionsBuilderCustomizer <span class="title">postgresCustomizer</span><span class="params">()</span> </span>{</span><br><span class="line">  Map&lt;String, String&gt; options = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  options.put(<span class="string">"lock_timeout"</span>, <span class="string">"30s"</span>);</span><br><span class="line">  options.put(<span class="string">"statement_timeout"</span>, <span class="string">"60s"</span>);</span><br><span class="line">  <span class="keyword">return</span> (builder) -&gt; builder.option(PostgresqlConnectionFactoryProvider.OPTIONS, options);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
当<code>ConnectionFactory</code>bean可用时,常规的 JDBC数据源的自动配置将不会生效.如果想保留 JDBC <code>DataSource</code>自动配置,并且能够接受在响应式应用中使用阻塞 JDBC API 的风险,可以在应用的<code>@Configuration</code>上添加<code>@Import(DataSourceAutoConfiguration.class)</code>,来使其重新开启.<ol>
<li><h6 id="对内嵌式数据的支持-Embedded-Database-Support"><a href="#对内嵌式数据的支持-Embedded-Database-Support" class="headerlink" title="对内嵌式数据的支持(Embedded Database Support)"></a>对内嵌式数据的支持(Embedded Database Support)</h6>与 JDBC 支持类似,Spring Boot可以自动配置嵌入式数据库以供响应式使用.您无需提供任何连接URL.只需要在编译依赖中添加要使用的嵌入式数据库,如以下示例所示:<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.r2dbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>r2dbc-h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意:</p>
<p>​    如果在测试中使用此功能,可能会注意到,无论您使用多少应用context,整个测试组件都会重用同一个数据库.如果要让每个context都使用单独的嵌入式数据库,则应将<code>spring.r2dbc.generate-unique-name</code>设置为<code>true</code>.</p>
</blockquote>
</li>
<li><h6 id="使用数据库客户端-Using-DatabaseClient"><a href="#使用数据库客户端-Using-DatabaseClient" class="headerlink" title="使用数据库客户端(Using DatabaseClient)"></a>使用数据库客户端(Using DatabaseClient)</h6><code>DatabaseClient</code>bean是自动配置的,可以将直接使用<code>@Autowire</code> 注入到到自己的 bean中.如下所示:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> DatabaseClient databaseClient;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(DatabaseClient databaseClient)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.databaseClient = databaseClient;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Spring-Data-R2DBC-Repositories"><a href="#Spring-Data-R2DBC-Repositories" class="headerlink" title="Spring Data R2DBC Repositories"></a>Spring Data R2DBC Repositories</h6>Spring Data R2DBC repositories是可以用来访问数据的接口.根据方法名来自动创建的查询.例如,<code>CityRepository</code>接口可能会声明一个<code>findAllByState(String state) </code>方法来查找指定状态的所有城市.<br>对于更复杂的查询,您可以使用Spring Data Query注释来标注方法.<br>Spring Data repositories 通常从<code>Repository</code>或<code>CrudRepository</code>接口扩展.如果使用自动配置,则从包含主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>标注的类)的包中搜索存储库.<br>以下示例显示了典型的 Spring Data repository 接口定义:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line"> <span class="function">Mono&lt;City&gt; <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>建议:</p>
<p>​    以上内容几乎没有触及Spring Data R2DBC的皮毛. 有关完整的详细信息,请参阅 Spring Data R2DBC 参考文档.</p>
</blockquote>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/58617.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/58617.html" class="post-title-link" itemprop="url">3.10 Feature: 安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-03 11:14:00" itemprop="dateCreated datePublished" datetime="2021-06-03T11:14:00+08:00">2021-06-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:58:09" itemprop="dateModified" datetime="2021-06-10T12:58:09+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/58617.html" class="post-meta-item leancloud_visitors" data-flag-title="3.10 Feature: 安全" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="安全-Security"><a href="#安全-Security" class="headerlink" title="安全(Security)"></a>安全(Security)</h5><p>如果Spring Security在classpath上,则默认情况下Web应用程序是安全的. Spring Boot依靠Spring Security的内容协商策略来确定是使用<code>httpBasic</code>还是<code>formLogin</code>.如果想要在应用添加方法级别的安全,可以使用<code>@EnableGlobalMethodSecurity</code>来进行设置.可以在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.5.0/reference/html5/#jc-method">Spring Security Reference Guide</a>中获得更多信息.<br>默认的<code>UserDetailsServic</code>只有一个用户. 用户名是<code>user</code>,密码是随机的,在应用启动时在INFO级别日志输出,如下例所示:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35</span><br></pre></td></tr></tbody></table></figure>

<p>如果想要调整日志配置,确保将<code>org.springframework.boot.autoconfigure.security</code>的日志级别设置为<code>INFO</code>级别. 不然,不会打印默认密码.<br>可以通过提供<code>spring.security.user.name</code>和<code>spring.security.user.password</code>来更改用户名和密码.<br>默认情况下,您在Web应用程序中的基本功能有:</p>
<ul>
<li>保留在内存中的,<code>UserDetailsService</code>(如果是WebFlux应用程序,则为<code>ReactiveUserDetailsService</code>)Bean和一个带有生成密码的单个用户(有关用户的属性,可以参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html"><code>SecurityProperties.User</code></a>).</li>
<li>为整个应用程序提供,基于表单的登录或HTTP基本安全性(依赖请求中的<code>Accept</code>header)(如果actuator在classpath上,则包含actuator endpoints).</li>
<li>用于发布身份验证事件的<code>DefaultAuthenticationEventPublisher</code>.</li>
<li>可以添加Bean的方式来提供不同的<code>AuthenticationEventPublisher</code></li>
</ul>
<ol>
<li><h6 id="MVC安全性-MVC-Security"><a href="#MVC安全性-MVC-Security" class="headerlink" title="MVC安全性(MVC Security)"></a>MVC安全性(MVC Security)</h6>默认的安全配置在<code>SecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code>中实现.<code> SecurityAutoConfiguration</code>导入<code>SpringBootWebSecurityConfiguration</code>来保证网络安全,而<code>UserDetailsServiceAutoConfiguration</code>配置身份验证,这也与非Web应用程序相关.要完全关闭默认的Web应用程序安全性配置或组合多个Spring Security组件(例如OAuth2 Client和Resource Server).添加一个类型为<code>SecurityFilterChain</code>的bean(这样做不会禁用<code>UserDetailsService</code>配置或<code>Actuator</code>安全性).<br>如果要关闭<code>UserDetailsService</code>配置,可以添加类型为<code>UserDetailsService</code>,<code>AuthenticationProvider</code>或<code>AuthenticationManager</code>的bean.<br>可以添加自定义<code>SecurityFilterChain</code>或<code>WebSecurityConfigurerAdapter</code>bean,来覆盖访问规则.Spring Boot提供了方便的方法,可用来覆盖actuator endpoints和静态资源的访问规则.可以使用<code>EndpointRequest</code>创建基于<code>management.endpoints.web.base-path</code>属性的<code>RequestMatcher</code>.可以使用<code>PathRequest</code>为常用路径的资源创建一个<code>RequestMatcher</code>.</li>
<li><h6 id="WebFlux安全性-WebFlux-Security"><a href="#WebFlux安全性-WebFlux-Security" class="headerlink" title="WebFlux安全性( WebFlux Security)"></a>WebFlux安全性( WebFlux Security)</h6>与Spring MVC应用程序类似,可以添加<code>spring-boot-starter-security</code>依赖项来保护WebFlux应用程序.默认的安全配置在<code>ReactiveSecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code>中实现.<code>ReactiveSecurityAutoConfiguration</code>导入<code>WebFluxSecurityConfiguration</code>来实现Web安全,而<code>UserDetailsServiceAutoConfiguration</code>则用来配置身份验证,这在非Web应用程序中也很重要.如果想要完全禁用默认的Web应用安全性设置,可以添加<code>WebFilterChainProxy</code>类型的Bean来实现(这样做不会禁用<code>UserDetailsService</code>配置或Actuator的功能).<br>如果也要关闭<code>UserDetailsService</code>的配置,您可以添加<code>ReactiveUserDetailsService</code>或<code>ReactiveAuthenticationManager</code>类型的Bean.<br>通过添加自定义<code>SecurityWebFilterChain</code>bean,来配置访问规则和组合多个Spring Security组件(例如OAuth 2 Client和Resource Server).Spring Boot提供了一些可以用于覆盖 actuator endpoints和静态资源的访问规则的便捷的方法.<code>EndpointRequest</code>可用于创建基于<code>management.endpoints.web.base-path</code>属性的<code>ServerWebExchangeMatcher</code>.<br>可以使用<code>PathRequest</code>为常用路径中的资源创建<code>ServerWebExchangeMatcher</code>.<br>例如,您可以通过添加以下内容来自定义安全配置:<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebFluxSecurityConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> SecurityWebFilterChain <span class="title">springSecurityFilterChain</span><span class="params">(ServerHttpSecurity http)</span> </span>{</span><br><span class="line">  http.authorizeExchange((spec) -&gt; {</span><br><span class="line">   spec.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll();</span><br><span class="line">   spec.pathMatchers(<span class="string">"/foo"</span>, <span class="string">"/bar"</span>).authenticated();</span><br><span class="line">  });</span><br><span class="line">  http.formLogin();</span><br><span class="line">  <span class="keyword">return</span> http.build();</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h6>OAuth2是Spring支持的一种广泛使用的授权框架.<ol>
<li><h6 id="客户端-Client"><a href="#客户端-Client" class="headerlink" title="客户端(Client)"></a>客户端(Client)</h6>如果classpath上有<code>spring-security-oauth2-client</code>,则可以利用一些自动配置来设置OAuth2 / Open ID Connect客户端.这个配置使用<code>OAuth2ClientProperties</code>的属性. 相同的属性适用于servlet和响应式应用.<br>您可以在<code>spring.security.oauth2.client</code>前缀下注册多个OAuth2客户端和providers ,如以下示例所示:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-secret</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-name</span>=<span class="string">Client for user scope</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.provider</span>=<span class="string">my-oauth-provider</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.scope</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.redirect-uri</span>=<span class="string">https://my-redirect-uri.com</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-authentication-method</span>=<span class="string">basic</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.authorization-grant-type</span>=<span class="string">authorization-code</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-secret</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-name</span>=<span class="string">Client for email scope</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.provider</span>=<span class="string">my-oauth-provider</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.scope</span>=<span class="string">email</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.redirect-uri</span>=<span class="string">https://my-redirect-uri.com</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-authentication-method</span>=<span class="string">basic</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.authorization-grant-type</span>=<span class="string">authorization_code</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri</span>=<span class="string">https://my-auth-server/oauth/authorize</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.token-uri</span>=<span class="string">https://my-auth-server/oauth/token</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri</span>=<span class="string">https://my-auth-server/userinfo</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method</span>=<span class="string">header</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri</span>=<span class="string">https://my-auth-server/token_keys</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute</span>=<span class="string">name</span></span><br><span class="line">	 </span><br></pre></td></tr></tbody></table></figure>
对于支持 <a target="_blank" rel="noopener" href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect discovery</a>的OpenID Connectproviders ,可以进一步简化配置.provider需要配置一个<code>issuer-uri</code>,这是它声明Issuer Identifier的URI.例如,如果提供的issuer-uri是” <a target="_blank" rel="noopener" href="https://example.com&quot;,则将向&quot;/">https://example.com",则将向"</a> <a href="https://example.com/.well-known/openid-configuration&quot;%E5%8F%91%E5%87%BA">https://example.com/.well-known/openid-configuration"发出</a> <code>OpenID Provider Configuration Request</code>.预期结果是<code>OpenID Provider Configuration Response</code>.以下示例显示了如何使用<code>issuer-uri</code>配置OpenID Connect Provider:</li>
</ol>
  <figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.client.provider.oidc-provider.issuer-uri</span>=<span class="string">https://dev-123456.oktapreview.com/oauth2/default/</span></span><br><span class="line">	</span><br></pre></td></tr></tbody></table></figure>
   默认情况下,Spring Security的<code>OAuth2LoginAuthenticationFilter</code>仅处理与<code>/login/oauth2/code/*</code>匹配的URL.如果要自定义<code>redirect-uri</code>来使用其他pattern,则需要提供配置来处理该自定义pattern.例如,对于servlet应用程序,您可以添加自定义的<code>SecurityFilterChain</code>,如下: <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOAuthClientConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> SecurityFilterChain <span class="title">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">  http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">  http.oauth2Login().redirectionEndpoint().baseUri(<span class="string">"custom-callback"</span>);</span><br><span class="line">  <span class="keyword">return</span> http.build();</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">	</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>建议:</p>
<p>​    Spring Boot自动配置一个<code>InMemoryOAuth2AuthorizedClientService</code>,Spring Security使用它来管理客户端注册.<code>InMemoryOAuth2AuthorizedClientService</code>的功能有限,建议仅将其用于开发环境.对于生产环境,考虑使用<code>JdbcOAuth2AuthorizedClientService</code>或实现自己的<code>OAuth2AuthorizedClientService</code>接口.</p>
</blockquote>
<h6 id="常见provider的OAuth2客户端注册-OAuth2-client-registration-for-common-providers"><a href="#常见provider的OAuth2客户端注册-OAuth2-client-registration-for-common-providers" class="headerlink" title="常见provider的OAuth2客户端注册(OAuth2 client registration for common providers)"></a>常见provider的OAuth2客户端注册(OAuth2 client registration for common providers)</h6>   对于常见的OAuth2和OpenID providers,包括Google,Github,Facebook和Okta,我们提供了一组提供程序默认值(分别是<code>google</code>,<code>github</code>,<code>facebook</code>和<code>okta</code>)<br>   如果不需要自定义这些providers,则可以将<code>provider</code>属性设置为需要推断默认值的属性.另外,如果客户端注册的密钥与默认的支持的provider匹配,Spring Boot也会推断出该provider.<br>   换句话说,以下示例中的两种配置都使用Google provider:<pre><code> <figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client.client-secret</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client.provider</span>=<span class="string">google</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.google.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.google.client-secret</span>=<span class="string">password</span></span><br></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><h6 id="资源服务器-Resource-Server"><a href="#资源服务器-Resource-Server" class="headerlink" title="资源服务器(Resource Server)"></a>资源服务器(Resource Server)</h6> 如果您的classpath上有<code>spring-security-oauth2-resource-server</code>,则Spring Boot可以配置OAuth2资源服务器.对于JWT配置,需要指定JWK Set URI或 OIDC Issuer URI,如以下示例所示: <figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.resourceserver.jwt.jwk-set-uri</span>=<span class="string">https://example.com/oauth2/default/v1/keys</span></span><br></pre></td></tr></tbody></table></figure>
 <figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.resourceserver.jwt.issuer-uri</span>=<span class="string">https://dev-123456.oktapreview.com/oauth2/default/</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意:</p>
<p>​    如果授权服务器不支持JWK Set URI,则可以使用用于验证JWT签名的公钥来配置资源服务器.可以使用<code>spring.security.oauth2.resourceserver.jwt.public-key-location</code>属性完成此操作,该值需要指向包含PEM编码的x509格式的公钥的文件.</p>
</blockquote>
 相同的属性适用于servlet和响应式应用.<br> 另外,您可以为Servlet应用程序定义自己的<code>JwtDecoder</code>Bean,或者为响应式应用定义<code>ReactiveJwtDecoder</code>.<br> 如果使用不透明令牌而不是JWT,则可以配置以下属性以通过introspection来验证令牌:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.resourceserver.opaquetoken.introspection-uri</span>=<span class="string">https://example.com/check-token</span></span><br><span class="line"><span class="meta">spring.security.oauth2.resourceserver.opaquetoken.client-id</span>=<span class="string">my-client-id</span></span><br><span class="line"><span class="meta">spring.security.oauth2.resourceserver.opaquetoken.client-secret</span>=<span class="string">my-client-secret</span></span><br></pre></td></tr></tbody></table></figure>
 同样,相同的属性适用于servlet和响应式应用.<br> 另外,可以为Servlet应用程序定义自己的<code>OpaqueTokenIntrospector</code>Bean,或者为响应式应用定义<code>ReactiveOpaqueTokenIntrospector</code>.</li>
<li><h6 id="授权服务器-Authorization-Server"><a href="#授权服务器-Authorization-Server" class="headerlink" title="授权服务器(Authorization Server)"></a>授权服务器(Authorization Server)</h6>当前,Spring Security不支持实现OAuth 2.0授权服务器.但是,Spring Security OAuth项目提供了此功能,这最终将被Spring Security完全取代.在此之前,可以使用<code>spring-security-oauth2-autoconfigure</code>模块来很容易地设置OAuth 2.0授权服务器； 有关说明,请参见 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security-oauth2-boot/">documentation</a> .</li>
<li><h6 id="SAML-2-0"><a href="#SAML-2-0" class="headerlink" title="SAML 2.0"></a>SAML 2.0</h6><ol>
<li><h6 id="Relying-Party"><a href="#Relying-Party" class="headerlink" title="Relying Party"></a>Relying Party</h6>如果您在classpath中具有<code>spring-security-saml2-service-provider</code>,则可以使用自动配置来设置SAML 2.0依赖方.此配置使用<code>Saml2RelyingPartyProperties</code>下的属性.<br>一个依赖方注册代表 Identity Provider, IDP和Service Provider, SP之间的配对配置.可以在<code>spring.security.saml2.relyingparty</code>前缀下注册多个依赖方,如以下示例所示:</li>
</ol>
  <figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location</span>=<span class="string">path-to-private-key</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location</span>=<span class="string">path-to-certificate</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.decryption.credentials[0].private-key-location</span>=<span class="string">path-to-private-key</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.decryption.credentials[0].certificate-location</span>=<span class="string">path-to-certificate</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.verification.credentials[0].certificate-location</span>=<span class="string">path-to-verification-cert</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.entity-id</span>=<span class="string">remote-idp-entity-id1</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.sso-url</span>=<span class="string">https://remoteidp1.sso.url</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location</span>=<span class="string">path-to-private-key</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location</span>=<span class="string">path-to-certificate</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.decryption.credentials[0].private-key-location</span>=<span class="string">path-to-private-key</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.decryption.credentials[0].certificate-location</span>=<span class="string">path-to-certificate</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.verification.credentials[0].certificate-location</span>=<span class="string">path-to-other-verification-cert</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.entity-id</span>=<span class="string">remote-idp-entity-id2</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.sso-url</span>=<span class="string">https://remoteidp2.sso.url</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Actuator安全性-Actuator-Security"><a href="#Actuator安全性-Actuator-Security" class="headerlink" title="Actuator安全性(Actuator Security)"></a>Actuator安全性(Actuator Security)</h6>为了安全起见,默认情况下禁用<code>/health</code>以外的所有actuator.可以使用 <code>management.endpoints.web.exposure.include</code>启用actuator.<br>如果Spring Security位于classpath中,并且不存在其他<code>WebSecurityConfigurerAdapter</code>或<code>SecurityFilterChain</code>Bean,则<code>/health</code>以外的actuators均由Spring Boot自动配置保护.如果自定义了<code>WebSecurityConfigurerAdapter</code>或<code>SecurityFilterChain</code>bean,那么Spring Boot的自动配置将退出,开发者将完全控制actuator访问规则.<blockquote>
<p>建议:</p>
<p>​    在设置<code>management.endpoints.web.exposure.include</code>之前,请确保公开的actuator不包含敏感信息和/或通过将它们放置在防火墙后面,或者使用Spring Security之类的方法进行保护.</p>
</blockquote>
<ol>
<li><h6 id="跨站点请求伪造保护-Cross-Site-Request-Forgery-Protection"><a href="#跨站点请求伪造保护-Cross-Site-Request-Forgery-Protection" class="headerlink" title="跨站点请求伪造保护(Cross Site Request Forgery Protection)"></a>跨站点请求伪造保护(Cross Site Request Forgery Protection)</h6>由于Spring Boot使用Spring Security的默认设置,因此CSRF保护默认情况下处于启用状态. 这意味着在使用默认安全配置时,需要<code>POST</code>(关闭和记录器endpoint),<code>PUT</code>或<code>DELETE</code>的actuator endpoint将收到403禁止错误.<blockquote>
<p>建议:</p>
<p>​    如果创建的服务,只是给非浏览器的客户端使用时,建议完全禁用CSRF保护.</p>
</blockquote>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/32243.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/32243.html" class="post-title-link" itemprop="url">3.9 Feature: RSocket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-03 10:58:00" itemprop="dateCreated datePublished" datetime="2021-06-03T10:58:00+08:00">2021-06-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-10 12:58:28" itemprop="dateModified" datetime="2021-06-10T12:58:28+08:00">2021-06-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/32243.html" class="post-meta-item leancloud_visitors" data-flag-title="3.9 Feature: RSocket" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="RSocket"><a href="#RSocket" class="headerlink" title="RSocket"></a>RSocket</h5><p>   RSocket是用于字节流传输的二进制协议. 它在单个连接上,传递的异步消息来实现对称交互模型.<br>   Spring框架的<code>spring-messaging</code>模块提供了对RSocket请求和发送的支持,在客户端和服务端都支持. 有关更多详细信息,参见Spring Framework参考中的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/web-reactive.html#rsocket-spring">RSocket section</a>,其中包括RSocket协议的概述.</p>
<ol>
<li><h6 id="RSocket策略的自动配置-RSocket-Strategies-Auto-configuration"><a href="#RSocket策略的自动配置-RSocket-Strategies-Auto-configuration" class="headerlink" title="RSocket策略的自动配置(RSocket Strategies Auto-configuration)"></a>RSocket策略的自动配置(RSocket Strategies Auto-configuration)</h6>Spring Boot自动配置一个<code>RSocketStrategies</code>bean,该bean提供了对RSocket有效负载的编码和解码基础结构. 默认情况下,自动配置将尝试(按顺序)配置以下内容:<ul>
<li>Jackson的CBOR编解码器</li>
<li>Jackson的JSON编解码器<br><code>spring-boot-starter-rsocket</code>启动器提供了两种依赖关系. 查阅Jackson支持部分,以了解有关定制的更多信息.<br>开发人员可以实现<code>RSocketStrategiesCustomizer</code>接口来自定义<code>RSocketStrategies</code>组件. 注意,<code>@Order</code>很重要,因为它确定编解码器的顺序.</li>
</ul>
</li>
<li><h6 id="RSocket服务器自动配置"><a href="#RSocket服务器自动配置" class="headerlink" title="RSocket服务器自动配置"></a>RSocket服务器自动配置</h6>Spring Boot提供了RSocket服务器自动配置. 所需依赖关系由<code>spring-boot-starter-rsocket</code>提供.<br>Spring Boot支持使用WebFlux服务器或者标准的独立RSocket服务器来暴露公开WebSocket. 这取决于应用类型及其配置.<br>对于WebFlux应用程序(即<code>WebApplicationType.REACTIVE</code>类型),仅当以下属性匹配时,RSocket服务器才会插入Web服务器:<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rsocket.server.mapping-path</span>=<span class="string">/rsocket</span></span><br><span class="line"><span class="meta">spring.rsocket.server.transport</span>=<span class="string">websocket</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>警告:</p>
<p>​    由于RSocket本身是使用Reactor Netty构建的,因此只有Reactor Netty支持将RSocket插入Web服务器.<br>另外,也可以以独立的,嵌入式服务器的方式启动RSocket TCP或Websocket服务器. 除了依赖,唯一需要的配置是定义服务器端口:      </p>
</blockquote>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rsocket.server.port</span>=<span class="string">9898</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Spring-Messaging-RSocket支持-Spring-Messaging-RSocket-support"><a href="#Spring-Messaging-RSocket支持-Spring-Messaging-RSocket-support" class="headerlink" title="Spring Messaging RSocket支持(Spring Messaging RSocket support)"></a>Spring Messaging RSocket支持(Spring Messaging RSocket support)</h6>Spring Boot自动配置Spring Messaging infrastructure来支持RSocket.<br>这意味着Spring Boot将创建一个<code>RSocketMessageHandler</code>bean,该bean用于处理对应用的的RSocket请求.</li>
<li><h6 id="使用RSocketRequester调用RSocket服务-Calling-RSocket-Services-with-RSocketRequester"><a href="#使用RSocketRequester调用RSocket服务-Calling-RSocket-Services-with-RSocketRequester" class="headerlink" title="使用RSocketRequester调用RSocket服务(Calling RSocket Services with RSocketRequester)"></a>使用RSocketRequester调用RSocket服务(Calling RSocket Services with RSocketRequester)</h6>只要服务器和客户端之间建立了RSocket通道,任何一方都可以向另一方发送或接收请求.<br>作为服务器,可以在RSocket <code>@Controller</code>的任何处理程序方法上注入<code>RSocketRequester</code>实例. 作为客户端,首先需要配置和建立RSocket连接. 在这种情况下,Spring Boot会使用期望中的编解码器来自动配置<code>RSocketRequester.Builder</code>.<br><code>RSocketRequester.Builder</code>实例是一个原型bean,这意味着每个注入点将为您提供一个新实例. 这样做是有其原因的,因为此builder是有状态的,因此同一个实例来创建具有不同设置的requesters.<br>以下代码显示了一个典型示例:     <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RSocketRequester rsocketRequester;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(RSocketRequester.Builder rsocketRequesterBuilder)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.rsocketRequester = rsocketRequesterBuilder.tcp(<span class="string">"example.org"</span>, <span class="number">9898</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">someRSocketCall</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rsocketRequester.route(<span class="string">"user"</span>).data(name).retrieveMono(User.class);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">…</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  © 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenyk</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">337k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:06</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>


  





  
  

  
  <script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  
  


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.1.0/dist/quicklink.umd.js"></script>
  
  



<script src="/bundle.js"></script><script>{&quot;enable&quot;:true,&quot;spinner&quot;:true};
{&quot;enable&quot;:true,&quot;app_id&quot;:null,&quot;app_key&quot;:null,&quot;server_url&quot;:null,&quot;security&quot;:true};
{&quot;enable&quot;:true,&quot;home&quot;:true,&quot;archive&quot;:true,&quot;delay&quot;:true,&quot;timeout&quot;:3000,&quot;priority&quot;:true,&quot;ignores&quot;:null,&quot;url&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;page&#x2F;4&#x2F;&quot;}</script></body></html>