<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1. 开发第一个SpringBoot工程</title>
    <url>/posts/24668.html</url>
    <content><![CDATA[<h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><h4 id="开发第一个SpringBoot工程"><a href="#开发第一个SpringBoot工程" class="headerlink" title="开发第一个SpringBoot工程"></a>开发第一个SpringBoot工程</h4><ol>
<li><h5 id="创建maven工程，添加依赖"><a href="#创建maven工程，添加依赖" class="headerlink" title="创建maven工程，添加依赖"></a>创建maven工程，添加依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="添加classpath依赖"><a href="#添加classpath依赖" class="headerlink" title="添加classpath依赖"></a>添加classpath依赖</h5>Spring Boot提供了很多的Starter，可以把需要的jar添加到classpath中。<code>spring-boot-starter-parent  </code>是一个特殊的starter，它提供了很多有用的默认配置。但是它不会添加任何依赖。<br>当需要开发指定类型的程序，可以使用其他的starters。因为要开发的是一个web应用，所以需要添加一个<code>spring-boot-starter-web  </code>依赖。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h5>maven的源代码路径在<code>src/main/java</code>,创建如下java文件<code>src/main/java/MyApplication.java</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><h6 id="RestController与-RequestMapping注解"><a href="#RestController与-RequestMapping注解" class="headerlink" title="@RestController与@RequestMapping注解"></a><code>@RestController</code>与<code>@RequestMapping</code>注解</h6>​    <code>@RestController</code>是一种模式注解（stereotype annotation，主要用于表明当前组件在整个项目中的作用，比如@Service、@Repository、@Controllr）。它的作用是让spring和阅读代码的人知道当前class所扮演的角色。<br>​    <code>@RequestMapping</code>注解提供路由信息。它告诉spring，任何的对/的HTTP请求，都会被映射到home方法上。<code>@RestController</code>让spring直接将字符串结果返回给调用者。</li>
<li><h6 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title=" @EnableAutoConfiguration注解"></a><code> @EnableAutoConfiguration</code>注解</h6>​    <code> @EnableAutoConfiguration</code>使用用来让springboot去推测如何配置Spring，主要基于所添加的jar依赖。因为<code>spring-boot-starter-web</code>添加了Tomcat和Spring MVC，自动配置假设当前正在开发一个web应用并作相应的设置。<blockquote>
<p>Starters和自动配置（Auto-configuration）</p>
<p>​    自动配置和“Starters”可以很好的配合，但是这个两个概念并没有直接的关联。可以在sterer之外自由选择jar依赖，Spring Boot会尽可能地自动配置整个应用。</p>
</blockquote>
</li>
<li><h6 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h6>main方法是一个标准的复合Java规范的方法，是整个应用程序的入口。通过调用<code>run</code>方法，main方法完成了对Spring Boot的<code>SpringApplication</code>的代理。<code>SpringApplication</code>启动应用程序，启动Spring，同时自动配置Tomcat服务器。我们需要将<code>MyApplication.class</code>作为参数传递给<code>run</code>方法，从而让<code>SpringApplication</code>知道那个是Spring的基本组件。<code>args</code>数组同时也将命令行参数传递。</li>
<li>可以直接运行项目，并且访问8080端口即可看到输出。</li>
</ol>
</li>
<li><h5 id="创建一个可执行的Jar"><a href="#创建一个可执行的Jar" class="headerlink" title="创建一个可执行的Jar"></a>创建一个可执行的Jar</h5>​    通过创建一个可执行的独立的Jar文件，完成了实例。可执行Jar（有时也被称作“fat jars” 胖jar），是一个包含编译后的class文件和运行时依赖的jar的文档。<blockquote>
<p>可执行Jar和Java</p>
<p>​    Java并没有提供一种标准的方法,去载入嵌套的jar文件(jar文件被包含在一个jar文件内部).如果想要分发一个自包含的应用,可能会有问题.</p>
<p>​    去解决这个问题,许多开发者使用uber jar.一个uber jar把应用所需要的依赖的class文件打包进一个文档.这种方式的问题在于,去看当前应用程序中有哪些库变得很困难.同样,如果存在文件同名的情况,也会导致问题.</p>
</blockquote>
​    去创建一个可执行的jar,需要将<code>spring-boot-maven-plugin</code>添加到<code>pom.xml</code>中.需要再<code>dependency</code>后面添加如下部分.<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

​    调用mvn package命令 ,对程序进行打包.然后在<code>target</code>目录中,可以看到制作完成的jar包<code>myproject-0.0.1-SNAPSHOT.jar</code>.文件应该在10M左右.​    同时也可以看到一个小的多的文件,<code>myproject-0.0.1-SNAPSHOT.jar.original</code>.这个是maven打包的初始的jar,Spring Boot对这个进行再打包.​    运行程序,可以使用<code>java -jar</code>命令来运行打包后的应用.使用<code>ctrl -c</code>结束整个应用.</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>3.10 Feature: 安全</title>
    <url>/posts/58617.html</url>
    <content><![CDATA[<h5 id="安全-Security"><a href="#安全-Security" class="headerlink" title="安全(Security)"></a>安全(Security)</h5><p>如果Spring Security在classpath上,则默认情况下Web应用程序是安全的. Spring Boot依靠Spring Security的内容协商策略来确定是使用<code>httpBasic</code>还是<code>formLogin</code>.如果想要在应用添加方法级别的安全,可以使用<code>@EnableGlobalMethodSecurity</code>来进行设置.可以在<a href="https://docs.spring.io/spring-security/site/docs/5.5.0/reference/html5/#jc-method">Spring Security Reference Guide</a>中获得更多信息.<br>默认的<code>UserDetailsServic</code>只有一个用户. 用户名是<code>user</code>,密码是随机的,在应用启动时在INFO级别日志输出,如下例所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35</span><br></pre></td></tr></table></figure>

<p>如果想要调整日志配置,确保将<code>org.springframework.boot.autoconfigure.security</code>的日志级别设置为<code>INFO</code>级别. 不然,不会打印默认密码.<br>可以通过提供<code>spring.security.user.name</code>和<code>spring.security.user.password</code>来更改用户名和密码.<br>默认情况下,您在Web应用程序中的基本功能有:</p>
<ul>
<li>保留在内存中的,<code>UserDetailsService</code>(如果是WebFlux应用程序,则为<code>ReactiveUserDetailsService</code>)Bean和一个带有生成密码的单个用户(有关用户的属性,可以参阅<a href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html"><code>SecurityProperties.User</code></a>).</li>
<li>为整个应用程序提供,基于表单的登录或HTTP基本安全性(依赖请求中的<code>Accept</code>header)(如果actuator在classpath上,则包含actuator endpoints).</li>
<li>用于发布身份验证事件的<code>DefaultAuthenticationEventPublisher</code>.</li>
<li>可以添加Bean的方式来提供不同的<code>AuthenticationEventPublisher</code></li>
</ul>
<ol>
<li><h6 id="MVC安全性-MVC-Security"><a href="#MVC安全性-MVC-Security" class="headerlink" title="MVC安全性(MVC Security)"></a>MVC安全性(MVC Security)</h6>默认的安全配置在<code>SecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code>中实现.<code> SecurityAutoConfiguration</code>导入<code>SpringBootWebSecurityConfiguration</code>来保证网络安全,而<code>UserDetailsServiceAutoConfiguration</code>配置身份验证,这也与非Web应用程序相关.要完全关闭默认的Web应用程序安全性配置或组合多个Spring Security组件(例如OAuth2 Client和Resource Server).添加一个类型为<code>SecurityFilterChain</code>的bean(这样做不会禁用<code>UserDetailsService</code>配置或<code>Actuator</code>安全性).<br>如果要关闭<code>UserDetailsService</code>配置,可以添加类型为<code>UserDetailsService</code>,<code>AuthenticationProvider</code>或<code>AuthenticationManager</code>的bean.<br>可以添加自定义<code>SecurityFilterChain</code>或<code>WebSecurityConfigurerAdapter</code>bean,来覆盖访问规则.Spring Boot提供了方便的方法,可用来覆盖actuator endpoints和静态资源的访问规则.可以使用<code>EndpointRequest</code>创建基于<code>management.endpoints.web.base-path</code>属性的<code>RequestMatcher</code>.可以使用<code>PathRequest</code>为常用路径的资源创建一个<code>RequestMatcher</code>.</li>
<li><h6 id="WebFlux安全性-WebFlux-Security"><a href="#WebFlux安全性-WebFlux-Security" class="headerlink" title="WebFlux安全性( WebFlux Security)"></a>WebFlux安全性( WebFlux Security)</h6>与Spring MVC应用程序类似,可以添加<code>spring-boot-starter-security</code>依赖项来保护WebFlux应用程序.默认的安全配置在<code>ReactiveSecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code>中实现.<code>ReactiveSecurityAutoConfiguration</code>导入<code>WebFluxSecurityConfiguration</code>来实现Web安全,而<code>UserDetailsServiceAutoConfiguration</code>则用来配置身份验证,这在非Web应用程序中也很重要.如果想要完全禁用默认的Web应用安全性设置,可以添加<code>WebFilterChainProxy</code>类型的Bean来实现(这样做不会禁用<code>UserDetailsService</code>配置或Actuator的功能).<br>如果也要关闭<code>UserDetailsService</code>的配置,您可以添加<code>ReactiveUserDetailsService</code>或<code>ReactiveAuthenticationManager</code>类型的Bean.<br>通过添加自定义<code>SecurityWebFilterChain</code>bean,来配置访问规则和组合多个Spring Security组件(例如OAuth 2 Client和Resource Server).Spring Boot提供了一些可以用于覆盖 actuator endpoints和静态资源的访问规则的便捷的方法.<code>EndpointRequest</code>可用于创建基于<code>management.endpoints.web.base-path</code>属性的<code>ServerWebExchangeMatcher</code>.<br>可以使用<code>PathRequest</code>为常用路径中的资源创建<code>ServerWebExchangeMatcher</code>.<br>例如,您可以通过添加以下内容来自定义安全配置:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebFluxSecurityConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> SecurityWebFilterChain <span class="title">springSecurityFilterChain</span><span class="params">(ServerHttpSecurity http)</span> </span>&#123;</span><br><span class="line">  http.authorizeExchange((spec) -&gt; &#123;</span><br><span class="line">   spec.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll();</span><br><span class="line">   spec.pathMatchers(<span class="string">&quot;/foo&quot;</span>, <span class="string">&quot;/bar&quot;</span>).authenticated();</span><br><span class="line">  &#125;);</span><br><span class="line">  http.formLogin();</span><br><span class="line">  <span class="keyword">return</span> http.build();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h6>OAuth2是Spring支持的一种广泛使用的授权框架.<ol>
<li><h6 id="客户端-Client"><a href="#客户端-Client" class="headerlink" title="客户端(Client)"></a>客户端(Client)</h6>如果classpath上有<code>spring-security-oauth2-client</code>,则可以利用一些自动配置来设置OAuth2 / Open ID Connect客户端.这个配置使用<code>OAuth2ClientProperties</code>的属性. 相同的属性适用于servlet和响应式应用.<br>您可以在<code>spring.security.oauth2.client</code>前缀下注册多个OAuth2客户端和providers ,如以下示例所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-secret</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-name</span>=<span class="string">Client for user scope</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.provider</span>=<span class="string">my-oauth-provider</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.scope</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.redirect-uri</span>=<span class="string">https://my-redirect-uri.com</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-authentication-method</span>=<span class="string">basic</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.authorization-grant-type</span>=<span class="string">authorization-code</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-secret</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-name</span>=<span class="string">Client for email scope</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.provider</span>=<span class="string">my-oauth-provider</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.scope</span>=<span class="string">email</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.redirect-uri</span>=<span class="string">https://my-redirect-uri.com</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-authentication-method</span>=<span class="string">basic</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.authorization-grant-type</span>=<span class="string">authorization_code</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri</span>=<span class="string">https://my-auth-server/oauth/authorize</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.token-uri</span>=<span class="string">https://my-auth-server/oauth/token</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri</span>=<span class="string">https://my-auth-server/userinfo</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method</span>=<span class="string">header</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri</span>=<span class="string">https://my-auth-server/token_keys</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute</span>=<span class="string">name</span></span><br><span class="line">	 </span><br></pre></td></tr></table></figure>
对于支持 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect discovery</a>的OpenID Connectproviders ,可以进一步简化配置.provider需要配置一个<code>issuer-uri</code>,这是它声明Issuer Identifier的URI.例如,如果提供的issuer-uri是” <a href="https://example.com&quot;,则将向&quot;/">https://example.com&quot;,则将向&quot;</a> <a href="https://example.com/.well-known/openid-configuration&quot;%E5%8F%91%E5%87%BA">https://example.com/.well-known/openid-configuration&quot;发出</a> <code>OpenID Provider Configuration Request</code>.预期结果是<code>OpenID Provider Configuration Response</code>.以下示例显示了如何使用<code>issuer-uri</code>配置OpenID Connect Provider:</li>
</ol>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.client.provider.oidc-provider.issuer-uri</span>=<span class="string">https://dev-123456.oktapreview.com/oauth2/default/</span></span><br><span class="line">	</span><br></pre></td></tr></table></figure>
   默认情况下,Spring Security的<code>OAuth2LoginAuthenticationFilter</code>仅处理与<code>/login/oauth2/code/*</code>匹配的URL.如果要自定义<code>redirect-uri</code>来使用其他pattern,则需要提供配置来处理该自定义pattern.例如,对于servlet应用程序,您可以添加自定义的<code>SecurityFilterChain</code>,如下: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOAuthClientConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> SecurityFilterChain <span class="title">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">  http.oauth2Login().redirectionEndpoint().baseUri(<span class="string">&quot;custom-callback&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> http.build();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    Spring Boot自动配置一个<code>InMemoryOAuth2AuthorizedClientService</code>,Spring Security使用它来管理客户端注册.<code>InMemoryOAuth2AuthorizedClientService</code>的功能有限,建议仅将其用于开发环境.对于生产环境,考虑使用<code>JdbcOAuth2AuthorizedClientService</code>或实现自己的<code>OAuth2AuthorizedClientService</code>接口.</p>
</blockquote>
<h6 id="常见provider的OAuth2客户端注册-OAuth2-client-registration-for-common-providers"><a href="#常见provider的OAuth2客户端注册-OAuth2-client-registration-for-common-providers" class="headerlink" title="常见provider的OAuth2客户端注册(OAuth2 client registration for common providers)"></a>常见provider的OAuth2客户端注册(OAuth2 client registration for common providers)</h6>   对于常见的OAuth2和OpenID providers,包括Google,Github,Facebook和Okta,我们提供了一组提供程序默认值(分别是<code>google</code>,<code>github</code>,<code>facebook</code>和<code>okta</code>)<br>   如果不需要自定义这些providers,则可以将<code>provider</code>属性设置为需要推断默认值的属性.另外,如果客户端注册的密钥与默认的支持的provider匹配,Spring Boot也会推断出该provider.<br>   换句话说,以下示例中的两种配置都使用Google provider:<pre><code> <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client.client-secret</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client.provider</span>=<span class="string">google</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.google.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.google.client-secret</span>=<span class="string">password</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><h6 id="资源服务器-Resource-Server"><a href="#资源服务器-Resource-Server" class="headerlink" title="资源服务器(Resource Server)"></a>资源服务器(Resource Server)</h6> 如果您的classpath上有<code>spring-security-oauth2-resource-server</code>,则Spring Boot可以配置OAuth2资源服务器.对于JWT配置,需要指定JWK Set URI或 OIDC Issuer URI,如以下示例所示: <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.resourceserver.jwt.jwk-set-uri</span>=<span class="string">https://example.com/oauth2/default/v1/keys</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.resourceserver.jwt.issuer-uri</span>=<span class="string">https://dev-123456.oktapreview.com/oauth2/default/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    如果授权服务器不支持JWK Set URI,则可以使用用于验证JWT签名的公钥来配置资源服务器.可以使用<code>spring.security.oauth2.resourceserver.jwt.public-key-location</code>属性完成此操作,该值需要指向包含PEM编码的x509格式的公钥的文件.</p>
</blockquote>
 相同的属性适用于servlet和响应式应用.<br> 另外,您可以为Servlet应用程序定义自己的<code>JwtDecoder</code>Bean,或者为响应式应用定义<code>ReactiveJwtDecoder</code>.<br> 如果使用不透明令牌而不是JWT,则可以配置以下属性以通过introspection来验证令牌:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.resourceserver.opaquetoken.introspection-uri</span>=<span class="string">https://example.com/check-token</span></span><br><span class="line"><span class="meta">spring.security.oauth2.resourceserver.opaquetoken.client-id</span>=<span class="string">my-client-id</span></span><br><span class="line"><span class="meta">spring.security.oauth2.resourceserver.opaquetoken.client-secret</span>=<span class="string">my-client-secret</span></span><br></pre></td></tr></table></figure>
 同样,相同的属性适用于servlet和响应式应用.<br> 另外,可以为Servlet应用程序定义自己的<code>OpaqueTokenIntrospector</code>Bean,或者为响应式应用定义<code>ReactiveOpaqueTokenIntrospector</code>.</li>
<li><h6 id="授权服务器-Authorization-Server"><a href="#授权服务器-Authorization-Server" class="headerlink" title="授权服务器(Authorization Server)"></a>授权服务器(Authorization Server)</h6>当前,Spring Security不支持实现OAuth 2.0授权服务器.但是,Spring Security OAuth项目提供了此功能,这最终将被Spring Security完全取代.在此之前,可以使用<code>spring-security-oauth2-autoconfigure</code>模块来很容易地设置OAuth 2.0授权服务器； 有关说明,请参见 <a href="https://docs.spring.io/spring-security-oauth2-boot/">documentation</a> .</li>
<li><h6 id="SAML-2-0"><a href="#SAML-2-0" class="headerlink" title="SAML 2.0"></a>SAML 2.0</h6><ol>
<li><h6 id="Relying-Party"><a href="#Relying-Party" class="headerlink" title="Relying Party"></a>Relying Party</h6>如果您在classpath中具有<code>spring-security-saml2-service-provider</code>,则可以使用自动配置来设置SAML 2.0依赖方.此配置使用<code>Saml2RelyingPartyProperties</code>下的属性.<br>一个依赖方注册代表 Identity Provider, IDP和Service Provider, SP之间的配对配置.可以在<code>spring.security.saml2.relyingparty</code>前缀下注册多个依赖方,如以下示例所示:</li>
</ol>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location</span>=<span class="string">path-to-private-key</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location</span>=<span class="string">path-to-certificate</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.decryption.credentials[0].private-key-location</span>=<span class="string">path-to-private-key</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.decryption.credentials[0].certificate-location</span>=<span class="string">path-to-certificate</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.verification.credentials[0].certificate-location</span>=<span class="string">path-to-verification-cert</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.entity-id</span>=<span class="string">remote-idp-entity-id1</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.sso-url</span>=<span class="string">https://remoteidp1.sso.url</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location</span>=<span class="string">path-to-private-key</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location</span>=<span class="string">path-to-certificate</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.decryption.credentials[0].private-key-location</span>=<span class="string">path-to-private-key</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.decryption.credentials[0].certificate-location</span>=<span class="string">path-to-certificate</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.verification.credentials[0].certificate-location</span>=<span class="string">path-to-other-verification-cert</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.entity-id</span>=<span class="string">remote-idp-entity-id2</span></span><br><span class="line"><span class="meta">spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.sso-url</span>=<span class="string">https://remoteidp2.sso.url</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Actuator安全性-Actuator-Security"><a href="#Actuator安全性-Actuator-Security" class="headerlink" title="Actuator安全性(Actuator Security)"></a>Actuator安全性(Actuator Security)</h6>为了安全起见,默认情况下禁用<code>/health</code>以外的所有actuator.可以使用 <code>management.endpoints.web.exposure.include</code>启用actuator.<br>如果Spring Security位于classpath中,并且不存在其他<code>WebSecurityConfigurerAdapter</code>或<code>SecurityFilterChain</code>Bean,则<code>/health</code>以外的actuators均由Spring Boot自动配置保护.如果自定义了<code>WebSecurityConfigurerAdapter</code>或<code>SecurityFilterChain</code>bean,那么Spring Boot的自动配置将退出,开发者将完全控制actuator访问规则.<blockquote>
<p>建议:</p>
<p>​    在设置<code>management.endpoints.web.exposure.include</code>之前,请确保公开的actuator不包含敏感信息和/或通过将它们放置在防火墙后面,或者使用Spring Security之类的方法进行保护.</p>
</blockquote>
<ol>
<li><h6 id="跨站点请求伪造保护-Cross-Site-Request-Forgery-Protection"><a href="#跨站点请求伪造保护-Cross-Site-Request-Forgery-Protection" class="headerlink" title="跨站点请求伪造保护(Cross Site Request Forgery Protection)"></a>跨站点请求伪造保护(Cross Site Request Forgery Protection)</h6>由于Spring Boot使用Spring Security的默认设置,因此CSRF保护默认情况下处于启用状态. 这意味着在使用默认安全配置时,需要<code>POST</code>(关闭和记录器endpoint),<code>PUT</code>或<code>DELETE</code>的actuator endpoint将收到403禁止错误.<blockquote>
<p>建议:</p>
<p>​    如果创建的服务,只是给非浏览器的客户端使用时,建议完全禁用CSRF保护.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.13 Feature: 缓存</title>
    <url>/posts/54951.html</url>
    <content><![CDATA[<h5 id="13-缓存-Caching"><a href="#13-缓存-Caching" class="headerlink" title="13 缓存(Caching)"></a>13 缓存(Caching)</h5><ol start="13">
<li><h5 id="缓存-Caching"><a href="#缓存-Caching" class="headerlink" title="缓存(Caching)"></a>缓存(Caching)</h5><p>Spring Framework 支持透明地向应用程序添加缓存. 在其核心,抽象上,对方法使用缓存,从而根据缓存中可用的信息,减少执行次数.缓存逻辑是透明化应用的,对调用者没有任何干扰. 只要通过<code>@EnableCaching</code> 注释启用缓存支持,Spring Boot 就会自动配置缓存基础结构.</p>
<blockquote>
<p>注意:</p>
<p>​    查看 Spring Framework 参考的相关部分(<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#cache">relevant section</a>)以获取更多详细信息.</p>
</blockquote>
<p>简而言之,要将缓存添加到服务的操作中,在其方法中添加相关的注解,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMathService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(&quot;piDecimals&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computePiDecimal</span><span class="params">(<span class="keyword">int</span> precision)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此示例演示了对潜在代价高昂的操作使用缓存.在调用 <code>computePiDecimal</code> 之前,抽象会在 <code>piDecimals</code> 缓存中查找与 <code>i</code> 参数匹配的条目. 如果找到一个条目,缓存中的内容会立即返回给调用者,并且不会调用该方法. 否则,调用该方法,并在返回值之前更新缓存.</p>
<blockquote>
<p>警告:</p>
<p>​    还可以透明地使用标准 JSR-107 (JCache) 注释(例如 <code>@CacheResult</code>). 但是,强烈建议不要混合搭配 Spring Cache 和 JCache 注释.</p>
</blockquote>
<p>如果不添加任何特定的缓存库,Spring Boot 会自动配置一个在内存中使用concurrent  Map的简单provider.当需要缓存时(例如前面示例中的 <code>piDecimals</code>),provider会创建它.不建议将 simple provider 用于生产用途,但它非常适合入门并帮助了解这些功能.当决定要使用的缓存provider时,务必阅读其文档以了解如何配置应用所用的缓存.几乎所有provider都要求在应用中显式配置使用的每个缓存. 有些提供了一种自定义由 <code>spring.cache.cache-names</code> 属性定义的默认缓存的方法.  </p>
<blockquote>
<p>建议:</p>
<p>​    还可以从缓存中透明地更新或驱逐数据(<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#cache-annotations-put">update</a> or <a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#cache-annotations-evict">evict</a>).</p>
</blockquote>
<ol>
<li><h6 id="支持的缓存Provider-Supported-Cache-Providers"><a href="#支持的缓存Provider-Supported-Cache-Providers" class="headerlink" title="支持的缓存Provider(Supported Cache Providers)"></a>支持的缓存Provider(Supported Cache Providers)</h6><p>缓存抽象不提供实际存储,并且依赖于 <code>org.springframework.cache.Cache</code> 和 <code>org.springframework.cache.CacheManager</code> 接口具体化的抽象.</p>
<p>如果尚未定义 <code>CacheManager</code> 类型的 bean 或名为 <code>cacheResolver</code> 的 <code>CacheResolver</code>(参阅 <code>CachingConfigurer</code>),Spring Boot 会尝试检测以下提供程序(按指示的顺序):</p>
<ol>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.generic">Generic</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.jcache">JCache (JSR-107)</a> (EhCache 3, Hazelcast, Infinispan, 和其他)</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.ehcache2">EhCache 2.x</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.hazelcast">Hazelcast</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.infinispan">Infinispan</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.couchbase">Couchbase</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.redis">Redis</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.caffeine">Caffeine</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.simple">Simple</a></li>
</ol>
<blockquote>
<p>建议:</p>
<p>​    也可以通过设置 <code>spring.cache.type</code> 属性来<strong>强制</strong>特定的cache provider.如果需要在某些环境(例如测试)中完全禁用缓存(<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.caching.provider.none">disable caching altogether</a>),请使用此属性.</p>
<p>建议:</p>
<p>​    使用 <code>spring-boot-starter-cache</code> “Starter” 快速添加基本缓存依赖.starter 引入了 <code>spring-context-support</code>.如果手动添加依赖项,则必须包含 <code>spring-context-support</code> 才能使用 JCache,EhCache 2.x 或 Caffeine 支持.</p>
</blockquote>
<p>如果 <code>CacheManager</code> 是由 Spring Boot 自动配置的,可以在它完全初始化之前通过公开实现 <code>CacheManagerCustomizer</code> 接口的 bean 进一步调整其配置.以下示例设置了一个标志,表示应将<code>null</code>传递给底层映射:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheManagerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (cacheManager) -&gt; cacheManager.setAllowNullValues(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    在前面的示例中,需要一个自动配置的 <code>ConcurrentMapCacheManager</code>. 如果不是这种情况(提供了自己的配置或自动配置了不同的缓存provider),则根本不会调用自定义程序. 可以根据需要,使用任意数量的customizers,也可以使用 <code>@Order</code> 或 <code>Ordered</code> 对它们进行排序.</p>
</blockquote>
<ol>
<li><h6 id="通用-Generic"><a href="#通用-Generic" class="headerlink" title="通用(Generic)"></a>通用(Generic)</h6><p>如果上下文<em><strong>至少</strong></em>定义了一个 <code>org.springframework.cache.Cache</code> bean,则使用通用缓存.创建了一个包装所有该类型 bean 的 <code>CacheManager</code>.</p>
</li>
<li><h6 id="JCache-JSR-107"><a href="#JCache-JSR-107" class="headerlink" title="JCache (JSR-107)"></a>JCache (JSR-107)</h6><p>JCache 通过classpath存在的 <code>javax.cache.spi.CachingProvider</code> 进行引导(即classpath上存在符合 JSR-107 的缓存库),而 <code>JCacheCacheManager</code> 由 <code>spring-boot-starter-cache</code> 提供 “Starter”.各种兼容库都可用,Spring Boot 为 Ehcache3,Hazelcast 和 Infinispan 提供依赖管理.也可以添加任何其他兼容的库.</p>
<p>可能会出现多个provider,在这种情况下,必须显式指定provider.即使 JSR-107 标准没有强制使用标准化的方式来指定配置文件的位置,Spring Boot 也会尽量设置缓存和实现细节,如下面的例子所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Only necessary if more than one provider is present</span></span><br><span class="line"><span class="meta">spring.cache.jcache.provider</span>=<span class="string">com.example.MyCachingProvider</span></span><br><span class="line"><span class="meta">spring.cache.jcache.config</span>=<span class="string">classpath:example.xml</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    当缓存库同时提供本地实现和 JSR-107支持时,Spring Boot 首选JSR-107 支持,以便在切换到不同的 JSR-107 实现时可以使用相同的功能.</p>
<p>建议:</p>
<p>​    Spring Boot 支持 Hazelcast.如果有一个<code>HazelcastInstance</code>可用,则它也会自动为 <code>CacheManager</code> 重用,除非指定了<code>spring.cache.jcache.config</code>属性</p>
</blockquote>
<p>有两种方式来自定义底层的<code>javax.cache.cacheManager</code>:</p>
<ul>
<li>可以通过设置 <code>spring.cache.cache-names</code> 属性在启动时创建缓存. 如果自定义了<code>javax.cache.configuration.Configuration</code> bean,则用于自定义属性.</li>
<li>使用 <code>CacheManager</code>的引用来调用<code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> bean 从而进行完全自定义.</li>
</ul>
<blockquote>
<p>建议:</p>
<p>​    如果定义了标准 <code>javax.cache.CacheManager</code> bean,会在<code>org.springframework.cache.CacheManager</code>实现(抽象所期望的)中自动包装,. 不会对其应用进一步的自定义.</p>
</blockquote>
</li>
<li><h6 id="EhCache-2-x"><a href="#EhCache-2-x" class="headerlink" title="EhCache 2.x"></a>EhCache 2.x</h6><p>如果可以在classpath的根目录找到名为<code>ehcache.xml</code>的文件,则使用 EhCache 2.x. 如果找到 EhCache 2.x,则使用 <code>spring-boot-starter-cache</code> “Starter” 提供的 <code>EhCacheCacheManager</code> 来引导缓存管理器.也可以提供备用配置文件,如以下示例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cache.ehcache.config</span>=<span class="string">classpath:config/another-config.xml</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h6><p>Spring Boot 支持 Hazelcast. 如果 <code>HazelcastInstance</code> 已自动配置,则它会自动包装在 <code>CacheManager</code> 中.</p>
</li>
<li><h6 id="Infinispan"><a href="#Infinispan" class="headerlink" title="Infinispan"></a>Infinispan</h6><p>Infinispan 没有默认配置文件位置,因此必须显式指定. 否则,使用默认引导程序:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cache.infinispan.config</span>=<span class="string">infinispan.xml</span></span><br></pre></td></tr></table></figure>

<p>可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存.如果自定义了 <code>ConfigurationBuilder</code> bean,它将用于自定义缓存.</p>
<blockquote>
<p>建议:</p>
<p>​    Spring Boot 对 Infinispan 的支持仅限于嵌入式模式,并且非常基础.如果想要更多的选择,应该使用官方的 Infinispan Spring Boot starter. 有关更多详细信息,请参阅 Infinispan(<a href="https://github.com/infinispan/infinispan-spring-boot">Infinispan’s documentation</a>) 的文档.</p>
</blockquote>
</li>
<li><h6 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h6><p>如果 Spring Data Couchbase 可用并且配置了 Couchbase,则<code>CouchbaseCacheManager</code>会自动配置.可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建额外的缓存,并且可以使用 <code>spring.cache.couchbase.*</code> 属性配置缓存默认值.例如,以下配置创建 <code>cache1</code> 和 <code>cache2</code> 缓存,条目过期时间为 10 分钟:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="meta">spring.cache.couchbase.expiration</span>=<span class="string">10m</span></span><br></pre></td></tr></table></figure>

<p>如果需要对配置进行更多控制,请考虑注册 <code>CouchbaseCacheManagerBuilderCustomizer</code> bean.以下示例显示了为 <code>cache1</code> 和 <code>cache2</code> 配置特定条目到期时间的customizer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCouchbaseCacheManagerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CouchbaseCacheManagerBuilderCustomizer <span class="title">myCouchbaseCacheManagerBuilderCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (builder) -&gt; builder</span><br><span class="line">                .withCacheConfiguration(<span class="string">&quot;cache1&quot;</span>, CouchbaseCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryExpiry(Duration.ofSeconds(<span class="number">10</span>)))</span><br><span class="line">                .withCacheConfiguration(<span class="string">&quot;cache2&quot;</span>, CouchbaseCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryExpiry(Duration.ofMinutes(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><p>如果 Redis 可用并已配置,则自动配置 <code>RedisCacheManager</code>. 如果想要在启动时添加额外缓存, 可以设置<code>spring.cache.cache-names</code>属性,并且可以使用 <code>spring.cache.redis.*</code> 属性配置缓存默认值.例如,以下配置创建 <code>cache1</code> 和 <code>cache2</code> 缓存,生存时间为 10 分钟:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="meta">spring.cache.redis.time-to-live</span>=<span class="string">10m</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    默认情况下,添加了一个key前缀,这样,如果两个单独的缓存使用相同的key,Redis 不会有重叠的键,也不会返回无效值.如果创建自己的 <code>RedisCacheManager</code>,我们强烈建议您启用此设置.</p>
<p>建议:</p>
<p>​    可以通过添加自己的 <code>RedisCacheConfiguration</code> <code>@Bean</code> 来完全控制默认配置.如果自定义默认序列化策略,这会很有.</p>
</blockquote>
<p>如果需要对配置进行更多控制,可以考虑注册一个 <code>RedisCacheManagerBuilderCustomizer</code> bean.以下示例显示了为 <code>cache1</code> 和 <code>cache2</code> 配置特定生存时间的customizer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisCacheManagerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManagerBuilderCustomizer <span class="title">myRedisCacheManagerBuilderCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (builder) -&gt; builder</span><br><span class="line">                .withCacheConfiguration(<span class="string">&quot;cache1&quot;</span>, RedisCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryTtl(Duration.ofSeconds(<span class="number">10</span>)))</span><br><span class="line">                .withCacheConfiguration(<span class="string">&quot;cache2&quot;</span>, RedisCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig().entryTtl(Duration.ofMinutes(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h6><p>Caffeine 是对 Guava 缓存的 Java 8 重写,取代了对 Guava 的支持.如果存在 Caffeine,则会自动配置 <code>CaffeineCacheManager</code>(由 <code>spring-boot-starter-cache</code> “Starter”提供). 可以通过设置 <code>spring.cache.cache-names</code> 属性, 在启动时创建缓存,并且可以通过以下之一(按指示的顺序)进行自定义:</p>
<ol>
<li>使用 <code>spring.cache.caffeine.spec</code> 定义的缓存规范</li>
<li>定义 <code>com.github.benmanes.caffeine.cache.CaffeineSpec</code> bean</li>
<li>定义 <code>com.github.benmanes.caffeine.cache.Caffeine</code> bean</li>
</ol>
<p>例如,以下配置创建 <code>cache1</code> 和 <code>cache2</code> 缓存,最大大小为 500,生存时间为 10 分钟:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="meta">spring.cache.caffeine.spec</span>=<span class="string">maximumSize=500,expireAfterAccess=600s</span></span><br></pre></td></tr></table></figure>

<p>如果定义了 <code>com.github.benmanes.caffeine.cache.CacheLoader</code> bean,它会自动关联到 <code>CaffeineCacheManager</code>. 由于 <code>CacheLoader</code> 将与缓存管理器管理的<em><strong>所有</strong></em>缓存相关联,因此必须将其定义为 <code>CacheLoader&lt;Object, Object&gt;</code>. 自动配置忽略任何其他通用类型.</p>
</li>
<li><h6 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h6><p>如果找不到其他providers,则指定 <code>ConcurrentHashMap</code> 作为缓存存储.如果应用程序中不存在缓存库,则这是默认设置.默认情况下,会根据需要创建缓存,但可以通过设置 <code>cache-names</code> 属性来限制可用缓存的列表.例如,如果只想要 <code>cache1</code> 和 <code>cache2</code> 缓存,设置 <code>cache-names</code> 属性如下:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br></pre></td></tr></table></figure>

<p>如果这样做,并且应用使用了未列出的缓存,那么在使用缓存而缓存不存在时,会运行时失败,但不会在启动时失败.如果使用未声明的缓存,这类似于”真实”缓存providers的行为方式.</p>
</li>
<li><h6 id="None"><a href="#None" class="headerlink" title="None"></a>None</h6><p>当配置中存在 <code>@EnableCaching</code> 时,也需要合适的缓存配置.如果需要在某些环境中完全禁用缓存,可以将缓存类型强制为 <code>none</code> 以使用无操作实现,如下例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cache.type</span>=<span class="string">none</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.15 Feature: 使用RestTemplate 调用 REST 服务</title>
    <url>/posts/54638.html</url>
    <content><![CDATA[<h5 id="3-15-使用-RestTemplate-调用-REST-服务"><a href="#3-15-使用-RestTemplate-调用-REST-服务" class="headerlink" title="3.15 使用 RestTemplate 调用 REST 服务"></a>3.15 使用 RestTemplate 调用 REST 服务</h5><ol start="15">
<li><h5 id="使用-RestTemplate-调用-REST-服务-Calling-REST-Services-with-RestTemplate"><a href="#使用-RestTemplate-调用-REST-服务-Calling-REST-Services-with-RestTemplate" class="headerlink" title="使用 RestTemplate 调用 REST 服务(Calling REST Services with RestTemplate)"></a>使用 RestTemplate 调用 REST 服务(Calling REST Services with RestTemplate)</h5><p>如果需要从应用中调用远程 REST 服务,可以使用 Spring Framework 的 <code>RestTemplate</code> 类.由于 <code>RestTemplate</code> 实例在使用前经常需要自定义,因此 Spring Boot 没有提供任何单个自动配置的 <code>RestTemplate</code> bean.然而,它会自动配置一个 <code>RestTemplateBuilder</code>,它可以在需要时用于创建 <code>RestTemplate</code> 实例.自动配置的 <code>RestTemplateBuilder</code> 确保将合适的 <code>HttpMessageConverters</code>应用于 <code>RestTemplate</code> 实例.</p>
<p>以下代码显示了一个典型示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Details <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;/&#123;name&#125;/details&quot;</span>, Details.class, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    <code>RestTemplateBuilder</code> 包含许多有用的方法,可用于快速配置 <code>RestTemplate</code>.例如,要添加 BASIC 身份验证支持,您可以使用 <code>builder.basicAuthentication(&quot;user&quot;, &quot;password&quot;).build()</code>.</p>
</blockquote>
<ol>
<li><h6 id="自定义RestTemplate-RestTemplate-Customization"><a href="#自定义RestTemplate-RestTemplate-Customization" class="headerlink" title="自定义RestTemplate (RestTemplate Customization)"></a>自定义RestTemplate (RestTemplate Customization)</h6><p>自定义<code>RestTemplate</code> 有三种主要方法,具体取决于自定义应用的范围.</p>
<p>为了尽可能缩小任何自定义的范围,注入自动配置的 <code>RestTemplateBuilder</code>,然后根据需要调用其方法.每个方法调用都会返回一个新的 <code>RestTemplateBuilder</code> 实例,因此自定义值影响构建器的使用.</p>
<p>要进行应用范围上的的,额外的自定义,使用 <code>RestTemplateCustomizer</code> bean.所有这些 bean 都会自动注册到自动配置的 <code>RestTemplateBuilder</code> 并应用于使用它构建的任何模板.</p>
<p>以下示例显示了一个定制器,它为除 <code>192.168.0.5</code> 之外的所有主机配置代理的使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestTemplateCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        HttpRoutePlanner routePlanner = <span class="keyword">new</span> CustomRoutePlanner(<span class="keyword">new</span> HttpHost(<span class="string">&quot;proxy.example.com&quot;</span>));</span><br><span class="line">        HttpClient httpClient = HttpClientBuilder.create().setRoutePlanner(routePlanner).build();</span><br><span class="line">        restTemplate.setRequestFactory(<span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRoutePlanner</span> <span class="keyword">extends</span> <span class="title">DefaultProxyRoutePlanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CustomRoutePlanner(HttpHost proxy) &#123;</span><br><span class="line">            <span class="keyword">super</span>(proxy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> HttpHost <span class="title">determineProxy</span><span class="params">(HttpHost target, HttpRequest request, HttpContext context)</span> <span class="keyword">throws</span> HttpException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (target.getHostName().equals(<span class="string">&quot;192.168.0.5&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.determineProxy(target, request, context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后,还可以创建自己的 <code>RestTemplateBuilder</code> bean.为了防止关闭 <code>RestTemplateBuilder </code>的自动配置,并防止使用任何 <code>RestTemplateCustomizer</code> bean,确保使用 <code>RestTemplateBuilderConfigurer</code> 配置自定义实例.下面的示例公开了一个Spring Boot 自动配置的 <code>RestTemplateBuilder</code>,还指定了自定义连接和读取超时:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestTemplateBuilderConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">(RestTemplateBuilderConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configurer.configure(<span class="keyword">new</span> RestTemplateBuilder()).setConnectTimeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                .setReadTimeout(Duration.ofSeconds(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最极端(也很少使用)的选项是在不使用配置器,创建自己的 <code>RestTemplateBuilder</code> bean.这样做会关闭 <code>RestTemplateBuilder</code> 的自动配置并禁用任何的 <code>RestTemplateCustomizer</code> bean.</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.16 Feature: 使用 WebClient 调用 REST 服务</title>
    <url>/posts/64077.html</url>
    <content><![CDATA[<h5 id="3-16-使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient"><a href="#3-16-使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient" class="headerlink" title="3.16 使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)"></a>3.16 使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)</h5><ol start="16">
<li><h6 id="使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient"><a href="#使用-WebClient-调用-REST-服务-Calling-REST-Services-with-WebClient" class="headerlink" title="使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)"></a>使用 WebClient 调用 REST 服务 (Calling REST Services with WebClient)</h6><p>如果classpath上有 Spring WebFlux,也可以选择使用 <code>WebClient</code> 来调用远程 REST 服务.与 <code>RestTemplate</code> 相比,这个客户端更加函数式,并且是完全响应式的.可以在 Spring Framework 文档的专门部分中了解有关 WebClient 的更多信息.</p>
<p>Spring Boot 为创建并预配置了一个 <code>WebClient.Builder</code>. 强烈建议将其注入到组件中并使用它来创建 <code>WebClient</code> 实例.Spring Boot 正在配置该构建器以共享 HTTP 资源,以与服务器相同的方式反映编解码器设置(请参阅 WebFlux HTTP 编解码器自动配置 <a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-web-applications.spring-webflux.httpcodecs">WebFlux HTTP codecs auto-configuration</a>)等等.</p>
<p>以下代码显示了一个典型示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebClient.Builder webClientBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webClient = webClientBuilder.baseUrl(<span class="string">&quot;https://example.org&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Details&gt; <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.webClient.get().uri(<span class="string">&quot;/&#123;name&#125;/details&quot;</span>, name).retrieve().bodyToMono(Details.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><h6 id="WebClient-运行时-WebClient-Runtime"><a href="#WebClient-运行时-WebClient-Runtime" class="headerlink" title="WebClient 运行时 (WebClient Runtime)"></a>WebClient 运行时 (WebClient Runtime)</h6><p>Spring Boot 将自动检测使用哪个 <code>ClientHttpConnector</code> 来驱动 <code>WebClient</code>,具体取决于应用程序classpath上可用的库.目前,支持 Reactor Netty 和 Jetty RS 客户端.<code>spring-boot-starter-webflux</code> “starter” 默认依赖于 <code>io.projectreactor.netty:reactor-netty</code>,它带来了服务端和客户端的实现.如果您选择使用 Jetty 作为响应式服务器,则应添加对 Jetty Reactive HTTP 客户端库的依赖 <code>org.eclipse.jetty:jetty-reactive-httpclient</code>.服务器和客户端使用相同的技术有其优势,因为它会自动在客户端和服务器之间共享 HTTP 资源.</p>
<p>开发人员可以通过提供自定义的 <code>ReactorResourceFactory</code> 或 <code>JettyResourceFactory</code> bean 来覆盖 Jetty 和 Reactor Netty 的资源配置 - 这将应用于客户端和服务器.</p>
<p>如果希望覆盖客户端该选择,可以定义自己的 <code>ClientHttpConnector</code> bean 并完全控制客户端配置.</p>
<p>可以在 Spring Framework 参考文档中了解有关 <code>WebClient</code> 配置选项的更多信息(<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/web-reactive.html#webflux-client-builder"><code>WebClient</code> configuration options in the Spring Framework reference documentation</a>).</p>
</li>
<li><h6 id="自定义WebClient-WebClient-Customization"><a href="#自定义WebClient-WebClient-Customization" class="headerlink" title="自定义WebClient (WebClient Customization)"></a>自定义WebClient (WebClient Customization)</h6><p> 自定义<code>WebClient</code>有三种方法,具体取决于希望自定义应用的范围.</p>
<p>为了尽可能缩小任何自定义的范围,注入自动配置的 <code>WebClient.Builder</code>,然后根据需要调用其方法.<code>WebClient.Builder</code> 实例是有状态的:Builder上的任何更改都会反映在随后使用它创建的所有客户端中.如果想用同一个构建器创建多个客户端,也可以考虑使用 <code>WebClient.Builder other = builder.clone();</code> 克隆构建器.</p>
<p>要对所有 <code>WebClient.Builder</code> 实例进行应用范围的,额外的自定义,可以声明 <code>WebClientCustomizer</code> bean 并在注入点本地更改 <code>WebClient.Builder</code>.</p>
<p>最后,可以回退到原始 API, 使用 <code>WebClient.create()</code>. 在这种情况下,不会应用自动配置或 <code>WebClientCustomizer</code>.</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.17 Feature: 校验</title>
    <url>/posts/45647.html</url>
    <content><![CDATA[<h5 id="3-17-校验-Validation"><a href="#3-17-校验-Validation" class="headerlink" title="3.17 校验(Validation)"></a>3.17 校验(Validation)</h5><ol start="17">
<li><h6 id="校验-Validation"><a href="#校验-Validation" class="headerlink" title="校验(Validation)"></a>校验(Validation)</h6><p>只要 JSR-303 实现(例如 Hibernate 验证器)在classpath上,Bean Validation 1.1 支持的方法验证功能就会自动启用.这让 bean 方法可以使用 <code>javax.validation</code> 注解对其参数和/或返回值的进行约束.带有这种注解标注的方法的目标类需要在类型级别使用 <code>@Validated</code> 注解进行标注,以便在类内方法中搜索内联约束注解.</p>
<p>例如,以下服务触发第一个参数的验证,确保其大小在 8 到 10 之间:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Archive <span class="title">findByCodeAndAuthor</span><span class="params">(<span class="meta">@Size(min = 8, max = 10)</span> String code, Author author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.18 Feature: 发送邮件</title>
    <url>/posts/34767.html</url>
    <content><![CDATA[<h5 id="3-18-发送邮件-Sending-Email"><a href="#3-18-发送邮件-Sending-Email" class="headerlink" title="3.18 发送邮件 (Sending Email)"></a>3.18 发送邮件 (Sending Email)</h5><ol start="18">
<li><h5 id="发送邮件-Sending-Email"><a href="#发送邮件-Sending-Email" class="headerlink" title="发送邮件 (Sending Email)"></a>发送邮件 (Sending Email)</h5><p>Spring Framework 提供了使用 <code>JavaMailSender</code> 接口发送电子邮件的抽象,Spring Boot 为其提供了自动配置以及 starter 模块.</p>
<blockquote>
<p>建议:</p>
<p>​    有关如何使用 JavaMailSender 的详细说明,请参阅参考文档(<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#mail">reference documentation</a>).</p>
</blockquote>
<p>如果 <code>spring.mail.host</code> 和相关库(由 <code>spring-boot-starter-mail</code> 定义)可用,如果<code>JavaMailSender</code>不存在,则会创建默认的 <code>JavaMailSender</code>.可以通过 <code>spring.mail</code> 命名空间中的配置项进一步自定义sender . 有关更多详细信息,参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java"><code>MailProperties</code></a>.</p>
<p>特别是,某些默认超时值是无限的,可能希望更改该值以避免线程被无响应的邮件服务器所阻塞,如下例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mail.properties[mail.smtp.connectiontimeout]</span>=<span class="string">5000</span></span><br><span class="line"><span class="meta">spring.mail.properties[mail.smtp.timeout]</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">spring.mail.properties[mail.smtp.writetimeout]</span>=<span class="string">5000</span></span><br></pre></td></tr></table></figure>

<p>还可以使用来自 JNDI 的现有<code>Session</code>配置 <code>JavaMailSender</code>:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mail.jndi-name</span>=<span class="string">mail/Session</span></span><br></pre></td></tr></table></figure>

<p>设置 <code>jndi-name</code> 时,它优先于所有其他与会话相关的设置.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.19 Feature: 使用 JTA 的分布式事务</title>
    <url>/posts/16277.html</url>
    <content><![CDATA[<h5 id="3-19-使用-JTA-的分布式事务-Distributed-Transactions-with-JTA"><a href="#3-19-使用-JTA-的分布式事务-Distributed-Transactions-with-JTA" class="headerlink" title="3.19 使用 JTA 的分布式事务(Distributed Transactions with JTA)"></a>3.19 使用 JTA 的分布式事务(Distributed Transactions with JTA)</h5><ol start="19">
<li><h6 id="使用-JTA-的分布式事务-Distributed-Transactions-with-JTA"><a href="#使用-JTA-的分布式事务-Distributed-Transactions-with-JTA" class="headerlink" title="使用 JTA 的分布式事务(Distributed Transactions with JTA)"></a>使用 JTA 的分布式事务(Distributed Transactions with JTA)</h6><p>Spring Boot 通过使用 Atomikos 嵌入式事务管理器支持跨多个 XA 资源的分布式 JTA 事务.部署到合适的 Java EE 应用服务器时, JTA 事务也受支持.</p>
<p>当检测到 JTA 环境时,Spring 的<code> JtaTransactionManager</code> 将用于管理事务.自动配置的 JMS,数据源和 JPA bean 会被升级以支持 XA 事务.可以使用标准的 Spring 习惯用法,例如 <code>@Transactional</code>,来参与分布式事务. 如果在 JTA 环境中并且仍想使用本地事务,则可以将 <code>spring.jta.enabled</code> 属性设置为 <code>false</code> 以禁用 JTA 自动配置.</p>
<ol>
<li><h6 id="使用Atomikos事务管理器-Using-an-Atomikos-Transaction-Manager"><a href="#使用Atomikos事务管理器-Using-an-Atomikos-Transaction-Manager" class="headerlink" title="使用Atomikos事务管理器(Using an Atomikos Transaction Manager)"></a>使用Atomikos事务管理器(Using an Atomikos Transaction Manager)</h6><p>Atomikos 是一个流行的开源事务管理器,可以嵌入到 Spring Boot 应用程序中.可以使用 <code>spring-boot-starter-jta-atomikos</code> starter来拉取 Atomikos 库.Spring Boot 自动配置 Atomikos 并将适当的<code>depends-on</code>应用于 Spring bean 以实现正确的启动和关闭顺序.</p>
<p>默认情况下,Atomikos 事务日志被写入应用主目录(应用程序 jar 文件所在的目录)中的<code>transaction-logs</code>目录.可以通过在 <code>application.properties</code> 文件中设置 <code>spring.jta.log-dir</code> 属性来自定义此目录的位置.以 <code>spring.jta.atomikos.properties</code> 开头的属性也可用于自定义 Atomikos <code>UserTransactionServiceImp</code>.有关完整的详细信息,请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html"><code>AtomikosProperties</code> Javadoc</a> .</p>
<blockquote>
<p>注意:</p>
<p>​    为了保证多个事务管理器可以安全地协调同一个资源管理器,每个 Atomikos 实例必须配置一个唯一的 ID.默认情况下,此 ID 是运行 Atomikos 的机器的 IP 地址.为了保证生产环境中的唯一性,应该为应用程序的每个实例配置 <code>spring.jta.transaction-manager-id</code> 属性配置不同的值.</p>
</blockquote>
</li>
<li><h6 id="使用-Java-EE-托管事务管理器-Using-a-Java-EE-Managed-Transaction-Manager"><a href="#使用-Java-EE-托管事务管理器-Using-a-Java-EE-Managed-Transaction-Manager" class="headerlink" title="使用 Java EE 托管事务管理器 (Using a Java EE Managed Transaction Manager)"></a>使用 Java EE 托管事务管理器 (Using a Java EE Managed Transaction Manager)</h6><p>如果将 Spring Boot 应用打包为 <code>war</code> 或 <code>ear</code> 文件并将其部署到 Java EE 应用服务器,则可以使用应用服务器的内置事务管理器.Spring Boot 尝试通过查看常见的 JNDI 位置(<code>java:comp/UserTransaction</code>,<code>java:comp/TransactionManager</code> 等)来自动配置事务管理器.如果使用应用服务器提供的事务服务,通常还希望确保所有资源都由服务器管理并通过 JNDI 公开.Spring Boot 尝试通过在 JNDI 路径(<code>java:/JmsXA</code> 或 <code>java:/XAConnectionFactory</code>)中查找 <code>ConnectionFactory</code> 来自动配置 JMS,可以使用 <code>spring.datasource.jndi-name</code> 属性来配置数据源.</p>
</li>
<li><h6 id="混合-XA-和非-XA-JMS-连接"><a href="#混合-XA-和非-XA-JMS-连接" class="headerlink" title="混合 XA 和非 XA JMS 连接"></a>混合 XA 和非 XA JMS 连接</h6><p>使用 JTA 时,主要的 JMS <code>ConnectionFactory</code> bean 是 XA-aware 并参与分布式事务.可以注入到 bean 中,而无需使用任何 <code>@Qualifier</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些情况下,可能希望使用非 XA的<code>ConnectionFactory</code> 来处理一些 JMS 消息.例如, JMS 处理逻辑可能需要时间比 XA 超时时间更长.</p>
<p>如果要使用非 XA <code>ConnectionFactory</code>,可以使用 <code>nonXaJmsConnectionFactory</code> bean:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(<span class="meta">@Qualifier(&quot;nonXaJmsConnectionFactory&quot;)</span> ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了一致性, <code>jmsConnectionFactory</code> bean还被使用 bean 别名 <code>xaJmsConnectionFactory </code>提供.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(<span class="meta">@Qualifier(&quot;xaJmsConnectionFactory&quot;)</span> ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="支持替代嵌入式事务管理器-Supporting-an-Alternative-Embedded-Transaction-Manager"><a href="#支持替代嵌入式事务管理器-Supporting-an-Alternative-Embedded-Transaction-Manager" class="headerlink" title="支持替代嵌入式事务管理器 (Supporting an Alternative Embedded Transaction Manager)"></a>支持替代嵌入式事务管理器 (Supporting an Alternative Embedded Transaction Manager)</h6><p><code>XAConnectionFactoryWrapper</code> 和 <code>XADataSourceWrapper</code> 接口可用于支持替代的嵌入式事务管理器.接口负责包装 <code>XAConnectionFactory</code> 和 <code>XADataSource</code> bean 并将它们公开为常规的<code>ConnectionFactory</code> 和 <code>DataSource</code> bean,它们透明地注册到分布式事务中.数据源和 JMS 自动配置使用 JTA 变体,前提是在 <code>ApplicationContext</code> 中注册了 <code>JtaTransactionManager</code> bean 和适当的 XA 包装 bean.</p>
<p> <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/atomikos/AtomikosXAConnectionFactoryWrapper.java">AtomikosXAConnectionFactoryWrapper</a> 和 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/atomikos/AtomikosXADataSourceWrapper.java">AtomikosXADataSourceWrapper</a> 提供了如何编写 XA 包装器的例子.</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.20 Feature: Hazelcast</title>
    <url>/posts/55600.html</url>
    <content><![CDATA[<h5 id="3-20-Hazelcast"><a href="#3-20-Hazelcast" class="headerlink" title="3.20 Hazelcast"></a>3.20 Hazelcast</h5><ol start="20">
<li><h5 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h5><p>如果 Hazelcast 在classpath上并且找到了合适的配置,Spring Boot 会自动配置一个 <code>HazelcastInstance</code>,可以将它注入到应用中.</p>
<p>Spring Boot 首先尝试检查以下配置选项来创建客户端:</p>
<ul>
<li><code>com.hazelcast.client.config.ClientConfig</code> bean 的存在.</li>
<li><code>spring.hazelcast.config</code> 属性定义的配置文件</li>
<li><code>hazelcast.client.config</code> 系统属性的存在.</li>
<li>工作目录或classpath根目录中的 <code>hazelcast-client.xml</code>.</li>
<li>工作目录或classpath根目录中的 <code>hazelcast-client.yaml</code>.</li>
</ul>
<blockquote>
<p>注意:</p>
<p>​    Spring Boot 支持 Hazelcast 4 和 Hazelcast 3.如果你降级到 Hazelcast 3,应该将 <code>hazelcast-client</code> 添加到classpath中来配置客户端.</p>
</blockquote>
<p>如果无法创建客户端,Spring Boot 会尝试配置嵌入式服务器.如果定义了一个 <code>com.hazelcast.config.Config</code> bean,Spring Boot 会使用它.如果配置定义了一个实例名称,Spring Boot 会尝试定位现有实例而不是创建新实例.</p>
<p>还可以通过配置指定 Hazelcast 配置文件,如以下示例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.hazelcast.config</span>=<span class="string">classpath:config/my-hazelcast.xml</span></span><br></pre></td></tr></table></figure>

<p>否则,Spring Boot 会尝试从默认位置查找 Hazelcast 配置:工作目录或classpath根目录中的 <code>hazelcast.xml</code>,或相同位置的<code>.yaml</code>对应文件.还检查是否设置了 <code>hazelcast.config</code> 系统属性. 有关更多详细信息,请参阅 <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/">Hazelcast documentation</a>.</p>
<blockquote>
<p>注意:</p>
<p>​    Spring Boot 也对 Hazelcast 有显式的缓存支持. 如果启用缓存,<code>HazelcastInstance</code>会自动包装在 <code>CacheManager</code> 实现中.</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.21 Feature: Quartz调度器</title>
    <url>/posts/12903.html</url>
    <content><![CDATA[<h5 id="3-21-Quartz调度器-Quartz-Scheduler"><a href="#3-21-Quartz调度器-Quartz-Scheduler" class="headerlink" title="3.21 Quartz调度器 (Quartz Scheduler)"></a>3.21 Quartz调度器 (Quartz Scheduler)</h5><ol start="21">
<li><h5 id="Quartz调度器-Quartz-Scheduler"><a href="#Quartz调度器-Quartz-Scheduler" class="headerlink" title="Quartz调度器 (Quartz Scheduler)"></a>Quartz调度器 (Quartz Scheduler)</h5><p>Spring Boot 为使用 Quartz 调度程序提供了多种便利,包括 <code>spring-boot-starter-quartz</code> “Starter”.如果 Quartz 可用,则自动配置<code>Scheduler</code>(通过 <code>SchedulerFactoryBean</code> 抽象).</p>
<p>以下类型的 Bean 会被自动获取并与 <code>Scheduler</code> 关联:</p>
<ul>
<li><code>JobDetail</code>:定义特定Job. 可以使用 <code>JobBuilder</code> API 构建 <code>JobDetail</code> 实例.</li>
<li><code>Calendar</code></li>
<li><code>Trigger</code>:定义何时触发特定Job.</li>
</ul>
<p>默认情况下,使用内存中<code>JobStore</code>. 但是,如果 <code>DataSource</code> bean 在您的应用中可用并且相应地配置了 <code>spring.quartz.job-store-type</code> 属性,则可以配置基于 JDBC 的存储,如以下示例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.quartz.job-store-type</span>=<span class="string">jdbc</span></span><br></pre></td></tr></table></figure>

<p>使用 JDBC 存储时,可以在启动时初始化schema,如以下示例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.quartz.jdbc.initialize-schema</span>=<span class="string">always</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>警告:</p>
<p>​    默认情况下,使用 Quartz 库提供的标准脚本来检测和初始化数据库.这些脚本删除现有表,在每次重新启动时删除所有触发器. 也可以通过设置 <code>spring.quartz.jdbc.schema</code> 属性来提供自定义脚本.</p>
</blockquote>
<p>要让 Quartz 不使用应用程序主<code>DataSource</code>,而是指定的<code>DataSource</code>,声明一个 <code>DataSource</code> bean,使用 <code>@QuartzDataSource</code> 标注其 <code>@Bean</code> 方法.这样做可以让Quartz专用的DataSource同时被 <code>SchedulerFactoryBean</code>使用和初始化schema.类似地,要让 Quartz 使用非应用程序主 <code>TransactionManager</code> 之外的 <code>TransactionManager</code>, 声明一个 <code>TransactionManager</code> bean,使用 <code>@QuartzTransactionManager</code> 标注其 <code>@Bean</code> 方法.</p>
<p>默认情况下,配置创建的jobs不会覆盖,从持久job 存储中读取的已注册作业.要启用覆盖现有job,设置 <code>spring.quartz.overwrite-existing-jobs</code> 属性.</p>
<p>Quartz Scheduler 配置可以使用 <code>spring.quartz</code> 属性和 <code>SchedulerFactoryBeanCustomizer</code> bean 进行自定义,这允许以编程的形式来自定义<code>SchedulerFactoryBean</code>.可以使用 <code>spring.quartz.properties.*</code> 自定义Quartz的高级配置.</p>
<blockquote>
<p>注意:</p>
<p>​    特别是,<code>Executor</code> bean 与<code>scheduler</code>无关,因为 Quartz 提供了一种通过 <code>spring.quartz.properties</code> 配置scheduler的方法.如果需要自定义任务executor,可以考虑实现<code>SchedulerFactoryBeanCustomizer</code>.</p>
</blockquote>
<p>Jobs可以定义 setter 来注入数据映射属性. 也可以用类似的方式注入普通 bean,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySampleJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fields ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject &quot;MyService&quot; bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyService</span><span class="params">(MyService myService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject the &quot;name&quot; job data property</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myService.someMethod(context.getFireTime(), <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.22 Feature: 任务执行与调度</title>
    <url>/posts/53415.html</url>
    <content><![CDATA[<h5 id="3-22-任务执行与调度-Task-Execution-and-Scheduling"><a href="#3-22-任务执行与调度-Task-Execution-and-Scheduling" class="headerlink" title="3.22 任务执行与调度 (Task Execution and Scheduling)"></a>3.22 任务执行与调度 (Task Execution and Scheduling)</h5><ol start="22">
<li><h5 id="任务执行与调度-Task-Execution-and-Scheduling"><a href="#任务执行与调度-Task-Execution-and-Scheduling" class="headerlink" title="任务执行与调度 (Task Execution and Scheduling)"></a>任务执行与调度 (Task Execution and Scheduling)</h5><p>在context中没有 <code>Executor</code> bean 的情况下,Spring Boot 自动配置了一个具有合理默认值的 <code>ThreadPoolTaskExecutor</code>,可以自动关联到异步任务执行(<code>@EnableAsync</code>)和 Spring MVC 异步请求处理.</p>
<blockquote>
<p>建议:</p>
<p>​    如果在context中添加了自定义的 <code>Executor</code>,常规任务执行(即<code>@EnableAsync</code>)将透明地使用它,但不会配置对 Spring MVC 支持,因为它需要 <code>AsyncTaskExecutor</code> 实现(名为 <code>applicationTaskExecutor</code>).根据的目标安排,可以将 <code>Executor</code> 更改为 <code>ThreadPoolTaskExecutor</code> 或同时定义 <code>ThreadPoolTaskExecutor </code>和 <code>AsyncConfigurer</code> 包装自定义的 <code>Executor</code>.</p>
<p>自动配置的 <code>TaskExecutorBuilder</code> 允许开发者轻松创建实例, 也是重现默认情况下自动配置所做的事情.</p>
</blockquote>
<p>线程池使用8个核心线程,可以根据负载增减. 这些默认设置可以使用 <code>spring.task.execution</code> 命名空间进行调整,如以下示例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.task.execution.pool.max-size</span>=<span class="string">16</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.queue-capacity</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.keep-alive</span>=<span class="string">10s</span></span><br></pre></td></tr></table></figure>

<p>这会将线程池更改为使用有界队列,以便当队列已满(100 个任务)时,线程池增加到最多 16 个线程.池的收缩更加积极,如果线程空闲 10 秒(而不是默认情况下为 60 秒),将被回收.</p>
<p>如果需要与计划任务执行相关联(例如 <code>@EnableScheduling</code>),也可以自动配置 <code>ThreadPoolTaskScheduler</code>. 线程池默认使用一个线程,其设置可以使用 <code>spring.task.scheduling</code> 命名空间进行微调,如下例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.task.scheduling.thread-name-prefix</span>=<span class="string">scheduling-</span></span><br><span class="line"><span class="meta">spring.task.scheduling.pool.size</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure>

<p>如果需要创建自定义executor或scheduler,则 <code>TaskExecutorBuilder</code> bean 和 <code>TaskSchedulerBuilder</code> bean 在context中都可用.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.23 Feature: Spring Integration</title>
    <url>/posts/18723.html</url>
    <content><![CDATA[<h5 id="Spring-Integration"><a href="#Spring-Integration" class="headerlink" title="Spring Integration"></a>Spring Integration</h5><ol start="23">
<li><h5 id="Spring-Integration-1"><a href="#Spring-Integration-1" class="headerlink" title="Spring Integration"></a>Spring Integration</h5><p>Spring Boot 为使用 Spring Integration 提供了多种便利,包括 spring-boot-starter-integration “Starter”.Spring Integration 提供了对消息和其他传输(如 HTTP,TCP 等)的抽象.如果 Spring Integration 在classpath上可用,则通过 <code>@EnableIntegration</code> 注解对其进行初始化.</p>
<p>Spring Integration 轮询逻辑依赖于自动配置的 <code>TaskScheduler</code>.</p>
<p>Spring Boot 还配置了一些功能,由 Spring Integration 模块存在时触发. 如果 <code>spring-integration-jmx</code> 也在classpath上,则消息处理统计信息通过 JMX 发布.如果 <code>spring-integration-jdbc</code> 可用,则可以在启动时创建默认数据库schema,如下行所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.integration.jdbc.initialize-schema</span>=<span class="string">always</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>spring-integration-rsocket</code> 可用,开发人员可以使用”<code>spring.rsocket.server.</code>*”属性配置 RSocket 服务器,并让它使用 <code>IntegrationRSocketEndpoint</code> 或 <code>RSocketOutboundGateway</code> 组件来处理传入的 RSocket 消息.这个基础设施可以处理 Spring Integration RSocket 通道适配器和 <code>@MessageMapping</code> 处理程序(假设配置了<code>&quot;spring.integration.rsocket.server.message-mapping-enabled&quot;</code>).</p>
<p>Spring Boot 还可以使用配置属性自动配置 <code>ClientRSocketConnector</code>:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Connecting to a RSocket server over TCP</span></span><br><span class="line"><span class="meta">spring.integration.rsocket.client.host</span>=<span class="string">example.org</span></span><br><span class="line"><span class="meta">spring.integration.rsocket.client.port</span>=<span class="string">9898</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Connecting to a RSocket Server over WebSocket</span></span><br><span class="line"><span class="meta">spring.integration.rsocket.client.uri</span>=<span class="string">ws://example.org</span></span><br></pre></td></tr></table></figure>

<p>默认情况下,如果存在 Micrometer <code>meterRegistry</code> bean,则 Spring Integration metrics 将由 Micrometer 管理.如果希望使用旧的 Spring Integration metrics,将 <code>DefaultMetricsFactory</code> bean 添加到应用上下文.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.24 Feature: Spring Session</title>
    <url>/posts/45154.html</url>
    <content><![CDATA[<h5 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h5><ol start="24">
<li><h5 id="Spring-Session-1"><a href="#Spring-Session-1" class="headerlink" title="Spring Session"></a>Spring Session</h5><p>Spring Boot 为很多数据存储提供 Spring Session 自动配置. 在构建 Servlet Web 应用程序时,可以自动配置以下存储:</p>
<ul>
<li>JDBC</li>
<li>Redis</li>
<li>Hazelcast</li>
<li>MongoDB</li>
</ul>
<p>Servlet 自动配置取代了必须使用<code>@Enable*HttpSession</code>.</p>
<p>在构建响应式 Web 应用程序时,可以自动配置以下存储:</p>
<ul>
<li>Redis</li>
<li>MongoDB</li>
</ul>
<p>响应式自动配置取代了必须使用<code>@Enable*WebSession</code> .</p>
<p>如果classpath上存在单个 Spring Session 模块,则 Spring Boot 会自动使用该存储实现.如果有多个实现,则必须选择要用于存储会话的 <code>StoreType</code>.例如,要使用 JDBC 作为后端存储,可以按如下方式配置您的应用:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.session.store-type</span>=<span class="string">jdbc</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    可以通过将 <code>store-type</code> 设置为 <code>none</code> 来禁用 Spring Session.</p>
</blockquote>
<p>每个store都有特定的额外设置. 例如,可以为 JDBC 存储自定义表的名称,如以下示例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.session.jdbc.table-name</span>=<span class="string">SESSIONS</span></span><br></pre></td></tr></table></figure>

<p>要设置会话超时,可以使用 <code>spring.session.timeout</code> 属性.如果没有使用 Servlet Web 应用程序设置该属性,则自动配置将回退到 <code>server.servlet.session.timeout</code> 的值.</p>
<p>可以使用 <code>@Enable*HttpSession</code> (Servlet) 或 <code>@Enable*WebSession</code> (Reactive) 来控制 Spring Session 的配置.这将导致自动配置退出. 然后可以使用注解的属性而不是之前描述的配置属性来配置 Spring Session.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.25 Feature : 通过 JMX 进行监控和管理</title>
    <url>/posts/45790.html</url>
    <content><![CDATA[<h5 id="3-25-通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX"><a href="#3-25-通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX" class="headerlink" title="3.25 通过 JMX 进行监控和管理 (Monitoring and Management over JMX)"></a>3.25 通过 JMX 进行监控和管理 (Monitoring and Management over JMX)</h5><ol start="25">
<li><h6 id="通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX"><a href="#通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX" class="headerlink" title="通过 JMX 进行监控和管理 (Monitoring and Management over JMX)"></a>通过 JMX 进行监控和管理 (Monitoring and Management over JMX)</h6><p>Java 管理扩展 (JMX) 提供了一种标准机制来监视和管理应用程序.Spring Boot 将最合适的 <code>MBeanServer</code> 暴露为bean, ID 为 <code>mbeanServer</code>.任何用 Spring JMX 注解的(<code>@ManagedResource</code>,<code>@ManagedAttribute</code> 或 <code>@ManagedOperation</code>)标注的 bean 都会暴露给它.</p>
<p>如果平台提供标准的 <code>MBeanServer</code>,Spring Boot 将使用它,并在必要时候,将其默认为 VM <code>MBeanServer</code>. 如果所有这些都失败了,将会创建一个新的 <code>MBeanServer</code>.</p>
<p>有关更多详细信息,参阅  <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java"><code>JmxAutoConfiguration</code></a> 类.</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.27 Feature: WebSockets</title>
    <url>/posts/14496.html</url>
    <content><![CDATA[<h5 id="3-27-WebSockets"><a href="#3-27-WebSockets" class="headerlink" title="3.27 WebSockets"></a>3.27 WebSockets</h5><ol start="27">
<li><h5 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h5><p>Spring Boot 为嵌入式 Tomcat,Jetty 和 Undertow 提供了 WebSockets 自动配置.如果你将一个 war 文件部署到一个独立的容器中,Spring Boot 会假设容器负责其 WebSocket 支持的配置.</p>
<p>Spring Framework 为 MVC web 应用程序提供了丰富的 WebSocket 支持,可以通过 <code>spring-boot-starter-websocket</code> 模块轻松访问.</p>
<p>WebSocket 也可用于响应式 Web 应用程序,并且需要包含 <code>spring-boot-starter-webflux</code>  和 WebSocket API:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.28 Feature: Web Service</title>
    <url>/posts/51065.html</url>
    <content><![CDATA[<h5 id="3-28-Web-服务"><a href="#3-28-Web-服务" class="headerlink" title="3.28 Web 服务"></a>3.28 Web 服务</h5><ol start="28">
<li><h5 id="Web-服务-Web-Services"><a href="#Web-服务-Web-Services" class="headerlink" title="Web 服务(Web Services)"></a>Web 服务(Web Services)</h5><p>Spring Boot 提供 Web 服务自动配置,因此所需要做的就是定义<code>Endpoints</code>.</p>
<p>使用 <code>spring-boot-starter-webservices</code> 模块可以轻松访问 Spring Web 服务功能.</p>
<p><code>SimpleWsdl11Definition</code> 和 <code>SimpleXsdSchema</code> bean 可以分别为 WSDL 和 XSD 自动创建. 为此,要配置它们的路径,如以下示例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.webservices.wsdl-locations</span>=<span class="string">classpath:/wsdl</span></span><br></pre></td></tr></table></figure>

<ol>
<li><h6 id="使用-WebServiceTemplate-调用-Web-服务-Calling-Web-Services-with-WebServiceTemplate"><a href="#使用-WebServiceTemplate-调用-Web-服务-Calling-Web-Services-with-WebServiceTemplate" class="headerlink" title="使用 WebServiceTemplate 调用 Web 服务(Calling Web Services with WebServiceTemplate)"></a>使用 WebServiceTemplate 调用 Web 服务(Calling Web Services with WebServiceTemplate)</h6><p>如果需要从应用调用远程 Web 服务,可以使用 <code>WebServiceTemplate</code> 类.由于 <code>WebServiceTemplate</code> 实例在使用前通常需要自定义,因此 Spring Boot 不提供任何单个自动配置的 <code>WebServiceT</code></p>
<p><code>emplate</code> bean.但是,它会自动配置一个 <code>WebServiceTemplateBuilder</code>,它可以在需要时用于创建 <code>WebServiceTemplate</code> 实例.</p>
<p>以下代码显示了一个典型示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebServiceTemplate webServiceTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebServiceTemplateBuilder webServiceTemplateBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webServiceTemplate = webServiceTemplateBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SomeResponse <span class="title">someWsCall</span><span class="params">(SomeRequest detailsReq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (SomeResponse) <span class="keyword">this</span>.webServiceTemplate.marshalSendAndReceive(detailsReq,</span><br><span class="line">                <span class="keyword">new</span> SoapActionCallback(<span class="string">&quot;https://ws.example.com/action&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下,<code>WebServiceTemplateBuilder</code> 使用classpath上可用的 HTTP 客户端库来检测合适的基于 HTTP 的 <code>WebServiceMessageSender</code>.还可以按如下方式自定义读取和连接超时:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebServiceTemplateConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebServiceTemplate <span class="title">webServiceTemplate</span><span class="params">(WebServiceTemplateBuilder builder)</span> </span>&#123;</span><br><span class="line">        WebServiceMessageSender sender = <span class="keyword">new</span> HttpWebServiceMessageSenderBuilder()</span><br><span class="line">                .setConnectTimeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                .setReadTimeout(Duration.ofSeconds(<span class="number">2</span>))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> builder.messageSenders(sender).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature </tag>
      </tags>
  </entry>
  <entry>
    <title>3.3 Feature: Profiles</title>
    <url>/posts/25620.html</url>
    <content><![CDATA[<h5 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h5><p>   Spring Profile提供了一种方法,可以将配置文件分离开来,并且只有在特定的环境中可用.<br>   所有的<code>@Component</code>,<code>@Configuration</code>或者<code>@ConfigurationProperties</code>可以使用<code>@Profile</code>来有条件地加载.如下所示:<br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意:</p>
<p>​    如果是通过<code>@ConfigurationProperties</code>和<code>@EnableConfigurationProperties</code>方式注册的bean,而不是自动扫描,<code>@Profile</code>注解应该被标注在使用<code>@EnableConfigurationProperties</code>的配置类上<code>Configuration</code>类上.在这个例子中,<code>@ConfigurationProperties</code>被扫描,<code>@Profile</code>可以被标注 在配置类上.<br>   也可以使用<code>spring.profiles.active</code>的<code>Environment</code>属性,来指定启动哪一个 profile.可以像前面一样的章节中的那样设置这个属性.比如,可以在<code>application.properties</code>,如下所示:<br>   <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev,hsqldb</span></span><br></pre></td></tr></table></figure><br>   也可以在命令行中,使用下面的命令来切换:<br>   <code>--spring.profiles.active=dev,hsqldb</code></p>
</blockquote>
<ol>
<li><h6 id="添加活动配置文件-Adding-Active-Profiles"><a href="#添加活动配置文件-Adding-Active-Profiles" class="headerlink" title="添加活动配置文件(Adding Active Profiles)"></a>添加活动配置文件(Adding Active Profiles)</h6><code>spring.profiles.active</code>和其他的属性遵循一样的顺序规则:最高的<code>PropertySource</code>最终有效.这意味着可以在<code>application.properties</code>中激活profile,然后在命令行中切换profile.<br>有时候,有一个可以增加profile的属性,而不是替换profile的属性,会很有用.<code>SpringApplication</code>入口有一个Java API来设置其他的profile(也就是说,除了那些由spring.profiles.active属性激活的属性之外).可以参照<code>SpringApplication</code>的<code>setAdditionalProfiles()</code>方法.下一章节中会描述,如果给定的profile被激活,profile组可以用来添加并激活profile.</li>
<li><h6 id="profile组-Profile-Groups"><a href="#profile组-Profile-Groups" class="headerlink" title="profile组(Profile Groups)"></a>profile组(Profile Groups)</h6>有时,您在应用程序中定义和使用的配置文件的粒度太细,使用起来很麻烦.比如,可以能需要<code>proddb</code>和<code>prodmq</code>profile来实现各自独立的启用数据库和消息中间件的功能.<br>为了解决这个问题,Spring Boot允许定义profile组.profile组能够允许给一组相关联的profile定义一个逻辑名.<br>比如,可以使用<code>production</code>组,组有<code>proddb</code>和<code>prodmq</code>组成.<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.profiles.group.production[0]</span>=<span class="string">proddb</span></span><br><span class="line"><span class="meta">spring.profiles.group.production[1]</span>=<span class="string">prodmq</span></span><br></pre></td></tr></table></figure>
现在可以使用<code>--spring.profiles.active = production</code>来启动应用程序,以一键激活<code>proddb</code>,<code>proddb</code>和<code>prodmq</code>配置文件.</li>
<li><h6 id="使用编程的方式设置profile-Programmatically-Setting-Profiles"><a href="#使用编程的方式设置profile-Programmatically-Setting-Profiles" class="headerlink" title="使用编程的方式设置profile(Programmatically Setting Profiles)"></a>使用编程的方式设置profile(Programmatically Setting Profiles)</h6>可以在应用启动前,调用<code>SpringApplication.setAdditionalProfiles(…)</code>方法来激活profile.可以实现<code>ConfigurableEnvironment</code>接口来实现指定profile.</li>
<li><h6 id="用于指定profile的配置文件-Profile-specific-Configuration-Files"><a href="#用于指定profile的配置文件-Profile-specific-Configuration-Files" class="headerlink" title="用于指定profile的配置文件(Profile-specific Configuration Files)"></a>用于指定profile的配置文件(Profile-specific Configuration Files)</h6><code>application.properties</code>(或者<code>application.yml</code>)和被<code>@ConfigurationProperties</code>引用的文件的变体都会被作为文件加载.</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.30 Feature: Kotlin 支持</title>
    <url>/posts/11629.html</url>
    <content><![CDATA[<h5 id="3-30-Kotlin-支持"><a href="#3-30-Kotlin-支持" class="headerlink" title="3.30 Kotlin 支持"></a>3.30 Kotlin 支持</h5><ol start="30">
<li><h6 id="3-30-Kotlin-支持-Kotlin-support"><a href="#3-30-Kotlin-支持-Kotlin-support" class="headerlink" title="3.30 Kotlin 支持(Kotlin support)"></a>3.30 Kotlin 支持(Kotlin support)</h6><p>Kotlin 是一种面向 JVM(和其他平台)的静态类型语言,它允许编写简洁优雅的代码,同时提供与用 Java 编写的现有库的互操作性.</p>
<p>Spring Boot 通过利用其他 Spring 项目(如 Spring Framework,Spring Data 和 Reactor)中的支持来提供 Kotlin 支持.</p>
<p>开始使用 Spring Boot 和 Kotlin 的最简单方法是遵循这个综合教程(<a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">this comprehensive tutorial</a>). 可以通过 start.spring.io 创建新的 Kotlin 项目. 如果需要支持,请随时加入 Kotlin Slack 的 #spring 频道或在 Stack Overflow 上提出有关 spring 和 kotlin 标签的问题.</p>
<ol>
<li><h6 id="要求-Requirements"><a href="#要求-Requirements" class="headerlink" title="要求(Requirements)"></a>要求(Requirements)</h6><p>Spring Boot 支持 Kotlin 1.3.x. 要使用 Kotlin,类路径中必须存在 <code>org.jetbrains.kotlin:kotlin-stdlib</code> 和 <code>org.jetbrains.kotlin:kotlin-reflect</code>.也可以使用 <code>kotlin-stdlib</code> 变体 <code>kotlin-stdlib-jdk7</code> 和 <code>kotlin-stdlib-jdk8</code>.</p>
<p>由于 Kotlin 类在默认情况下是 final 的,可能希望配置 kotlin-spring 插件以自动打开 Spring 注解标注的的类,以便它们可以被代理.</p>
<p>在 Kotlin 中序列化/反序列化 JSON 数据需要 Jackson 的 Kotlin 模块.在classpath中找到它时会自动注册.如果 Jackson 和 Kotlin 存在但 Jackson Kotlin 模块不存在,则会记录一条警告消息.</p>
<blockquote>
<p>建议:</p>
<p>​    如果在 start.spring.io 上引导 Kotlin 项目,则默认提供这些依赖项和插件.</p>
</blockquote>
</li>
<li><h6 id="Null-safety"><a href="#Null-safety" class="headerlink" title="Null-safety"></a>Null-safety</h6><p>Kotlin 的主要特性之一是空值安全性.它在编译时处<code>null</code>,而不是将问题推迟到运行时并遇到 <code>NullPointerException</code>.这有助于消除常见的错误来源,而无需耗费 <code>Optional</code> 等包装器的成本.Kotlin 还允许使用具有可为空值的函数构造,如 Kotlin 中的空值安全综合指南(<a href="https://www.baeldung.com/kotlin-null-safety">comprehensive guide to null-safety in Kotlin</a>)中所述.</p>
<p>尽管 Java 不允许在其类型系统中表达null-safety,但 Spring Framework,Spring Data 和 Reactor 现在通过工具友好型注解提供其 API 的null-safety.默认情况下, Kotlin 中使用的 Java API 的类型被识别为平台类型,并且relax null-checks.Kotlin 对 JSR 305 注解的支持与nullability注解相结合,为 Kotlin 中的相关 Spring API 提供了空安全性.</p>
<p>可以通过添加带有以下选项的 <code>-Xjsr305</code> 编译器标志来配置 JSR 305 检查: <code>-Xjsr305=&#123;strict|warn|ignore&#125;</code>.默认行为与 <code>-Xjsr305=warn</code> 相同.在从 Spring API 推断出的 Kotlin 类型中,需要使用 <code>strict</code> 值来考虑null-safety,但也应该要知道,使用 Spring API nullability声明即使在次要版本之间也可以发展,并且将来可能会添加更多.</p>
<blockquote>
<p>警告:</p>
<p>​    尚不支持Generic类型参数,可变参数和数组元素nullability.</p>
</blockquote>
</li>
<li><h6 id="Kotlin-API"><a href="#Kotlin-API" class="headerlink" title="Kotlin API"></a>Kotlin API</h6><p>[[features.kotlin.api.?run-application]] ==== runApplication Spring Boot 提供了一种使用 <code>runApplication&lt;MyApplication&gt;(*args) </code>运行应用程序的方法,如下例所示:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.runApplication</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;MyApplication&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 <code>SpringApplication.run(MyApplication::class.java, *args)</code> 的替代品.它还允许自定义应用程序,如以下示例所示:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runApplication&lt;MyApplication&gt;(*args) &#123;</span><br><span class="line">    setBannerMode(OFF)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><h6 id="扩展-Extensions"><a href="#扩展-Extensions" class="headerlink" title="扩展(Extensions)"></a>扩展(Extensions)</h6><p>Kotlin 扩展提供了使用额外功能扩展现有类的能力.Spring Boot Kotlin API 利用这些扩展为现有 API 添加新的特定 Kotlin 的 conveniences .</p>
<p>提供了 <code>TestRestTemplate</code> 扩展,类似于 Spring Framew          ork 为 Spring Framework 中的 <code>RestOperations</code> 提供的扩展.除其他外,这些扩展利用 Kotlin 实体化类型参数.</p>
</li>
</ol>
</li>
<li><h6 id="依赖管理-Dependency-management"><a href="#依赖管理-Dependency-management" class="headerlink" title="依赖管理(Dependency management)"></a>依赖管理(Dependency management)</h6><p>为了避免在类路径上混合不同版本的 Kotlin 依赖,Spring Boot 导入了 Kotlin BOM.</p>
<p>使用 Maven,可以通过 <code>kotlin.version</code> 属性自定义 Kotlin 版本,并为 <code>kotlin-maven-plugin</code> 提供插件管理.使用 Gradle,Spring Boot 插件会自动将 <code>kotlin.version</code> 与 Kotlin 插件的版本对齐.</p>
<p>Spring Boot 还通过导入 Kotlin 协程 BOM 来管理协程依赖的版本.可以通过 <code>kotlin-coroutines.version</code> 属性自定义版本.</p>
<blockquote>
<p>建议:</p>
<p>​    <code>org.jetbrains.kotlinx:kotlinx-coroutines-reactor</code> 依赖项是默认提供的,如果引导一个 Kotlin 项目在 <code>start.spring.io</code> 至少有一个响应式依赖项.</p>
</blockquote>
</li>
<li><h6 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h6><p><code>@ConfigurationProperties</code> 与 <code>@ConstructorBinding</code> 结合使用时支持不可变 <code>val</code> 属性的类,如下例所示:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(<span class="meta-string">&quot;example.kotlin&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinExampleProperties</span></span>(</span><br><span class="line">        <span class="keyword">val</span> name: String,</span><br><span class="line">        <span class="keyword">val</span> description: String,</span><br><span class="line">        <span class="keyword">val</span> myService: MyService) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span></span>(</span><br><span class="line">            <span class="keyword">val</span> apiToken: String,</span><br><span class="line">            <span class="keyword">val</span> uri: URI</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    要使用注释处理器生成您自己的元数据,应该使用 <code>spring-boot-configuration-processor</code> 依赖项配置 <code>kapt</code>.请注意,由于 <code>kapt </code>提供模型的限制,某些功能(例如检测default 值或deprecated 项目)无法正常工作.</p>
</blockquote>
</li>
<li><h6 id="测试-Testing"><a href="#测试-Testing" class="headerlink" title="测试(Testing)"></a>测试(Testing)</h6><p>虽然可以使用 JUnit 4 来测试 Kotlin 代码,但默认情况下提供并推荐使用 JUnit 5.这使得在非静态方法上可以使用 <code>@BeforeAll</code> 和 <code>@AfterAll</code> 注解,非常适合 Kotlin.</p>
<p>要模拟 Kotlin 类,建议使用 MockK.如果需要类似于 <code>Mockito</code> 特有的 <code>@MockBean</code> 和 <code>@SpyBean</code> 注解的 <code>Mockk</code> 等效项,可以使用提供类似 <code>@MockkBean</code> 和 <code>@SpykBean</code> 注解的 SpringMockK.</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.31 Feature:  容器镜像</title>
    <url>/posts/29720.html</url>
    <content><![CDATA[<h5 id="3-31-容器镜像-Container-Images"><a href="#3-31-容器镜像-Container-Images" class="headerlink" title="3.31 容器镜像(Container Images)"></a>3.31 容器镜像(Container Images)</h5><ol start="31">
<li><h5 id="容器镜像-Container-Images"><a href="#容器镜像-Container-Images" class="headerlink" title="容器镜像(Container Images)"></a>容器镜像(Container Images)</h5><p>很容易将 Spring Boot fat jar 打包为 docker 镜像.然而,复制和运行 docker 镜像中的 fat jar 有很多缺点.在不拆包的情况下运行一个fat jar时总是会有一定的开销,而在容器化环境中,这可能会很明显.另一个问题是将应用的代码及其所有依赖项放在 Docker 镜像的一层中是次选的.由于与升级所使用的 Spring Boot 版本相比,可能更频繁地重新编译代码,因此最好将内容分开一些.如果在应用程序类之前将 jar 文件放在层中,Docker 通常只需要更改最底层,并且可以从其缓存中提取其他层.</p>
<ol>
<li><h6 id="分层-Docker-镜像"><a href="#分层-Docker-镜像" class="headerlink" title="分层 Docker 镜像"></a>分层 Docker 镜像</h6><p>为了更轻松地创建优化的 Docker 镜像,Spring Boot 支持向 jar 添加层索引文件.它提供了一个层列表以及部分能够包含一部分jar.索引中的层列表排序和添加到 Docker/OCI 镜像的顺序相同.支持以下开箱即用的层:</p>
<ul>
<li><code>dependencies</code>(用于常规发布的依赖项)</li>
<li><code>spring-boot-loader</code>(适用于 <code>org/springframework/boot/loader</code> 下的所有内容)</li>
<li><code>snapshot-dependencies</code>(用于快照依赖)</li>
<li><code>application</code>(用于应用程序类和资源)</li>
</ul>
<p>下面显示了一个 <code>layers.idx</code> 文件的例子:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">&quot;dependencies&quot;:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BOOT-INF/lib/library1.jar</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BOOT-INF/lib/library2.jar</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">&quot;spring-boot-loader&quot;:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">org/springframework/boot/loader/JarLauncher.class</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">org/springframework/boot/loader/jar/JarEntry.class</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">&quot;snapshot-dependencies&quot;:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BOOT-INF/lib/library3-SNAPSHOT.jar</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">&quot;application&quot;:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">META-INF/MANIFEST.MF</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">BOOT-INF/classes/a/b/C.class</span></span><br></pre></td></tr></table></figure>

<p>这种分层根据应用程序的构建可能会改变分隔代码.库代码不太可能在构建时发生变化,因此它被放置在自己的层中,以允许工具重新使用缓存中的层.应用程序更有可能在构建时发生变化,因此它被隔离在一个单独的层中.</p>
<p>Spring Boot 还支持使用<code>layers.idx</code> 对war 文件进行分层.</p>
<p>对于 Maven,请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/reference/htmlsingle/#repackage-layers">packaging layered jar or war section</a>以获取有关向存档添加层索引的更多详细信息.对于 Gradle,请参阅 Gradle 插件文档的打包分层 jar 或 war 部分( <a href="https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#packaging-layered-archives">packaging layered jar or war section</a>).</p>
</li>
<li><h6 id="Building-Container-Images"><a href="#Building-Container-Images" class="headerlink" title="Building Container Images"></a>Building Container Images</h6><p>Spring Boot 应用程序可以使用 Dockerfiles 进行容器化,或者使用 Cloud Native Buildpacks 来创建可以在任何地方运行的与 docker 兼容的容器镜像.</p>
<ol>
<li><h6 id="Dockerfiles"><a href="#Dockerfiles" class="headerlink" title="Dockerfiles"></a>Dockerfiles</h6><p>虽然可以通过 <code>Dockerfile</code> 中的几行代码将 Spring Boot fat jar 转换为 docker 镜像,但我们将使用分层功能来创建优化的 docker 镜像.当创建一个包含layer索引文件的 jar 时,<code>spring-boot-jarmode-layertools</code> jar 将作为依赖添加到 jar 中.当类路径上有这个jar时,可以以一种特殊的模式启动应用,允许引导代码运行与应用程序完全不同的内容,例如,提取layer的内容.</p>
<blockquote>
<p>Caution:</p>
<p>​    <code>layertools</code> 模式不能与包含启动脚本的完全可执行的 Spring Boot 存档一起使用.想要构建一个可以使用<code>layertools </code>的jar时,要禁用启动脚本.</p>
</blockquote>
<p>以下是使用 <code>layertools</code> jar 模式启动 jar 的方法:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -Djarmode=layertools -jar my-app.jar</span></span><br></pre></td></tr></table></figure>

<p>这将提供以下输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  java -Djarmode=layertools -jar my-app.jar</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line">  list     List layers from the jar that can be extracted</span><br><span class="line">  extract  Extracts layers from the jar for image creation</span><br><span class="line">  help     Help about any command</span><br></pre></td></tr></table></figure>

<p><code>extract</code>命令可用于轻松地将应用程序拆分为层,然后这些层可以添加到 dockerfile .这是一个使用 <code>jarmode</code> 的 Dockerfile 示例.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> adoptopenjdk:<span class="number">11</span>-jre-hotspot as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> application</span></span><br><span class="line"><span class="keyword">ARG</span> JAR_FILE=target/*.jar</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$&#123;JAR_FILE&#125;</span> application.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> java -Djarmode=layertools -jar application.jar extract</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> adoptopenjdk:<span class="number">11</span>-jre-hotspot</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> application</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/dependencies/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/spring-boot-loader/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/snapshot-dependencies/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/application/ ./</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;org.springframework.boot.loader.JarLauncher&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>假设上述 <code>Dockerfile</code> 位于当前目录中, docker 镜像可以使用 <code>docker build</code> . 构建,或者可以选择指定应用程序 jar 的路径,如下例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build --build-arg JAR_FILE=path/to/myapp.jar .</span></span><br></pre></td></tr></table></figure>

<p>这是一个多stage的 dockerfile.builder stage 提取以后需要的目录.每个 <code>COPY</code> 命令都与 jarmode 提取的层相关.</p>
<p>当然,不使用jarmode也可以写一个Dockerfile.可以使用 <code>unzip</code> 和 <code>mv</code> 的组合将内容移动到正确的层,但 jarmode 简化了这一点.</p>
</li>
<li><h6 id="云本地Buildpacks-Cloud-Native-Buildpacks"><a href="#云本地Buildpacks-Cloud-Native-Buildpacks" class="headerlink" title="云本地Buildpacks(Cloud Native Buildpacks)"></a>云本地Buildpacks(Cloud Native Buildpacks)</h6><p>Dockerfiles 只是构建 docker 镜像的一种方式. 另一种构建 docker 镜像的方法是直接从你的 Maven 或 Gradle 插件中使用 buildpacks.如果曾经使用过 Cloud Foundry 或 Heroku 等应用平台,那么可能已经使用过 buildpack.Buildpacks 是平台的一部分,它将应用转换为平台可以实际运行的东西.例如,Cloud Foundry 的 Java buildpack 会发现正在推送的 <code>.jar</code> 文件并自动添加相关的 JRE.</p>
<p>使用 Cloud Native Buildpacks,可以创建可在任何地方运行的 Docker 兼容镜像.Spring Boot 包括直接支持 Maven 和 Gradle 的 buildpack.这意味着只需输入一个命令,即可快速将合理的映像放入本地运行的 Docker 守护程序中.</p>
<p>请参阅有关如何在 Maven(<a href="https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/reference/htmlsingle/#build-image">Maven</a>) 和 Gradle(<a href="https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#build-image">Gradle</a>) 中使用 buildpack 的各个插件文档.</p>
<blockquote>
<p>注意:</p>
<p>​    Paketo Spring Boot buildpack 也已更新以支持 <code>layer.idx</code> 文件,因此对它的任何自定义都将反映在 buildpack 创建的image中.</p>
<p>注意:</p>
<p>​    为了实现可重现的构建和容器镜像缓存,Buildpacks 可以操作应用程序资源元数据(例如文件”last modified”的信息).应该确保应用程序在运行时不依赖该元数据.Spring Boot 可以在提供静态资源时使用该信息,但这可以通过 <code>spring.web.resources.cache.use-last-modified</code> 禁用.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>3.5 Feature: 国际化</title>
    <url>/posts/52941.html</url>
    <content><![CDATA[<h5 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h5><p>   Spring Boot支持本地化消息,因此您的应用程序可以迎合不同语言的用户.默认情况下,Spring Boot在类路径的根目录下查找<code>messages</code>资源包的存在.</p>
<blockquote>
<p>注意:</p>
<p>​    当配置的资源束(resource bundle)的默认配置文件可用时,将会自动配置(即默认情况下,<code>messages.properties</code>).如果您的资源包仅包含指定语言的配置文件,则需要添加默认文件. 如果找不到与任何配置的base名匹配的配置文件, 将不会自动配置<code>MessageSource</code>.<br>   可以使用<code>spring.messages</code>命名空间配置资源包的basename以及其他几个属性,如以下示例所示:<br>   <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.messages.basename</span>=<span class="string">messages,config.i18n.messages</span></span><br><span class="line"><span class="meta">spring.messages.fallback-to-system-locale</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><br>建议:</p>
<p>​    <code>spring.messages.basename</code>支持以逗号分隔的locations,可以是包限定符,也可以是从类路径根目录解析的资源.</p>
</blockquote>
<p>   有关更多受支持的选项,请参见<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceProperties.java"><code>MessageSourceProperties</code></a>.</p>
]]></content>
  </entry>
  <entry>
    <title>3.6 Feature: JSON</title>
    <url>/posts/23342.html</url>
    <content><![CDATA[<h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><p>   Spring Boot提供了三个JSON映射库的集成:</p>
<ul>
<li>Gson</li>
<li>Jackson</li>
<li>JSON-B<br>Jackson是首选的,也是默认库.</li>
</ul>
<ol>
<li><h6 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h6>Spring Boot提供了Jackson的自动配置,并且Jackson是<code>spring-boot-starter-json</code>的一部分. 当Jackson在类路径中,将会自动配置<code>ObjectMapper</code>Bean. 有几个配置属性,用来自定义<code>ObjectMapper</code>的配置.</li>
<li><h6 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h6>针对Gson,Spring Boot自动配置. 当在classpath中有Gson在类中,会自动配置一个<code>Gson</code>bean.有几个<code>spring.gson.*</code>属性配置可以用来自定义配置.为了可以更多的配置,可以使用一个或者多个<code>GsonBuilderCustomizer</code>.</li>
<li><h6 id="JSON-B"><a href="#JSON-B" class="headerlink" title="JSON-B"></a>JSON-B</h6>针对<code>JSON-B</code>自动配置.当在类路径存在JSON-B API其实现类, 将自动配置<code>Jsonb</code>bean. 首选JSON-B的实现是Apache Johnzon, 这个依赖管理已经提供.</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.8 Feature: 优雅停机</title>
    <url>/posts/19259.html</url>
    <content><![CDATA[<h5 id="优雅停机-Graceful-shutdown"><a href="#优雅停机-Graceful-shutdown" class="headerlink" title="优雅停机(Graceful shutdown)"></a>优雅停机(Graceful shutdown)</h5><p>   四个嵌入式Web服务器(Jetty,Reactor Netty,Tomcat和Undertow)以及响应式和基于Servlet的Web应用都支持优雅停机.发生在关闭应用context过程中,并且是在停止<code>SmartLifecycle</code> bean的最早阶段执行.这个停止处理使用一个超时时间,该超时提供一个宽限期,宽限期内,现有请求将被允许完成,但不允许有新的请求进来.所使用的Web服务器不同,不允许新请求的实现方式也不同.Jetty,Reactor Netty和Tomcat将在网络层体制接受请求. Undertow接受请求,但会立即响应服务不可用(503).</p>
<blockquote>
<p>注意:</p>
<p>​    使用Tomcat的优雅停机mcat 9.0.33或更高版本.<br>   要启用优雅停机,配置server.shutdown属性,如以下示例所示:</p>
</blockquote>
   <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.shutdown</span>=<span class="string">graceful</span></span><br></pre></td></tr></table></figure>
<p>   配置超时时间,配置<code>spring.lifecycle.timeout-per-shutdown-phase</code>属性,如以下示例所示:</p>
   <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.lifecycle.timeout-per-shutdown-phase</span>=<span class="string">20s</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>重要:</p>
<p>​    如果IDE无法发送适当的<code>SIGTERM</code>信号,则IDE上,优雅停机可能无法正常工作. 有关更多详细信息,请参阅IDE的文档.</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.9 Feature: RSocket</title>
    <url>/posts/32243.html</url>
    <content><![CDATA[<h5 id="RSocket"><a href="#RSocket" class="headerlink" title="RSocket"></a>RSocket</h5><p>   RSocket是用于字节流传输的二进制协议. 它在单个连接上,传递的异步消息来实现对称交互模型.<br>   Spring框架的<code>spring-messaging</code>模块提供了对RSocket请求和发送的支持,在客户端和服务端都支持. 有关更多详细信息,参见Spring Framework参考中的<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/web-reactive.html#rsocket-spring">RSocket section</a>,其中包括RSocket协议的概述.</p>
<ol>
<li><h6 id="RSocket策略的自动配置-RSocket-Strategies-Auto-configuration"><a href="#RSocket策略的自动配置-RSocket-Strategies-Auto-configuration" class="headerlink" title="RSocket策略的自动配置(RSocket Strategies Auto-configuration)"></a>RSocket策略的自动配置(RSocket Strategies Auto-configuration)</h6>Spring Boot自动配置一个<code>RSocketStrategies</code>bean,该bean提供了对RSocket有效负载的编码和解码基础结构. 默认情况下,自动配置将尝试(按顺序)配置以下内容:<ul>
<li>Jackson的CBOR编解码器</li>
<li>Jackson的JSON编解码器<br><code>spring-boot-starter-rsocket</code>启动器提供了两种依赖关系. 查阅Jackson支持部分,以了解有关定制的更多信息.<br>开发人员可以实现<code>RSocketStrategiesCustomizer</code>接口来自定义<code>RSocketStrategies</code>组件. 注意,<code>@Order</code>很重要,因为它确定编解码器的顺序.</li>
</ul>
</li>
<li><h6 id="RSocket服务器自动配置"><a href="#RSocket服务器自动配置" class="headerlink" title="RSocket服务器自动配置"></a>RSocket服务器自动配置</h6>Spring Boot提供了RSocket服务器自动配置. 所需依赖关系由<code>spring-boot-starter-rsocket</code>提供.<br>Spring Boot支持使用WebFlux服务器或者标准的独立RSocket服务器来暴露公开WebSocket. 这取决于应用类型及其配置.<br>对于WebFlux应用程序(即<code>WebApplicationType.REACTIVE</code>类型),仅当以下属性匹配时,RSocket服务器才会插入Web服务器:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rsocket.server.mapping-path</span>=<span class="string">/rsocket</span></span><br><span class="line"><span class="meta">spring.rsocket.server.transport</span>=<span class="string">websocket</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>警告:</p>
<p>​    由于RSocket本身是使用Reactor Netty构建的,因此只有Reactor Netty支持将RSocket插入Web服务器.<br>另外,也可以以独立的,嵌入式服务器的方式启动RSocket TCP或Websocket服务器. 除了依赖,唯一需要的配置是定义服务器端口:      </p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rsocket.server.port</span>=<span class="string">9898</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Spring-Messaging-RSocket支持-Spring-Messaging-RSocket-support"><a href="#Spring-Messaging-RSocket支持-Spring-Messaging-RSocket-support" class="headerlink" title="Spring Messaging RSocket支持(Spring Messaging RSocket support)"></a>Spring Messaging RSocket支持(Spring Messaging RSocket support)</h6>Spring Boot自动配置Spring Messaging infrastructure来支持RSocket.<br>这意味着Spring Boot将创建一个<code>RSocketMessageHandler</code>bean,该bean用于处理对应用的的RSocket请求.</li>
<li><h6 id="使用RSocketRequester调用RSocket服务-Calling-RSocket-Services-with-RSocketRequester"><a href="#使用RSocketRequester调用RSocket服务-Calling-RSocket-Services-with-RSocketRequester" class="headerlink" title="使用RSocketRequester调用RSocket服务(Calling RSocket Services with RSocketRequester)"></a>使用RSocketRequester调用RSocket服务(Calling RSocket Services with RSocketRequester)</h6>只要服务器和客户端之间建立了RSocket通道,任何一方都可以向另一方发送或接收请求.<br>作为服务器,可以在RSocket <code>@Controller</code>的任何处理程序方法上注入<code>RSocketRequester</code>实例. 作为客户端,首先需要配置和建立RSocket连接. 在这种情况下,Spring Boot会使用期望中的编解码器来自动配置<code>RSocketRequester.Builder</code>.<br><code>RSocketRequester.Builder</code>实例是一个原型bean,这意味着每个注入点将为您提供一个新实例. 这样做是有其原因的,因为此builder是有状态的,因此同一个实例来创建具有不同设置的requesters.<br>以下代码显示了一个典型示例:     <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RSocketRequester rsocketRequester;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(RSocketRequester.Builder rsocketRequesterBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rsocketRequester = rsocketRequesterBuilder.tcp(<span class="string">&quot;example.org&quot;</span>, <span class="number">9898</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">someRSocketCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rsocketRequester.route(<span class="string">&quot;user&quot;</span>).data(name).retrieveMono(User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot Feature</tag>
        <tag>Spring Boot </tag>
      </tags>
  </entry>
  <entry>
    <title>4.1 Actuator:  启用生产就绪功能</title>
    <url>/posts/4391.html</url>
    <content><![CDATA[<h4 id="Spring-Boot-Actuator：生产就绪功能"><a href="#Spring-Boot-Actuator：生产就绪功能" class="headerlink" title="Spring Boot Actuator：生产就绪功能"></a>Spring Boot Actuator：生产就绪功能</h4><p>Spring Boot 包含许多附加功能，应用程序发布到生产环境后,可以帮助监控和管理应用。可以选择使用 HTTP endpoints 或 JMX 来管理和监控应用程序。审计、健康和指标收集也可以自动应用到应用上。</p>
<ol>
<li><h5 id="启用生产就绪功能-Enabling-Production-ready-Features"><a href="#启用生产就绪功能-Enabling-Production-ready-Features" class="headerlink" title="启用生产就绪功能(Enabling Production-ready Features)"></a>启用生产就绪功能(Enabling Production-ready Features)</h5><p><code>spring-boot-actuator</code> 模块提供 Spring Boot 的所有Production-ready功能。启用功能的方法是添加 <code>spring-boot-starter-actuator</code> ‘Starter’的依赖。</p>
<blockquote>
<p>Actuator的定义:</p>
<p>actuator 是一个制造术语，指的是用于移动或控制某物的机械装置。执行器可以从一个小的修改中产生大量的运动。</p>
</blockquote>
<p>要将actuator 添加到基于 Maven 的项目，请添加以下“Starter”依赖项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于 Gradle，请使用以下声明：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Actuator</tag>
      </tags>
  </entry>
  <entry>
    <title>4.10 Acuator: Cloud Foundry 支持</title>
    <url>/posts/55274.html</url>
    <content><![CDATA[<ol start="10">
<li><h5 id="Cloud-Foundry-支持"><a href="#Cloud-Foundry-支持" class="headerlink" title="Cloud Foundry 支持"></a>Cloud Foundry 支持</h5><p>当部署 Cloud Foundry 实例时,将会激活的Spring Boot 的执行器模块所包含的其他的功能支持.  <code>/cloudfoundryapplication</code> 路径为所有<code>@Endpoint</code> bean 提供了一个可以替代的的安全路由. </p>
<p>扩展支持让 Cloud Foundry 管理 UI(例如可用于查看已部署应用程序的 Web 应用)使用 Spring Boot 执行器信息进行扩充.例如,应用状态页面可能包含完整的健康信息,而不是典型的”running”或”stopped”状态.</p>
<blockquote>
<p>注意:</p>
<p>​    普通用户无法直接访问 <code>/cloudfoundryapplication</code> 路径. 为了使用端点,有效的 UAA token 必须与请求一起传递.</p>
</blockquote>
<ol>
<li><h5 id="禁用扩展-Cloud-Foundry-执行器支持-Disabling-Extended-Cloud-Foundry-Actuator-Support"><a href="#禁用扩展-Cloud-Foundry-执行器支持-Disabling-Extended-Cloud-Foundry-Actuator-Support" class="headerlink" title="禁用扩展 Cloud Foundry 执行器支持(Disabling Extended Cloud Foundry Actuator Support)"></a>禁用扩展 Cloud Foundry 执行器支持(Disabling Extended Cloud Foundry Actuator Support)</h5><p>如果要完全禁用 <code>/cloudfoundryapplication</code> 端点,可以将以下设置添加到 <code>application.properties</code> 文件:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.cloudfoundry.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Cloud-Foundry-自签名证书-Cloud-Foundry-Self-signed-Certificates"><a href="#Cloud-Foundry-自签名证书-Cloud-Foundry-Self-signed-Certificates" class="headerlink" title="Cloud Foundry 自签名证书(Cloud Foundry Self-signed Certificates)"></a>Cloud Foundry 自签名证书(Cloud Foundry Self-signed Certificates)</h6><p>默认情况下,<code>/cloudfoundryapplication</code> 端点的安全验证会对各种 Cloud Foundry 服务进行 SSL 调用.如果 Cloud Foundry UAA 或 Cloud Controller 服务使用自签名证书,则需要设置以下属性:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.cloudfoundry.skip-ssl-validation</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="自定义上下文路径-Custom-Context-Path"><a href="#自定义上下文路径-Custom-Context-Path" class="headerlink" title="自定义上下文路径(Custom Context Path)"></a>自定义上下文路径(Custom Context Path)</h6><p>如果服务器的context-path已配置为 <code>/</code> 以外的任何内容,则 Cloud Foundry 端点在应用的根目录中将不可用.例如,如果 <code>server.servlet.context-path=/app</code>,则 Cloud Foundry 端点将在 <code>/app/cloudfoundryapplication/*</code> 处可用.</p>
<p>如果希望 Cloud Foundry 端点始终在 <code>/cloudfoundryapplication/*</code> 可用,无论服务器的上下文路径如何,都需要在应用中显式配置它.配置将因 Web 服务器而异. 对于Tomcat,可以添加如下配置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCloudFoundryConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TomcatServletWebServerFactory <span class="title">servletWebServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TomcatServletWebServerFactory() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(Host host, ServletContextInitializer[] initializers)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.prepareContext(host, initializers);</span><br><span class="line">                StandardContext child = <span class="keyword">new</span> StandardContext();</span><br><span class="line">                child.addLifecycleListener(<span class="keyword">new</span> Tomcat.FixContextListener());</span><br><span class="line">                child.setPath(<span class="string">&quot;/cloudfoundryapplication&quot;</span>);</span><br><span class="line">                ServletContainerInitializer initializer = getServletContextInitializer(getContextPath());</span><br><span class="line">                child.addServletContainerInitializer(initializer, Collections.emptySet());</span><br><span class="line">                child.setCrossContext(<span class="keyword">true</span>);</span><br><span class="line">                host.addChild(child);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ServletContainerInitializer <span class="title">getServletContextInitializer</span><span class="params">(String contextPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (classes, context) -&gt; &#123;</span><br><span class="line">            Servlet servlet = <span class="keyword">new</span> GenericServlet() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">                    ServletContext context = req.getServletContext().getContext(contextPath);</span><br><span class="line">                    context.getRequestDispatcher(<span class="string">&quot;/cloudfoundryapplication&quot;</span>).forward(req, res);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            context.addServlet(<span class="string">&quot;cloudfoundry&quot;</span>, servlet).addMapping(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Actuator</tag>
      </tags>
  </entry>
  <entry>
    <title>4.3 Acuator:  通过 HTTP 进行监控和管理</title>
    <url>/posts/42024.html</url>
    <content><![CDATA[<h5 id="通过-HTTP-进行监控和管理-Monitoring-and-Management-over-HTTP"><a href="#通过-HTTP-进行监控和管理-Monitoring-and-Management-over-HTTP" class="headerlink" title="通过 HTTP 进行监控和管理(Monitoring and Management over HTTP)"></a>通过 HTTP 进行监控和管理(Monitoring and Management over HTTP)</h5><p>如果正在开发 Web 应用程序，Spring Boot Actuator 会自动配置所有启用的endpoint来通过 HTTP 公开。默认约定是使用endpoint的 <code>id</code> 和前缀 <code>/actuator</code> 作为 URL 路径。例如，<code>health</code>暴露为 <code>/actuator/health</code>。</p>
<blockquote>
<p>建议:</p>
<p>   Actuator 由 Spring MVC、Spring WebFlux 和 Jersey 原生支持。 如果 Jersey 和 Spring MVC 都可用，则将使用 Spring MVC。</p>
<p>注意:</p>
<p>   为了获得正确的 JSON 响应，Jackson 是必需的依赖项。</p>
</blockquote>
<ol>
<li><h6 id="自定义管理Endpoint路径-Customizing-the-Management-Endpoint-Paths"><a href="#自定义管理Endpoint路径-Customizing-the-Management-Endpoint-Paths" class="headerlink" title="自定义管理Endpoint路径(Customizing the Management Endpoint Paths)"></a>自定义管理Endpoint路径(Customizing the Management Endpoint Paths)</h6><p>有时，自定义Management endpoint的前缀很有用。例如，应用程序可能已经将 <code>/actuator</code> 用于其他目的。可以使用 <code>management.endpoints.web.base-path</code> 属性来更改管理endpoint的前缀，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.base-path</span>=<span class="string">/manage</span></span><br></pre></td></tr></table></figure>

<p>前面的 <code>application.properties</code> 示例将endpoint从 <code>/actuator/&#123;id&#125;</code> 更改为 <code>/manage/&#123;id&#125;</code>（例如，<code>/manage/info</code>）。</p>
<blockquote>
<p>注意:</p>
<p>   除非已将管理端口配置为使用不同的 HTTP 端口公开endpoint，否则 <code>management.endpoints.web.base-path</code> 相关与 <code>server.servlet.context-path</code>（Servlet Web 应用）或 <code>spring.webflux.base-path</code>（ 响应式 Web 应用）。如果配置了 <code>management.server.port</code>，则 <code>management.endpoints.web.base-path</code> 关联与 <code>management.server.base-path</code>。</p>
</blockquote>
<p>如果要将endpoint映射到不同的路径，可以使用 <code>management.endpoints.web.path-mapping</code> 属性。</p>
<p>以下示例将 <code>/actuator/health</code> 重新映射到 <code>/healthcheck</code>：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.base-path</span>=<span class="string">/</span></span><br><span class="line"><span class="meta">management.endpoints.web.path-mapping.health</span>=<span class="string">healthcheck</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="自定义管理服务器端口-Customizing-the-Management-Server-Port"><a href="#自定义管理服务器端口-Customizing-the-Management-Server-Port" class="headerlink" title="自定义管理服务器端口(Customizing the Management Server Port)"></a>自定义管理服务器端口(Customizing the Management Server Port)</h6><p>使用默认 HTTP 端口公开管理endpoint是基于云的部署的明智选择。但是，如果应用在自己的数据中心内运行，可能更愿意使用不同的 HTTP 端口来公开endpoint。</p>
<p>可以设置 <code>management.server.port</code> 属性来更改 HTTP 端口，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>   在 Cloud Foundry 上，默认情况下，应用仅接收端口 8080 上的 HTTP 和 TCP 路由请求。如果要在 Cloud Foundry 上使用自定义管理端口，则需要明确设置应用的路由以将流量转发到自定义端口。</p>
</blockquote>
</li>
<li><h6 id="配置针对管理的-SSL-Configuring-Management-specific-SSL"><a href="#配置针对管理的-SSL-Configuring-Management-specific-SSL" class="headerlink" title="配置针对管理的 SSL(Configuring Management-specific SSL)"></a>配置针对管理的 SSL(Configuring Management-specific SSL)</h6><p>当配置为使用自定义端口时，还可以使用各种 <code>management.server.ssl.*</code> 属性为管理服务器配置自己的 SSL。例如，这样做可以让管理服务器通过 HTTP 可用，而主应用程序使用 HTTPS，如以下属性设置所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8443</span></span><br><span class="line"><span class="meta">server.ssl.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">server.ssl.key-store</span>=<span class="string">classpath:store.jks</span></span><br><span class="line"><span class="meta">server.ssl.key-password</span>=<span class="string">secret</span></span><br><span class="line"><span class="meta">management.server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="meta">management.server.ssl.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>或者，主服务器和管理服务器都可以使用 SSL，但使用不同的密钥存储，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8443server.ssl.enabled=trueserver.ssl.key-store=classpath:main.jksserver.ssl.key-password=secretmanagement.server.port=8080management.server.ssl.enabled=truemanagement.server.ssl.key-store=classpath:management.jksmanagement.server.ssl.key-password=secret</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="自定义管理服务器地址-Customizing-the-Management-Server-Address"><a href="#自定义管理服务器地址-Customizing-the-Management-Server-Address" class="headerlink" title="自定义管理服务器地址(Customizing the Management Server Address)"></a>自定义管理服务器地址(Customizing the Management Server Address)</h6><p>可以通过设置 <code>management.server.address</code> 属性来自定义管理endpoint可用的地址。如果只想在内部或面向 ops 的网络上侦听，或者只想侦听来自 localhost 的连接，那么这样做会很有用。</p>
<blockquote>
<p>注意:</p>
<p>   只有当端口与主服务器端口不同时，才能侦听不同的地址。</p>
</blockquote>
<p>以下示例 <code>application.properties</code> 不允许远程管理连接：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.server.port</span>=<span class="string">8081management.server.address=127.0.0.1</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="禁用HTTP-Endpoint-Disabling-HTTP-Endpoints"><a href="#禁用HTTP-Endpoint-Disabling-HTTP-Endpoints" class="headerlink" title="禁用HTTP Endpoint(Disabling HTTP Endpoints)"></a>禁用HTTP Endpoint(Disabling HTTP Endpoints)</h6><p>如果不想通过 HTTP 公开endpoint，可以将管理端口设置为 <code>-1</code>，如下例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.server.port</span>=<span class="string">-1</span></span><br></pre></td></tr></table></figure>

<p>这也可以使用 <code>management.endpoints.web.exposure.exclude</code> 属性来实现，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.exclude</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Actuator</tag>
      </tags>
  </entry>
  <entry>
    <title>4.4 Acuator:  通过 JMX 进行监控和管理</title>
    <url>/posts/64967.html</url>
    <content><![CDATA[<h5 id="通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX"><a href="#通过-JMX-进行监控和管理-Monitoring-and-Management-over-JMX" class="headerlink" title="通过 JMX 进行监控和管理(Monitoring and Management over JMX)"></a>通过 JMX 进行监控和管理(Monitoring and Management over JMX)</h5><p>Java 管理扩展 (JMX) 提供了一种标准机制来监视和管理应用程序。默认情况下，此功能未启用，可以通过将配置属性 <code>spring.jmx.enabled</code> 设置为 <code>true</code> 来开启。默认情况下，Spring Boot 将管理endpoint公开为 <code>org.springframework.boot</code> 域下的 JMX MBean。要完全控制 JMX 域中的endpoint注册，考虑注册自己的 <code>EndpointObjectNameFactory</code> 实现。</p>
<ol>
<li><h6 id="自定义-MBean-名称-Customizing-MBean-Names"><a href="#自定义-MBean-名称-Customizing-MBean-Names" class="headerlink" title="自定义 MBean 名称(Customizing MBean Names)"></a>自定义 MBean 名称(Customizing MBean Names)</h6><p>MBean 的名称通常从endpoint的 id 生成。例如，<code>health</code>endpoint公开为<code>org.springframework.boot:type=Endpoint,name=Health</code>。</p>
<p>如果应用包含多个 Spring <code>ApplicationContext</code>，可能会发现名称冲突。要解决此问题，可以将 <code>spring.jmx.unique-names</code> 属性设置为 <code>true</code>，以便 MBean 名称始终唯一。</p>
<p>还可以自定义公开endpoint的 JMX 域。 以下设置显示了在 <code>application.properties</code> 中执行此操作的示例：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jmx.unique-names</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">management.endpoints.jmx.domain</span>=<span class="string">com.example.myapp</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="禁用-JMX-Endpoint-Disabling-JMX-Endpoints"><a href="#禁用-JMX-Endpoint-Disabling-JMX-Endpoints" class="headerlink" title="禁用 JMX Endpoint(Disabling JMX Endpoints)"></a>禁用 JMX Endpoint(Disabling JMX Endpoints)</h6><p>如果不想通过 JMX 公开endpoint，可以将 <code>management.endpoints.jmx.exposure.exclude</code> 属性设置为 <code>*</code>，如下例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.jmx.exposure.exclude</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="将-Jolokia-用于基于-HTTP-的-JMX-Using-Jolokia-for-JMX-over-HTTP"><a href="#将-Jolokia-用于基于-HTTP-的-JMX-Using-Jolokia-for-JMX-over-HTTP" class="headerlink" title="将 Jolokia 用于基于 HTTP 的 JMX(Using Jolokia for JMX over HTTP)"></a>将 Jolokia 用于基于 HTTP 的 JMX(Using Jolokia for JMX over HTTP)</h6><p>Jolokia 是一个 JMX-HTTP 桥，它提供了一种访问 JMX bean 的替代方法。要使用 Jolokia，要包含对 <code>org.jolokia:jolokia-core</code> 的依赖项。 例如，使用 Maven，将添加以下依赖项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jolokia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jolokia-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后可以通过将 <code>jolokia</code> 或 <code>*</code> 添加到 <code>management.endpoints.web.exposure.include</code> 属性来公开 Jolokia endpoint。然后，可以通过在管理 HTTP 服务器上使用 <code>/actuator/jolokia</code> 来访问。</p>
<blockquote>
<p>注意:</p>
<p>   Jolokia endpoint将 Jolokia 的 servlet 作为actuatorendpoint公开。因此，它特定于 servlet 环境，例如 Spring MVC 和 Jersey。该endpoint在 WebFlux 应用中不可用。</p>
</blockquote>
<ol>
<li><h6 id="自定义-Jolokia-Customizing-Jolokia"><a href="#自定义-Jolokia-Customizing-Jolokia" class="headerlink" title="自定义 Jolokia(Customizing Jolokia)"></a>自定义 Jolokia(Customizing Jolokia)</h6><p>Jolokia 有许多设置，通常会通过设置 servlet 参数来配置这些设置。通过 Spring Boot，可以使用 <code>application.properties</code> 文件。为此，请使用 <code>management.endpoint.jolokia.config.</code> 作为参数的前缀，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoint.jolokia.config.debug</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="禁用-Jolokia-Disabling-Jolokia"><a href="#禁用-Jolokia-Disabling-Jolokia" class="headerlink" title="禁用 Jolokia(Disabling Jolokia)"></a>禁用 Jolokia(Disabling Jolokia)</h6><p>如果使用 Jolokia 但不希望 Spring Boot 对其进行配置，请将 <code>management.endpoint.jolokia.enabled</code> 属性设置为 <code>false</code>，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoint.jolokia.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>4.5 Acuator: 日志</title>
    <url>/posts/48342.html</url>
    <content><![CDATA[<h5 id="日志-Loggers"><a href="#日志-Loggers" class="headerlink" title="日志(Loggers)"></a>日志(Loggers)</h5><p>Spring Boot Actuator 具有在运行时查看和配置应用程序日志级别的能力。可以查看整个列表或单个记录器的配置，它由显式配置的日志记录级别以及日志记录框架为其提供的有效日志记录级别组成。 这些级别可以是以下级别之一：</p>
<ul>
<li><p><code>TRACE</code></p>
</li>
<li><p><code>DEBUG</code></p>
</li>
<li><p><code>INFO</code></p>
</li>
<li><p><code>WARN</code></p>
</li>
<li><p><code>ERROR</code></p>
</li>
<li><p><code>FATAL</code></p>
</li>
<li><p><code>OFF</code></p>
</li>
<li><p><code>null</code></p>
</li>
</ul>
<p><code>null</code> 表示没有显式配置。</p>
<ol>
<li><h6 id="配置日志器-Configure-a-Logger"><a href="#配置日志器-Configure-a-Logger" class="headerlink" title="配置日志器(Configure a Logger)"></a>配置日志器(Configure a Logger)</h6><p>要配置给定的logger，请将部分实体 <code>POST</code> 到资源的 URI，如以下示例所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;configuredLevel&quot;</span>: <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>   要“重置”记录器的指定级别（并改用默认配置），您可以传递一个 <code>null</code> 作为<code>configuredLevel</code>。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Actuator</tag>
      </tags>
  </entry>
  <entry>
    <title>4.7 Acuator: 审计</title>
    <url>/posts/24567.html</url>
    <content><![CDATA[<ol start="7">
<li><h5 id="审计-Auditing"><a href="#审计-Auditing" class="headerlink" title="审计(Auditing)"></a>审计(Auditing)</h5><p>一旦 Spring Security 发挥作用,Spring Boot Actuator 就有一个灵活的审计框架来发布事件( 默认情况下,”authentication success”,”failure”和”access denied”异常).此功能对于报告和实施基于身份验证失败的锁定策略非常有用.</p>
<p>可以通过在应用配置中提供类型为 <code>AuditEventRepository</code> 的 bean 来启用审计.为方便起见,Spring Boot 提供了一个 <code>InMemoryAuditEventRepository</code>.<code>InMemoryAuditEventRepository</code> 的功能有限,建议仅将其用于开发环境.对于生产环境,请考虑创建自己的替代 <code>AuditEventRepository</code> 实现.</p>
<ol>
<li><h6 id="Custom-Auditing"><a href="#Custom-Auditing" class="headerlink" title="Custom Auditing"></a>Custom Auditing</h6><p>要自定义发布的安全事件,可以提供自己的 <code>AbstractAuthenticationAuditListener</code> 和 <code>AbstractAuthorizationAuditListener</code> 实现.</p>
<p>还可以将审计服务用于自己的业务事件.为此,请将 <code>AuditEventRepository</code> bean 注入自己的组件并直接使用它,或者使用 Spring <code>ApplicationEventPublisher</code>( 通过实现 <code>ApplicationEventPublisherAware</code>)发布 <code>AuditApplicationEvent</code>.</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Actuator</tag>
      </tags>
  </entry>
  <entry>
    <title>4.8 Acuator:  HTTP 追踪</title>
    <url>/posts/64760.html</url>
    <content><![CDATA[<ol start="8">
<li><h5 id="HTTP-追踪-HTTP-Tracing"><a href="#HTTP-追踪-HTTP-Tracing" class="headerlink" title="HTTP 追踪(HTTP Tracing)"></a>HTTP 追踪(HTTP Tracing)</h5><p>可以在应用的配置中提供类型为 <code>HttpTraceRepository</code> 的 bean 来启用 HTTP 跟踪.为方便起见,默认情况下,Spring Boot 提供了一个 <code>InMemoryHttpTraceRepository</code>,用于存储最近 100 个请求-响应交换的跟踪.<code>InMemoryHttpTraceRepository</code> 与其他跟踪解决方案相比功能有限,建议仅将其用于开发环境.对于生产环境,建议使用生产就绪的跟踪或可观察性解决方案,例如 Zipkin 或 Spring Cloud Sleuth.或者,创建自己的 <code>HttpTraceRepository</code> 以满足需求.</p>
<p><code>httptrace</code> 端点可用于获取存储在 <code>HttpTraceRepository</code> 中的有关请求-响应交换的信息.</p>
<ol>
<li><h6 id="自定义-HTTP-跟踪-Custom-HTTP-tracing"><a href="#自定义-HTTP-跟踪-Custom-HTTP-tracing" class="headerlink" title="自定义 HTTP 跟踪(Custom HTTP tracing)"></a>自定义 HTTP 跟踪(Custom HTTP tracing)</h6><p>要自定义每个跟踪中包含的项目,请使用 <code>management.trace.http.include</code> 配置属性.对于高级自定义,考虑注册自己的 <code>HttpExchangeTracer</code> 实现.</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Actuator</tag>
      </tags>
  </entry>
  <entry>
    <title>4.9 Acuator: 进程监控</title>
    <url>/posts/21505.html</url>
    <content><![CDATA[<ol start="9">
<li><h5 id="进程监控-Process-Monitoring"><a href="#进程监控-Process-Monitoring" class="headerlink" title="进程监控(Process Monitoring)"></a>进程监控(Process Monitoring)</h5><p>在 <code>spring-boot</code> 模块中,可以找到两个类来创建用于进程监控的文件:</p>
<ul>
<li><code>ApplicationPidFileWriter</code> 创建一个包含应用程序 PID 的文件(默认情况下,在应用程序目录中,文件名为”<code>application.pid</code>“).</li>
<li><code>WebServerPortFileWriter</code> 创建一个文件(或多个文件),其中包含正在运行的 Web 服务器的端口(默认情况下,在应用程序目录中,文件名为”<code>application.port</code>“).</li>
</ul>
<p>默认情况下,这些writers未激活,但可以启用:</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.process-monitoring.configuration">By Extending Configuration</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.process-monitoring.programmatically">Programmatically</a></li>
</ul>
</li>
</ol>
<ol>
<li><h6 id="扩展配置-Extending-Configuration"><a href="#扩展配置-Extending-Configuration" class="headerlink" title="扩展配置(Extending Configuration)"></a>扩展配置(Extending Configuration)</h6><p>在 <code>META-INF/spring.factories</code> 文件中,可以启用写入 PID 文件的监听器,如下例所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.context.ApplicationPidFileWriter,\</span><br><span class="line">org.springframework.boot.web.context.WebServerPortFileWriter</span><br></pre></td></tr></table></figure></li>
<li><h6 id="编程方式实现-Programmatically"><a href="#编程方式实现-Programmatically" class="headerlink" title="编程方式实现(Programmatically)"></a>编程方式实现(Programmatically)</h6><p>还可以通过调用 <code>SpringApplication.addListeners(… ) </code>方法并传递适当的 <code>Writer</code> 对象来激活监听器.此方法还允许在 <code>Writer</code> 构造函数中自定义文件名和路径.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Actuator</tag>
      </tags>
  </entry>
  <entry>
    <title>5.1 Deploy:  部署Spring Boot应用</title>
    <url>/posts/15372.html</url>
    <content><![CDATA[<h5 id="部署Spring-Boot应用-Deploying-Spring-Boot-Applications"><a href="#部署Spring-Boot应用-Deploying-Spring-Boot-Applications" class="headerlink" title="部署Spring Boot应用(Deploying Spring Boot Applications)"></a>部署Spring Boot应用(Deploying Spring Boot Applications)</h5><p>Spring Boot 的灵活打包选项在部署应用时,提供了大量选择.可以将 Spring Boot 应用程序部署到各种云平台,容器映像( 例如 Docker)或虚拟/真实机器上.</p>
<p>本节介绍了一些更常见的部署方案.</p>
<ol>
<li><h5 id="部署到容器-Deploying-to-Containers"><a href="#部署到容器-Deploying-to-Containers" class="headerlink" title="部署到容器(Deploying to Containers)"></a>部署到容器(Deploying to Containers)</h5><p>如果从容器运行应用,则可以使用可执行 jar,但将其unexploded 并以不同方式运行它通常也是一个优势.某些 PaaS 实现也能在运行之前解压缩存档.例如,Cloud Foundry 就是这样运作的. 运行解压存档的一种方法是启动合适的启动器,如下所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jar -xf myapp.jar</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java org.springframework.boot.loader.JarLauncher</span></span><br></pre></td></tr></table></figure>

<p>这实际上在启动时( 取决于 jar 的大小)比从未unexploded 的存档中运行要快一些. 在运行时,没有任何差异.</p>
<p>解压 jar 文件后,还可以通过使用其”自然”main 方法而不是 <code>JarLauncher</code> 运行应用程序来获得额外的启动时间. 例如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jar -xf myapp.jar</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -cp BOOT-INF/classes:BOOT-INF/lib/* com.example.MyApplication</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    在应用程序的 main 方法上使用 <code>JarLauncher</code> 具有其他好处:可以预测的类路径的顺序.jar 包含一个 <code>classpath.idx</code> 文件,<code>JarLauncher</code> 在构造类路径时使用该文件.</p>
</blockquote>
<p>可以通过[创建单独的层](<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.container-images.building">https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.container-images.building</a> .dockerfiles) 用于依赖项和应用程序类和资源( 通常更改更频繁)来更高效的容器镜像.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>6. Spring Boot CLI</title>
    <url>/posts/49381.html</url>
    <content><![CDATA[<h4 id="Spring-Boot-CLI"><a href="#Spring-Boot-CLI" class="headerlink" title="Spring Boot CLI"></a>Spring Boot CLI</h4><p>Spring Boot CLI 是一个命令行工具,如果想快速开发 Spring 应用程序,可以使用它.它允许运行 Groovy 脚本,这意味着拥有类似 Java 的语法,而无需太多样板代码.还可以引导一个新项目或为它编写自己的命令.</p>
<ol>
<li><h5 id="安装-CLI-Installing-the-CLI"><a href="#安装-CLI-Installing-the-CLI" class="headerlink" title="安装 CLI(Installing the CLI)"></a>安装 CLI(Installing the CLI)</h5><p>可以使用 SDKMAN(SDK 管理器)手动安装 Spring Boot CLI(Command-Line Interface)或使用 Homebrew 或 MacPorts(如果是 OSX 用户).</p>
</li>
<li><h5 id="使用-CLI-Using-the-CLI"><a href="#使用-CLI-Using-the-CLI" class="headerlink" title="使用 CLI(Using the CLI)"></a>使用 CLI(Using the CLI)</h5><p>安装 CLI 后,可以在命令行中输入 <code>spring</code> 并按 Enter 来运行它.如果不带任何参数运行 <code>spring</code>,将显示帮助屏幕,如下所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring</span></span><br><span class="line">usage: spring [--help] [--version]</span><br><span class="line">       &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Available commands are:</span><br><span class="line"></span><br><span class="line">  run [options] &lt;files&gt; [--] [args]</span><br><span class="line">    Run a spring groovy script</span><br><span class="line"></span><br><span class="line">  _... more command help is shown here_</span><br></pre></td></tr></table></figure>

<p>可以输入 <code>spring help</code> 以获取有关任何受支持命令的更多详细信息,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring <span class="built_in">help</span> run</span></span><br><span class="line">spring run - Run a spring groovy script</span><br><span class="line"></span><br><span class="line">usage: spring run [options] &lt;files&gt; [--] [args]</span><br><span class="line"></span><br><span class="line">Option                     Description</span><br><span class="line">------                     -----------</span><br><span class="line">--autoconfigure [Boolean]  Add autoconfigure compiler</span><br><span class="line">                             transformations (default: true)</span><br><span class="line">--classpath, -cp           Additional classpath entries</span><br><span class="line">--no-guess-dependencies    Do not attempt to guess dependencies</span><br><span class="line">--no-guess-imports         Do not attempt to guess imports</span><br><span class="line">-q, --quiet                Quiet logging</span><br><span class="line">-v, --verbose              Verbose logging of dependency</span><br><span class="line">                             resolution</span><br><span class="line">--watch                    Watch the specified file for changes</span><br></pre></td></tr></table></figure>

<p><code>version</code> 命令提供了一种快速检查使用的 Spring Boot 版本的方法,如下所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring version</span></span><br><span class="line">Spring CLI v2.5.0</span><br></pre></td></tr></table></figure>

<ol>
<li><h6 id="使用-CLI-运行应用程序-Running-Applications-with-the-CLI"><a href="#使用-CLI-运行应用程序-Running-Applications-with-the-CLI" class="headerlink" title="使用 CLI 运行应用程序(Running Applications with the CLI)"></a>使用 CLI 运行应用程序(Running Applications with the CLI)</h6><p>可以使用 <code>run</code> 命令编译和运行 Groovy 源代码.Spring Boot CLI 是完全独立的,因此不需要任何外部 Groovy 安装.</p>
<p>以下示例显示了一个用 Groovy 编写的”hello world”Web 应用程序:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebApplication</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    String home() &#123;</span><br><span class="line">        <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要编译和运行应用程序,请输入以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring run hello.groovy</span></span><br></pre></td></tr></table></figure>

<p>要将命令行参数传递给应用程序,请使用<code>--</code> 将命令与”spring”命令参数分开,如下例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring run hello.groovy -- --server.port=9000</span></span><br></pre></td></tr></table></figure>

<p>要设置 JVM 命令行参数,可以使用 <code>JAVA_OPTS</code> 环境变量,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> JAVA_OPTS=-Xmx1024m spring run hello.groovy</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    在 Microsoft Windows 上设置 <code>JAVA_OPTS</code> 时,请确保引用整个指令,例如设置”<code>JAVA_OPTS=-Xms256m -Xmx2048m</code>“. 这样做可确保将值正确传递给进程.</p>
</blockquote>
<ol>
<li><h6 id="推导出的”抓取”依赖关系-Deduced-“grab”-Dependencies"><a href="#推导出的”抓取”依赖关系-Deduced-“grab”-Dependencies" class="headerlink" title="推导出的”抓取”依赖关系(Deduced “grab” Dependencies)"></a>推导出的”抓取”依赖关系(Deduced “grab” Dependencies)</h6><p>标准 Groovy 包括一个 <code>@Grab</code> 注解,它允许声明对第三方库的依赖关系.这项有用的技术让 Groovy 以与 Maven 或 Gradle 相同的方式下载 jar,但不需要使用构建工具.</p>
<p>Spring Boot 进一步扩展了这项技术,并尝试根据代码推断出要”抓取”哪些库.例如,由于之前显示的 Web 应用程序代码使用了 <code>@RestController</code> 注解,因此 Spring Boot 会抓取”Tomcat”和”Spring MVC”.</p>
<p>以下项目用作”抓取提示”:</p>
<table>
<thead>
<tr>
<th>Items</th>
<th>Grabs</th>
</tr>
</thead>
<tbody><tr>
<td><code>JdbcTemplate</code>, <code>NamedParameterJdbcTemplate</code>, <code>DataSource</code></td>
<td>JDBC Application.</td>
</tr>
<tr>
<td><code>@EnableJms</code></td>
<td>JMS Application.</td>
</tr>
<tr>
<td><code>@EnableCaching</code></td>
<td>Caching abstraction.</td>
</tr>
<tr>
<td><code>@Test</code></td>
<td>JUnit.</td>
</tr>
<tr>
<td><code>@EnableRabbit</code></td>
<td>RabbitMQ.</td>
</tr>
<tr>
<td>extends <code>Specification</code></td>
<td>Spock test.</td>
</tr>
<tr>
<td><code>@EnableBatchProcessing</code></td>
<td>Spring Batch.</td>
</tr>
<tr>
<td><code>@MessageEndpoint</code> <code>@EnableIntegration</code></td>
<td>Spring Integration.</td>
</tr>
<tr>
<td><code>@Controller</code> <code>@RestController</code> <code>@EnableWebMvc</code></td>
<td>Spring MVC + Embedded Tomcat.</td>
</tr>
<tr>
<td><code>@EnableWebSecurity</code></td>
<td>Spring Security.</td>
</tr>
<tr>
<td><code>@EnableTransactionManagement</code></td>
<td>Spring Transaction Management.</td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>​    参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-cli/src/main/java/org"><code>CompilerAutoConfiguration</code></a> 的子类,在 Spring Boot CLI 源代码中,以准确了解如何应用自定义.</p>
</blockquote>
</li>
<li><h6 id="推导出的”抓取”坐标-Deduced-“grab”-Coordinates"><a href="#推导出的”抓取”坐标-Deduced-“grab”-Coordinates" class="headerlink" title="推导出的”抓取”坐标(Deduced “grab” Coordinates)"></a>推导出的”抓取”坐标(Deduced “grab” Coordinates)</h6><p>Spring Boot 扩展了 Groovy 的标准 <code>@Grab</code> 支持,允许指定没有组或版本的依赖项(例如,<code>@Grab(&#39;freemarker&#39;)</code>).这样做会参考 Spring Boot 的默认依赖项元数据来推断artifact的组和版本.</p>
<blockquote>
<p>注意:</p>
<p>​    默认元数据与使用的 CLI 版本相关联. 它仅在迁移到到新版本的 CLI 时才会更改,可以控制依赖项的版本何时可能更改.</p>
</blockquote>
</li>
<li><h6 id="默认导入语句-Default-Import-Statements"><a href="#默认导入语句-Default-Import-Statements" class="headerlink" title="默认导入语句(Default Import Statements)"></a>默认导入语句(Default Import Statements)</h6><p>为了帮助减少 Groovy 代码的大小,自动包含了几个<code>import</code>语句.请注意前面的示例如何引用 <code>@Component</code>,<code>@RestController</code> 和 <code>@RequestMapping</code> 而无需使用完全限定名称或<code>import</code>语句.</p>
<blockquote>
<p>建议:</p>
<p>​    许多 Spring 注解可以在不使用 <code>import</code> 语句的情况下工作. 在添加导入之前尝试运行应用的方式来查看失败的内容.</p>
</blockquote>
</li>
<li><h6 id="自动Main方法-Automatic-Main-Method"><a href="#自动Main方法-Automatic-Main-Method" class="headerlink" title="自动Main方法(Automatic Main Method)"></a>自动Main方法(Automatic Main Method)</h6><p>与等效的 Java 应用程序不同,不需要在 Groovy 脚本中包含 <code>public static void main(String[] args)</code> 方法. <code>SpringApplication</code> 是自动创建的,编译的代码作为源代码.</p>
</li>
<li><h6 id="自定义依赖管理-Custom-Dependency-Management"><a href="#自定义依赖管理-Custom-Dependency-Management" class="headerlink" title="自定义依赖管理(Custom Dependency Management)"></a>自定义依赖管理(Custom Dependency Management)</h6><p>默认情况下,CLI 在解析 <code>@Grab</code> 依赖项时使用 <code>spring-boot-dependencies</code> 中声明的依赖项管理.用来覆盖默认依赖管理的其他依赖管理,可以使用<code>@DependencyManagementBom</code> 注解实现.注解的值应指定一个或多个 Maven BOM 的坐标 (<code>groupId:artifactId:version</code>).</p>
<p>例如,考虑以下声明:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DependencyManagementBom</span>(<span class="string">&quot;com.example.custom-bom:1.0.0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>前面的声明在 <code>com/example/custom-versions/1.0.0/</code> 下的 Maven 存储库中选择 <code>custom-bom-1.0.0.pom</code>.</p>
<p>当指定多个 BOM 时,它们将按照声明顺序应用,如以下示例所示:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DependencyManagementBom</span>([    <span class="string">&quot;com.example.custom-bom:1.0.0&quot;</span>,    <span class="string">&quot;com.example.another-bom:1.0.0&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>前面的例子表明 <code>another-bom</code> 中的依赖管理覆盖了 <code>custom-bom</code> 中的依赖管理.</p>
<p>可以在任何可以使用<code>@Grab</code> 的地方使用<code>@DependencyManagementBom</code>. 但是,为了确保依赖项管理的顺序一致,最多可以在应用程序中使用 <code>@DependencyManagementBom</code> 一次.</p>
</li>
</ol>
</li>
<li><h6 id="具有多个源文件的应用程序-Applications-with-Multiple-Source-Files"><a href="#具有多个源文件的应用程序-Applications-with-Multiple-Source-Files" class="headerlink" title="具有多个源文件的应用程序(Applications with Multiple Source Files)"></a>具有多个源文件的应用程序(Applications with Multiple Source Files)</h6><p>可以对所有接受文件输入的命令使用”shell globbing”.这样做可以使用单个目录中的多个文件,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring run *.groovy</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="打包应用程序-Packaging-Your-Application"><a href="#打包应用程序-Packaging-Your-Application" class="headerlink" title="打包应用程序(Packaging Your Application)"></a>打包应用程序(Packaging Your Application)</h6><p>可以使用 <code>jar</code> 命令将应用打包成一个自包含的可执行 jar 文件,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring jar my-app.jar *.groovy</span></span><br></pre></td></tr></table></figure>

<p>生成的 jar 包含通过编译应用程序生成的类以及应用程序的所有依赖项,以便可以使用 <code>java -jar </code>运行它.jar 文件还包含来自应用程序类路径的条目. 可以使用 <code>--include</code> 和 <code>--exclude</code> 添加和删除 jar 的显式路径.两者都以逗号分隔,并且都接受”+”和”-“形式的前缀,以表示它们应该从默认值中删除.</p>
<p>默认包含的如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public/**, resources/**, static/**, templates/**, META-INF/**, *</span><br></pre></td></tr></table></figure>

<p>默认排除如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.*, repository/**, build/**, target/**, **/*.jar, **/*.groovy</span><br></pre></td></tr></table></figure>

<p>在命令行中输入 <code>spring help jar</code> 以获取更多信息.</p>
</li>
<li><h6 id="初始化一个新项目-Initialize-a-New-Project"><a href="#初始化一个新项目-Initialize-a-New-Project" class="headerlink" title="初始化一个新项目(Initialize a New Project)"></a>初始化一个新项目(Initialize a New Project)</h6><p><code>init</code> 命令允许使用 <code>start.spring.io</code> 创建一个新项目,而无需离开 shell,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring init --dependencies=web,data-jpa my-projectUsing service at https://start.spring.ioProject extracted to <span class="string">&#x27;/Users/developer/example/my-project&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>前面的示例使用基于 Maven 的项目创建了一个 <code>my-project</code> 目录,该项目使用 <code>spring-boot-starter-web</code> 和 <code>spring-boot-starter-data-jpa</code>..可以使用 <code>--list</code> 标志位列出服务的功能,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring init --list=======================================Capabilities of https://start.spring.io=======================================Available dependencies:-----------------------actuator - Actuator: Production ready features to <span class="built_in">help</span> you monitor and manage your application...web - Web: Support <span class="keyword">for</span> full-stack web development, including Tomcat and spring-webmvcwebsocket - Websocket: Support <span class="keyword">for</span> WebSocket developmentws - WS: Support <span class="keyword">for</span> Spring Web ServicesAvailable project types:------------------------gradle-build -  Gradle Config [format:build, build:gradle]gradle-project -  Gradle Project [format:project, build:gradle]maven-build -  Maven POM [format:build, build:maven]maven-project -  Maven Project [format:project, build:maven] (default)...</span></span><br></pre></td></tr></table></figure>

<p><code>init</code> 命令支持许多选项. 有关更多详细信息,请参阅帮助输出. 例如,以下命令创建一个使用 Java 8 和 <code>war</code> 打包的 Gradle 项目:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring init --build=gradle --java-version=1.8 --dependencies=websocket --packaging=war sample-app.zipUsing service at https://start.spring.ioContent saved to <span class="string">&#x27;sample-app.zip&#x27;</span></span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="使用嵌入式-Shell-Using-the-Embedded-Shell"><a href="#使用嵌入式-Shell-Using-the-Embedded-Shell" class="headerlink" title="使用嵌入式 Shell(Using the Embedded Shell)"></a>使用嵌入式 Shell(Using the Embedded Shell)</h6><p>Spring Boot 包含用于 BASH 和 zsh shell 的命令行完整脚本.如果不使用其中任何一个 shell(可能您是 Windows 用户),可以使用 <code>shell</code> 命令启动一个集成的 shell,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring shellSpring Boot (v2.5.0)Hit TAB to complete. Type \<span class="string">&#x27;help&#x27;</span> and hit RETURN <span class="keyword">for</span> <span class="built_in">help</span>, and \<span class="string">&#x27;exit&#x27;</span> to quit.</span></span><br></pre></td></tr></table></figure>

<p>从嵌入式 shell 内部,可以直接运行其他命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> versionSpring CLI v2.5.0</span></span><br></pre></td></tr></table></figure>

<p>嵌入式shell支持 ANSI 颜色输出以及<code>tab</code>补全.如果需要运行本机命令,可以使用 <code>!</code> 前缀. 要退出嵌入式 shell,请按 <code>ctrl-c</code>.</p>
</li>
<li><h6 id="向-CLI-添加扩展-Adding-Extensions-to-the-CLI"><a href="#向-CLI-添加扩展-Adding-Extensions-to-the-CLI" class="headerlink" title="向 CLI 添加扩展(Adding Extensions to the CLI)"></a>向 CLI 添加扩展(Adding Extensions to the CLI)</h6><p>可以使用 <code>install</code> 命令向 CLI 添加扩展.该命令采用 <code>group:artifact:version</code> 格式的一组或多组artifact坐标,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring install com.example:spring-boot-cli-extension:1.0.0.RELEASE</span></span><br></pre></td></tr></table></figure>

<p>除了安装提供的坐标标识的artifact之外,还安装了所有artifact的依赖项.要卸载依赖项,使用<code>uninstall</code>命令. 与 <code>install</code> 命令一样,它采用 <code>group:artifact:version</code> 格式的一组或多组artifact坐标,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring uninstall com.example:spring-boot-cli-extension:1.0.0.RELEASE</span></span><br></pre></td></tr></table></figure>

<p>它会卸载提供的坐标及其依赖项标识的artifact.</p>
<p>要卸载所有其他依赖项,可以使用 <code>--all</code> 选项,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring uninstall --all</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="使用-Groovy-Beans-DSL-开发应用程序-Developing-Applications-with-the-Groovy-Beans-DSL"><a href="#使用-Groovy-Beans-DSL-开发应用程序-Developing-Applications-with-the-Groovy-Beans-DSL" class="headerlink" title="使用 Groovy Beans DSL 开发应用程序(Developing Applications with the Groovy Beans DSL)"></a>使用 Groovy Beans DSL 开发应用程序(Developing Applications with the Groovy Beans DSL)</h5><p>Spring Framework 4.0 原生支持 <code>beans&#123;&#125;</code> “DSL”(从 Grails 借来),可以使用相同的格式将 bean 定义嵌入到 Groovy 应用脚本中.这有时是包含中间件声明等外部功能的好方法,如以下示例所示:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="literal">false</span>)<span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> &#123;</span>    <span class="meta">@Autowired</span>    SharedService service    <span class="meta">@Override</span>    <span class="keyword">void</span> run(String... args) &#123;        println service.message    &#125;&#125;<span class="keyword">import</span> my.company.SharedServicebeans &#123;    service(SharedService) &#123;        message = <span class="string">&quot;Hello World&quot;</span>    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>可以将类声明与 <code>beans&#123;&#125;</code> 混合在同一个文件中,只要它们保持在顶层,或者,如果愿意,可以将 beans DSL 放在单独的文件中.</p>
</li>
<li><h5 id="使用-settings-xml-配置-CLI-Configuring-the-CLI-with-settings-xml"><a href="#使用-settings-xml-配置-CLI-Configuring-the-CLI-with-settings-xml" class="headerlink" title="使用 settings.xml 配置 CLI (Configuring the CLI with settings.xml)"></a>使用 settings.xml 配置 CLI (Configuring the CLI with settings.xml)</h5><p>Spring Boot CLI 使用 Maven 的依赖解析引擎 Aether 来解析依赖.CLI 使用 <code>~/.m2/settings.xml</code> 中的 Maven 配置来配置 Aether.CLI 遵循以下配置设置:</p>
<ul>
<li>Offline</li>
<li>Mirrors</li>
<li>Servers</li>
<li>Proxies</li>
<li>Profiles<ul>
<li>Activation</li>
<li>Repositories</li>
</ul>
</li>
<li>Active profiles</li>
</ul>
</li>
</ol>
<p>`</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot CLI</tag>
      </tags>
  </entry>
  <entry>
    <title>7. Build Tool Plugins</title>
    <url>/posts/13348.html</url>
    <content><![CDATA[<h4 id="构建工具插件-Build-Tool-Plugins"><a href="#构建工具插件-Build-Tool-Plugins" class="headerlink" title="构建工具插件(Build Tool Plugins)"></a>构建工具插件(Build Tool Plugins)</h4><p>Spring Boot 为 Maven 和 Gradle 提供了构建工具插件.这些插件提供了多种功能,包括可执行 jar 的打包.本节提供了有关这两个插件的更多详细信息,并在需要扩展不受支持的构建系统时提供一些帮助.</p>
<ol>
<li><h5 id="Spring-Boot-Maven-插件-Spring-Boot-Maven-Plugin"><a href="#Spring-Boot-Maven-插件-Spring-Boot-Maven-Plugin" class="headerlink" title="Spring Boot Maven 插件(Spring Boot Maven Plugin)"></a>Spring Boot Maven 插件(Spring Boot Maven Plugin)</h5><p>Spring Boot Maven 插件在 Maven 中提供 Spring Boot 支持,可以打包可执行的 jar 或 war 文件并”就地”运行应用程序. 要使用它,必须使用 Maven 3.2(或更高版本).</p>
<p>请参阅插件的文档以了解更多信息:</p>
<ul>
<li>参考 (<a href="https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/reference/htmlsingle/">HTML</a> 和 [PDF](<a href="https://docs.spring.io/">https://docs.spring.io</a> /spring-boot/docs/2.5.0/maven-plugin/reference/pdf/spring-boot-maven-plugin-reference.pdf))</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/api/">API</a></li>
</ul>
</li>
<li><h5 id="Spring-Boot-AntLib-模块-Spring-Boot-AntLib-Module"><a href="#Spring-Boot-AntLib-模块-Spring-Boot-AntLib-Module" class="headerlink" title="Spring Boot AntLib 模块(Spring Boot AntLib Module)"></a>Spring Boot AntLib 模块(Spring Boot AntLib Module)</h5><p>Spring Boot AntLib 模块为 Apache Ant 提供基本的 Spring Boot 支持. 可以使用该模块创建可执行的 jar.要使用该模块,需要在 <code>build.xml</code> 中声明一个额外的 <code>spring-boot</code> 命名空间,如以下示例所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:ivy</span>=<span class="string">&quot;antlib:org.apache.ivy.ant&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:spring-boot</span>=<span class="string">&quot;antlib:org.springframework.boot.ant&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;myapp&quot;</span> <span class="attr">default</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要记住使用 <code>-lib</code> 选项启动 Ant,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ant -lib &lt;directory containing spring-boot-antlib-2.5.0.jar&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Spring-Boot-AntLib-模块-Spring-Boot-AntLib-Module-1"><a href="#Spring-Boot-AntLib-模块-Spring-Boot-AntLib-Module-1" class="headerlink" title="Spring Boot AntLib 模块(Spring Boot AntLib Module)"></a>Spring Boot AntLib 模块(Spring Boot AntLib Module)</h6><p>Spring Boot AntLib 模块为 Apache Ant 提供基本的 Spring Boot 支持.可以使用该模块创建可执行的 jar. 要使用该模块,需要在 <code>build.xml</code> 中声明一个额外的 <code>spring-boot </code>命名空间,如以下示例所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:ivy</span>=<span class="string">&quot;antlib:org.apache.ivy.ant&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:spring-boot</span>=<span class="string">&quot;antlib:org.springframework.boot.ant&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;myapp&quot;</span> <span class="attr">default</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要记住使用 <code>-lib</code> 选项启动 Ant,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ant -lib &lt;directory containing spring-boot-antlib-2.5.0.jar&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><h5 id="Spring-Boot-Ant-任务-Spring-Boot-Ant-Tasks"><a href="#Spring-Boot-Ant-任务-Spring-Boot-Ant-Tasks" class="headerlink" title="Spring Boot Ant 任务(Spring Boot Ant Tasks)"></a>Spring Boot Ant 任务(Spring Boot Ant Tasks)</h5><p>声明 <code>spring-boot-antlib</code> 命名空间后,可以使用以下附加任务:</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/build-tool-plugins.html#build-tool-plugins.antlib.tasks.exejar">Using the “exejar” Task</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/build-tool-plugins.html#build-tool-plugins.antlib.findmainclass">Using the “findmainclass” Task</a></li>
</ul>
<ol>
<li><h6 id="使用”exejar”任务-Using-the-“exejar”-Task"><a href="#使用”exejar”任务-Using-the-“exejar”-Task" class="headerlink" title="使用”exejar”任务(Using the “exejar” Task)"></a>使用”exejar”任务(Using the “exejar” Task)</h6><p>可以使用 <code>exejar</code> 任务来创建 Spring Boot 可执行 jar. 任务支持以下属性:</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody><tr>
<td><code>destfile</code></td>
<td>要创建的目标 jar 文件</td>
<td>Yes</td>
</tr>
<tr>
<td><code>classes</code></td>
<td>Java类文件的根目录</td>
<td>Yes</td>
</tr>
<tr>
<td><code>start-class</code></td>
<td>要运行的主要应用程序类</td>
<td>No <em>(默认是找到的第一个声明 <code>main</code> 方法的类)</em></td>
</tr>
</tbody></table>
<p>以下嵌套元素可用于任务:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>resources</code></td>
<td>一个或多个 <a href="https://ant.apache.org/manual/Types/resources.html#collection">资源集合</a> 描述一组 [资源](<a href="https://ant.apache.org/manual/Types/">https://ant.apache.org/manual/Types/</a> resources.html) 应该添加到创建的 jar 文件的内容中.</td>
</tr>
<tr>
<td><code>lib</code></td>
<td>一个或多个 <a href="https://ant.apache.org/manual/Types/resources.html#collection">Resource Collections</a> 应该添加到组成应用程序运行时依赖类路径的一组 jar 库中.</td>
</tr>
</tbody></table>
</li>
<li><h6 id="例子-Examples"><a href="#例子-Examples" class="headerlink" title="例子(Examples)"></a>例子(Examples)</h6><p>本节展示了 Ant 任务的两个示例.</p>
<p><em>Specify start-class</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot:exejar</span> <span class="attr">destfile</span>=<span class="string">&quot;target/my-application.jar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">classes</span>=<span class="string">&quot;target/classes&quot;</span> <span class="attr">start-class</span>=<span class="string">&quot;com.example.MyApplication&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">&quot;src/main/resources&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lib</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">&quot;lib&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lib</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">spring-boot:exejar</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>Detect start-class</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exejar</span> <span class="attr">destfile</span>=<span class="string">&quot;target/my-application.jar&quot;</span> <span class="attr">classes</span>=<span class="string">&quot;target/classes&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lib</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">&quot;lib&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lib</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exejar</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h6 id="使用”findmainclass”任务-Using-the-“findmainclass”-Task"><a href="#使用”findmainclass”任务-Using-the-“findmainclass”-Task" class="headerlink" title="使用”findmainclass”任务(Using the “findmainclass” Task)"></a>使用”findmainclass”任务(Using the “findmainclass” Task)</h6><p><code>exejar</code> 在内部使用 <code>findmainclass</code> 任务来定位声明 main 的类. 如有必要,还可以直接在构建中使用此任务. 支持以下属性:</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody><tr>
<td><code>classesroot</code></td>
<td>Java类文件的根目录</td>
<td>Yes <em>(unless <code>mainclass</code> is specified)</em></td>
</tr>
<tr>
<td><code>mainclass</code></td>
<td>可用于短路<code>main</code>类搜索</td>
<td>No</td>
</tr>
<tr>
<td><code>property</code></td>
<td>应使用结果设置的 Ant 属性</td>
<td>No <em>(result will be logged if unspecified)</em></td>
</tr>
</tbody></table>
<ol>
<li><h6 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h6><p>本节包含三个使用 <code>findmainclass</code> 的示例.</p>
<p><em>Find and log</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">findmainclass</span> <span class="attr">classesroot</span>=<span class="string">&quot;target/classes&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>Find and set</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">findmainclass</span> <span class="attr">classesroot</span>=<span class="string">&quot;target/classes&quot;</span> <span class="attr">property</span>=<span class="string">&quot;main-class&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>Override and set</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">findmainclass</span> <span class="attr">mainclass</span>=<span class="string">&quot;com.example.MainClass&quot;</span> <span class="attr">property</span>=<span class="string">&quot;main-class&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><h6 id="支持其他构建系统"><a href="#支持其他构建系统" class="headerlink" title="支持其他构建系统"></a>支持其他构建系统</h6><p>如果想使用 Maven,Gradle 或 Ant 以外的构建工具,可能需要开发自己的插件.可执行jar需要遵循特定的格式,某些条目需要以未压缩的形式写入.</p>
<p>Spring Boot Maven 和 Gradle 插件都使用 <code>spring-boot-loader-tools</code> 来实际生成 jar. 如果需要,可以直接使用这个库.</p>
<ol>
<li><h6 id="重新打包文档-Repackaging-Archives"><a href="#重新打包文档-Repackaging-Archives" class="headerlink" title="重新打包文档(Repackaging Archives)"></a>重新打包文档(Repackaging Archives)</h6><p>要重新打包现有存档以使其成为独立的可执行存档,请使用 <code>org.springframework.boot.loader.tools.Repackager</code>.Repackager 类采用单个构造函数参数,该参数引用现有的 jar 或 war 存档. 使用两种可用的 <code>repackage()</code> 方法之一替换原始文件或写入新目标.在重新打包程序运行之前,还可以在重新打包程序上配置各种设置.</p>
</li>
<li><h6 id="嵌套库-Nested-Libraries"><a href="#嵌套库-Nested-Libraries" class="headerlink" title="嵌套库(Nested Libraries)"></a>嵌套库(Nested Libraries)</h6><p>重新打包存档时,可以使用 <code>org.springframework.boot.loader.tools.Libraries</code> 接口来包含对依赖文件的引用.在这里不提供库的任何具体实现,因为它们通常是特定于构建系统的.</p>
<p>如果存档已包含库,则可以使用 <code>Libraries.NONE</code>.</p>
</li>
<li><h6 id="寻找主类-Finding-a-Main-Class"><a href="#寻找主类-Finding-a-Main-Class" class="headerlink" title="寻找主类(Finding a Main Class)"></a>寻找主类(Finding a Main Class)</h6><p>如果不使用 <code>Repackager.setMainClass()</code> 指定主类,则重新打包程序使用 ASM 读取类文件并尝试使用 <code>public static void main(String[] args)</code> 方法找到合适的类.如果找到多个候选项,则会引发异常.</p>
</li>
<li><h6 id="重新打包实现的示例-Example-Repackage-Implementation"><a href="#重新打包实现的示例-Example-Repackage-Implementation" class="headerlink" title="重新打包实现的示例(Example Repackage Implementation)"></a>重新打包实现的示例(Example Repackage Implementation)</h6><p>以下示例显示了典型的重新打包实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBuildTool</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;        File sourceJarFile = ...        Repackager repackager = <span class="keyword">new</span> Repackager(sourceJarFile);        repackager.setBackupSource(<span class="keyword">false</span>);        repackager.repackage(<span class="keyword">this</span>::getLibraries);    &#125;    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getLibraries</span><span class="params">(LibraryCallback callback)</span> <span class="keyword">throws</span> IOException </span>&#123;        <span class="comment">// Build system specific implementation, callback for each dependency        for (File nestedJar : getCompileScopeJars()) &#123;            callback.library(new Library(nestedJar, LibraryScope.COMPILE));        &#125;        // ...    &#125;    private List&lt;File&gt; getCompileScopeJars() &#123;        return ...    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Build Tool Plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/posts/38008.html</url>
    <content><![CDATA[<h4 id="Maven入门"><a href="#Maven入门" class="headerlink" title="Maven入门"></a>Maven入门</h4><p>maven是Java平台上的自动化构建工具</p>
<ul>
<li>关于构建的各个环节<ol>
<li>清理：将之前编译得到的旧的class字节码文件删除，为下一次编译做准备。</li>
<li>编译：将Java源代码编译成class字节码。</li>
<li>测试：自动测试，自动调用junit程序。</li>
<li>报告：测试程序执行的结果。</li>
<li>打包：动态Web工程打war包，Java工程打jar包。</li>
<li>安装：Maven特定的概念——将打包得到文件复制到“仓库”中指定的位置。</li>
<li>部署：将动态Web工程生成的war包复制到Servlet容器的指定目录下，使其可以运行。</li>
</ol>
</li>
</ul>
<ol>
<li>创建约定的目录结构<ol>
<li>根目录：工程名</li>
<li>src目录：源码</li>
<li>pom.xml文件：Maven核心配置文件</li>
<li>main目录：存放程序</li>
<li>test目录：存放测试程序</li>
<li>java目录：存放java源文件</li>
<li>resources目录：存放框架或者其他工具的配置文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-app</span><br><span class="line">|-- pom.xml</span><br><span class="line">`-- src</span><br><span class="line">    |-- main</span><br><span class="line">    |   |-- java</span><br><span class="line">    |   |   `-- com</span><br><span class="line">    |   |       `-- mycompany</span><br><span class="line">    |   |           `-- app</span><br><span class="line">    |   |               `-- App.java</span><br><span class="line">    |   `-- resources</span><br><span class="line">    |       `-- META-INF</span><br><span class="line">    |           `-- application.properties</span><br><span class="line">    `-- test</span><br><span class="line">        `-- java</span><br><span class="line">            `-- com</span><br><span class="line">                `-- mycompany</span><br><span class="line">                    `-- app</span><br><span class="line">                        `-- AppTest.java</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>为什么要遵守约定的目录结构？<ol>
<li>Maven负责这个项目的自动化构建，以编译为例，Maven要想自动编译，那么它必须知道Java源文件保存在哪里。</li>
<li>如果自己定义的东西想要让框架或者工具知道，有两种办法：<ol>
<li>以配置的方式明确告诉框架。</li>
<li>遵循框架内部已经存在的约定。<br>比如log4j.xml</li>
<li>约定&gt;配置&gt;编码。</li>
</ol>
</li>
</ol>
</li>
<li>常用Maven命令<ol>
<li>注意：执行与构建过程相关的Maven命令，必须进入pom.xml所在的目录。<br>与构建过程相关的操作：编译、测试、打包。。。</li>
<li>常用命令<ol>
<li>mvn clean：清理。</li>
<li>mvn compile ：编译主程序。</li>
<li>mvn test-compile：编译测试程序。</li>
<li>mvn test：执行测试。</li>
<li>mvn package：打包。</li>
</ol>
</li>
<li>关于联网问题<ol>
<li>Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含在Maven的核心程序中。</li>
<li>当执行Maven命令需要用到某些插件是，Maven核心程序会首先到本地仓库中查找。</li>
<li>Maven核心程序如果在本地仓库中找不到需要的插件，那么会自动连接外网，到中央仓库中下载。</li>
</ol>
</li>
</ol>
</li>
<li>POM<ol>
<li>含义（Project Object Model）项目对象模型。类似于DOM Docment Object Model文档对象模型。</li>
<li>pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置。</li>
<li>坐标<ol>
<li>数学中的坐标<ol>
<li>平面上，使用X、Y两个向量可以唯一确定平面中的任何一个点。</li>
<li>在空间中，使用X、Y、Z三个向量可以唯一定位空间中的任何一个点。</li>
</ol>
</li>
<li>Maven的坐标<br>使用下面三个向量可以在仓库中唯一定位一个Maven工程<ol>
<li>groupId：公司或者组织域名倒序+项目名<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupid</span>&gt;</span>com.proton.projectname<span class="tag">&lt;/<span class="name">groupid</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>artifactId：模块名<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>modulename<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>version：版本<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>Maven工程的坐标与仓库中路径的对应关系<ol>
<li>坐标<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>路径<br>命名规则：参照坐标<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">\repository\org\mybatis\mybatis\3.5.7\mybatis-3.5.7.jar</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>仓库：<ol>
<li>分类：<ol>
<li>本地仓库：当前电脑上部署的仓库目录，为当前电脑上所有Maven工程服务。</li>
<li>远程仓库：<ol>
<li>私服：搭建在局域网中，为局域网范围内的所有Maven工程服务。</li>
<li>中央仓库：架设在Internet上，为世界所有Maven工程服务。</li>
<li>中央仓库镜像：为了分担中央仓库的流量，提升用户访问速度。</li>
</ol>
</li>
</ol>
</li>
<li>仓库中保存的内容：Maven工程<ol>
<li>Mavne自身所需要的插件</li>
<li>第三方框架或者工具的jar包</li>
<li>自己开发的Maven工程。</li>
</ol>
</li>
</ol>
</li>
<li>依赖(dependency)<ol>
<li>Maven解析依赖信息时会到本地仓库中查找被依赖的jar包<br>对于我们自己开发的maven工程，使用 mvn install命令安装后就可以进入仓库。</li>
<li>依赖的范围<ol>
<li>compile<br>compile描述的是jar包在编译阶段是否可用，是否参与到编译中。主程序可以使用范围为compile的依赖。测试程序也可以使用，并且会被打包到最终的包中。<ol>
<li>对主程序是否有效：有效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：参与</li>
<li>典型例子：spring-core</li>
</ol>
</li>
<li>test<br>依赖范围为test依赖，对主程序而不可用，主要用于在测试环境中提供给测试程序测试支持。也不会参与到最终的打包。<ol>
<li>对主程序是否有效：无效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：不参与</li>
<li>典型例子：junit</li>
<li><img src="/.%5CMaven.assets%5Cscope-compile-test.png" alt="image-20210522120546311"></li>
</ol>
</li>
<li>provided<br>描述的是开发阶段。在开发阶段，需要使用一些运行环境的jar包，如果缺少这部分jar包，则开发时编译器报错，而这部分jar包不需要在打包在程序中，在运行环境中会提供，比如tomcat的servlet-api.jar。provided属性标记的jar包，会在开发阶段提供给调用，在部署阶段会被忽略，在运行时，由运行环境中提供。<ol>
<li>对主程序是否有效：有效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：不参与</li>
<li>是否参与部署：不参与</li>
<li>典型例子：servlet-api.jar<br><img src="/.%5CMaven.assets%5Cprovided.png" alt="image-20210522120048328"></li>
</ol>
</li>
</ol>
</li>
<li>依赖的传递性。在pom直接添加的dependency是直接依赖。如果添加的dependency还有其他依赖，则其他依赖被称作传递过来的依赖。<ol>
<li>依赖传递性的好处：可以传递的依赖不必再每个模块工程中都重复声明，只要在最底层的依赖中即可。</li>
<li>注意事项：依赖传递性仅限于compile范围，非compile范围的依赖不能传递。所以在各个模块工程中，针对test或者provided依赖范围，如果需要就得重复声明依赖。</li>
</ol>
</li>
<li>排除依赖：<br>当前工程有个直接依赖A，但是A也有个依赖B，此时如果不希望将B引入到当前工程中，可以对直接依赖的子依赖进行排除。<ol>
<li>依赖排除的场合：<br>当依赖中A存在着不稳定的依赖B，比如spring-core（A）中引入了一个不稳定的依赖common-log（B）。且不希望将不稳定的依赖（B）加入当前项目，则可以将不稳定的部分排除。</li>
<li>配置方式<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.ykproton<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			排除依赖，</span></span><br><span class="line"><span class="comment">			排除过后，被排除的依赖传递性停止，不会继续向上传递</span></span><br><span class="line"><span class="comment"> 		--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>依赖冲突时选择原则<br>​    用于解决多个依赖，同时依赖的jar包的冲突。<ol>
<li><p>路径最短者优先原则。<br>如果A依赖B，B依赖C。C使用D的v1版本，B使用D的v2版本。根据路径最短，D-v1距离A最近。此时真正会使用的是D的v1版本。<br><img src="/.%5CMaven.assets%5Cimage-20210522141414168.png" alt="image-20210522120546311"></p>
</li>
<li><p>路径相同时，先声明者优先。先后顺序指的是dependency标签的顺序。<br><img src="/.%5CMaven.assets%5Cimage-20210522141527255.png" alt="image-20210522120546311"></p>
</li>
</ol>
</li>
<li>统一管理依赖版本<br>工程有很多依赖，如果升级依赖，手动修改每一个依赖的版本，容易出现错误，比如漏改错改。<br>可以使用properties标签内，使用自定义标签统一声明版本号。在使用同一版本的位置，引用自定义标签。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- properties标签可以配置多种属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- myApp.spring.version 为自定义标签 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">myApp.spring.version</span>&gt;</span></span><br><span class="line">    4.2.2.RELEASE</span><br><span class="line">  <span class="tag">&lt;/<span class="name">myApp.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引用自定义标签，$&#123;标签名&#125; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;helloCaller.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>生命周期<ol>
<li>各个构建环节执行的顺序：不能打乱顺序，必须按照既定的正确顺序执行。</li>
<li>Maven的核心应用程序定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。</li>
<li>Maven核心程序为了更好实现自动化构建，按照这一特点执行生命周期中的各个阶段：无论现在要执行生命周期的哪一个阶段，都是从这个生命周期最初的位置开始执行。</li>
<li>插件和目标：<ol>
<li>生命周期各个阶段仅仅定义了要执行什么任务。</li>
<li>各个阶段和插件的目标是对应的。</li>
<li>相似的目标由特定的插件来完成。<table>
<thead>
<tr>
<th>生命周期阶段</th>
<th>插件目标</th>
<th>插件</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>compile</td>
<td>maven-compiler-plugin</td>
</tr>
<tr>
<td>test-compile</td>
<td>testCompile</td>
<td>maven-compiler-plugin</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
</li>
<li>继承<br>　多个子项目都需要某些依赖, 就可以把子项目共同的依赖抽取到父项目中, 子项目通过继承得到这些依赖, 这样也更好的来管理(比如升级, 删除等)。也能解决因为范围为test、provided的依赖不能传递，导致的环境不一致的问题。<br>步骤：<ol>
<li>父项目打包方式修改为pom。<br>可以在父工程中，统一管理项目版本号。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.ykproton<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 此处为pom --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     		......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在子工程中声明对父工程的引用<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.ykproton<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>聚合<br>Java项目，往往是多个模块组成，聚合就是将多个模块整合在一起构建。快速构建<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>mail<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>account<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>聚合的两种结构<ol>
<li>父子结构<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">|-- my-module1</span><br><span class="line">|   `-- pom.xml</span><br><span class="line">|-- my-module2</span><br><span class="line">|   `-- pom.xml</span><br><span class="line">`-- pom.xml</span><br></pre></td></tr></table></figure>
直接指定子项目名即可。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-module1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-module2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>同级结构<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">|-- my-module1</span><br><span class="line">|   `-- pom.xml</span><br><span class="line">|-- my-module2</span><br><span class="line"> |   `-- pom.xml</span><br><span class="line"> `-- parent</span><br><span class="line">     `-- pom.xml</span><br></pre></td></tr></table></figure>
通过相对路径，进行聚合。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../my-module1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../my-module2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/posts/9355.html</url>
    <content><![CDATA[<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><ol>
<li><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p><em>Nginx</em> (engine x) 是一个高性能的<strong>HTTP</strong>和<strong>反向代理</strong>web服务器.</p>
</li>
<li><h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理:"></a>反向代理:</h5><ul>
<li><h6 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理:"></a>正向代理:</h6><p>代理服务器为客户端做代理,主要为客户端服务,可以隐藏客户端信息</p>
<p><img src="/Nginx/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="img"></p>
</li>
<li><h6 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理:"></a>反向代理:</h6><p>主要是为服务端代理,所以叫做反向代理,可以隐藏服务端信息</p>
<img src="Nginx/反向代理.png" alt="img" style="zoom:67%;" /></li>
</ul>
</li>
<li><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡:"></a>负载均衡:</h5><p>缓解服务器压力,和提升容错能力</p>
<ol>
<li><h6 id="单点负载均衡"><a href="#单点负载均衡" class="headerlink" title="单点负载均衡"></a>单点负载均衡</h6></li>
</ol>
<img src="Nginx/v2-6aa2607e04cc9d2f0d448f9fa80b2ae2_720w.jpg" alt="img" style="zoom:50%;" />

<ol>
<li><h6 id="负载均衡集群"><a href="#负载均衡集群" class="headerlink" title="负载均衡集群"></a>负载均衡集群</h6><p>避免因为单个负载均衡节点故障,导致不可用</p>
<img src="Nginx/负载均衡集群.jpg" alt="preview" style="zoom:50%;" /></li>
<li><h6 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h6><ol>
<li><strong>Round Robin（轮询）：</strong>为第一个请求选择列表中的第一个服务器，然后按顺序向下移动列表直到结尾，然后循环。</li>
<li><strong>LeastConnections（最小连接）：</strong>优先选择连接数最少的服务器，在普遍会话较长的情况下推荐使用。</li>
<li><strong>Source：</strong>根据请求源的 IP 的散列（hash）来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h5><p>动态请求与静态资源放在不同的服务器上</p>
</li>
<li><h5 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h5><ol>
<li><p>添加源:<code>sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></p>
</li>
<li><p>使用<code>yum search nginx</code>查看,源是否添加成功</p>
<p>安装Nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure></li>
<li><p>设置自动运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start nginx.service</span><br><span class="line">sudo systemctl enable nginx.service</span><br></pre></td></tr></table></figure>

<p>若想使用外部主机连接上虚拟机,访问 IP:80 ，需要关闭虚拟机的防火墙：</p>
<p>centOS7关闭防火墙命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">       systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>

<p>或者配置防火墙开放端口:</p>
<ul>
<li><p>查看开放的端口号:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all </span><br></pre></td></tr></table></figure></li>
<li><p>设置开放的端口号:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd  --add-service=http -permanent</span><br><span class="line">sudo firewall-cmd --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure></li>
<li><p>重启防火墙:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd -reload</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><p>使用nginx命令式,必须进入nginx目录: 比如 /user/sbin/nginx</p>
<ol>
<li><p>查看版本号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./nginx -v</span><br></pre></td></tr></table></figure></li>
<li><p>启动nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./nginx</span><br></pre></td></tr></table></figure></li>
<li><p>关闭nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure></li>
<li><p>重新加载配置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>配置文件: 在安装位置找到配置文件,nginx.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">user  nobody;</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">        # concurs with nginx&#x27;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>配置文件分为三个部分:</p>
<ol>
<li><p>全局块:</p>
<p>从配置文件开始到event 块之间的内容,主要设置一些影响nginx服务器整体运行的配置指令.比如并发数,log位置,pid</p>
</li>
<li><p>event 块</p>
<p> 主要影响Nginx服务器与用户的网络连接.</p>
<p>worker_connections 支持的最大连接数.</p>
</li>
<li><p>http 块</p>
<p>配置最频繁的部分,代理,缓存,日志定义,以及第三方配置都在这部分</p>
<p>注意:http 块也包括 http全局块,server块</p>
<ol>
<li><p>http 全局块 </p>
<p>包括文件引入,MIME-TYPE定义,日志自定义,连接超时时间,单链接请求数上限</p>
</li>
<li><p>server 块</p>
<p>与虚拟主机有密切关系.虚拟主机从用户看,是和独立的硬件注意是完全一样的,该技术是为了节省硬件成本.</p>
<p>每个http块可以包含多个server块,每一个server块就相当于一个虚拟主机.</p>
<p>每一个server块也分为全局server块,以及可以同事包含多个location 块</p>
<ul>
<li><p>全局server块:</p>
<p>配置虚拟主机的监听配置和本虚拟主机的名称或者IP配置</p>
</li>
<li><p>location 块</p>
<p>主要作用是基于Nginx服务器接收到的请求字符串(server_name/uri-string),对虚拟主机名称之外的字符串进行匹配,对特定的请求进行处理.地址定向,数据缓存和应答控制等功能,还有许多第三方模块的配置也在这里进行.</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ol>
<li><h6 id="反向代理-2"><a href="#反向代理-2" class="headerlink" title="反向代理"></a>反向代理</h6><p>效果: 将发送的Nginx的请求,直接转发给tomcat.访问Nginx的端口,即可访问tomcat的8080端口</p>
<p>在Nginx配置文件中修改或者增加:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  root html;</span><br><span class="line"><span class="meta">  #</span><span class="bash">主要配置proxy_pass</span></span><br><span class="line">  proxy_pass http://127.0.0.1:8080/examples/;</span><br><span class="line">  index index.html index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="根据路径的反向代理"><a href="#根据路径的反向代理" class="headerlink" title="根据路径的反向代理"></a>根据路径的反向代理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line"><span class="meta">#</span><span class="bash">监听端口</span></span><br><span class="line">	listen 9001;</span><br><span class="line">	server_name xxxName;</span><br><span class="line"><span class="meta">	</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">如果路径是/edu/开头,则进行如下服务</span></span><br><span class="line">	location ~ /edu/ &#123;</span><br><span class="line">		proxy_pass http://127.0.0.1:8080;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">	</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">如果路径是/vod/开头,则进行如下服务</span></span><br><span class="line">	location ~ /vod/ &#123;</span><br><span class="line">		proxy_pass http://127.0.0.1:8081;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>location 参数说明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~ ] uri &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>= : 用于不含正则表达式的uri前,要求请求祖父穿与 uri 严格匹配,如果匹配成功,就停止继续向下搜索,并立即处理请求.</p>
</li>
<li><p>~ : 用于表示uri包含正则表达式,并且区分大小写</p>
</li>
<li><p>~* :表示用于uri包含正则表达式,不区分大小写</p>
</li>
<li><p>^~ : 用于不包含正则表达式的uri前,要求Nginx服务器找到标志uri和请求字符串匹配度最高的 location后,立即使用此location处理请求,而不再使用location中的正则 uri 和请求字符串做匹配:</p>
<p>注意: 如果uri包含正则表达式,则必须要有~ 或者 ~* 标志.</p>
</li>
</ol>
</li>
<li><h6 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h6><p>配置文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">    server 192.168.0.104:9002 weight=1; # 服务器1</span><br><span class="line">    server 192.168.0.104:9003 weight=1; # 服务器2</span><br><span class="line">    ip_hash;   #负载均衡策略</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root         /usr/share/nginx/html;</span><br><span class="line">      </span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    location /  &#123;</span><br><span class="line">            proxy_pass http://myserver; # 导向自定义的myserver</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">    location = /404.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<ul>
<li><p>分配策略:</p>
<ol>
<li><p>轮询(默认)</p>
<p>每个请求按时间顺序,注意分配到不同的后端服务器,如果后端服务器down掉,则自动剔除.</p>
</li>
<li><p>weight</p>
<p>weight代表权重,默认为1,权重越高,被分配的客户端越多.用于后端服务器性能不均的情况.</p>
</li>
<li><p>ip_hash</p>
<p>每个请求按照ip的hash结果进行分配,这样每个访客固定访问一个后端服务器,可以解决session问题.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">  server 192.168.0.104:9002 weight=1;</span><br><span class="line">  server 192.168.0.104:9003 weight=1;</span><br><span class="line">  ip_hash; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>fair(第三方)</p>
<p>按照后端服务器响应时间来分配请求,响应时间越短的优先分配.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">  server 192.168.0.104:9002 weight=1;</span><br><span class="line">  server 192.168.0.104:9003 weight=1;</span><br><span class="line">  fair; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<ol start="4">
<li><p>动态资源静态资源分离:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root         /usr/share/nginx/html;</span><br><span class="line">         </span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line">         </span><br><span class="line"><span class="meta">#</span><span class="bash">静态资源路径, root会作为根路径,实际访问路径是/home/static</span></span><br><span class="line">    location /static/ &#123;</span><br><span class="line">            root /home/;</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">    location /  &#123;</span><br><span class="line">            proxy_pass http://myserver;</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">    location = /404.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>2. 使用Spring Boot</title>
    <url>/posts/42178.html</url>
    <content><![CDATA[<h4 id="使用Spring-Boot"><a href="#使用Spring-Boot" class="headerlink" title="使用Spring Boot"></a>使用Spring Boot</h4><p>这个章节深入研究使用Spring Boot的更多细节.包含了主题有构建系统,自动配置,如何运行程序.也会包含一些使用Spring Boot的最佳实践.虽然Spring Boot没有什么特别特殊的地方(你可以假设这只是另外一个库),但是又仍有一些建议.如果遵循这些建议,可以开发过程更容易.</p>
<ol>
<li><h5 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h5>​    强烈建议选择一个支持依赖管理的构建系统.推荐使用支持Maven Central仓库的工具.推荐使用Maven和Grande.虽然其他的构建系统可以使用Spring Boot.<ol>
<li><h6 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h6>每一个Spring Boot的发布都会提供一份精心挑选的依赖.在实际构建配置工作中,不需要提供任何依赖的版本,Spring Boot管理已经做了管理.当升级Spring Boot是,这些依赖也会保持一致的升级.<br>note:如果有需要的话,也可以指定版本,覆盖Spring Boot的建议.<br>精选的列表包含所有的可以和Spring Boot一起使用的Spring模块,同时这个列表也是精选的第三方库.</li>
<li><h6 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h6>学习如何使用Spring Boot和Maven,可以参考下面网址.<br><a href="https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/reference/htmlsingle/">https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/reference/htmlsingle/</a></li>
<li><h6 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h6>​    Starters是一系列方便的依赖描述符,可以用在应用中.可以一站式解决所有Spring和相关技术栈的依赖,不需要翻遍样例代码,然后复制相关依赖描述符.比如,如果想要使用Spring和JPA,就可以直接包含<code>spring-boot-starter-data-jpa</code>.<br>​    starters包含了很多依赖,使用连续,支持一系列可传递的依赖可以被用来快速构建,运行项目.<blockquote>
<p>在starter的name</p>
<p>​    所有官方的starter都遵循类似的命名模式.<code>spring-boot-starter-*</code>,<code>*</code>是一种特定类型的程序.这种命名结构旨在方便使用者寻找需要的starter.在很多IDE中集成的Maven可以根据名称搜索依赖.</p>
<p>​    第三方的starters不应该以<code>spring-boot</code>,因为这是官方Spring Boot的artifacts.第三方的starter应该使用项目名开头.必须一个第三方的starter工程叫做<code>thirdpartyproject</code>,应该被命名为<code>thirdpartyproject-spring-boot-starter</code>.<br>下面的starter是Spring Boot提供的在<code>org.springframework.boot</code>组中:    </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>spring-boot-starter</code></td>
<td>核心starter,包括自动配置支持,日志和YAML</td>
</tr>
<tr>
<td><code>spring-boot-starter-activemq</code></td>
<td>使用 Apache ActiveMQ的JMS消息的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-amqp</code></td>
<td>使用 Spring AMQP和Rabbit MQ的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-aop</code></td>
<td>使用SpringAOP和AspectJ的面向切面编程的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-artemis</code></td>
<td>使用 Apache Artemis的JMS消息的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-batch</code></td>
<td>使用Spring Batch的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-cache</code></td>
<td>支持Spring Framework的cache的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-data-cassandra</code></td>
<td>使用 Cassandra distributed database and Spring Data Cassandra的starter</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ol>
</li>
<li><h5 id="组织代码"><a href="#组织代码" class="headerlink" title="组织代码"></a>组织代码</h5>Spring Boot不要求任何的特定代码格式.但是有一些是最好的实践方式.<ol>
<li><h6 id="使用”default”包"><a href="#使用”default”包" class="headerlink" title="使用”default”包"></a>使用”default”包</h6>​    当一个class没有包含<code>package</code>生命是,会被默认放在”default package”.不应该使用默认包的方式,应当尽量避免使用默认包.对于Spring Boot应用来说,在使用<code>@ComponentScan</code>,<code>@ConfigurationPropertiesScan</code>,<code>@entityScan</code>,<code>@SpringBootApplication</code>注解时,可能会导致一些问题,因为每个jar中的每个class都会被读取.<br>tip:推荐遵循Java推荐的包命名方式,使用倒置的域名(com.github….).</li>
<li><h6 id="主程序类的位置"><a href="#主程序类的位置" class="headerlink" title="主程序类的位置"></a>主程序类的位置</h6>​    推荐将主程序类放到包的根路径下,在其他所有的class上级.<code>@SpringBootApplication</code>注解经常放在main所在的类上,这隐式地定义了搜索特定项目的基础包.比如,当写一个JPA应用,<code>@SpringBootApplication</code>注解标注的类所在的包,将会被用来检索<code>@Entity</code>项目.使用包的根路径也可以用来扫描项目中的组件<br>​    tip:如果不想使用<code>@SpringBootApplication</code>,可以改用<code>@EnableAutoConfiguration</code>,<code>@ComponentScan</code>注解来定义导入行为.<br>下面是典型的代码结构:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com</span><br><span class="line"> +- example</span><br><span class="line">     +- myapplication</span><br><span class="line">         +- MyApplication.java</span><br><span class="line">         |</span><br><span class="line">         +- customer</span><br><span class="line">         |   +- Customer.java</span><br><span class="line">         |   +- CustomerController.java</span><br><span class="line">         |   +- CustomerService.java</span><br><span class="line">         |   +- CustomerRepository.java</span><br><span class="line">         |</span><br><span class="line">         +- order</span><br><span class="line">             +- Order.java</span><br><span class="line">             +- OrderController.java</span><br><span class="line">             +- OrderService.java</span><br><span class="line">             +- OrderRepository.java</span><br></pre></td></tr></table></figure>
<code>MyApplication.java</code>文件应该使用<code>@SpringBootApplication</code>来声明<code>main</code>方法:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h6>​    Spring Boot支持使用基于Java的配置.尽管可以使用xml源来配置<code>SpringApplication</code>,仍然推荐使用主要配置源应该是一个<code>@Configuration</code>类.通常来说,使用定义<code>main</code>方法的类作为主要源是一个很好的选择.<br>​    tip:在网络上,发布了很多使用XML配置的例子.如果可以的话,应该尽量使用作用相同的基于Java类的配置方式.尝试搜索<code>Enable*</code>注解可能是一个好的开始.<ol>
<li>导入其他配置类<br>不需要将所有使用<code>@Configuration</code>的类融合成一个单独的类.可以使用<code>@Import</code>注解去导入其他配置类.同样,也可以使用<code>@ComponentScan</code>注解去自动导入是所有类,包括标有<code>@configuration</code>的类.</li>
<li>导入XML配置<br>如果必须要使用基于xml的配置方式,仍然推荐使用使用<code>@Configuration</code>类.在类上使用<code>@ImportResource</code>注解去导入XML配置文件.</li>
</ol>
</li>
<li><h6 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h6>​    Spring Boot自动配置尝试基于已经添加的jar依赖去自动配置应用.比如,<code>HSQLDB</code>在classpath中,并且没有手动配置任何关于数据库连接的Bean,Spring Boot会自动配置一个内存数据库.<br>​    可以在任意一个标有<code>@Configuration</code>的配置类上,添加<code>@EnableAutoConfiguration</code>注解或者<code>@SpringBootApplication</code>注解来启用自动配置.<br>​    tip: 应该只添加一个<code>@SpringBootApplication</code>或者<code>@EnableAutoConfiguration</code>注解,推荐添加其中一个到主要的配置类上.<ol>
<li>逐渐替换自动配置<br>​    自动配置是非侵入的.在任何时候,都可以开始定义自己的配置,去替换自动配置的特定部分.比如,如果增加了自己的<code>DataSource</code>Bean,默认的内置数据库的支持会被替换.<br>​    如果想要知道有些自动配置正在被使用,并且使用的原因是是什么,可以使用<code>--debug</code>模,切换到debug模式.会在控制台输出相关信息.</li>
<li>指定不使用自动配置的类,<br>​    如果希望对指定的类,不使用自动配置.可以使用<code>@SpringBootApplication</code>的exclude属性去禁用自动配置.如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
​    如果类没有在classpath中,可以使用注解的<code>excludeName</code>属性来指定类的全路径名. 如果使用的是<code>@EnableAutoConfiguration</code>而不是<code>@SpringApplication</code>,<code>exclude</code>和<code>excludeName</code>同样可以使用. 最后,还可以使用<code>spring.autoconfigure.exclude</code>属性来指定不需要自动配置的类.<br>​    tip:可以同时在注解和配置文件中指定不要自动注解类<br>​    note: 尽管自动配置类是public的,该类的唯一被认为是公共API的方面是可用于禁用自动配置的类的名称。这些类的实际内容（例如嵌套配置类或Bean方法）仅供内部使用，我们不建议直接使用它们。(不要直接使用配置类的内部配置)</li>
</ol>
</li>
<li><h6 id="Spring-Bean和依赖注入"><a href="#Spring-Bean和依赖注入" class="headerlink" title="Spring Bean和依赖注入"></a>Spring Bean和依赖注入</h6>​    可以选择任何一种Spring提供的定义beans和注入依赖的方式.通常建议使用<em><strong>构造器注入</strong></em>的方式去织入依赖和使用<code>@ComponentScan</code>去发现bean.<br>​    如果和上面提到的代码组织方式一致(将主程序类放到最上层包中),可以使用不含参数的<code>@ComponentScan</code>注解,或者使用<code>@SpringApplication</code>注解,该注解已经隐式地包含<code>@ComponentScan</code>. 程序的所有组件(<code>@Component</code>,<code>@Service</code>,<code>@Repository</code>,<code>@Controller</code> etc)都会自动注册为Spring Bean.<br>​    下面的例子展示的是,<code>@Service</code>Bean使用构造器注入,构造器包含一个<code>RiskAssessor</code>Bean作为参数:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccountService</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果bean有多个构造器,需要使用<code>@AutoWired</code>指定使用哪一个构造器进行构造注入.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccountService</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PrintStream out;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">        <span class="keyword">this</span>.out = System.out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAccountService</span><span class="params">(RiskAssessor riskAssessor, PrintStream out)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">        <span class="keyword">this</span>.out = out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="使用-SpringBootApplication注解"><a href="#使用-SpringBootApplication注解" class="headerlink" title="使用@SpringBootApplication注解"></a>使用<code>@SpringBootApplication</code>注解</h6>​    很多开发者希望在程序中使用自动配置,组件扫描,并且定义额外配置.只需要一个<code>@SpringApplication</code>注解就可以实现三个功能:<ul>
<li><code>@EnableAutoConfiguration</code>,开启自动配置机制</li>
<li><code>@ComponentScan</code>:开启扫描包</li>
<li><code>@Configuration</code>:允许在context中注册额外bean或者导入额外配置类.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// same as @Configuration @EnableAutoConfiguration @ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
note: 这些特性不是强制的,可以选择这些特性的注解去替换掉<code>@SpringBootApplication</code>注解.比如,如果不想使用component scan或者配置属性的.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@Import(&#123; SomeConfiguration.class, AnotherConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在这个例子中,application就像其他任何一个Spring Boot应用程序,除了<code>@Component</code>注解标注的类和<code>@ConfigurationProperties</code>注解标注的类不是自动检测的,还有用户自定义的bean被显式导入之外,并没有什么不同.</li>
<li><h6 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h6>​    将程序打包成jar并且使用嵌入的HTTP server的一个最大的优点,就是可以像运行其他应用程序一样运行应用程序。同样也适用于调试Spring  Boot程序.不需要任何IDE的插件或者扩展.<ol>
<li>从IDE运行<br>将项目导入到IDE中,直接运行.</li>
<li>以运行打包程序方式运行<br>如果使用Maven创建可执行Jar,则可以直接使用<code>java -jar</code> 运行.</li>
<li>使用Maven插件<br>直接使用 mvn 执行 run goal.<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure></li>
<li>热部署形式运行</li>
</ol>
</li>
<li><h6 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h6>​    Spring Boot包含一些额外的开发工具集,可以让开发更加方便.<code>spring-boot-devtools</code>可以被放在任何工程中,以提供开发过程中的功能.添加依赖到Maven中:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
注意:<br>​    当运行整个打包后程序时,发者工具会自动禁用.如果程序是从<code>java -jar</code>方式运行或者是从特殊的类加载器加载是,会被当做是生产环境应用.可以通过使用<code>spring.devtools.restart.enabled</code>系统变量,来控制行为.如果无论什么类加载器,都启用开发工具,设置系统变量<code>-Dspring.devtools.restart.enabled=true</code>.绝对不能在运行devtools有安全风险的生产环境中执行此操作.禁用开发工具,排查相关依赖或者设置系统变量<code>-Dspring.devtools.restart.enabled=false</code>.<br>提示:在maven中,将依赖设为optional,从而禁止devtools的传递性.<ol>
<li><h6 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h6>​    Spring Boot支持的几个库使用缓存来提升性能.比如,template引擎缓存编译后的模板,来避免对模板文件的重复解析.同样的,Spring MVC可以在为静态资源提供服务时将HTTP缓存header添加到响应中。<br>​    虽然缓存在生产环境中有很多好处, 但是在开发过程中, 可能会适得其反,可能会让开发者无法看到刚发布的程序的变化. 出于这个原因,spring-boot-devtools 默认引用缓存项.<br>​    缓存选项通常在<code>application.properties</code>中配置.比如Thymeleaf 提供<code>spring.thymeleaf.cache</code>属性. 不需要手动配置这些属性, <code>spring-boot-devtools</code> 自动设置一些在开发阶段的合理的配置.<br>​    在开发Spring MVC和Spring WebFlux应用时,开发者需要很多关于请求的信息, 开发者工具会自动开启网络部分的<code>DEBUG</code>日志. 这能够提供更多关于请求的信息, 那个handler正在处理, 响应的结果等等. 如果想要日志输出所有的细节(包括潜在敏感信息), 可以开启<code>spring.mvc.log-request-details</code> 或者 <code>spring.codec.log-request-details</code> 配置项.<blockquote>
<p>注意:</p>
<p>如果不想使用默认的开发者工具属性,可以在<code>application.properties</code>中配置关闭:<code>spring.devtools.add-properties = false</code></p>
</blockquote>
</li>
<li><h6 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h6>​    当编译路径中的文件发生改变时, 使用<code>spring-boot-devtools</code>的应用会自动重启. 在IDE中,这是个特性很有用, 可以对代码更改给出快速反应. 默认情况下, classpath目录被监视改变. 需要注意, 特定的资源,比如静态资源和视图模板,不需要改变.<blockquote>
<p>触发重启.</p>
<p>DevTools监视编译路径资源,能够触发重启的唯一方式是编译路径内的更新. 对编译路径下的更新主要取决于使用哪种编译器:</p>
<ul>
<li>推荐打开项目的自动编译属性.<br>注意:</li>
</ul>
<p>如果使用Maven的build插件来实现重启,则必须让<code>forking</code>开启状态.</p>
<p>提示:</p>
<p>​    自动重启能和LiveReload良好的协作. 如果使用JRebel,自动重启会禁用, 以支持动态class的载入.其他的devtools的功能(比如LiveReload和覆盖属性)正常使用</p>
<p>注意:</p>
<p>​    在重启中, DevTools依赖应用上下文环境的钩子函数来关闭.如果金融了shutdown hook, 可能导致不能够正常工作(<code>SpringApplication.setRegisterShutdownHook(false)</code>)</p>
<p>注意:</p>
<p>​    DevTools需要自定义<code>ApplicationContext</code>中的<code>ResourceLoader</code>. 如果应用中已经提供了一个, 会被包装. 在<code>ApplicationContext</code>中直接重写<code>getResource</code>方法不会被支持.<br>Restart vs Reload</p>
<p>​    Spring Boot提供两个classloader来实现restart. 不会改变的类(比如来自第三方的jar)会被加载到叫<code>base</code>的classloader中. 正在开发过程的class会被加载到叫<code>restart</code>的classloader中. 当应用被重启, <code>restart</code>classloader被丢弃, 会重新创建一个. 这种方式意味着, 应用程序通常可以比冷启动快很多, 因为<code>base</code>classloader已经可用并已填充.</p>
<p>​    如果发现重启不够快,或者遇到classloading问题,可以考虑reloading technology, 比如ZeroTurnaround的JRebel. 这些方法通过在加载类时重写类来使它们更适合于重新加载。</p>
</blockquote>
<ol>
<li>记录条件评估中的更改<br>​    默认情况下, 每次应用程序重新启动时，都会记录一个报告，其中显示了条件评估增量。报告显示了应用的自动配置的更改, 比如增加或者移除了bean还有对配置属性的更改.可以关闭报告日志:<code>spring.devtools.restart.log-condition-evaluation-delta=false</code></li>
<li>排除资源<br>​    有些资源改变时, 不需要触发重启. 比如Thymeleaf templates可以就地编辑. 默认情况下, 改变一下目录下的资源时,不会触发重启但是会触发热加载(live reload):<code>/META-INF/maven</code>, <code>/META-INF/resources</code>, <code>/resources</code>, <code>/static</code>, <code>/public</code>, <code>/templates</code>.如果想要自定义排除规则, 可以使用<code>spring.devtools.restart.exclude</code>属性. 比如只想排除<code>/static</code>,<code>/public</code>,可以如下配置:<code>spring.devtools.restart.exclude=static/**,public/**</code><blockquote>
<p>提示:</p>
<p>​    如果想要保持默认配置,并且想增加新的排除规则,可以使用<code>spring.devtools.restart.additional-exclude</code>属性.</p>
</blockquote>
</li>
<li>监视其他路径<br>​    如果想要应用根据其他目录比如不是classpath, 而重启或者重新加载.可以使用<code>spring.devtools.restart.additional-paths</code> 属性来配置其他监视路径.可以使用前面所述的<code>spring.devtools.restart.exclude</code>属性来控制其他路径下的更改是触发完全重启还是实时重新加载。</li>
<li>关闭重启<br>​    如果不想要使用重启功能,可以使用<code>spring.devtools.restart.enabled</code>关闭. 在多数情况下,可以在<code>application.properties</code>. (即使关闭, 也会初始化<code>restart</code> classloader,但是不会监视文件更改).<br>​    如果想要完全关闭重启功能(比如,该功能和其他库发生冲突时),可以在调用<code>SpringApplication.run(…)</code>前,将<code>System</code>的<code>spring.devtools.restart.enabled</code>设置为<code>false</code>.如下:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;spring.devtools.restart.enabled&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用触发文件<br>​    如果使用的IDE不断编译文件,可能只需要在特定的几次触发重启.这种情况下,可以使用触发文件,这种方式是修改特定的文件来触发重启.<blockquote>
<p>注意:</p>
<p>​    对文件的任何更新都会触发检查，但是只有在Devtools检测到有事情要做的情况下，重启才会真正发生。<br>​    使用触发文件, 设置<code>spring.devtools.restart.trigger-file</code>为文件名(不包含任何路径). 文件必须实在classpath中.<br>比如,项目结构如下:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">+- main</span><br><span class="line">   +- resources</span><br><span class="line">      +- .reloadtrigger</span><br></pre></td></tr></table></figure>
<code>trigger-file</code>的配置应该是<code>spring.devtools.restart.trigger-file=.reloadtrigger</code>.<br>当<code>src/main/resources/.reloadtrigger</code>文件更新时,将会重启.</li>
<li>自定义重启类加载器<br>​    正如前面所说, 重启功能是通过使用两个类加载器.在大多数应用中, 可以 很好工作.但是有时也会导致classloading问题.<br>​    默认情况下, IDE打开的工程会使用<code>restart</code>classloader来载入, 任何<code>.jar</code>文件会使用<code>base</code>classloader载入.如果在一个多模块工程中,每个模块都导入到IDE中, 需要做一些自定义的工作.创建<code>META-INF/spring-devtools.properties</code>文件.<br>​    <code>spring-devtools.properties</code>文件包含以<code>restart.exclude</code>和<code>restart.include</code>属性. <code>include</code>标签中的元素会放进<code>restart</code>classloader,并且<code>exclude</code>标签中的元素会被放进<code>base</code>classloader中. 属性值是正则表达式,被应用到class中.如下所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">restart.exclude.companycommonlibs</span>=<span class="string">/mycorp-common-[\\w\\d-\\.]+\\.jar</span></span><br><span class="line"><span class="meta">restart.include.projectcommon</span>=<span class="string">/mycorp-myproj-[\\w\\d-\\.]+\\.jar</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>所有的属性key都必须不同.只要以<code>restart.include.</code>或者<code>restart.exclude.</code></p>
<p>建议:</p>
<p>​    所有来自classpath的<code>META-INF/spring-devtools.properties</code>的属性都会被载入.可以将文件打包到项目中,或者打包到项目需要的库中.</p>
</blockquote>
</li>
<li>已知的局限性<br>​    重启功能不能和通过使用<code>ObjectInputStream</code>来反序列的对象良好工作.如果需要反序列化数据,需要使用Spring的<code>ConfigurableObjectInputStream</code>和<code>Thread.currentThread().getContextClassLoader()</code>的组合.<br>​    很多第三方库反序列化没有考虑到context loader.</li>
</ol>
</li>
<li><h6 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h6>​    <code>spring-boot-devtools</code>内置了 LiveReload server, 当资源更新时,可以用来触发浏览器刷新.对于多种浏览器有很好的支持.<br>​    如果不想开启LiveReload server ,可以配置属<code>spring.devtools.livereload.enabled</code>为<code>false</code><blockquote>
<p>注意:</p>
<p>​    一次只能够运行一个LiveReload server.在运行程序前,应该保证没有其他的LiveReload server 在运行.如果在IDE中运行多个应用, 则只有第一个应用程序有LiveReload 支持.</p>
<p>警告:</p>
<p>​    当文件发生改变时, 为了触发LiveReload ,自动重启功能必须开启.</p>
</blockquote>
</li>
<li><h6 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h6>​    可以配置devtools的全局配置.在<code>$HOME/.config/spring-boot</code>下添加如下任一一个配置文件:<ol>
<li><code>spring-boot-devtools.properties</code></li>
<li><code>spring-boot-devtools.yaml</code></li>
<li><code>spring-boot-devtools.yml</code><br>这些文件中任一一个属性都会被应用到使用devtools的Spring Boot应用中. 比如, 配置总是使用一个trigger file来触发重启, 可以把下面的配置添加到<code>spring-boot-devtools</code>文件中.<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.devtools.restart.trigger-file</span>=<span class="string">.reloadtrigger</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    如果在<code>$HOME/.config/spring-boot</code>目录下没有任何devtools的配置文件, 将会在<code>$HOME</code>目录中,搜索一个叫<code>.spring-boot-devtools.properties</code>文件. 通过这种方式, 可以将devtools的全局配置分享到一个不支持<code>$HOME/.config/spring-boot</code>的老版本Spring Boot上.</p>
<p>注意:</p>
<p>​    在devtools的properties/yaml配置文件中,不支持Profiles.</p>
<p>​    在<code>.spring-boot-devtools.properties</code>配置profiles不会影响到指定的profiel配置文件的加载.  在YAML和properties配置文件中, 不支持配置profile文件名(<code>spring-boot-devtools-&lt;profile&gt;.properties</code>和<code>spring.config.activate.on-profile</code>都不支持)</p>
</blockquote>
</li>
<li>配置文件系统监视器<br>​    <code>FileSystemWatcher</code>的工作原理是, 通过一个特定时间的轮询class的变化,然后等待先前定义好的时间来保证没有其他更多的变化. 因为Spring Boot基本上都是依赖IDE去编译并且把编译好的文件拷贝到Spring Boot可以读取的目录, 在实际的使用过程中, 可能会发现,当devtools重启应用时, 有的对代码的改动反映到应用中. 如果这个问题不断出现, 可以尝试提高<code>spring.devtools.restart.poll-interval</code>和<code>spring.devtools.restart.quiet-period</code>参数值来适应当前的开发环境.<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.devtools.restart.poll-interval</span>=<span class="string">2s</span></span><br><span class="line"><span class="meta">spring.devtools.restart.quiet-period</span>=<span class="string">1s</span></span><br></pre></td></tr></table></figure>
​    被监视的classpath路径,每隔2s会被监视一次变化, 并且经过1s的等待,来保证class没有其他改动.</li>
</ol>
</li>
<li><h6 id="远程应用"><a href="#远程应用" class="headerlink" title="远程应用"></a>远程应用</h6>​    Spring Boot的devtools并不被限制在本地开发, 当运行远程应用是,可以使用其中几项功能. 使用远程支持可能会带来一些安全风险问题. 只有在安全可信任的网络上,或者启动SSL来保障安全的网络上,启用这项功能. 如果上面的两个选项都没有, 那就不应该使用devtools提供的远程支持. 在生产部署的时候,也不应该开启该功能.<br>​    开启这个功能,要保证<code>devtools</code>包含在重新打包的文档中.如下所示.<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludeDevtools</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeDevtools</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
​    还需要设置<code>spring.devtools.remote.secret</code>属性. 应该像重视重要的密码那样重视, 属性值应该唯一且强壮,不应该被轻易猜到或者暴力破解.<br>​    远程devtools支持由两部分支持:接受连接的server端和运行在IDE中的client. 当设置<code>spring.devtools.remote.secret</code>属性时, server端的组件会自动开启. 客户端组件只能手动启动.<ol>
<li>运行远程客户端应用<br>​    远程客户端应用由IDE启动, 需要使用与连接到的远程项目相同的类路径来运行<code>org.springframework.boot.devtools.RemoteSpringApplication</code>.  该应用程序的唯一必需参数是它连接到的远程URL。<br>​    比如,如果使用Eclipse或者 Spring Tools, 并且有一个工程叫做<code>my-app</code>应将部署在云上,可以做一下操作:<ul>
<li>选择在<code>Run</code>菜单中选择<code>Run Configurations…</code></li>
<li>创建一个<code>Java Application</code>d的启动配置</li>
<li>浏览<code>my-app</code>工程</li>
<li>把<code>org.springframework.boot.devtools.RemoteSpringApplication</code>当做main类来使用.</li>
<li>添加<code>https://myapp.cfapps.io</code>(远程url)到<code>Program arguments</code>中.<br>启动后如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .   ____          _                                              __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) &#x27;  \/ _ \  _/ -_) ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /</span><br><span class="line"> =========|_|==============|___/===================================/_/_/_/</span><br><span class="line"> :: Spring Boot Remote :: 2.5.0</span><br><span class="line"></span><br><span class="line">2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-project/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code)</span><br><span class="line">2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy</span><br><span class="line">2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with &#x27;https://&#x27;.</span><br><span class="line">2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729</span><br><span class="line">2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    因为远程客户端使用和实际应用一样的classpath,所以它可以直接读取应用配置文件. 这就是<code>spring.devtools.remote.secret</code>被读取和传递到服务端进行验证的方式.</p>
<p>建议:    </p>
<p>​    建议使用<code>https://</code>作为连接协议,  连接被加密并且密码不会被拦截.</p>
<p>建议:</p>
<p>    如果使用代理连接远程应用.可以配置<code>spring.devtools.remote.proxy.host</code>和<code>spring.devtools.remote.proxy.port</code>属性.</p>
</blockquote>
</li>
</ul>
</li>
<li>远程更新<br>​    远程客户端监视应用的classpath的变化,这个本地启动的方式一样. 任何资源的更新都会被推送到远程应用,并且会触发重启(如果设置的话). 这个功能有时候会很有帮助, 比如迭代一个使用云服务的功能,但是本地没有. 通常来说, 远程更新和重启会比本地全部重新编译部署要快很多.<br>​    在一个很慢的开发环境中, 可能会出现quiet时间太短, 导致对class的更改被分割成了好几批. 在第一批更改上传之后, 服务端被重启.第二批更改不能够发送给服务端, 因为服务端正在重启.<br>​    这通常通过RemoteSpringApplication日志中的警告来，即有关上传某些类失败的消息，并随后重试. 但是这也可能会导致代码的不一致性,可能会导致在第一批更改上传之后, 应用重启失败. 如果不断遇到这些问题,可以尝试增加<code>spring.devtools.restart.poll-interval</code>和<code>spring.devtools.restart.quiet-period</code>的参数值以适应当前的开发环境.<blockquote>
<p>注意:</p>
<p>​    只有当远程客户端启动了,文件才会被监视.如果在启动远程客户端之前改变了文件, 那么文件不会被推送到远程服务器上.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="打包生产环境应用"><a href="#打包生产环境应用" class="headerlink" title="打包生产环境应用"></a>打包生产环境应用</h6>​    可执行Jar一般用在部署生产环境中.因为他们是独立的, 所以非常适合部署在云上.<br>​    其他的适合生产环境的功能,比如运行状况,审核,度量REST或者JMX端点,可以考虑使用<code>spring-boot-actuator</code>.</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>3.1 Feature: SpringApplication</title>
    <url>/posts/1049.html</url>
    <content><![CDATA[<h4 id="3-Spring-Boot-功能"><a href="#3-Spring-Boot-功能" class="headerlink" title="3. Spring Boot 功能"></a>3. Spring Boot 功能</h4><p>​    这个章节将深入讨论Spring Boot的细节. 在这里可以学习使用,定制一些核心的功能. 如果还没有使用过,则可以阅读前面的内容,来获得基础知识.</p>
<ol>
<li><h5 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h5>​    <code>SpringApplication</code>类提供了一种非常方便的方式去启动Spring应用, 那就是从<code>main()</code>方法启动. 在很多情况下, 可以委派给静态方法<code>SpringApplication.run</code>.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当应用启动时,可以看到输出类似下面的内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::   v2.5.0</span><br><span class="line"></span><br><span class="line">2021-02-03 10:33:25.224  INFO 17321 --- [           main] o.s.b.d.s.s.SpringAppplicationExample    : Starting SpringAppplicationExample using Java 1.8.0_232 on mycomputer with PID 17321 (/apps/myjar.jar started by pwebb)</span><br><span class="line">2021-02-03 10:33:25.226  INFO 17900 --- [           main] o.s.b.d.s.s.SpringAppplicationExample    : No active profile set, falling back to default profiles: default</span><br><span class="line">2021-02-03 10:33:26.046  INFO 17321 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br><span class="line">2021-02-03 10:33:26.054  INFO 17900 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2021-02-03 10:33:26.055  INFO 17900 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.41]</span><br><span class="line">2021-02-03 10:33:26.097  INFO 17900 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2021-02-03 10:33:26.097  INFO 17900 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 821 ms</span><br><span class="line">2021-02-03 10:33:26.144  INFO 17900 --- [           main] s.tomcat.SampleTomcatApplication         : ServletContext initialized</span><br><span class="line">2021-02-03 10:33:26.376  INFO 17900 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#x27;&#x27;</span><br><span class="line">2021-02-03 10:33:26.384  INFO 17900 --- [           main] o.s.b.d.s.s.SpringAppplicationExample    : Started SampleTomcatApplication in 1.514 seconds (JVM running for 1.823)</span><br></pre></td></tr></table></figure>
默认情况下,显示的是<code>INFO</code>的日志,包括一些相关的启动细节,比如启动应用的用户. 如果需要的日志等级不是<code>INFO</code>,可以自己设置. 使用主应用程序类包中的实现版本来确定应用程序版本. 启动信息日志可以使用<code>spring.main.log-startup-info</code>设为<code>false</code>来关闭.这也会关闭应用激活的那个profile的日志信息.<blockquote>
<p>建议:</p>
<p>​    在启动过程中,增加额外的日志, 可以重写<code>SpringApplication</code>的子类中的<code>logStartupInfo(boolean)</code>方法实现.</p>
</blockquote>
<ol>
<li><h6 id="启动失败"><a href="#启动失败" class="headerlink" title="启动失败"></a>启动失败</h6>​    如果应用启动失败, 已经注册的<code>FailureAnalyzers</code>会提供专门的错误消息和具体措施来解决问题. 比如,  当在已经被占用的8080端口上启动应用, 如下的类似的信息将会被输出.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Embedded servlet container failed to start. Port 8080 was already in use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that&#x27;s listening on port 8080 or configure this application to listen on another port.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    Spring Boot提供了很多<code>FailureAnalyzer</code>的实现类, 也可以自己添加自定的类.<br>​    如果没有<code> failure analyzer</code>能够处理异常, 你也可以选择完整的情况报告去帮助更好地理解错误. 为此, 需要开启<code>debug</code>属性,或者开启针对<code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code>的<code>debug</code>日志.<br>​    比如, 想要使用<code>java -jar</code>运行应用, 可以像下面一样开启<code>debug</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myproject-0.0.1-SNAPSHOT.jar --debug</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h6>​    <code>SpringApplication</code>允许应用延迟初始化. 当延迟初始化开启时, bean会在被需要的时候创建,而不是在启动过程中初始化. 开启延迟加载可以减少应用启动时间.在web应用程序中, 开启延迟初始化,导致很多网络相关的bean不会初始化,直到接收网络请求.<br>​    延迟初始化的一个缺点是,可能会推迟发现应用问题的时间点. 如果一个配置出错的bean被延迟初始化,那么在启动过程中不会发生问题,直到这个bean被初始化时才会暴露问题. 同时也要注意, 确保JVM有足够的内存来容纳所有的bean, 而不是只能容乃在启动阶段初始化的bean. 出于这些原因, 延迟初始化没有被默认开启, 并且建议在开启延迟加载前,对JVM的堆内存进行调整.<br>​        延迟初始化可以已编程的方式开启, 使用<code>SpringApplicationBuilder</code>的<code>lazyInitialization</code>方法来开启,或者<code>SpringApplication</code>的<code>setLazyInitialization</code>方法.或者,也可以使用<code>spring.main.lazy-initialization</code>属性来开启.如下所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.main.lazy-initialization</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    如果想要对特定的bean关闭延迟初始化,同时对于程序的剩余部分使用延迟初始化,可以显式地使用注解设置延迟初始化属性.<code>@Lazy(false)</code>.</p>
</blockquote>
</li>
<li><h6 id="自定义Banner"><a href="#自定义Banner" class="headerlink" title="自定义Banner"></a>自定义Banner</h6>​    启动时打印的标志,就是banner.可以增加<code>banner.txt</code>到classpath中,或者设置<code>spring.banner.location</code>属性指向文件,从而改变banner. 如果banner文件中有用不是UTF-8的属性, 可以设置<code>spring.banner.charset</code> 来配置编码. 除了text文件,Spring Boot也支持图片,比如<code>banner.gif</code>,<code>banner.jpg</code>,或者<code>banner.png</code>.可以将图片放到classpath中,或者配置<code>spring.banner.image.location</code>来指定文件. 图片会被转换成ASCII art然后打印所有文本banner上面.<br>在<code>banner.txt</code>文件中,可以使用下面的占位符:<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>${application.version}</td>
<td>应用的版本号,在<code>MANIFEST.MF</code>文件中声明的.<code>Implementation-Version: 1.0</code>会被输出成<code>1.0</code></td>
</tr>
<tr>
<td>${application.formatted-version}</td>
<td>应用程序的版本号格式化后输出,如<code>1.0</code>会格式化成<code>(v1.0)</code></td>
</tr>
<tr>
<td>${spring-boot.version}</td>
<td>使用的Spring Boot版本号.如:<code>2.5.0</code></td>
</tr>
<tr>
<td>${spring-boot.formatted-version}</td>
<td>格式化后的Spring Boot版本号<code>(v2.5.0)</code></td>
</tr>
<tr>
<td><code>$&#123;Ansi.NAME&#125;</code>或<code>$&#123;AnsiColor.NAME&#125;</code></td>
<td>其中NAME是ANSI转义码的名称</td>
</tr>
<tr>
<td>${application.title}</td>
<td>应用的标题,在<code>MANIFEST.MF</code>中声明.比如<code>Implementation-Title: MyApp</code>,输出<code>MyApp</code></td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>​    如果想要以编程的方式实现的话,可以使用<code>SpringApplication.setBanner(…)</code>方法.使用<code>org.springframework.boot.Banner</code>接口并且实现自己的<code>printBanner()</code>方法.<br>可以使用<code>spring.main.banner-mode</code>来指定banner是在<code>System.out</code>(控制台)输出,还是在日志中输出,或者不输出(<code>off</code>).<br>输出的banner以单例的形式注册,名称为<code>springBootBanner</code>.<br>注意:</p>
<p>​    <code>$&#123;application.version&#125;</code>和<code>$&#123;application.formatted-version&#125;</code>属性只有在使用Spring Boot启动器启动时可以使用. 如果使用<code>java -cp &lt;classpath&gt; &lt;mainclass&gt;</code>来运行一个没有打包的jar, 这些值都不能被使用.</p>
<p>​    这也是为什么推荐,使用<code>java org.springframework.boot.loader.JarLauncher</code>来启动没打包的jar. 这样可以在编译classpath和启动应用前,初始化<code>application.*</code>的banner变量.</p>
</blockquote>
</li>
<li><h5 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h5>​    如果默认的<code>SpringApplication</code>不能够满足需求, 可以自定义一个本地的实例并且进行自定义.比如关闭banner,可以这样写:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(MyApplication.class);</span><br><span class="line">        application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    传给<code>SpringApplication</code>构造器的参数是Spring bean的配置源. 在大多数情况下, 这些都是<code>@Configuration</code>类的引用, 但是也可以是<code>@Component</code>类的直接引用.<br>​    也可以使用<code>application.properties</code>来配置<code>SpringApplication</code>.</p>
</blockquote>
</li>
<li><h5 id="Fluent-Builder-API"><a href="#Fluent-Builder-API" class="headerlink" title="Fluent Builder API"></a>Fluent Builder API</h5>​    如果需要构建一个<code>ApplicationContext</code>层级结构(有父子/关系的多个上下文),或者想要使用流式 builder API,可以使用<code>SpringApplicationBuilder</code>.<br>​    <code>SpringApplicationBuilder</code>能够以链式调用多个方法,并且可以包含<code>parent</code>和<code>child</code>方法来创建层级结构.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">        .sources(Parent.class)</span><br><span class="line">        .child(Application.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    创建<code>ApplicationContext</code>层级结构的时候,有一些限制.比如, 网络模块必须包含在<code>child</code>上下文中,<code>Environment</code>被父子上下文环境同时使用.</p>
</blockquote>
</li>
<li><h5 id="应用可用性"><a href="#应用可用性" class="headerlink" title="应用可用性"></a>应用可用性</h5>​    在平台上部署后，应用程序可以使用诸如<code>Kubernetes Probes</code>之类的基础结构向平台提供有关其可用性的信息。Spring Boot对常用的<code>liveness</code>和<code>readiness</code>可用性状态提供了开箱即用的支持.如果使用Spring Boot的<code>actuator</code>,这些状态将会显示为运行状况端点组.<br>​    此外, 可以在自己的bean中注入<code>ApplicationAvailability</code>来获取应用的可用性状态.<ol>
<li><h6 id="活动状态-Liveness-Liveness-State"><a href="#活动状态-Liveness-Liveness-State" class="headerlink" title="活动状态(Liveness Liveness State)"></a>活动状态(Liveness Liveness State)</h6>​    活动状态(<code>liveness</code>)说明应用内部装填是否能够允许应用正常工作,或者依靠自身,从当前失败中恢复过来.如果<code>Liveness</code>状态被打破,意味着应用处于一种不能恢复的状态,并且<code>infrastructure </code>应该重启应用.<blockquote>
<p>注意:</p>
<p>​    通常来说, <code>liveness</code>状态不应该基于白雾检查,比如健康检查.如果是这种方式,那么一个失败的外部系统(数据库,web api,外部缓存)可能会触发平台上的大量重启和级联故障.<br>Spring Boot应用的内部状态主要由<code>ApplicationContext</code>表示.如果应用的上下文环境启动成功,Spring Boot认为应用处于可用状态.只要刷新上下文环境,那么就可以认为应用处于可用状态.</p>
</blockquote>
</li>
<li><h6 id="就绪状态-Readiness-State"><a href="#就绪状态-Readiness-State" class="headerlink" title="就绪状态(Readiness State)"></a>就绪状态(Readiness State)</h6>​    就绪(<code>readiness</code>)表示应用是否处于可以处理流量的状态.失败的就绪状态告诉平台,现在不应将流量路由到应用. 这通常是在启动过程中,或者当<code>CommandLineRunner</code>和<code>ApplicationRunner</code>正在被处理,或者当前过于繁忙, 应用认为不应该处理额外流量.<blockquote>
<p>建议:</p>
<p>​    在启动过程中执行任务是,应该使用<code>CommandLineRunner</code>或者<code>ApplicationRunner</code>来执行,而不是使用Spring的生命周期的回调函数,比如<code>@PostConstruct</code></p>
</blockquote>
</li>
<li><h6 id="管理应用的可用性"><a href="#管理应用的可用性" class="headerlink" title="管理应用的可用性"></a>管理应用的可用性</h6>​    应用中的组件,可以注入<code>ApplicationAvailability</code>并且调用其方法,在任何时候获取当前的可用性.大多数情况下,应用希望能够监听到状态的变化或者去更改状态.<br>​    比如,可以应用的将<code>Readiess</code>状态导出为文件,从而可以在<code>Kubernetes </code>上执行<code>exec Probe</code>去看到这个文件.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReadinessStateExporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChange</span><span class="params">(AvailabilityChangeEvent&lt;ReadinessState&gt; event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getState()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACCEPTING_TRAFFIC:</span><br><span class="line">            <span class="comment">// create file /tmp/healthy</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFUSING_TRAFFIC:</span><br><span class="line">            <span class="comment">// remove file /tmp/healthy</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
当应用崩溃,不能够恢复时,也可以更新应用的可用状态.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocalCacheVerifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocalCacheVerifier</span><span class="params">(ApplicationEventPublisher eventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eventPublisher = eventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLocalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (CacheCompletelyBrokenException ex) &#123;</span><br><span class="line">            AvailabilityChangeEvent.publish(<span class="keyword">this</span>.eventPublisher, ex, LivenessState.BROKEN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="应用事件和监听器"><a href="#应用事件和监听器" class="headerlink" title="应用事件和监听器"></a>应用事件和监听器</h5>​    除了常规的Spring框架时间,比如<code>ContextRefreshEvent</code>,<code>SpringApplication</code>也会发送一些其他的应用事件.<blockquote>
<p>注意:</p>
<p>​    有一些事件实际上在<code>ApplicationContext</code>创建前触发,所以不能够通过<code>@Bean</code>的方式来注册监听器. 可以通过<code>SpringApplication.addListeners(…)</code>或者<code>SpringApplicationBuilder.listeners(…)</code>这两个方法来注册.</p>
<p>​    如果想要自动监听器,而不在乎应用的创建方式,可以在项目中增加一个<code>META-INF/spring.factories</code>文件,在文件中使用<code>org.springframework.context.ApplicationListener</code>的key来引用监听器.比如:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;org.springframework.context.ApplicationListener</span>=<span class="string">com.example.project.MyListener</span></span><br></pre></td></tr></table></figure>
<p>​    应用的时间会按照下面的顺序发送:</p>
</blockquote>
<ol>
<li><code>ApplicationStartingEvent</code><br>启动 -&gt;  <code>触发当前事件</code> -&gt; 其他处理(监听器和初始化注册除外)</li>
<li><code>ApplicationEnvironmentPreparedEvent</code><br>获知要使用的<code>Environment</code> -&gt;<br>​         <code>触发当前事件</code><br>-&gt; 上下文创建</li>
<li><code>ApplicationContextInitializedEvent</code><br><code>ApplicationContext</code>和<code>ApplicationContextInitializers</code>初始化完成 -&gt;<br>​     <code>触发当前事件</code><br>-&gt; 载入bean</li>
<li><code>ApplicationPreparedEvent</code><br>载入bean -&gt; <code>触发当前事件</code> -&gt;  刷新前</li>
<li><code>ApplicationStartedEvent</code><br> 在上下文环境刷新 -&gt; <code>触发当前事件</code> -&gt; 应用或者命令行启动器调用</li>
<li><code>AvailabilityChangeEvent</code><br><code>LivenessState.CORRECT</code>发送 -&gt; <code>触发当前事件</code><br>表明整个应用处于可用状态.</li>
<li><code>ApplicationReadyEvent</code><br> 任何应用或者命令行执行程序启动 -&gt; <code>触发当前事件</code></li>
<li><code>AvailabilityChangeEvent</code><br><code>ReadinessState.ACCEPTING_TRAFFIC</code>发送 -&gt; <code>触发当前事件</code><br>表明整个应用做好准备,接收服务请求.</li>
<li><code>ApplicationFailedEvent</code><br>启动发生错误 -&gt; <code>触发当前事件</code><br>上面只有<code>SpringApplicationEvent</code>s 事件和<code>SpringApplication</code>相关.除了这些之外.下面的事件会在<code>ApplicationPreparedEvent</code>后,<code>ApplicationStartedEvent</code>前触发.</li>
</ol>
<ul>
<li>当<code>WebServer </code>就绪,<code>WebServerInitializedEvent</code>发送. <code>ServletWebServerInitializedEvent</code>和<code>ReactiveWebServerInitializedEvent</code>分别是serlvet和reactive的各自变体.</li>
<li><code>ApplicationContext</code>刷新之后, <code>ContextRefreshedEvent</code>发送.<blockquote>
<p>建议:</p>
<p>​    在很多时候,不需要使用应用的时间,只需要知道有这些事件.在内部, Spring Boot使用事件来处理大量的任务.</p>
<p>注意:</p>
<p>   事件监听器不应该运行那些可能长任务,因为它们都是运行在同一个线程中.如果要运行长任务,可以考虑使用<code>ApplicationRunner</code>或<code>CommandLineRunner</code><br>​    应用事件的发送是使用Spring Framework的事件发送机制发送的.机制的一部分保证了,发送给子上下文环境中的监听器的事件, 也会发送给祖先上下文环境的监听器.因此, 如果应用程序使用SpringApplication实例的层次结构,一个监听器或许能够接收到来自多个实例的同一种应用事件.<br>​    为了让监听器区分事件是来自自身的<code>context</code>,还是后代的<code>context</code>, 应该注入应用的上下文环境,然后比较应用上下文和事件的上下文环境.可以实现<code>ApplicationContextAware</code>接口来注入<code>context</code>,或者如果监听器是一个<code>bean</code>,可以直接使用<code>@Autowired</code>.</p>
</blockquote>
</li>
</ul>
</li>
<li><h5 id="应用环境"><a href="#应用环境" class="headerlink" title="应用环境"></a>应用环境</h5>​    <code>SpringApplication</code>代替开发者创建正确的<code>ApplicationContext</code>,决定<code>WebApplicationType</code>的算法如下:<ul>
<li>如果出现<code>Spring MVC</code>,就使用<code>AnnotationConfigServletWebServerApplicationContext</code>.</li>
<li>如果没出现<code>Spring MVC</code>,并且出现<code>Spring WebFlux</code>,就使用<code>AnnotationConfigReactiveWebServerApplicationContext</code></li>
<li>否则就使用,<code>AnnotationConfigApplicationContext</code><br>​    这意味着,如果在应用中同时使用<code>Spring MVC</code>和<code>Spring WebFlux</code>的<code>client</code>, Spring MVC会被默认使用.可以使用<code>setWebApplicationType(WebApplicationType)</code>来重写.<br>​    也可以使<code>setApplicationContextClass(…)</code>来完全控制<code>ApplicationContext</code>的类型.<blockquote>
<p>建议:</p>
<p>​    当是用<code>SpringApplication</code>进行Junit测试时, 应该调用<code>setWebApplicationType(WebApplicationType.NONE)</code>.</p>
</blockquote>
</li>
</ul>
</li>
<li><h5 id="访问应用参数"><a href="#访问应用参数" class="headerlink" title="访问应用参数"></a>访问应用参数</h5>​    如果要访问传递给<code>SpringApplication.run(…)</code>的参数时,可以注入<code>org.springframework.boot.ApplicationArguments</code>bean.接口<code>ApplicationArguments</code>同时提供了访问原始的数组形式的参数(<code>String[]</code>),也有已经被解析的<code>option</code>和<code>non-option</code>.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> debug = args.containsOption(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        List&lt;String&gt; files = args.getNonOptionArgs();</span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            System.out.println(files);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if run with &quot;--debug logfile.txt&quot; prints [&quot;logfile.txt&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    Spring Boot在Spring环境中也注册了<code>CommandLinePropertySource</code>,这样可以直接使用<code>@Value </code>注解来访问单例形式的应用参数.</p>
</blockquote>
</li>
<li><h5 id="使用ApplicationRunner-或者CommandLineRunner"><a href="#使用ApplicationRunner-或者CommandLineRunner" class="headerlink" title="使用ApplicationRunner 或者CommandLineRunner"></a>使用ApplicationRunner 或者CommandLineRunner</h5>​    如果需要在<code>SpringApplication</code>启动后运行一些代码,可以实现<code>ApplicationRunner</code>或者<code>CommandLineRunner</code>接口.这两个接口都提供了<code>run</code>方法,这个方法在<code>SpringApplication.run(…)</code>完成之前调用.<blockquote>
<p>注意:</p>
<p>​    这种特别适合在应用启动之后,但是在接收流量之前运行任务.<br>​    <code>CommandLineRunner</code>以字符串数组方式访问应用程序参数, <code>ApplicationRunner</code>使用<code>ApplicationArguments</code>.下面的示例,展示的<code>CommandLineRunner</code>和<code>run</code>方法:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
​    如果有使用了多个<code>CommandLineRunner</code>和<code>ApplicationRunner</code>bean,且必须要按照特定顺序调用.可以实现额外的<code>org.springframework.core.Ordered</code>接口,或者使用<code>org.springframework.core.annotation.Order</code>来实现指定顺序调用.</li>
<li><h5 id="应用退出"><a href="#应用退出" class="headerlink" title="应用退出"></a>应用退出</h5>​    每个<code>SpringApplication</code>都在向JVM注册了一个关闭hook,来保证<code>ApplicationContext</code>在退出时能够正常的关闭. 所有的标准的Spring生命周期回调函数(比如<code>DisposableBean</code>接口或者<code>@PreDestroy</code>)都可以被使用.<br>​    此外,如果在调用<code>SpringApplication.exit()</code>时想要返回指定的退出状态码,bean可以实现<code>org.springframework.boot.ExitCodeGenerator</code>接口.退出状态码可以传给<code>System.exit()</code>来返回状态码.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExitCodeGenerator <span class="title">exitCodeGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.exit(SpringApplication.exit(SpringApplication.run(MyApplication.class, args)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
​    当然,<code>ExitCodeGenerator</code>也可以被异常类实现.当发生这些异常时,Spring Boot会返回异常实现类的<code>getExitCode()</code>提供的code.</li>
<li><h5 id="管理员功能"><a href="#管理员功能" class="headerlink" title="管理员功能"></a>管理员功能</h5>​    通过指定<code>spring.application.admin.enabled</code>属性值,可以开启应用中与管理员相关的功能.这将在平台<code>MBeanServer</code>上公开<code>SpringApplicationAdminMXBean</code>.对于任何服务包装器实现，此功能也可能很有用.<blockquote>
<p>建议:</p>
<p>​    如果想要知道应用运行在那个HTTP端口上,可以使用<code>local.server.port</code>来获取属性.</p>
</blockquote>
</li>
<li><h5 id="跟踪应用启动"><a href="#跟踪应用启动" class="headerlink" title="跟踪应用启动"></a>跟踪应用启动</h5>​    在应用启动过程中,<code>SpringApplication</code>和<code>ApplicationContext</code>执行很多关于应用生命周期,bean生命周期,甚至处理应用事件的任务. 使用<code> ApplicationStartup</code>,Spring Framework允许使用<code>StartupStep</code>对象,来可以追踪应用启动.这些数据可以被用来做做分析,或者用来更好地理解应用启动过程.<br>​    在配置<code>SpringApplication</code>实例时,可以使用<code>ApplicationStartup</code>的一个实例比如使用<code>BufferingApplicationStartup</code>,可以如下:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(MyApplication.class);</span><br><span class="line">        application.setApplicationStartup(<span class="keyword">new</span> BufferingApplicationStartup(<span class="number">2048</span>));</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
​    <code>ApplicationStartup</code>的第一个实现,<code>FlightRecorderApplicationStartup</code>由Spring Framework提供.它将特定于Spring的启动事件添加到Java Flight Recorder会话中，旨在对应用程序进行性能分析,并将Spring上下文生命周期与JVM事件相关联(比如内存分配,垃圾回收,类加载…).只要配置过后,可以启用飞行日志来收集数据.<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -XX:StartFlightRecording:filename=recording.jfr,duration=10s -jar demo.jar</span><br></pre></td></tr></table></figure>
      ​    Spring Boot带有<code>BufferingApplicationStartup</code>,这个实现是用来缓冲启动步骤并将数据发送到外部评估系统.应用可以在任何组件中调用<code>BufferingApplicationStartup</code>.此外,Spring Boot Actuator会以JSON文档的形式,输出终端的启动.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.11 Feature: 使用SQL数据库</title>
    <url>/posts/58530.html</url>
    <content><![CDATA[<h5 id="使用SQL数据库"><a href="#使用SQL数据库" class="headerlink" title="使用SQL数据库"></a>使用SQL数据库</h5><p>Spring Framework 为使用 SQL 数据库提供了大量支持,从使用 JdbcTemplate 的直接 JDBC 访问到完整的”对象关系映射”技术,如 Hibernate.Spring Data 提供了新级别的个功能功能:直接从接口创建 <code>Repository </code>实现,并根据约定,使用方法名来生成查询.</p>
<ol>
<li><h6 id="配置数据源-Configure-a-DataSource"><a href="#配置数据源-Configure-a-DataSource" class="headerlink" title="配置数据源( Configure a DataSource)"></a>配置数据源( Configure a DataSource)</h6>Java 的<code>javax.sql.DataSource</code>接口提供了可以和数据库建立连接的标准方法. 传统上,”数据源”使用<code>URL</code>和一些凭据来建立数据库连接.<blockquote>
<p>建议:</p>
<p>​    有关更高级的示例,请参阅”<code>How to</code>“部分,通常是为了完全控制数据源的配置.</p>
</blockquote>
<ol>
<li><h6 id="对嵌入式数据库支持-Embedded-Database-Support"><a href="#对嵌入式数据库支持-Embedded-Database-Support" class="headerlink" title="对嵌入式数据库支持(Embedded Database Support)"></a>对嵌入式数据库支持(Embedded Database Support)</h6>使用内嵌内存数据库来开发应用更加方便.显然,内存数据库不提供持久化功能.在应用程序启动时需要填充数据库,并在应用程序结束时丢弃数据.<blockquote>
<p>建议:</p>
<p>​    “<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.data-initialization">section on how to initialize a database</a>“部分包括有关如何初始化数据库的部分.</p>
</blockquote>
Spring Boot支持内嵌的H2,HSQL和Derby数据库的自动配置.无需提供任何连接URL.只需添加嵌入式数据库依赖.如果编译路径内有多个嵌入式数据库,可以使用<code>spring.datasource.embedded-database-connection</code>来指定选择哪一个.将该属性设置为<code>none</code> 会禁用嵌入式数据库的自动配置.<blockquote>
<p>注意:</p>
<p>​    如果测试中使用这个功能,可以注意到,无论使用了多少个应用context,测试部分只会使用同一个数据库. 如果想要每个context都有各自的嵌入式数据库,则应将<code>spring.datasource.generate-unique-name</code> 设置为<code>true</code>.</p>
</blockquote>
例如,典型的 POM 依赖如下:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;</span><br><span class="line"> &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    您需要使用<code>spring-jdbc</code>才能够自动配置嵌入式数据库.在这个例子中,它是通过<code>spring-boot-starter-data-jpa</code>传递拉取的.</p>
<p>建议:</p>
<p>​    如果出于某种原因,确实需要为嵌入式数据库配置URL,确保禁用数据库的自动关闭.如果使用 H2,则应使用<code>DB_CLOSE_ON_EXIT=FALSE</code>来执行此操作. 如果使用 HSQLDB,则应确保不使用<code>shutdown=true</code>. 禁用数据库的自动关闭可以让 Spring Boot 控制何时关闭数据库,从而确保在不再需要访问数据库时,关闭数据库.</p>
</blockquote>
</li>
<li><h6 id="连接生产环境数据库-Connection-to-a-Production-Database"><a href="#连接生产环境数据库-Connection-to-a-Production-Database" class="headerlink" title="连接生产环境数据库(Connection to a Production Database)"></a>连接生产环境数据库(Connection to a Production Database)</h6>还可以使用池化<code>DataSource</code>来对生产环境数据库的连接进行自动配置.</li>
<li><h6 id="数据源配置-DataSource-Configuration"><a href="#数据源配置-DataSource-Configuration" class="headerlink" title="数据源配置(DataSource Configuration)"></a>数据源配置(DataSource Configuration)</h6>数据源配置由外部配置属性<code>spring.datasource.*</code>进行配置.例如,可以在<code>application.properties</code>中声明以下部分:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost/test</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">dbuser</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">dbpass</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    应该配置<code>spring.datasource.url</code>属性来指定URL. 否则,Spring Boot 会尝试自动配置嵌入式数据库.</p>
<p>建议:</p>
<p>​    Spring Boot 可以从URL推导出大多数数据库的 JDBC 驱动类.如果需要指定特定的类,可以使用<code>spring.datasource.driver-class-name</code>属性.</p>
<p>注意:</p>
<p>​    对于要创建的池化<code>DataSource</code>,需要验证<code>Driver</code>类是否可用,所以在任何动作前都会检查<code>Driver</code>.换句话说,可以设置<code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>,则该类会被加载.</p>
</blockquote>
有关更多支持的选项,请参阅  <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java"><code>DataSourceProperties</code></a>.无论实际的<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.sql.datasource.connection-pool">implementation</a>.如何,这些都是标准选项.还可以通过使用各自的前缀(<code>spring.datasource.hikari.*</code>,<code>spring.datasource.tomcat.*</code>,<code>spring.datasource.dbcp2.*</code> 和 <code>spring.datasource.oracleucp.*</code>)来调整各自实现的设置 ).有关更多详细信息,请参阅相关连接池实现的文档.<br>例如,如果您使用 Tomcat 连接池,您可以自定义许多附加设置,如下例所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.tomcat.max-wait</span>=<span class="string">10000</span></span><br><span class="line"><span class="meta">spring.datasource.tomcat.max-active</span>=<span class="string">50</span></span><br><span class="line"><span class="meta">spring.datasource.tomcat.test-on-borrow</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
如果没有可用连接,在抛出异常前,会让连接池等待10000ms;将最大连接数限制为 50 ms;在从连接池中获取连接前验证连接.</li>
<li><h6 id="支持的连接池-Supported-Connection-Pools"><a href="#支持的连接池-Supported-Connection-Pools" class="headerlink" title="支持的连接池(Supported Connection Pools)"></a>支持的连接池(Supported Connection Pools)</h6>Spring Boot 使用以下算法来选择具体实现:<ol>
<li>首选HikariCP,因为它的高性能和高并发性. 如果 HikariCP 可用,则总是选用它.</li>
<li>否则,如果 Tomcat 池化<code>DataSource</code>可用,就使用它.</li>
<li>否则,如果 Commons DBCP2 可用,就使用它.</li>
<li>如果 HikariCP,Tomcat 和 DBCP2 都不可用,而 Oracle UCP 可用,就使用它.<blockquote>
<p>注意:</p>
<p>   如果你使用<code>spring-boot-starter-jdbc</code>或<code>spring-boot-starter-data-jpa</code> “starters”,你会自动获得<code>HikariCP</code>的依赖.</p>
</blockquote>
</li>
</ol>
可以使用<code>spring.datasource.type</code>属性来绕过算法,使用指定连接池. 在 Tomcat运行应用程序时,这一点尤其重要,因为默认情况下提供了<code>tomcat-jdbc</code>.<br>其他的连接池可以手动配置,使用<code>DataSourceBuilder</code>.如果自定义的<code>DataSource</code>bean,则不会发生自动配置.<code>DataSourceBuilder</code>支持以下连接池:<ul>
<li>HikariCP</li>
<li>Tomcat池化<code>Datasource</code></li>
<li>Commons DBCP2</li>
<li>Oracle UCP &amp; <code>OracleDataSource</code></li>
<li>Spring Framework的<code>SimpleDriverDataSource</code></li>
<li>H2<code>JdbcDataSource</code></li>
<li>PostgreSQL的<code>PGSimpleDataSource</code></li>
</ul>
</li>
<li><h6 id="连接到JNDI数据源-Connection-to-a-JNDI-DataSource"><a href="#连接到JNDI数据源-Connection-to-a-JNDI-DataSource" class="headerlink" title="连接到JNDI数据源(Connection to a JNDI DataSource)"></a>连接到JNDI数据源(Connection to a JNDI DataSource)</h6>如果要将Spring Boot应用部署到应用程序服务器上,可能会想要使用应用服务器内置功能和使用JNDI访问的方式来配置和管理数据源.<br>spring.datasource.jndi-name 属性可以用来替代<code>spring.datasource.url</code>,<code>spring.datasource.username</code>和<code>spring.datasource.password</code> 属性,来访问特定  位置的JNDI提供的数据源.例如,<code>application.properties</code>中的以下部分显示了如何访问 JBoss AS 定义的<code>DataSource</code>:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.jndi-name</span>=<span class="string">java:jboss/datasources/customers</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h6 id="使用JdbcTemplate-Using-JdbcTemplate"><a href="#使用JdbcTemplate-Using-JdbcTemplate" class="headerlink" title="使用JdbcTemplate(Using JdbcTemplate)"></a>使用JdbcTemplate(Using JdbcTemplate)</h6>Spring 的 <code>JdbcTemplate</code> 和 <code>NamedParameterJdbcTemplate</code> 类是自动配置的,你可以直接将它们<code>@Autowire</code> 到自己的 bean 中,如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.jdbcTemplate ...</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
您可以使用<code>spring.jdbc.template.*</code>属性来自定义模板的属性,如下例所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jdbc.template.max-rows</span>=<span class="string">500</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    <code>NamedParameterJdbcTemplate</code>在背后重用 <code>JdbcTemplate</code>实例.如果定义了多个 <code>JdbcTemplate</code>并且不存在主要候选者,则<code>NamedParameterJdbcTemplate</code>不会自动配置.</p>
</blockquote>
</li>
<li><h6 id="JPA和Spring-Data-JPA-JPA-and-Spring-Data-JPA"><a href="#JPA和Spring-Data-JPA-JPA-and-Spring-Data-JPA" class="headerlink" title="JPA和Spring Data JPA( JPA and Spring Data JPA)"></a>JPA和Spring Data JPA( JPA and Spring Data JPA)</h6>Java Persistence API 是一种标准技术,可让将对象”映射”到关系数据库.<code>spring-boot-starter-data-jpa</code>POM提供了一种快速入门的方法. 它提供以下关键依赖项:<ul>
<li>Hibernate:最流行的 JPA 实现之一.</li>
<li>Spring Data JPA:帮助您实现基于 JPA 的repository.</li>
<li>Spring ORM:来自 Spring框架的支持核心ORM </li>
</ul>
<ol>
<li><h6 id="Entity-Classes"><a href="#Entity-Classes" class="headerlink" title="Entity Classes"></a>Entity Classes</h6>传统上,JPA”Entity”类在<code>persistence.xml</code>文件中指定.在Spring Boot中,此文件不是必需的,而是使用”Entity Scanning”.默认情况下,检索主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>标注的)下的所有包.<br>任何用<code>@Entity</code>,<code>@Embeddable</code>或<code>@MappedSuperclass</code>标注的类都会被考虑. 典型的实体类如下示例:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Id</span></span><br><span class="line"> <span class="meta">@GeneratedValue</span></span><br><span class="line"> <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Column(nullable = false)</span></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Column(nullable = false)</span></span><br><span class="line"> <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ... additional members, often include @OneToMany mappings</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">City</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// no-args constructor required by JPA spec</span></span><br><span class="line">  <span class="comment">// this one is protected since it shouldn&#x27;t be used directly</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(String name, String state)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.state = state;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ... etc</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    您可以使用<code>@EntityScan</code>注解自定义实体扫描位置. 参阅”how-to”.</p>
</blockquote>
</li>
<li><h6 id="Spring-Data-JPA-Repositories"><a href="#Spring-Data-JPA-Repositories" class="headerlink" title="Spring Data JPA Repositories"></a>Spring Data JPA Repositories</h6>Spring Data JPA repositories是可以用来定义来访问数据的接口.JPA查询是根据方法名自动创建的.例如,<code>CityRepository</code>接口可能会声明一个<code>findAllByState(String state) </code>方法来查找给定状态下的所有城市.<br>对于更复杂的查询,可以使用 Spring Data <code>Query</code> 注解来标注方法.<br>Spring Data repositories通常从<code>Repository</code>或<code>CrudRepository</code>接口扩展来的.如果使用自动配置,则从包含您的主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>标注的那个)的包中搜索repositories.<br>以下示例显示了典型的Spring Data存储库接口定义:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Spring Data JPA 存储库支持三种不同的引导模式:默认,延迟和懒加载:<br>要启用deferred或lazy启动模式,将<code>spring.data.jpa.repositories.bootstrap-mode</code>属性分别设置为<code>deferred</code>或<code>lazy</code>.当使用deferred或lazy引导时,自动配置的 <code>EntityManagerFactoryBuilder</code>会使用context的<code>AsyncTaskExecutor</code>(如果有)作为引导执行程序.如果存在多个,将使用名为<code>applicationTaskExecutor</code>的一个.<blockquote>
<p>注意:</p>
<p>​    使用deferred或lazy启动时时,确保对JPA的任何访问都应该在应用context引导阶段再进行.可以使用<code>SmartInitializingSingleton</code>来调用任何需要 JPA的初始化.对于作为Spring bean形式创建的 JPA 组件(例如转换器),会使用<code>ObjectProvider</code>来延迟对依赖项的解析(如果有的话).</p>
<p>建议:</p>
<p>​    上面说的仅仅触及 Spring Data JPA 的皮毛. 有关完整的详细信息,参阅 <a href="https://docs.spring.io/spring-data/jdbc/docs/2.2.1/reference/html/">Spring Data JPA reference documentation</a>.</p>
</blockquote>
</li>
<li><h6 id="创建和删除-JPA-数据库-Creating-and-Dropping-JPA-Databases"><a href="#创建和删除-JPA-数据库-Creating-and-Dropping-JPA-Databases" class="headerlink" title="创建和删除 JPA 数据库(Creating and Dropping JPA Databases)"></a>创建和删除 JPA 数据库(Creating and Dropping JPA Databases)</h6>默认情况下,只有在您使用嵌入式数据库(H2,HSQL 或 Derby)时才会自动创建 JPA 数据库.您可以使用<code>spring.jpa.*</code>属性显式配置 JPA 设置.例如,要创建和删除表,您可以在 application.properties 中添加以下行:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>=<span class="string">create-drop</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    Hibernate 自己的内部属性名称(如果您碰巧记得更好的话)是 <code>hibernate.hbm2ddl.auto</code>.可以使用<code>spring.jpa.properties.*</code>以及其他 Hibernate的自有属性(在将添加到实体管理器之前去除前缀)来设置.以下行显示了为 Hibernate 设置 JPA 属性的示例:</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jpa.properties.hibernate[globally_quoted_identifiers]</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

前面示的例子中,将<code>hibernate.globally_quoted_identifiers</code>属性的<code>true</code>值传递给 Hibernate 实体管理器.<br>默认情况下,DDL 执行(或验证)被推迟到<code>ApplicationContext</code>已经启动后.还有一个<code>spring.jpa.generate-ddl</code>标志位,但如果 Hibernate 自动配置处于活动状态,则不会使用它,因为<code>ddl-auto</code>设置更细粒度.</li>
<li><h6 id="在视图中打开-EntityManager-Open-EntityManager-in-View"><a href="#在视图中打开-EntityManager-Open-EntityManager-in-View" class="headerlink" title="在视图中打开 EntityManager(Open EntityManager in View)"></a>在视图中打开 EntityManager(Open EntityManager in View)</h6>如果您正在运行 Web 应用程序,Spring Boot 默认注册 <code>OpenEntityManagerInViewInterceptor</code>来使用”在视图中打开 EntityManager”模式,从而允许在 Web 视图中延迟加载.如果不想要这种行为,可以在 <code>application.properties</code>中将<code>spring.jpa.open-in-view</code>设置为<code>false</code>.</li>
</ol>
</li>
<li><h6 id="Spring-Data-JDBC"><a href="#Spring-Data-JDBC" class="headerlink" title="Spring Data JDBC"></a>Spring Data JDBC</h6>Spring Data 包括对JDBC 的存储库支持,并将自动为<code>CrudRepository</code>上的方法生成 SQL.对于更高级的查询,提供了<code>@Query</code>注解.<br>当在classpath上有依赖项时,Spring Boot将自动配置 Spring Data 的 JDBC 存储库.可以通过对一个<code>spring-boot-starter-data-jdbc</code>依赖,将所有的依赖添加到的工程中.如有必要,您可以通过向应用添加<code>@EnableJdbcRepositories</code>注解或<code> JdbcConfiguration</code>子类来完全控制 Spring Data JDBC 的配置.</li>
<li><h6 id="使用H2的Web控制台-Using-H2’s-Web-Console"><a href="#使用H2的Web控制台-Using-H2’s-Web-Console" class="headerlink" title="使用H2的Web控制台(Using H2’s Web Console)"></a>使用H2的Web控制台(Using H2’s Web Console)</h6>H2 数据库提供了一个基于浏览器的控制台,Spring Boot 可以自动配置.当满足以下条件时,控制台会自动配置:<ul>
<li>正在开发一个基于servlet的Web应用程序.</li>
<li><code>com.h2database:h2</code>在类路径上.</li>
<li>您正在使用 Spring Boot 的开发人员工具<blockquote>
<p>建议:</p>
<p>   如果你没有使用Spring Boot的开发者工具,但仍想使用 H2 的控制台.您可以将 <code>spring.h2.console.enabled</code>属性配置为<code>true</code>.</p>
<p>注意:</p>
<p>​    H2 控制台仅用于开发期间,因此您应该注意确保<code>spring.h2.console.enabled</code>在生产中未设置为<code>true</code>.</p>
</blockquote>
</li>
</ul>
<ol>
<li><h6 id="更改-H2-控制台的路径-Changing-the-H2-Console’s-Path"><a href="#更改-H2-控制台的路径-Changing-the-H2-Console’s-Path" class="headerlink" title="更改 H2 控制台的路径(Changing the H2 Console’s Path)"></a>更改 H2 控制台的路径(Changing the H2 Console’s Path)</h6>默认情况下,控制台位于<code>/h2-console</code>. 可以使用 <code>spring.h2.console.path</code> 属性自定义控制台的路径.</li>
</ol>
</li>
</ol>
<ol start="6">
<li><h6 id="使用jOOQ-Using-jOOQ"><a href="#使用jOOQ-Using-jOOQ" class="headerlink" title="使用jOOQ(Using jOOQ)"></a>使用jOOQ(Using jOOQ)</h6>jOOQ Object Oriented Querying (jOOQ) 是 Data Geekery 的一款流行产品,根据数据库生成 Java 代码,并允许使用流式 API 构建类型安全的 SQL 查询.商业版和开源版都可以与Spring Boot一起使用.<ol>
<li><h6 id="代码生成-Code-Generation"><a href="#代码生成-Code-Generation" class="headerlink" title="代码生成(Code Generation)"></a>代码生成(Code Generation)</h6>为了使用 jOOQ 类型安全查询,您需要从数据库schema生成 Java 类.可以按照 jOOQ 用户手册中的说明进行操作.如果您使用<code>jooq-codegen-maven</code>插件,并且还使用<code>spring-boot-starter-parent</code>“父POM”,则可以很安全地忽略该插件的<code>&lt;version&gt;</code>标签.您还可以使用 Spring Boot 定义的版本变量(例如 <code>h2.version</code>)来声明插件的数据库依赖. 以下清单显示了一个示例:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line"> &lt;groupId&gt;org.jooq&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;</span><br><span class="line"> &lt;executions&gt;</span><br><span class="line">  ...</span><br><span class="line"> &lt;/executions&gt;</span><br><span class="line"> &lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">	  &lt;groupId&gt;com.h2database&lt;/groupId&gt;</span><br><span class="line">	  &lt;artifactId&gt;h2&lt;/artifactId&gt;</span><br><span class="line">	  &lt;version&gt;$&#123;h2.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line"> &lt;/dependencies&gt;</span><br><span class="line"> &lt;configuration&gt;</span><br><span class="line">  &lt;jdbc&gt;</span><br><span class="line">	  &lt;driver&gt;org.h2.Driver&lt;/driver&gt;</span><br><span class="line">	  &lt;url&gt;jdbc:h2:~/yourdatabase&lt;/url&gt;</span><br><span class="line">  &lt;/jdbc&gt;</span><br><span class="line">  &lt;generator&gt;</span><br><span class="line">	  ...</span><br><span class="line">  &lt;/generator&gt;</span><br><span class="line"> &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="使用DSLContext-Using-DSLContext"><a href="#使用DSLContext-Using-DSLContext" class="headerlink" title="使用DSLContext(Using DSLContext)"></a>使用DSLContext(Using DSLContext)</h6>jOOQ 提供的流式API 是通过<code>org.jooq.DSLContext</code>接口初始化的.Spring Boot 将 <code>DSLContext</code> 自动配置成Spring Bean并将将其连接到应用的数据源<code>DataSource</code>.要使用<code>DSLContext</code>,可以如下注:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> DSLContext create;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(DSLContext dslContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.create = dslContext;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    jOOQ 手册倾向于使用名为<code>create</code>的变量来保存<code>DSLContext</code>.<br>可以使用<code>DSLContext</code>去构建查询,如下所示;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;GregorianCalendar&gt; <span class="title">authorsBornAfter1980</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.create.selectFrom(AUTHOR)</span><br><span class="line">	  .where(AUTHOR.DATE_OF_BIRTH.greaterThan(<span class="keyword">new</span> GregorianCalendar(<span class="number">1980</span>, <span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">	  .fetch(AUTHOR.DATE_OF_BIRTH);</span><br></pre></td></tr></table></figure></li>
<li><h6 id="jOOQ-SQL方言-jOOQ-SQL-Dialect"><a href="#jOOQ-SQL方言-jOOQ-SQL-Dialect" class="headerlink" title="jOOQ SQL方言(jOOQ SQL Dialect)"></a>jOOQ SQL方言(jOOQ SQL Dialect)</h6>除非已经配置了<code>spring.jooq.sql-dialect</code>属性,否则Spring Boot会决定用于数据源的 SQL 方言.如果 Spring Boot无法检测到方言,则使用<code>DEFAULT</code>.<blockquote>
<p>注意:</p>
<p>​    Spring Boot只能自动配置 jOOQ 开源版本支持的方言.</p>
</blockquote>
</li>
<li><h6 id="自定义jOOQ-Customizing-jOOQ"><a href="#自定义jOOQ-Customizing-jOOQ" class="headerlink" title="自定义jOOQ(Customizing jOOQ)"></a>自定义jOOQ(Customizing jOOQ)</h6>可以通过自定义<code>DefaultConfigurationCustomizer</code>bean来实现更高级的自定义,该 bean将在创建<code>org.jooq.Configuration</code> <code>@Bean</code>之前调用.这优先于任何自动配置的内容.<br>如果您想完全控制 jOOQ 配置,您还可以创建自己的<code>org.jooq.Configuration</code> <code>@Bean</code>.</li>
</ol>
</li>
<li><h6 id="使用R2DBC-Using-R2DBC"><a href="#使用R2DBC-Using-R2DBC" class="headerlink" title="使用R2DBC(Using R2DBC)"></a>使用R2DBC(Using R2DBC)</h6>响应式关系数据库连接(The Reactive Relational Database Connectivity ,R2DBC)项目将响应式编程API引入了关系数据库.R2DBC 的<code>io.r2dbc.spi.Connection</code>提供了一种标准方法来使用非阻塞数据库连接.连接是通过<code>ConnectionFactory</code>提供的,类似于带有jdbc的<code>DataSource</code>.<br><code>ConnectionFactory</code>配置由<code>spring.r2dbc.*</code>中的外部配置属性控制.例如,可以在 <code>application.properties</code>中声明以下部分:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.r2dbc.url</span>=<span class="string">r2dbc:postgresql://localhost/test</span></span><br><span class="line"><span class="meta">spring.r2dbc.username</span>=<span class="string">dbuser</span></span><br><span class="line"><span class="meta">spring.r2dbc.password</span>=<span class="string">dbpass</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    不需要指定驱动程序类名,因为Spring Boot从 R2DBC 的连接工厂发现中获取驱动程序.</p>
<p>注意:</p>
<p>​    至少应该提供网址. URL 中指定的信息优先于单个属性,即<code>name</code>,<code>username</code>,<code>password</code>和池选项.</p>
</blockquote>
可以自定义由<code>ConnectionFactory</code>创建的连接,即在中央数据库配置中设置不想(或不能)特定参数,您可以使用<code>ConnectionFactoryOptionsBuilderCustomizer</code> <code>@Bean</code>.以下示例显示了如何手动覆盖数据库端口,而其余选项来使用应用程序配置:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyR2dbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ConnectionFactoryOptionsBuilderCustomizer <span class="title">connectionFactoryPortCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (builder) -&gt; builder.option(ConnectionFactoryOptions.PORT, <span class="number">5432</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以下示例显示了如何设置PostgreSQL 连接选项:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPostgresR2dbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ConnectionFactoryOptionsBuilderCustomizer <span class="title">postgresCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Map&lt;String, String&gt; options = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  options.put(<span class="string">&quot;lock_timeout&quot;</span>, <span class="string">&quot;30s&quot;</span>);</span><br><span class="line">  options.put(<span class="string">&quot;statement_timeout&quot;</span>, <span class="string">&quot;60s&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (builder) -&gt; builder.option(PostgresqlConnectionFactoryProvider.OPTIONS, options);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当<code>ConnectionFactory</code>bean可用时,常规的 JDBC数据源的自动配置将不会生效.如果想保留 JDBC <code>DataSource</code>自动配置,并且能够接受在响应式应用中使用阻塞 JDBC API 的风险,可以在应用的<code>@Configuration</code>上添加<code>@Import(DataSourceAutoConfiguration.class)</code>,来使其重新开启.<ol>
<li><h6 id="对内嵌式数据的支持-Embedded-Database-Support"><a href="#对内嵌式数据的支持-Embedded-Database-Support" class="headerlink" title="对内嵌式数据的支持(Embedded Database Support)"></a>对内嵌式数据的支持(Embedded Database Support)</h6>与 JDBC 支持类似,Spring Boot可以自动配置嵌入式数据库以供响应式使用.您无需提供任何连接URL.只需要在编译依赖中添加要使用的嵌入式数据库,如以下示例所示:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.r2dbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>r2dbc-h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    如果在测试中使用此功能,可能会注意到,无论您使用多少应用context,整个测试组件都会重用同一个数据库.如果要让每个context都使用单独的嵌入式数据库,则应将<code>spring.r2dbc.generate-unique-name</code>设置为<code>true</code>.</p>
</blockquote>
</li>
<li><h6 id="使用数据库客户端-Using-DatabaseClient"><a href="#使用数据库客户端-Using-DatabaseClient" class="headerlink" title="使用数据库客户端(Using DatabaseClient)"></a>使用数据库客户端(Using DatabaseClient)</h6><code>DatabaseClient</code>bean是自动配置的,可以将直接使用<code>@Autowire</code> 注入到到自己的 bean中.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> DatabaseClient databaseClient;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(DatabaseClient databaseClient)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.databaseClient = databaseClient;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="Spring-Data-R2DBC-Repositories"><a href="#Spring-Data-R2DBC-Repositories" class="headerlink" title="Spring Data R2DBC Repositories"></a>Spring Data R2DBC Repositories</h6>Spring Data R2DBC repositories是可以用来访问数据的接口.根据方法名来自动创建的查询.例如,<code>CityRepository</code>接口可能会声明一个<code>findAllByState(String state) </code>方法来查找指定状态的所有城市.<br>对于更复杂的查询,您可以使用Spring Data Query注释来标注方法.<br>Spring Data repositories 通常从<code>Repository</code>或<code>CrudRepository</code>接口扩展.如果使用自动配置,则从包含主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>标注的类)的包中搜索存储库.<br>以下示例显示了典型的 Spring Data repository 接口定义:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function">Mono&lt;City&gt; <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    以上内容几乎没有触及Spring Data R2DBC的皮毛. 有关完整的详细信息,请参阅 Spring Data R2DBC 参考文档.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.12 Featue: NoSQL技术</title>
    <url>/posts/11539.html</url>
    <content><![CDATA[<h5 id="使用NoSQL技术-Working-with-NoSQL-Technologies"><a href="#使用NoSQL技术-Working-with-NoSQL-Technologies" class="headerlink" title="使用NoSQL技术( Working with NoSQL Technologies)"></a>使用NoSQL技术( Working with NoSQL Technologies)</h5><p>Spring Data提供了其他项目来帮助访问各种NoSQL 技术,包括:</p>
<ul>
<li><a href="https://spring.io/projects/spring-data-mongodb">MongoDB</a></li>
<li><a href="https://spring.io/projects/spring-data-neo4j">Neo4J</a></li>
<li><a href="https://spring.io/projects/spring-data-elasticsearch">Elasticsearch</a></li>
<li><a href="https://spring.io/projects/spring-data-redis">Redis</a></li>
<li><a href="https://spring.io/projects/spring-data-gemfire">GemFire</a> 或者 <a href="https://spring.io/projects/spring-data-geode">Geode</a></li>
<li><a href="https://spring.io/projects/spring-data-cassandra">Cassandra</a></li>
<li><a href="https://spring.io/projects/spring-data-couchbase">Couchbase</a></li>
<li><a href="https://spring.io/projects/spring-data-ldap">LDAP</a><br>Spring Boot为Redis,MongoDB,Neo4j,Solr,Elasticsearch,Cassandra,Couchbase,LDAP 和 InfluxDB 提供自动配置. 可以使用其他NoSQL项目,但必须自己配置它们.请参阅<code>spring.io/projects/spring-data</code>中的相应参考文档.</li>
</ul>
<ol>
<li><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><p>Redis 是一个缓存,消息代理和功能丰富的键值存储. Spring Boot 为 Lettuce 和 Jedis 客户端库以及由Spring Data Redis 提供的在他们之上的抽象提供了基本的自动配置.<br>有一个<code>spring-boot-starter-data-redis</code> “Starter” 可以方便地配置各个依赖项.默认情况下,使用<a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>. 该启动器处理传统和反应式应用程序.</p>
<blockquote>
<p>建议:</p>
<p>​    Spring Boot还提供了一个<code>spring-boot-starter-data-redis-reactive</code> “Starter”,用来和其他的具有响应式支持的存储保持一致.</p>
</blockquote>
<ol>
<li><h6 id="连接Redis-Connecting-to-Redis"><a href="#连接Redis-Connecting-to-Redis" class="headerlink" title="连接Redis(Connecting to Redis)"></a>连接Redis(Connecting to Redis)</h6>可以像注入任何其他Spring Bean一样注入自动配置的<code>RedisConnectionFactory</code>,<code>StringRedisTemplate</code>或 vanilla <code>RedisTemplate</code>实例.默认情况下,实例会尝试连接到<code>localhost:6379</code>的 Redis 服务器. 以下列表显示了此类 bean 的示例:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(StringRedisTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.template = template;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    可以注册任意数量的,实现<code>LettuceClientConfigurationBuilderCustomizer </code>的bean来实现更高级的自定义.如果使用 Jedis,<code>JedisClientConfigurationBuilderCustomizer</code>也是可用的.<br>如果添加自己的任何自动配置类型的<code>@Bean</code>,它将替换默认值(<code>RedisTemplate</code>除外,当排除基于bean名称,<code>redisTemplate</code>而不是其类型时).默认情况下,如果 <code>commons-pool2</code>在类路径上,将获得一个池化连接工厂.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h6><p>MongoDB是一个开源的NoSQL文档数据库,它使用类似 JSON 的模式而不是传统的基于表的关系数据.Spring Boot为使用MongoDB提供了多种便利,包括<code>spring-boot-starter-data-mongodb</code>和<code>spring-boot-starter-data-mongodb-reactive</code> “Starters”.</p>
<ol>
<li><h6 id="连接到MongoDB-Connecting-to-a-MongoDB-Database"><a href="#连接到MongoDB-Connecting-to-a-MongoDB-Database" class="headerlink" title="连接到MongoDB(Connecting to a MongoDB Database)"></a>连接到MongoDB(Connecting to a MongoDB Database)</h6>要访问MongoDB数据库,可以注入自动配置的<code>org.springframework.data.mongodb.MongoDatabaseFactory</code>.默认情况下,实例会尝试连接到<code>mongodb://localhost/test</code>的MongoDB服务器.以下示例显示了如何连接到MongoDB数据库:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> MongoDatabaseFactory mongo;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoDatabaseFactory mongo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.mongo = mongo;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果定义了<code>MongoClient</code>,它将用于合适的 <code>MongoDatabaseFactory</code>进行自动配置.<br>自动配置的<code>MongoClient</code>,是使用<code>MongoClientSettings</code>bean.如果定义了自己的<code>MongoClientSettings</code>,则无需修改即可使用,<code>spring.data.mongodb</code>属性会被自动忽略.否则<code>MongoClientSettings</code>将被自动配置,并将应用 <code>spring.data.mongodb</code>属性.在任一情况下,都可以声明一个或多个 <code>MongoClientSettingsBuilderCustomizer</code>bean来调整<code>MongoClientSettings</code>配置.每个都会被<code>MongoClientSettings.Builder</code>按顺序调用,<code>MongoClientSettings.Builder</code>是用来构建<code>MongoClientSettings</code>的.<br>您可以设置<code>spring.data.mongodb.uri</code>属性来更改URL并配置其他设置,例如<em>replica set</em>,如以下示例所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.data.mongodb.uri</span>=<span class="string">mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test</span></span><br></pre></td></tr></table></figure>
或者,您可以使用离散属性指定连接详细信息. 例如,您可以在 <code>application.properties</code>中声明以下设置:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.data.mongodb.host</span>=<span class="string">mongoserver.example.com</span></span><br><span class="line"><span class="meta">spring.data.mongodb.port</span>=<span class="string">27017</span></span><br><span class="line"><span class="meta">spring.data.mongodb.database</span>=<span class="string">test</span></span><br><span class="line"><span class="meta">spring.data.mongodb.username</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.data.mongodb.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    如果没有指定<code>spring.data.mongodb.port</code>,则使用默认值 <code>27017</code>. 可以从前面显示的示例中删除此行.</p>
<p>建议:</p>
<p>​    如果不使用Spring Data MongoDB,则可以注入<code>MongoClient</code> bean 而不是使用<code>MongoDatabaseFactory</code>.如果想完全控制MongoDB的连接建立,可以声明自己的<code>MongoDatabaseFactory</code>或<code>MongoClient</code>bean.</p>
<p>注意:</p>
<p>​    如果您使用的是响应式驱动程序,则SSL需要 Netty.如果 Netty 可用并且要使用的工厂尚未被自定义,则自动配置会自动配置此工厂.</p>
</blockquote>
</li>
<li><h6 id="MongoTemplate"><a href="#MongoTemplate" class="headerlink" title="MongoTemplate"></a>MongoTemplate</h6>Spring Data MongoDB提供了一个<code>MongoTemplate</code>类,它的设计与 Spring 的<code>JdbcTemplate</code>非常相似.和<code>JdbcTemplate</code>一样,Spring Boot自动配置了一个 bean供开发者注入模板,如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoTemplate mongoTemplate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.mongoTemplate = mongoTemplate;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="Spring-Data-MongoDB-Repositories"><a href="#Spring-Data-MongoDB-Repositories" class="headerlink" title="Spring Data MongoDB Repositories"></a>Spring Data MongoDB Repositories</h6>Spring Data 包括对 MongoDB 的存储库支持.与前面讨论的 JPA 存储库一样,基本理念是根据方法名称自动构造查询.<br>事实上,Spring Data JPA 和 Spring Data MongoDB 共享同样的公共基础架构.可以使用JPA示例,并假设<code>City</code>现在是MongoDB数据类,而不是JPA <code>@Entity</code>,它的工作方式相同,如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    您可以使用<code>@EntityScan</code>注解自定义文档扫描位置.</p>
<p>建议:</p>
<p>​    有关 Spring Data MongoDB 的完整详细信息,包括其丰富的对象映射技术,请参阅其<a href="https://spring.io/projects/spring-data-mongodb">reference documentation</a>.</p>
</blockquote>
</li>
<li><h6 id="嵌入式Mongo"><a href="#嵌入式Mongo" class="headerlink" title="嵌入式Mongo"></a>嵌入式Mongo</h6>Spring Boot 为嵌入式 Mongo 提供了自动配置. 要在 Spring Boot 应用程序中使用它,请添加 <code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code> 依赖<br>可以通过设置<code>spring.data.mongodb.port</code>属性来配置 Mongo 监听端口.要使用随机分配的空闲端口,请使用值 0. <code>MongoAutoConfiguration</code>创建的<code>MongoClient</code>使用随机分配的端口进行自动配置.<blockquote>
<p>注意:</p>
<p>​    如果不配置自定义端口,嵌入式Mongo支持默认使用随机端口(而不是 27017).<br>如果类路径上有 SLF4J,Mongo 生成的输出会自动路由到名为 <code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code> 的logger上.<br>可以声明自己的<code>IMongodConfig</code>和<code>IRuntimeConfig</code> bean 来配置Mongo实例和日志路由.可以通过<code>DownloadConfigBuilderCustomizer</code>bean来自定义下载配置.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h6><p>Neo4j 是一个开源的 NoSQL 图数据库,它由first class relationships连接的,具有丰富数据模型,比传统的 RDBMS方案更适合连接大数据. Spring Boot 为使用 Neo4j 提供了多种便利,包括 <code>spring-boot-starter-data-neo4j</code> “Starter”.</p>
<ol>
<li><h6 id="连接到Neo4j数据库-Connecting-to-a-Neo4j-Database"><a href="#连接到Neo4j数据库-Connecting-to-a-Neo4j-Database" class="headerlink" title="连接到Neo4j数据库(Connecting to a Neo4j Database)"></a>连接到Neo4j数据库(Connecting to a Neo4j Database)</h6>要访问 Neo4j 服务器,可以注入一个自动配置的 <code>org.neo4j.driver.Driver</code>.默认情况下,实例尝试使用 Bolt 协议连接到 <code>localhost:7687</code> 的 Neo4j 服务器.以下示例显示了如何注入 Neo4j 驱动程序,该驱动程序可让访问 <code>Session</code>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Driver driver;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(Driver driver)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.driver = driver;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以使用<code>spring.neo4j.*</code>属性配置驱动程序的各个部分. 以下示例显示了如何配置uri和凭据:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.neo4j.uri</span>=<span class="string">bolt://my-server:7687</span></span><br><span class="line"><span class="meta">spring.neo4j.authentication.username</span>=<span class="string">neo4j</span></span><br><span class="line"><span class="meta">spring.neo4j.authentication.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
自动配置的驱动是使用<code>ConfigBuilder</code>来创建的.要调整配置,应该要声明一个或多个 <code>ConfigBuilderCustomizer</code>bean.每个将按顺序调用被<code>ConfigBuilder</code>调用,<code>ConfigBuilder</code>是用于构建驱动程序的 .</li>
<li><h6 id="Spring-Data-Neo4j-Repositories"><a href="#Spring-Data-Neo4j-Repositories" class="headerlink" title="Spring Data Neo4j Repositories"></a>Spring Data Neo4j Repositories</h6>Spring Data 包括对 Neo4j 的存储库支持. 有关 Spring Data Neo4j 的完整详细信息,请参阅<a href="https://docs.spring.io/spring-data/neo4j/docs/6.1.1/reference/html/">参考文档</a>.<br>就像许多其他 Spring Data 模块一样,Spring Data Neo4j 与 Spring Data JPA 共享公共基础设施.可以采用前面的 JPA 示例,并将<code>City</code>定义为 Spring Data Neo4j <code>@Node</code> 而不是 JPA <code>@Entity</code>,并且存储库抽象以相同的方式工作,如下面的示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Neo4jRepository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function">Optional&lt;City&gt; <span class="title">findOneByNameAndState</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>spring-boot-starter-data-neo4j</code> “Starter”开启存储库支持以及事务管理.Spring Boot 支持经典和响应式 Neo4j 存储库,使用 <code>Neo4jTemplate</code> 或 <code>ReactiveNeo4jTemplate</code> bean.当Project Reactor在类路径上可用时,响应式风格也会被自动配置.<br>可以通过在<code>@Configuration</code> bean上使用<code>@EnableNeo4jRepositories</code>和<code>@EntityScan</code>来自定义存储库和实体的路径.<blockquote>
<p>注意:</p>
<p>​    在使用响应式风格的应用程序中,<code>ReactiveTransactionManager</code>不是自动配置的.要启用事务管理,必须在配置中定义以下 bean:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNeo4jConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ReactiveNeo4jTransactionManager <span class="title">reactiveTransactionManager</span><span class="params">(Driver driver,</span></span></span><br><span class="line"><span class="params"><span class="function">         ReactiveDatabaseSelectionProvider databaseNameProvider)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ReactiveNeo4jTransactionManager(driver, databaseNameProvider);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
</li>
<li><h6 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h6><p>Apache Solr是一个搜索引擎. Spring Boot 为 Solr 5 客户端库提供基本的自动配置.</p>
<ol>
<li><h6 id="连接到Solr"><a href="#连接到Solr" class="headerlink" title="连接到Solr"></a>连接到Solr</h6>可以像注入任何其他 Spring bean 一样注入自动配置的 <code>SolrClient</code> 实例.默认情况下,实例会尝试连接到位于 localhost:8983/solr 的服务器. 以下示例显示了如何注入 Solr bean:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> SolrClient solr;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(SolrClient solr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.solr = solr;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果添加自己的<code>SolrClient</code>类型的<code>@Bean</code>,它将替换默认值.</li>
</ol>
</li>
<li><h6 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h6><p>Elasticsearch 是一个开源,分布式,RESTful 搜索和分析引擎.Spring Boot 为 Elasticsearch 提供了基本的自动配置.<br>Spring Boot 支持多种客户端:</p>
<ul>
<li>官方 Java”Low Level”和”High Level”REST 客户端</li>
<li>Spring Data Elasticsearch 提供的<code>ReactiveElasticsearchClient</code><br>Spring Boot 提供了一个专用的”Starter”,<code>spring-boot-starter-data-elasticsearch</code></li>
</ul>
<ol>
<li><h6 id="使用-REST-客户端连接到-Elasticsearch-Connecting-to-Elasticsearch-using-REST-clients"><a href="#使用-REST-客户端连接到-Elasticsearch-Connecting-to-Elasticsearch-using-REST-clients" class="headerlink" title="使用 REST 客户端连接到 Elasticsearch(Connecting to Elasticsearch using REST clients)"></a>使用 REST 客户端连接到 Elasticsearch(Connecting to Elasticsearch using REST clients)</h6>Elasticsearch 提供了两个不同的 REST 客户端,您可以使用它们来查询集群:”Low Level”客户端和”High Level”客户端.Spring Boot 提供对”High Level”客户端的支持,该客户端随<code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code>一起提供.<br>如果classpath中存在依赖时,Spring Boot 将自动配置并注册一个 <code>RestHighLevelClient</code> bean,默认情况下该 bean 以<code>localhost:9200</code>为targets.可以进一步调整<code>RestHighLevelClient</code>的配置方式,如下例所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.elasticsearch.rest.uris</span>=<span class="string">https://search.example.com:9200</span></span><br><span class="line"><span class="meta">spring.elasticsearch.rest.read-timeout</span>=<span class="string">10s</span></span><br><span class="line"><span class="meta">spring.elasticsearch.rest.username</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.elasticsearch.rest.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
您还可以注册任意数量实现<code>RestClientBuilderCustomizer</code>的 bean,来进行更高级的自定义.要完全控制注册,请定义一个<code>RestClientBuilder</code> bean.<blockquote>
<p>建议:</p>
<p>​    如果应用程序需要访问”Low Level” <code>RestClient</code>,可以在自动配置的<code>RestHighLevelClient</code>上调用 <code>client.getLowLevelClient()</code> 来获取它.</p>
</blockquote>
另外,如果<code>elasticsearch-rest-client-sniffer</code>在类路径上,则自动配置的<code>Sniffer</code>会从当前正在运行的Elasticsearch集群中自动发现节点并将其设置为<code>RestHighLevelClient</code> Bean.可以进一步调整 <code>Sniffer</code> 的配置方式,如以下示例所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.elasticsearch.rest.sniffer.interval</span>=<span class="string">10m</span></span><br><span class="line"><span class="meta">spring.elasticsearch.rest.sniffer.delay-after-failure</span>=<span class="string">30s</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="使用响应式REST客户端连接到Elasticsearch-Connecting-to-Elasticsearch-using-Reactive-REST-clients"><a href="#使用响应式REST客户端连接到Elasticsearch-Connecting-to-Elasticsearch-using-Reactive-REST-clients" class="headerlink" title="使用响应式REST客户端连接到Elasticsearch(Connecting to Elasticsearch using Reactive REST clients)"></a>使用响应式REST客户端连接到Elasticsearch(Connecting to Elasticsearch using Reactive REST clients)</h6>Spring Data Elasticsearch 提供 <code>ReactiveElasticsearchClient</code> 以响应式方式来查询 Elasticsearch 实例.它建立在 WebFlux 的<code>WebClient</code>之上,因此 <code>spring-boot-starter-elasticsearch</code>和<code>spring-boot-starter-webflux</code>依赖项对于启用此支持很有用.<br>默认情况下,Spring Boot 会自动配置并注册一个<code>ReactiveElasticsearchClient</code>  bean,它以 <code>localhost:9200</code> 为目标.可以进一步调整它的配置方式,如以下示例所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.data.elasticsearch.client.reactive.endpoints</span>=<span class="string">search.example.com:9200</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.client.reactive.use-ssl</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.client.reactive.socket-timeout</span>=<span class="string">10s</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.client.reactive.username</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.client.reactive.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
如果提供的配置属性不够,并且想完全控制客户端配置,则可以注册自定义<code>ClientConfiguration</code>bean.</li>
<li><h6 id="使用-Spring-Data-连接到-Elasticsearch-Connecting-to-Elasticsearch-by-Using-Spring-Data"><a href="#使用-Spring-Data-连接到-Elasticsearch-Connecting-to-Elasticsearch-by-Using-Spring-Data" class="headerlink" title="使用 Spring Data 连接到 Elasticsearch(Connecting to Elasticsearch by Using Spring Data)"></a>使用 Spring Data 连接到 Elasticsearch(Connecting to Elasticsearch by Using Spring Data)</h6>要连接到 Elasticsearch,必须定义一个 <code>RestHighLevelClient</code> bean,由 Spring Boot 自动配置或由应用程序手动提供(参见前面的部分).有了这个配置,一个 <code>ElasticsearchRestTemplate</code>可以像任何其他 Spring bean 一样注入,如下面的例子所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchRestTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ElasticsearchRestTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.template = template;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当存在<code>spring-data-elasticsearch</code>和使用<code>WebClient</code>(通常是<code>spring-boot-starter-webflux</code>)所需的依赖项的情况下,Spring Boot 还可以将<code>ReactiveElasticsearchClient</code>和<code>ReactiveElasticsearchTemplate</code>自动配置为 bean.它们是与其他REST 客户端相等同的响应式客户端.</li>
<li><h6 id="Spring-Data-Elasticsearch-存储库-Spring-Data-Elasticsearch-Repositories"><a href="#Spring-Data-Elasticsearch-存储库-Spring-Data-Elasticsearch-Repositories" class="headerlink" title="Spring Data Elasticsearch 存储库(Spring Data Elasticsearch Repositories)"></a>Spring Data Elasticsearch 存储库(Spring Data Elasticsearch Repositories)</h6>Spring Data 包括对 Elasticsearch 的存储库支持.与前面讨论的 JPA 存储库一样,基本原则是根据方法名称自动构造查询.<br>实际上,Spring Data JPA 和 Spring Data Elasticsearch 共享相同的公共基础架构.. 可以以前面的JPA示例为例,并假设<code>City</code>现在是Elasticsearch <code>@Document</code>类,而不是JPA <code>@Entity</code>,它的工作方式相同.<blockquote>
<p>建议:</p>
<p>​    有关 Spring Data Elasticsearch 的完整详细信息,请参阅<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/">参考文档</a>.</p>
</blockquote>
Spring Boot 支持经典和响应式 Elasticsearch 存储库,使用 <code>ElasticsearchRestTemplate</code> 或 <code>ReactiveElasticsearchTemplate</code> bean.根据存在所需的依赖项,这些bean很由 Spring Boot 自动配置的.<br>如果您希望使用自己的模板来支持 Elasticsearch 存储库,可以添加自己的 <code>ElasticsearchRestTemplate</code>或<code>ElasticsearchOperations</code>@Bean,只要它被命名为<code>&quot;elasticsearchTemplate&quot;</code>. 这个方式同样适用于<code>ReactiveElasticsearchTemplate</code>和<code>ReactiveElasticsearchOperations</code>,bean 名称为<code>&quot;reactiveElasticsearchTemplate&quot;</code>.<br>可以选择使用以下属性禁用存储库支持:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.data.elasticsearch.repositories.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h6 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h6><p>Cassandra 是一个开源的分布式数据库管理系统,旨在处理跨许多商用服务器的大量数据.Spring Boot 为 Cassandra 和 Spring Data Cassandra 的基于Cassandra 的抽象提供了自动配置.有一个<code>spring-boot-starter-data-cassandra</code> “Starter” 可以方便地收集依赖项.</p>
<ol>
<li><h6 id="连接到Cassandra-Connecting-to-Cassandra"><a href="#连接到Cassandra-Connecting-to-Cassandra" class="headerlink" title="连接到Cassandra(Connecting to Cassandra)"></a>连接到Cassandra(Connecting to Cassandra)</h6>可以像使用任何其他 Spring Bean 一样注入自动配置的<code>CassandraTemplate</code>或Cassandra <code>CqlSession</code> 实例. <code>spring.data.cassandra.*</code>属性可用于自定义连接.<br>通常,提供<code>keyspace-name</code> 和 <code>contact-points</code> 以及本地数据中心名称,如以下示例所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.data.cassandra.keyspace-name</span>=<span class="string">mykeyspace</span></span><br><span class="line"><span class="meta">spring.data.cassandra.contact-points</span>=<span class="string">cassandrahost1:9042,cassandrahost2:9042</span></span><br><span class="line"><span class="meta">spring.data.cassandra.local-datacenter</span>=<span class="string">datacenter1</span></span><br></pre></td></tr></table></figure>
如果所有联系点的端口都相同,则可以使用快捷方式并仅指定主机名,如下例所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.data.cassandra.keyspace-name</span>=<span class="string">mykeyspace</span></span><br><span class="line"><span class="meta">spring.data.cassandra.contact-points</span>=<span class="string">cassandrahost1,cassandrahost2</span></span><br><span class="line"><span class="meta">spring.data.cassandra.local-datacenter</span>=<span class="string">datacenter1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    这两个例子相同,端口默认为<code>9042</code>.如果需要配置端口,使用<code>spring.data.cassandra.port</code>.</p>
<p>建议:</p>
<p>​    Cassandra 驱动程序有自己的配置基础infrastructure,它在classpath的根路径加载一个<code>application.conf</code>.</p>
<p>​    Spring Boot 默认不会查找这样的文件,但可以使用 <code>spring.data.cassandra.config</code> 加载.如果一个属性同时存在于 <code>spring.data.cassandra.*</code> 和配置文件中,则 <code>spring.data.cassandra.*</code> 中的值优先.</p>
<p>​    对于更高级的自定义驱动程序,可以注册任意数量的实现 <code>DriverConfigLoaderBuilderCustomizer</code>的 bean.可以使用类型为 <code>CqlSessionBuilder</code> Customizer 的 bean 自定义 <code>CqlSession</code>.</p>
<p>注意:</p>
<p>​    如果您使用<code>CqlSessionBuilder</code>创建多<code>CqlSession bean</code>,要记住builder是可变的,因此请确保为每个会话注入一个新副本.</p>
</blockquote>
以下代码清单显示了如何注入 Cassandra bean:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> CassandraTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CassandraTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.template = template;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果添加自己的 <code>CassandraTemplate</code> 类型的 <code>@Bean</code>,它将替换默认值.</li>
<li><h6 id="Spring-Data-Cassandra-Repositories"><a href="#Spring-Data-Cassandra-Repositories" class="headerlink" title="Spring Data Cassandra Repositories"></a>Spring Data Cassandra Repositories</h6>Spring Data 包括对 Cassandra 的基本存储库支持.目前,这比前面讨论的 JPA 存储库更受限制,需要使用<code>@Query</code>注释查找器方法.<blockquote>
<p>建议:</p>
<p>​    有关 Spring Data Cassandra 的完整详细信息,请参阅<a href="https://docs.spring.io/spring-data/cassandra/docs/">reference documentation</a>.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h6><p>Couchbase 是一个开源,分布式,多模型 NoSQL 面向文档的数据库,针对交互式应用程序进行了优化.Spring Boot 为 Couchbase 和 Spring Data Couchbase 提供的抽象提供了自动配置.有 <code>spring-boot-starter-data-couchbase</code>和<code>spring-boot-starter-data-couchbase-reactive</code>“Starters” 可以很方便地添加依赖.</p>
<ol>
<li><h6 id="连接到Couchbase-Connecting-to-Couchbase"><a href="#连接到Couchbase-Connecting-to-Couchbase" class="headerlink" title="连接到Couchbase(Connecting to Couchbase)"></a>连接到Couchbase(Connecting to Couchbase)</h6>你可以通过添加 Couchbase SDK 和一些配置来获得一个<code>Cluster</code>.<code>spring.couchbase.*</code>属性可以用来自定义连接.通常来说,连接字符串,用户名和密码,会如下例所示提供:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.couchbase.connection-string</span>=<span class="string">couchbase://192.168.1.123</span></span><br><span class="line"><span class="meta">spring.couchbase.username</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.couchbase.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
也可以自定义一些 <code>ClusterEnvironment</code> 设置.例如,以下配置更改用于打开新<code>Bucket</code>的超时并启用 SSL 支持:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.couchbase.env.timeouts.connect</span>=<span class="string">3s</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.key-store</span>=<span class="string">/location/of/keystore.jks</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.key-store-password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    检查 <code>spring.couchbase.env.*</code> 属性以获取更多详细信息. 要进行更多控制,可以使用一个或多个<code>ClusterEnvironmentBuilderCustomizer</code> bean.</p>
</blockquote>
</li>
<li><h6 id="Spring-Data-Couchbase-Repositories"><a href="#Spring-Data-Couchbase-Repositories" class="headerlink" title="Spring Data Couchbase Repositories"></a>Spring Data Couchbase Repositories</h6>Spring Data 包括对 Couchbase 的存储库支持. 有关 Spring Data Couchbase 的完整详细信息,请参阅<a href="https://docs.spring.io/spring-data/couchbase/docs/4.2.1/reference/html/">reference documentation</a>.<br>可以像使用任何其他 Spring Bean一样注入自动配置的 <code>CouchbaseTemplate</code> 实例,前提是 <code>CouchbaseClientFactory</code> bean 可用.当使用集群是可能会发生这种情况,如上所述,并且指定存储桶名称:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.data.couchbase.bucket-name</span>=<span class="string">my-bucket</span></span><br></pre></td></tr></table></figure>
以下示例显示了如何注入<code>CouchbaseTemplate</code>bean:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> CouchbaseTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CouchbaseTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.template = template;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以在自己的配置中定义一些 bean 来覆盖自动配置提供的那些 bean:<ul>
<li>名为 <code>couchbaseMappingContext</code> 的 <code>CouchbaseMappingContext</code> <code>@Bean</code></li>
<li>名为 <code>couchbaseCustomConversions</code> 的 <code>CustomConversions</code> <code>@Bean</code></li>
<li>名为 <code>couchbaseTemplate</code> 的 <code>CouchbaseTemplate</code> <code>@Bean</code><br>为了避免在自己的配置中硬编码这些名称,可以重用 Spring Data Couchbase 提供的 <code>BeanNames</code>. 例如,可以自定义要使用的转换器,如下所示:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCouchbaseConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> CouchbaseCustomConversions <span class="title">myCustomConversions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CouchbaseCustomConversions(Arrays.asList(<span class="keyword">new</span> MyConverter()));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h6 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h6><p>LDAP(轻型目录访问协议)是一种开放的,供应商中立的行业标准应用协议,用于通过 IP 网络访问和维护分布式目录信息服务.Spring Boot 为任何兼容的 LDAP 服务器提供自动配置,并支持来自 UnboundID 的嵌入式内存 LDAP 服务器.<br>LDAP 抽象由 Spring Data LDAP 提供.<code>spring-boot-starter-data-ldap</code> “Starter” 可以很方便地添加依赖项.</p>
<ol>
<li><h6 id="连接到-LDAP-服务器-Connecting-to-an-LDAP-Server"><a href="#连接到-LDAP-服务器-Connecting-to-an-LDAP-Server" class="headerlink" title="连接到 LDAP 服务器 (Connecting to an LDAP Server)"></a>连接到 LDAP 服务器 (Connecting to an LDAP Server)</h6>要连接到 LDAP 服务器,确保声明<code>spring-boot-starter-data-ldap</code> “Starter”或 <code>spring-ldap-core</code>的依赖,然后在 application.properties 中声明服务器的 URL,如下所示 下面的例子:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.ldap.urls</span>=<span class="string">ldap://myserver:1235</span></span><br><span class="line"><span class="meta">spring.ldap.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.ldap.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
如果需要自定义连接设置,可以使用 <code>spring.ldap.base</code> 和 <code>spring.ldap.base-environment</code> 属性.<br><code>LdapContextSource</code>是根据这些设置自动配置的. 如果 <code>DirContextAuthenticationStrategy</code> bean 可用,则它与自动配置的 <code>LdapContextSource</code> 相关联.如果需要自定义它,例如使用 <code>PooledContextSource</code>,仍然可以注入自动配置的 <code>LdapContextSource</code>.确保将自定义的 <code>ContextSource</code> 标记为 <code>@Primary</code>,从而让自动配置的 <code>LdapTemplate</code> 使用.</li>
<li><h6 id="Spring-Data-LDAP-Repositories"><a href="#Spring-Data-LDAP-Repositories" class="headerlink" title="Spring Data LDAP Repositories"></a>Spring Data LDAP Repositories</h6>Spring Data 支持 LDAP 的存储库. 有关 Spring Data LDAP 的完整详细信息,参阅<a href="https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/">reference documentation</a>.<br>可以像使用任何其他 Spring Bean 一样注入自动配置的 <code>LdapTemplate</code> 实例,如下例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> LdapTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(LdapTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.template = template;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="嵌入式内存-LDAP-服务器-Embedded-In-memory-LDAP-Server"><a href="#嵌入式内存-LDAP-服务器-Embedded-In-memory-LDAP-Server" class="headerlink" title="嵌入式内存 LDAP 服务器(Embedded In-memory LDAP Server)"></a>嵌入式内存 LDAP 服务器(Embedded In-memory LDAP Server)</h6>出于测试目的,Spring Boot 支持从 UnboundID 自动配置内存中的 LDAP 服务器.配置服务器,添加依赖 <code>com.unboundid:unboundid-ldapsdk</code>, 并声明一个 <code>spring.ldap.embedded.base-dn</code> 属性,如下:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.ldap.embedded.base-dn</span>=<span class="string">dc=spring,dc=io</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    可以定义多个 base-dn 值,但是,由于专有名称通常包含逗号,因此必须使用正确的表示法定义它们.</p>
<p>在yaml文件中,您可以使用yaml列表表示法. 在属性文件中,必须包含索引作为属性名称的一部分:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.ldap.embedded.base-dn[0]</span>=<span class="string">dc=spring,dc=io</span></span><br><span class="line"><span class="meta">spring.ldap.embedded.base-dn[1]</span>=<span class="string">dc=pivotal,dc=io</span></span><br></pre></td></tr></table></figure>
<p>默认情况下,服务器在随机端口上启动并触发常规 LDAP 支持. 无需指定 <code>spring.ldap.urls</code> 属性.<br>如果classpath上有 <code>schema.ldif</code> 文件,它将用于初始化服务器. 如果要从不同的资源中加载初始化脚本,也可以使用 <code>spring.ldap.embedded.ldif</code> 属性.<br>默认情况下,标准schema被用来验证 <code>LDIF</code> 文件. 可以通过设置 <code>spring.ldap.embedded.validation.enabled</code> 属性来完全关闭验证.如果有自定义属性,可以使用 <code>spring.ldap.embedded.validation.schema</code> 来定义自定义属性类型或对象类.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h6><p>InfluxDB 是一个开源时间序列数据库,针对操作监控,应用程序指标,物联网传感器数据和实时分析等领域的时间序列数据的快速,高可用性存储和检索进行了优化.</p>
<ol>
<li><h6 id="连接到-InfluxDB-Connecting-to-InfluxDB"><a href="#连接到-InfluxDB-Connecting-to-InfluxDB" class="headerlink" title="连接到 InfluxDB(Connecting to InfluxDB)"></a>连接到 InfluxDB(Connecting to InfluxDB)</h6>Spring Boot 会自动配置一个 <code>InfluxDB</code> 实例,前提是 <code>influxdb-java</code> 客户端在classpath上并且设置了数据库的 URL,如下例所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.influx.url</span>=<span class="string">https://172.0.0.1:8086</span></span><br></pre></td></tr></table></figure>
如果连接到 InfluxDB 需要用户和密码,可以相应地设置 <code>spring.influx.user</code> 和 <code>spring.influx.password</code> 属性.<br>InfluxDB 依赖 OkHttp. 如果需要调整 <code>InfluxDB</code> 背后使用的 http 客户端,可以注册一个 <code>InfluxDbOkHttpClientBuilderProvider</code> bean.<br>如果需要对配置进行更多控制,请考虑注册一个 <code>InfluxDbCustomizer</code> bean.</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>3.14 Feature: 消息中间件</title>
    <url>/posts/10287.html</url>
    <content><![CDATA[<h6 id="3-14-Messaging-消息中间件"><a href="#3-14-Messaging-消息中间件" class="headerlink" title="3.14 Messaging(消息中间件)"></a>3.14 Messaging(消息中间件)</h6><ol start="14">
<li><h6 id="Messaging-消息中间件"><a href="#Messaging-消息中间件" class="headerlink" title="Messaging(消息中间件)"></a>Messaging(消息中间件)</h6><p>Spring Framework 对集成消息中间件系统提供了大量支持,从使用<code>JmsTemplate</code>的 JMS API 的简单使用到异步接收消息的完整基础架构.Spring AMQP 为高级消息队列协议提供了类似的功能集.Spring Boot 还为 <code>RabbitTemplate</code> 和 RabbitMQ 提供了自动配置选项.Spring WebSocket 本身就包含对 STOMP 消息传递的支持,而 Spring Boot 通过starter和少量自动配置来实现支持.Spring Boot 还支持 Apache Kafka.</p>
<ol>
<li><h6 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h6><p><code>javax.jms.ConnectionFactory</code>接口提供了创建 <code>javax.jms.Connection</code> ,以用于 JMS broker交互的标准方法. 虽然Spring需要一个 <code>ConnectionFactory</code> 来与 JMS 一起工作,但通常不需要自己直接使用,而是可以依靠更高级别的消息传递抽象.(有关详细信息<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/integration.html#jms">relevant section</a>,请参阅 Spring Framework 参考文档的相关部分).Spring Boot 还自动配置必要的infrastructure 来发送和接收消息.</p>
<ol>
<li><h6 id="ActiveMQ-Support"><a href="#ActiveMQ-Support" class="headerlink" title="ActiveMQ Support"></a>ActiveMQ Support</h6><p>当classpath上有 ActiveMQ 时,Spring Boot 也可以配置 <code>ConnectionFactory</code>.如果代理存在,则会自动启动和配置嵌入式代理(前提是没有通过配置指定代理 URL).</p>
<blockquote>
<p>注意:</p>
<p>​    如果使用<code>spring-boot-starter-activemq</code>,则提供了连接或嵌入 ActiveMQ 实例所需的依赖项,以及和JMS集成的 Spring infrastructure.</p>
</blockquote>
<p>可以使用<code>spring.activemq.*</code>中的外部配置属性来配置 ActiveMQ.例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.activemq.broker-url</span>=<span class="string">tcp://192.168.1.210:9876</span></span><br><span class="line"><span class="meta">spring.activemq.user</span>=<span class="string">admin </span></span><br><span class="line"><span class="meta">spring.activemq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>

<p>默认情况下, <code>CachingConnectionFactory</code>使用合理的设置包装本地 <code>ConnectionFactory</code>,可以通过 <code>spring.jms.*</code> 中的外部配置属性来配置这些设置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jms.cache.session-cache-size</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure>

<p>如果更想要使用本地池,可以添加依赖<code>org.messaginghub:pooled-jms</code> ,并相应地配置 <code>JmsPoolConnectionFactory</code> 来实现,如下例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.activemq.pool.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.activemq.pool.max-connections</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    有关更多支持的选项,参阅(<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java"><code>ActiveMQProperties</code></a>).可以注册任意数量的实现 <code>ActiveMQConnectionFactoryCustomizer</code> 的 bean 以进行更高级的自定义.</p>
</blockquote>
<p>默认情况下,如果目标尚不存在,ActiveMQ 会创建一个目标,以便根据名称解析目标.</p>
</li>
<li><h6 id="ActiveMQ-Artemis-Support-支持ActiveMQ-Artemis"><a href="#ActiveMQ-Artemis-Support-支持ActiveMQ-Artemis" class="headerlink" title="ActiveMQ Artemis Support (支持ActiveMQ Artemis)"></a>ActiveMQ Artemis Support (支持ActiveMQ Artemis)</h6><p>Spring Boot检测到ActiveMQ Artemis在classpath上可用时,自动配置 <code>ConnectionFactory</code>. 如果broker存在,则会自动启动和配置嵌入式broker(除非已显式设置模式属性).支持的模式是<code>embedded</code>(明确表明需要一个嵌入式代理,如果代理在类路径上不可用,则会发生错误)和<code>native</code>(使用 netty 传输协议连接到代理).配置后者时,Spring Boot 会配置一个 <code>ConnectionFactory</code>,它使用默认设置连接到在本地机器上运行的broker.</p>
<blockquote>
<p>注意:</p>
<p>​    如果使用 <code>spring-boot-starter-artemis</code>,则提供连接到ActiveMQ Artemis 实例所需的依赖,以及与 JMS 集成的 Spring infrastructure.将 <code>org.apache.activemq:artemis-jms-server</code> 添加到的应用中,可以使用嵌入模式.</p>
</blockquote>
<p>ActiveMQ Artemis 配置由 <code>spring.artemis.*</code> 中的外部配置属性控制. 例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.artemis.mode</span>=<span class="string">native</span></span><br><span class="line"><span class="meta">spring.artemis.broker-url</span>=<span class="string">tcp://192.168.1.210:9876</span></span><br><span class="line"><span class="meta">spring.artemis.user</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.artemis.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>

<p>嵌入broker时,可以选择是否要启用持久化并列出应该可用的destination.这些可以使用逗号分割的列表来指定,从而使用默认选项创建它们,或者可以定义 <code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code> 或 <code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>类型的bean,分别用于queue和configurations高级配置.</p>
<p>默认情况下, <code>CachingConnectionFactory</code> 使用合理的设置包装本地的<code>ConnectionFactory</code>,您可以通过 <code>spring.jms.*</code> 中的外部配置属性控制这些设置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jms.cache.session-cache-size</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure>

<p>如果更愿意使用本地的池,可以通过向 <code>org.messaginghub:pooled-jms</code> 添加依赖,并配置 <code>JmsPoolConnectionFactory</code> 来实现,如下例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.artemis.pool.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.artemis.pool.max-connections</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure>

<p>有关更多支持的选项,请参阅<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java"><code>ArtemisProperties</code></a>.</p>
<p>不涉及 JNDI 查找,并且根据其名称解析destination, 使用 Artemis 配置中的 <code>name</code> 属性或通过配置提供的名称.</p>
</li>
<li><h6 id="使用-JNDI-连接工厂-Using-a-JNDI-ConnectionFactory"><a href="#使用-JNDI-连接工厂-Using-a-JNDI-ConnectionFactory" class="headerlink" title="使用 JNDI 连接工厂(Using a JNDI ConnectionFactory)"></a>使用 JNDI 连接工厂(Using a JNDI ConnectionFactory)</h6><p>如果在应用程序服务器中运行应用,Spring Boot 会尝试使用 JNDI 来定位 JMS <code>ConnectionFactory</code>.默认情况下,会检查 <code>java:/JmsXA</code> 和 <code>java:/XAConnectionFactory</code> 位置. 如果需要指定路径,可以使用 <code>spring.jms.jndi-name</code> 属性,如下例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jms.jndi-name</span>=<span class="string">java:/MyConnectionFactory</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="发送消息-Sending-a-Message"><a href="#发送消息-Sending-a-Message" class="headerlink" title="发送消息(Sending a Message)"></a>发送消息(Sending a Message)</h6><p>Spring 的 <code>JmsTemplate</code> 是自动配置的,可以将其直接autowire到自己的 bean 中,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JmsTemplate jmsTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jmsTemplate = jmsTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    <code>JmsMessagingTemplate</code> 可以以类似的方式注入. 如果定义了 <code>DestinationResolver</code> 或 <code>MessageConverter</code> bean,它会自动关联到自动配置的 <code>JmsTemplate</code>.</p>
</blockquote>
</li>
<li><h6 id="接收消息-Receiving-a-Message"><a href="#接收消息-Receiving-a-Message" class="headerlink" title="接收消息(Receiving a Message)"></a>接收消息(Receiving a Message)</h6></li>
</ol>
</li>
</ol>
<p>         当 JMS infrastructure存在时,任何 bean 都可以使用 <code>@JmsListener</code> 进行标注以创建监听器端点.如果没有定义 <code>JmsListenerContainerFactory</code>,则会自动配置默认值. 如果定义了 <code>DestinationResolver</code>,<code>MessageConverter</code> 或 <code>javax.jms.ExceptionListener</code> bean,它们将自动与默认工厂关联.</p>
<pre><code>  默认情况下,默认工厂是事务性的. 如果infrastructure 中存在 `JtaTransactionManager` ,则默认情况下它会被关联到监听器容器.如果没有,则启用 `sessionTransacted` 标志. 在后一种情况下,可以通过在监听器方法(或其委托)上添加 `@Transactional` 将本地数据存储事务关联到对传入消息的处理上来.这可确保在本地事务完成后,acknowledge传入消息.这还包括发送响应消息,消息是已在同一 JMS 会话上执行的.

  以下组件在 `someQueue` 目标上创建一个监听器端点:

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;someQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  &gt;建议:
  &gt;
  &gt;​    有关更多详细信息,请参阅 `@EnableJms的Javadoc`([the Javadoc of `@EnableJms`](https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/jms/annotation/EnableJms.html).)

  如果需要创建更多 `JmsListenerContainerFactory` 实例或者如果想覆盖默认值,Spring Boot 提供了一个 `DefaultJmsListenerContainerFactoryConfigurer`,可以使用它来初始化 `DefaultJmsListenerContainerFactory` ,其设置与自动配置的设置相同.

  例如,以下示例暴露了另一个使用特定 `MessageConverter` 的工厂:

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJmsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">myFactory</span><span class="params">(DefaultJmsListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        ConnectionFactory connectionFactory = getCustomConnectionFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        factory.setMessageConverter(<span class="keyword">new</span> MyMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ConnectionFactory <span class="title">getCustomConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  然后可以在任何 `@JmsListener` 注释的方法中使用工厂,如下所示:

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;someQueue&quot;, containerFactory = &quot;myFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="2">
<li><h6 id="AMQP-高级消息队列协议"><a href="#AMQP-高级消息队列协议" class="headerlink" title="AMQP(高级消息队列协议)"></a>AMQP(高级消息队列协议)</h6><p>高级消息队列协议 (AMQP) 是面向消息中间件的平台中立的线级协议.Spring AMQP 项目将核心 Spring 概念应用于基于 AMQP 的消息传递方案的开发.Spring Boot 为通过 RabbitMQ 使用 AMQP 提供了多种便利的方式,包括 <code>spring-boot-starter-amqp</code> “Starter”.</p>
<ol>
<li><h6 id="RabbitMQ-支持-RabbitMQ-support"><a href="#RabbitMQ-支持-RabbitMQ-support" class="headerlink" title="RabbitMQ 支持 (RabbitMQ support)"></a>RabbitMQ 支持 (RabbitMQ support)</h6><p>RabbitMQ 是一个基于 AMQP 协议的轻量级,可靠,可扩展和可移植的消息代理. Spring 使用 <code>RabbitMQ</code> 通过 AMQP 协议进行通信.</p>
<p>RabbitMQ 配置由 <code>spring.rabbitmq.*</code> 中的外部配置属性控制.例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>

<p>或者,可以使用 <code>address</code> 属性配置相同的连接:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.addresses</span>=<span class="string">amqp://admin:secret@localhost</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    以这种方式指定地址时,主机和端口属性将被忽略. 如果地址使用 <code>amqps</code> 协议,则自动启用 SSL 支持.</p>
</blockquote>
<p>有关更多受支持的基于属性的配置选项,参阅 RabbitProperties(<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java"><code>RabbitProperties</code></a>).要配置 Spring AMQP 使用的 RabbitMQ <code>ConnectionFactory</code> 的低级详细信息,定义 <code>ConnectionFactoryCustomizer</code> bean.</p>
<p>如果context中存在 <code>ConnectionNameStrategy</code> bean,它将自动用于命名由自动配置的 <code>CachingConnectionFactory</code> 创建的连接.</p>
<blockquote>
<p>建议:</p>
<p>​    有关更多详细信息,请参阅了解 RabbitMQ 使用的协议 AMQP( <a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">Understanding AMQP, the protocol used by RabbitMQ</a>).</p>
</blockquote>
</li>
<li><h6 id="发送消息-Sending-a-Message-1"><a href="#发送消息-Sending-a-Message-1" class="headerlink" title="发送消息(Sending a Message)"></a>发送消息(Sending a Message)</h6><p>Spring 的 <code>AmqpTemplate</code> 和 <code>AmqpAdmin</code> 是自动配置的,可以将它们直接自动装配到自己的 bean 中,如下例所示 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpAdmin amqpAdmin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amqpAdmin = amqpAdmin;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate = amqpTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    <code>RabbitMessagingTemplate</code> 可以以类似的方式注入. 如果定义了 <code>MessageConverter</code> bean,它会自动关联到自动配置的 <code>AmqpTemplate</code>.</p>
</blockquote>
<p>如有必要,任何定义为 bean 的 <code>org.springframework.amqp.core.Queue</code> 都会自动用于在 RabbitMQ 实例上声明相应的队列.</p>
<p>要重试操作,可以在 <code>AmqpTemplate</code> 上启用重试(例如,在broker连接丢失的情况下):</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.template.retry.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.initial-interval</span>=<span class="string">2s</span></span><br></pre></td></tr></table></figure>

<p>默认情况下禁用重试. 还可以通过声明 <code>RabbitRetryTemplateCustomizer</code> bean 以编程方式自定义 <code>RetryTemplate</code>.</p>
<p>如果需要创建更多 <code>RabbitTemplate</code> 实例或者如果想覆盖默认值,Spring Boot 提供了一个 <code>RabbitTemplateConfigurer</code> bean,可以使用它来初始化 <code>RabbitTemplate</code>,其设置与自动配置使用的工厂相同.</p>
</li>
<li><h6 id="接受消息-Receiving-a-Message"><a href="#接受消息-Receiving-a-Message" class="headerlink" title="接受消息(Receiving a Message)"></a>接受消息(Receiving a Message)</h6><p>当存在 Rabbit infrastructure时,任何 bean 都可以被 <code>@RabbitListener </code>标注以创建监听器端点.如果未定义 <code>RabbitListenerContainerFactory</code>,则会自动配置默认的 <code>SimpleRabbitListenerContainerFactory</code>,可以使用 <code>spring.rabbitmq.listener.type</code> 属性切换到直接容器.如果定义了 <code>MessageConverter</code> 或 <code>MessageRecoverer</code> bean,它会自动与默认工厂相关联.</p>
<p>以下示例组件在 <code>someQueue</code> 队列上创建一个监听器端点:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;someQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    有关更多详细信息,请参阅 <code>@EnableRabbit</code>的<code>Javadoc</code>(<a href="https://docs.spring.io/spring-amqp/docs/2.3.7/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html">the Javadoc of <code>@EnableRabbit</code></a>).</p>
</blockquote>
<p>如果需要创建更多 <code>RabbitListenerContainerFactory</code> 实例或者如果想覆盖默认值,Spring Boot 提供了 <code>SimpleRabbitListenerContainerFactoryConfigurer</code> 和 <code>DirectRabbitListenerContainerFactoryConfigurer</code> 可用于初始化 <code>SimpleRabbitListenerContainerFactory</code> 和 <code>DirectRabbitListenerContainerFactory</code> ,其设置与自动配置使用的工厂相同.</p>
<blockquote>
<p>建议:</p>
<p>​    选择哪种容器类型并不重要. 这两个 bean 由自动配置公开.</p>
</blockquote>
<p>例如,以下配置类公开了另一个使用特定 <code>MessageConverter</code> 的工厂:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">myFactory</span><span class="params">(SimpleRabbitListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        ConnectionFactory connectionFactory = getCustomConnectionFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        factory.setMessageConverter(<span class="keyword">new</span> MyMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ConnectionFactory <span class="title">getCustomConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以在任何<code>@RabbitListener</code>标注方法中使用工厂了,如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;ublic <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;someQueue&quot;, containerFactory = &quot;myFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以启用重试来处理监听器抛出异常的情况. 默认使用 <code>RejectAndDontRequeueRecoverer</code>,但可以定义自己的 <code>MessageRecoverer</code>.当重试次数用尽时,如果代理配置为此,消息将被拒绝并被丢弃或路由到死信交换.默认情况下,重试被禁用. 可以通过声明 <code>RabbitRetryTemplateCustomizer</code> bean 以编程方式自定义 <code>RetryTemplate</code>.</p>
<blockquote>
<p>重要:</p>
<p>​    默认情况下,如果禁用重试并且listener抛出异常,则将无限重试发送.可以通过两种方式修改此行为:将 <code>defaultRequeueRejected</code> 属性设置为 <code>false</code> 以便尝试零重新发送或抛出 <code>AmqpRejectAndDontRequeueException</code> 以表示应拒绝消息.后者是启用重试并达到最大传递尝试次数时使用的机制.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="Apache-Kafka-支持-Apache-Kafka-Support"><a href="#Apache-Kafka-支持-Apache-Kafka-Support" class="headerlink" title="Apache Kafka 支持(Apache Kafka Support)"></a>Apache Kafka 支持(Apache Kafka Support)</h6><p>通过提供 spring-kafka 项目的自动配置来支持 Apache Kafka.</p>
<p>Kafka 配置由 <code>spring.kafka.*</code> 中的外部配置属性控制. 例如,可以在 <code>application.properties</code> 中声明以下部分:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>=<span class="string">localhost:9092</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.group-id</span>=<span class="string">myGroup</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    要在启动时创建topic,请添加 <code>NewTopic</code> 类型的 bean. 如果主题已存在,则忽略该 bean.</p>
</blockquote>
<p>有关更多支持的选项,请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java"><code>KafkaProperties</code></a>.</p>
<ol>
<li><h6 id="发送消息-Sending-a-Message-2"><a href="#发送消息-Sending-a-Message-2" class="headerlink" title="发送消息 (Sending a Message)"></a>发送消息 (Sending a Message)</h6><p>Spring 的 <code>KafkaTemplate</code> 是自动配置的,可以直接在自己的 bean 中自动装配,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(KafkaTemplate&lt;String, String&gt; kafkaTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    如果定义了 <code>spring.kafka.producer.transaction-id-prefix</code> 属性,则会自动配置一个 <code>KafkaTransactionManager</code>.此外,如果定义了 <code>RecordMessageConverter</code> bean,它会自动关联到自动配置的 <code>KafkaTemplate</code>.</p>
</blockquote>
</li>
<li><h6 id="接受消息-Receiving-a-Message-1"><a href="#接受消息-Receiving-a-Message-1" class="headerlink" title="接受消息(Receiving a Message)"></a>接受消息(Receiving a Message)</h6><p>当存在 Apache Kafka infrastructure 时,任何 bean 都可以使用 <code>@KafkaListener</code> 进行标注以创建listener endpoint.如果未定义 <code>KafkaListenerContainerFactory</code>,则默认使用 <code>spring.kafka.listener.*</code> 中定义的键进行自动配置.</p>
<p>以下组件在 <code>someTopic</code> 主题上创建一个listener endpoint:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;someTopic&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果定义了 <code>KafkaTransactionManager</code> bean,它会自动关联到容器工厂.同样,如果定义了 <code>RecordFilterStrategy</code>,<code>ErrorHandler</code>,<code>AfterRollbackProcessor</code> 或 <code>ConsumerAwareRebalanceListener</code> bean,它会自动关联到默认工厂.</p>
<p>根据listener类型,将 <code>RecordMessageConverter</code> 或 <code>BatchMessageConverter</code> bean 关联到默认工厂.如果只有<code>RecordMessageConverter</code> bean用于批监听器,则它被包装在 <code>BatchMessageConverter</code> 中.</p>
<blockquote>
<p>建议:</p>
<p>​    自定义 <code>ChainedKafkaTransactionManager</code> 必须标记为 <code>@Primary</code>,因为它通常引用自动配置的 <code>KafkaTransactionManager</code> bean.</p>
</blockquote>
</li>
<li><h6 id="Kafka-Streams"><a href="#Kafka-Streams" class="headerlink" title="Kafka Streams"></a>Kafka Streams</h6><p>Spring for Apache Kafka 提供了一个工厂 bean 来创建一个 <code>StreamsBuilder</code> 对象并管理流的生命周期.只要 <code>kafka-streams</code> 在classpath上并且使用 <code>@EnableKafkaStreams</code> 注解启用了 <code>Kafka Streams</code>,Spring Boot 就会自动配置所需的 <code>KafkaStreamsConfiguration</code> bean.</p>
<p>启用 Kafka Streams 意味着必须设置应用程序 ID 和引导服务器.前者可以使用 <code>spring.kafka.streams.application-id</code> 配置,如果没有设置默认为 <code>spring.application.name</code>. 后者可以全局设置或仅针对流专门覆盖.</p>
<p>使用专用属性可以使用多个附加属性.可以使用 <code>spring.kafka.streams.properties</code> 命名空间设置其他任意 Kafka 属性.另参阅其他 Kafka 属性以获取更多信息.(<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.messaging.kafka.additional-properties">Additional Kafka Properties</a>).</p>
<p>要使用工厂 bean,将 <code>StreamsBuilder</code> 连接到 <code>@Bean</code> 中,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableKafkaStreams</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKafkaStreamsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KStream&lt;Integer, String&gt; <span class="title">kStream</span><span class="params">(StreamsBuilder streamsBuilder)</span> </span>&#123;</span><br><span class="line">        KStream&lt;Integer, String&gt; stream = streamsBuilder.stream(<span class="string">&quot;ks1In&quot;</span>);</span><br><span class="line">        stream.map(<span class="keyword">this</span>::uppercaseValue).to(<span class="string">&quot;ks1Out&quot;</span>, Produced.with(Serdes.Integer(), <span class="keyword">new</span> JsonSerde&lt;&gt;()));</span><br><span class="line">        <span class="keyword">return</span> stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> KeyValue&lt;Integer, String&gt; <span class="title">uppercaseValue</span><span class="params">(Integer key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyValue&lt;&gt;(key, value.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下,由 <code>StreamBuilder</code> 对象管理的流会自动启动.可以使用 <code>spring.kafka.streams.auto-startup</code> 属性自定义此行为.</p>
</li>
<li><h6 id="其他-Kafka-属性-Additional-Kafka-Properties"><a href="#其他-Kafka-属性-Additional-Kafka-Properties" class="headerlink" title="其他 Kafka 属性 (Additional Kafka Properties)"></a>其他 Kafka 属性 (Additional Kafka Properties)</h6><p>自动配置支持的属性显示在<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/application-properties.html#application-properties">application-properties.html</a> 中. 注意,在大多数情况下,这些属性(连字符或驼峰命名)直接映射到 Apache Kafka 虚线属性.有关详细信息,请参阅 Apache Kafka 文档.</p>
<p>这些属性中的前几个适用于所有组件(生产者,消费者,管理员和流),但如果希望使用不同的值,可以在组件级别指定.Apache Kafka 指定使用高,中或低重要性来指定属性.Spring Boot 自动配置支持所有 HIGH 重要性属性,一些特定的 MEDIUM 和 LOW 属性,以及任何没有默认值的属性.</p>
<p>只有 Kafka 支持属性的一个子集可以直接通过 <code>KafkaProperties</code> 类获得.如果希望使用那些没有直接支持的其他属性,来配置生产者或消费者,使用以下属性:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.kafka.properties[prop.one]</span>=<span class="string">first</span></span><br><span class="line"><span class="meta">spring.kafka.admin.properties[prop.two]</span>=<span class="string">second</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties[prop.three]</span>=<span class="string">third</span></span><br><span class="line"><span class="meta">spring.kafka.producer.properties[prop.four]</span>=<span class="string">fourth</span></span><br><span class="line"><span class="meta">spring.kafka.streams.properties[prop.five]</span>=<span class="string">fifth</span></span><br></pre></td></tr></table></figure>

<p>这将共通的 <code>prop.one</code> Kafka 属性设置为 <code>first</code>(适用于生产者,消费者和管理员),<code>prop.two admin</code> 属性设置为<code>second</code>,<code>prop.three</code>消费者属性设置为<code>third</code>,<code>prop.four</code> 生产者属性设置为<code>prop.four</code>和 <code>prop .five</code> 流属性为<code>fifth</code>.</p>
<p>还可以按如下方式配置 Spring Kafka <code>JsonDeserializer</code>:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.kafka.consumer.value-deserializer</span>=<span class="string">org.springframework.kafka.support.serializer.JsonDeserializer</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties[spring.json.value.default.type]</span>=<span class="string">com.example.Invoice</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties[spring.json.trusted.packages]</span>=<span class="string">com.example.main,com.example.another</span></span><br></pre></td></tr></table></figure>

<p>同样,可以禁用在header中发送类型信息的 <code>JsonSerializer</code> 默认行为:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.kafka.producer.value-serializer</span>=<span class="string">org.springframework.kafka.support.serializer.JsonSerializer</span></span><br><span class="line"><span class="meta">spring.kafka.producer.properties[spring.json.add.type.headers]</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重要:</p>
<p>​    以这种方式设置的属性会覆盖 Spring Boot 显示支持的任何配置.</p>
</blockquote>
</li>
<li><h6 id="使用嵌入式-Kafka-进行测试-Testing-with-Embedded-Kafka"><a href="#使用嵌入式-Kafka-进行测试-Testing-with-Embedded-Kafka" class="headerlink" title="使用嵌入式 Kafka 进行测试 (Testing with Embedded Kafka)"></a>使用嵌入式 Kafka 进行测试 (Testing with Embedded Kafka)</h6><p>Spring 为 Apache Kafka 提供了一种使用嵌入式 Apache Kafka broker测试项目的便捷方法.要使用此功能,请使用 <code>spring-kafka-test</code> 模块中的 <code>@EmbeddedKafka</code> 注解来测试类.有关更多信息,请参阅 Spring for Apache Kafka 参考手册(<a href="https://docs.spring.io/spring-kafka/docs/2.7.1/reference/html/#embedded-kafka-annotation">reference manual</a>).</p>
<p>要使 Spring Boot 自动配置与上述嵌入式 Apache Kafka broker一起工作,需要将嵌入式broker地址(由 <code>EmbeddedKafkaBroker</code> 填充)的系统属性重新映射到  Spring Boot为 Apache Kafka 设置的配置属性中.有几种方法可以做到这一点:</p>
<ul>
<li><p>提供一个系统属性将嵌入的broker地址映射到测试类中的 <code>spring.kafka.bootstrap-servers</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, <span class="string">&quot;spring.kafka.bootstrap-servers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>@EmbeddedKafka</code> 注解上配置属性名:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@EmbeddedKafka(topics = &quot;someTopic&quot;, bootstrapServersProperty = &quot;spring.kafka.bootstrap-servers&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在配置属性中使用占位符:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>=<span class="string">$&#123;spring.embedded.kafka.brokers&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.29 Feature: 创建自己的自动配置 </title>
    <url>/posts/53310.html</url>
    <content><![CDATA[<h5 id="3-29-创建自己的自动配置-Creating-Your-Own-Auto-configuration"><a href="#3-29-创建自己的自动配置-Creating-Your-Own-Auto-configuration" class="headerlink" title="3.29 创建自己的自动配置(Creating Your Own Auto-configuration)"></a>3.29 创建自己的自动配置(Creating Your Own Auto-configuration)</h5><ol start="29">
<li><h5 id="创建自己的自动配置-Creating-Your-Own-Auto-configuration"><a href="#创建自己的自动配置-Creating-Your-Own-Auto-configuration" class="headerlink" title="创建自己的自动配置(Creating Your Own Auto-configuration)"></a>创建自己的自动配置(Creating Your Own Auto-configuration)</h5><p>如果在开发共享库的公司工作,或者正在开发开源或商业库,可能希望开发自己的自动配置.自动配置类可以捆绑在外部 jar 中,并且仍然可以由 Spring Boot 获取.</p>
<p>自动配置可以与”starter”相关联, 启动器提供自动配置代码以及典型的库.</p>
<ol>
<li><h6 id="了解自动配置的-Bean-Understanding-Auto-configured-Beans"><a href="#了解自动配置的-Bean-Understanding-Auto-configured-Beans" class="headerlink" title="了解自动配置的 Bean (Understanding Auto-configured Beans)"></a>了解自动配置的 Bean (Understanding Auto-configured Beans)</h6><p>自动配置是使用标准 <code>@Configuration</code> 类实现的.<code>@Conditional</code> 注解用于限制何时应应用自动配置.通常,自动配置类使用 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingBean</code> 注解.这确保自动配置仅在找到相关类并且尚未声明自己的 <code>@Configuration</code> 时才应用.</p>
<p>可以浏览 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure"><code>spring-boot-autoconfigure</code></a> 的源代码以查看 Spring 提供的 <code>@Configuration</code> 类(请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories"><code>META-INF/spring.factories</code></a> 文件).</p>
</li>
<li><h6 id="定位自动配置Candidates-Locating-Auto-configuration-Candidates"><a href="#定位自动配置Candidates-Locating-Auto-configuration-Candidates" class="headerlink" title="定位自动配置Candidates (Locating Auto-configuration Candidates)"></a>定位自动配置Candidates (Locating Auto-configuration Candidates)</h6><p>Spring Boot 检查发布的 jar 中是否存在 <code>META-INF/spring.factories</code> 文件.该文件应在 <code>EnableAutoConfiguration</code> key下列出配置类,如以下示例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    必须<strong>仅</strong>以这种方式加载自动配置. 确保它们是在特定的package空间中定义的,并且它们永远不会成为组件扫描的目标.此外,自动配置类不应启用组件扫描以查找其他组件. 应该使用特定的<code>@Imports</code>.</p>
</blockquote>
<p>如果配置需要按特定顺序应用,可以使用 <code>@AutoConfigureAfter</code> 或 <code>@AutoConfigureBefore</code> 注解.例如,如果提供特定于 Web 的配置,则类可能需要在 <code>WebMvcAutoConfiguration</code> 之后应用.</p>
<p>如果想指定某些互不直接了解的自动配置的顺序,还可以使用 <code>@AutoConfigureOrder</code>.该注解与常规的 <code>@Order</code> 注解具有相同的语义,但为自动配置类提供指定顺序.</p>
<p>与标准<code>@Configuration</code> 类一样,应用自动配置类的顺序仅影响定义它们的 bean 的顺序.随后这些 bean 的创建顺序不受影响,并由每个 bean 的依赖项和任何 <code>@DependsOn</code> 关系决定.</p>
</li>
<li><h6 id="条件注解-Condition-Annotations"><a href="#条件注解-Condition-Annotations" class="headerlink" title="条件注解(Condition Annotations)"></a>条件注解(Condition Annotations)</h6><p>几乎总是希望在自动配置类中包含一个或多个 <code>@Conditional</code> 注解.<code>@ConditionalOnMissingBean</code> 注解是一个常见示例,如果开发人员对默认设置不满意,则可以使用它来覆盖自动配置.</p>
<p>Spring Boot 包含许多 <code>@Conditional</code> 注解,可以通过 <code>@Configuration</code> 注解或单个 <code>@Bean</code> 方法在自己的代码中重用这些注解. 这些注解包括:</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.class-conditions">Class Conditions</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.bean-conditions">Bean Conditions</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.property-conditions">Property Conditions</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.resource-conditions">Resource Conditions</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.web-application-conditions">Web Application Conditions</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-auto-configuration.condition-annotations.spel-conditions">SpEL Expression Conditions</a></li>
</ul>
<ol>
<li><h6 id="Class条件-Class-Conditions"><a href="#Class条件-Class-Conditions" class="headerlink" title="Class条件(Class Conditions)"></a>Class条件(Class Conditions)</h6><p><code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingClass</code> 注解让 <code>@Configuration</code> 类根据指定类的存在或不存在来确定是否被包含.由于注解元数据是使用 ASM 解析的,因此可以使用 <code>value</code> 属性来引用真实的类,即使该类实际上可能不会出现在正在运行的应用程序类路径中.如果更喜欢使用 <code>String</code> 值指定类名,也可以使用 <code>name</code> 属性.</p>
<p>此机制不适用于 <code>@Bean</code> 方法,其中通常返回类型是条件的target:在方法的condition应用前,JVM 将加载类和可能会处理方法引用,如果类不存在,这些引用将失败.</p>
<p>为了处理这种情况,可以使用单独的 <code>@Configuration</code> 类来隔离条件,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// Some conditions ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Auto-configured beans ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(SomeService.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServiceConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SomeService <span class="title">someService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SomeService();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果使用 <code>@ConditionalOnClass</code> 或 <code>@ConditionalOnMissingClass</code> 作为元注释的一部分来组成自己的组合注解,则必须使用<code>name</code>作为引用类的名称,在这种情况下不会被处理.</p>
</blockquote>
</li>
<li><h6 id="Bean-条件-Bean-Conditions"><a href="#Bean-条件-Bean-Conditions" class="headerlink" title="Bean 条件(Bean Conditions)"></a>Bean 条件(Bean Conditions)</h6><p><code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解允许根据特定 bean 的存在或不存在来确定是否要包含 bean.可以使用 <code>value</code> 属性按类型指定 bean 或 使用<code>name</code> 以按 name 指定 beans.<code>search</code> 属性允许让开发者限制<code>ApplicationContext</code> 层次结构, 这在搜索 bean 时应考虑的.</p>
<p>当放在<code>@Bean</code>方法上时,目标类型默为该方法的返回类型,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SomeService <span class="title">someService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SomeService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的示例中,如果 <code>ApplicationContext</code> 中尚未包含 <code>MyService</code> 类型的 bean,则将创建 <code>myService</code> bean.</p>
<blockquote>
<p>建议:</p>
<p>​    需要非常小心指定 bean 定义的顺序,因为这些条件是根据目前已处理的内容进行评估的.出于这个原因,我们建议在自动配置类上仅使用 <code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解(在用户定义的bean添加后,这些注解会能够保证加载).</p>
<p>注意:</p>
<p>​    <code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 不会阻止创建 <code>@Configuration</code> 类.在class level使用这些condition与使用注解标记每个包含的 <code>@Bean</code> 方法之间的唯一区别是,如果条件不匹配,前者会阻止将 <code>@Configuration</code> 类注册为 bean.</p>
<p>建议:</p>
<p>​    在声明 <code>@Bean</code> 方法时,在方法的返回类型中提供尽可能多的类型信息.例如,如果你的 bean 的实体类实现了一个接口,那么 bean 方法的返回类型应该是具体的类而不是接口.在使用 bean 条件时,在 <code>@Bean</code> 方法中提供尽可能多的类型信息,因为它们的evaluation只能依赖于方法签名中可用的类型信息.</p>
</blockquote>
</li>
<li><h6 id="Property-条件-Property-Conditions"><a href="#Property-条件-Property-Conditions" class="headerlink" title="Property 条件(Property Conditions)"></a>Property 条件(Property Conditions)</h6><p><code>@ConditionalOnProperty</code> 注解允许根据 Spring Environment 属性来决定是否包含配置.使用 <code>prefix</code> 和 <code>name</code> 属性来指定那些属性应该被检查.默认情况下,存在且不等于 <code>false</code> 的属性才会被匹配.还可以通过使用 <code>havingValue</code> 和 <code>matchIfMissing</code> 属性创建更高级的检查.</p>
</li>
<li><h6 id="Resource-条件-Resource-Conditions"><a href="#Resource-条件-Resource-Conditions" class="headerlink" title="Resource 条件(Resource Conditions)"></a>Resource 条件(Resource Conditions)</h6><p><code>@ConditionalOnResource</code> 注解允许仅在存在特定资源时才包含配置.可以使用通常的 Spring 风格指定资源,如下例所示:<code>file:/home/user/test.dat</code></p>
</li>
<li><h6 id="Web-Application-条件-Web-Application-Conditions"><a href="#Web-Application-条件-Web-Application-Conditions" class="headerlink" title="Web Application 条件(Web Application Conditions)"></a>Web Application 条件(Web Application Conditions)</h6><p><code>@ConditionalOnWebApplication</code> 和 <code>@ConditionalOnNotWebApplication</code> 注解允许根据应用程序是否为”Web 应用程序”来包含配置.基于 servlet 的 Web 应用程序可以是任何使用<code>WebApplicationContext</code>, 定义<code>session</code>范围或具有 <code>ConfigurableWebEnvironment</code>的应用.响应式 Web 应用是任何使用 <code>ReactiveWebApplicationContext</code> 或具有 <code>ConfigurableReactiveWebEnvironment</code> 的应用.</p>
<p><code>@ConditionalOnWarDeployment</code> 注解允许根据应用程序是否是部署到容器的传统 WAR 应用程序来包含配置.此Condition与使用嵌入式服务器运行的应用不匹配.</p>
</li>
<li><h6 id="SpEL-表达式条件-SpEL-Expression-Conditions"><a href="#SpEL-表达式条件-SpEL-Expression-Conditions" class="headerlink" title="SpEL  表达式条件(SpEL Expression Conditions)"></a>SpEL  表达式条件(SpEL Expression Conditions)</h6><p><code>@ConditionalOnExpression</code> 注解允许根据<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/core.html#expressions">SpEL expression</a>的结果包含配置.</p>
</li>
</ol>
</li>
<li><h6 id="测试自己的自动配置-Testing-your-Auto-configuration"><a href="#测试自己的自动配置-Testing-your-Auto-configuration" class="headerlink" title="测试自己的自动配置(Testing your Auto-configuration)"></a>测试自己的自动配置(Testing your Auto-configuration)</h6><p>自动配置会受到许多因素的影响:用户配置(<code>@Bean</code> 定义和<code>Environment</code>自定义),条件评估(特定库的存在)等.具体来说,每个测试都应该创建一个定义良好的 <code>ApplicationContext</code> 来表示这些自定义的组合. <code>ApplicationContextRunner</code> 提供了一种很好的方法来实现这一点.</p>
<p><code>ApplicationContextRunner</code> 通常被定义为测试类的一个字段,用于获得基本的通用配置.以下示例确保始终调用 <code>MyServiceAutoConfiguration</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApplicationContextRunner contextRunner = <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">   .withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration.class));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果必须定义多个自动配置,则无需对它们的声明进行排序,因为它们的调用顺序与运行应用程序时的顺序完全相同.</p>
</blockquote>
<p>每个测试都可以使用runner来表示特定的用例. 例如,下面的示例调用用户配置 (<code>UserConfiguration</code>) 并检查自动配置是否正确回退. 调用 <code>run</code> 提供了一个可以与 <code>AssertJ</code> 一起使用的回调context.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defaultServiceBacksOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.contextRunner.withUserConfiguration(UserConfiguration.class).run((context) -&gt; &#123;</span><br><span class="line">        assertThat(context).hasSingleBean(MyService.class);</span><br><span class="line">        assertThat(context).getBean(<span class="string">&quot;myCustomService&quot;</span>).isSameAs(context.getBean(MyService.class));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MyService <span class="title">myCustomService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyService(<span class="string">&quot;mine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以轻松定制环境,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceNameCanBeConfigured</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.contextRunner.withPropertyValues(<span class="string">&quot;user.name=test123&quot;</span>).run((context) -&gt; &#123;</span><br><span class="line">        assertThat(context).hasSingleBean(MyService.class);</span><br><span class="line">        assertThat(context.getBean(MyService.class).getName()).isEqualTo(<span class="string">&quot;test123&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runner 也可以用来显示 <code>ConditionEvaluationReport</code>.报告可以在 <code>INFO</code> 或 <code>DEBUG</code> 级别打印.以下示例显示如何使用 <code>ConditionEvaluationReportLoggingListener</code> 在自动配置测试中打印报告.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConditionEvaluationReportingTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">autoConfigTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">            .withInitializer(<span class="keyword">new</span> ConditionEvaluationReportLoggingListener(LogLevel.INFO))</span><br><span class="line">            .run((context) -&gt; &#123;</span><br><span class="line">                    <span class="comment">// Test something...</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><h6 id="模拟-Web-Context-Simulating-a-Web-Context"><a href="#模拟-Web-Context-Simulating-a-Web-Context" class="headerlink" title="模拟 Web Context(Simulating a Web Context)"></a>模拟 Web Context(Simulating a Web Context)</h6><p>如果需要测试仅在 Servlet 或 Reactive Web 应用上下文中运行的自动配置,请分别使用 <code>WebApplicationContextRunner</code> 或 <code>ReactiveWebApplicationContextRunner</code>.</p>
</li>
<li><h6 id="覆盖类路径-Overriding-the-Classpath"><a href="#覆盖类路径-Overriding-the-Classpath" class="headerlink" title="覆盖类路径(Overriding the Classpath)"></a>覆盖类路径(Overriding the Classpath)</h6><p>还可以测试在运行时不存在特定类和/或包时会发生什么.Spring Boot 附带了一个 <code>FilteredClassLoader</code>,可以很容易地被runner调用.在以下示例中,我们断言如果 <code>MyService</code> 不存在,则正确禁用自动配置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceIsIgnoredIfLibraryIsNotPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.contextRunner.withClassLoader(<span class="keyword">new</span> FilteredClassLoader(MyService.class))</span><br><span class="line">            .run((context) -&gt; assertThat(context).doesNotHaveBean(<span class="string">&quot;myService&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h6 id="创建自己的启动器-Creating-Your-Own-Starter"><a href="#创建自己的启动器-Creating-Your-Own-Starter" class="headerlink" title="创建自己的启动器(Creating Your Own Starter)"></a>创建自己的启动器(Creating Your Own Starter)</h6><p>一个典型的 Spring Boot starter 包含自动配置和自定义给定技术的infrastructure的代码,我们称之为”acme”.为了使其易于扩展,可以将专用命名空间中的许多配置key暴露给环境.最后,提供了一个”starter”依赖项,以帮助用户尽可能轻松地入门.</p>
<p>具体来说,自定义启动器可以包含以下内容:</p>
<ul>
<li>包含”acme”自动配置代码的<code>autoconfigure</code>模块.</li>
<li><code>starter</code>模块提供对<code>autoconfigure</code>模块和”acme”和其他有用的依赖.简而言之,添加 “starter” ,应该提供使用该库所需的一切.</li>
</ul>
<p>简而言之,添加 starter 应该提供开始使用该库所需的一切.如果”acme”有多种偏好,选项或可选功能,那么最好将自动配置分开,因为可以清楚地表达某些功能是可选的.此外,还可以创建一个启动器,提供有关这些可选依赖项的意见.同时,其他人也能只依靠<code>autoconfigure</code>模块,根据各自不同的选择,来创建启动器.</p>
<p>如果自动配置比较简单,没有可选功能,可以选择将两个模块合并到一个starter.</p>
<ol>
<li><h6 id="命名空间-Naming"><a href="#命名空间-Naming" class="headerlink" title="命名空间(Naming)"></a>命名空间(Naming)</h6><p>应该确保为自己的 starter 提供一个合适的命名空间. 不要用 <code>spring-boot</code> 用作模块名称的开始,即使你使用不同的 Maven <code>groupId</code>.将来可能会为你自动配置的东西提供官方支持.</p>
<p>根据经验,应该在 starter 之后命名一个组合模块.例如,假设正在为”acme”创建一个启动器,并将自动配置模块命名为 <code>acme-spring-boot</code> 和starter <code>acme-spring-boot-starter</code>.</p>
</li>
<li><h6 id="配置键-Configuration-keys"><a href="#配置键-Configuration-keys" class="headerlink" title="配置键(Configuration keys)"></a>配置键(Configuration keys)</h6><p>如果 starter 提供配置keys,请为它们使用唯一的命名空间.特别是,不要在 Spring Boot 使用的命名空间(例如<code>server</code>,<code>management</code>,<code>spring</code>等)中包含自己的key.如果使用相同的命名空间,官方可能会修改这些命名空间,可能会以破坏自定义的模块.根据经验,用自己的命名空间(例如 <code>acme</code>)作为所有key的前缀.</p>
<p>确保通过为每个属性添加字段 javadoc 来记录配置key,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;acme&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;    <span class="comment">/**     * Whether to check the location of acme resources.     */</span>    <span class="keyword">private</span> <span class="keyword">boolean</span> checkLocation = <span class="keyword">true</span>;    <span class="comment">/**     * Timeout for establishing a connection to the acme server.     */</span>    <span class="keyword">private</span> Duration loginTimeout = Duration.ofSeconds(<span class="number">3</span>);    <span class="comment">// getters/setters ...&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    应该只使用带有 <code>@ConfigurationProperties</code> 字段 Javadoc 的纯文本,因为它们在被添加到 JSON 之前不会被处理.</p>
</blockquote>
<p>以下是官方在内部遵循的一些规则,以确保描述一致:</p>
<ul>
<li>不要以”The”或”A”开头.</li>
<li>对于<code>boolean</code>类型,以”Whether”或”Enable”开始描述.</li>
<li>对于基于集合的类型,以”Comma-separated list”开头的描述</li>
<li>如果不使用毫秒,请使用 <code>java.time.Duration</code> 而不是 <code>long</code> 并描述默认单位,例如 “如果未指定持续时间后缀,则将使用秒”.</li>
<li>不要在描述中提供默认值,除非它必须在运行时确定.</li>
</ul>
<p>确保触发元数据生成,以便 IDE 帮助也可用于自己的keys.可能需要查看生成的元数据 (<code>META-INF/spring-configuration-metadata.json</code>) 以确保您自己的key被正确记录.在兼容的 IDE 中使用自己的启动器也是验证元数据好主意.</p>
</li>
<li><h6 id="“自动配置”模块-The-“autoconfigure”-Module"><a href="#“自动配置”模块-The-“autoconfigure”-Module" class="headerlink" title="“自动配置”模块(The “autoconfigure” Module)"></a>“自动配置”模块(The “autoconfigure” Module)</h6><p><code>autoconfigure</code>模块包含使用库所需的一切.它还可能包含配置key定义(例如<code>@ConfigurationProperties</code>)和任何可用于进一步自定义组件初始化方式的回调接口.</p>
<blockquote>
<p>建议:</p>
<p>​    应该将库的依赖项标记为可选,以便可以更轻松地在项目中包含<code>autoconfigure</code>模块.如果这样做,则该不会被提供库,并且默认情况下,Spring Boot 会退出.</p>
</blockquote>
<p>Spring Boot 使用注解处理器来收集元数据文件 (<code>META-INF/spring-autoconfigure-metadata.properties</code>) 中自动配置的条件.如果该文件存在,则用于过滤不匹配的自动配置,这将缩短启动时间.建议在包含自动配置的模块中添加以下依赖项:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果在应用程序中直接定义了自动配置,请确保配置 <code>spring-boot-maven-plugin</code> 以防止<code>repackage</code>目标将依赖项添加到胖 jar 中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;project&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                            &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>对于 Gradle 4.5 及更早版本,应在 <code>compileOnly</code> 配置中声明依赖项,如以下示例所示:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;    compileOnly <span class="string">&quot;org.springframework.boot:spring-boot-autoconfigure-processor&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Gradle 4.6 及更高版本,应在 <code>annotationProcessor</code> 配置中声明依赖项,如以下示例所示:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;    annotationProcessor <span class="string">&quot;org.springframework.boot:spring-boot-autoconfigure-processor&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="Starter-模块-Starter-Module"><a href="#Starter-模块-Starter-Module" class="headerlink" title="Starter 模块(Starter Module)"></a>Starter 模块(Starter Module)</h6><p>starter 实际上是一个空jar. 它的唯一目的是提供必要的依赖来使用库.可以将其视为对入门所需内容的必不可少的内容.</p>
<p>不要对添加启动器的项目做出假设.如果自己的自动配置的库通常需要其他启动器,也请提及它们.如果可选依赖的数量很多,则提供一组正确的默认依赖可能会很困难,因为应该避免包含对于库的不必要的依赖项.换句话说,不应该包含optional依赖项.</p>
<blockquote>
<p>注意:</p>
<p>​    无论哪种方式,starter 都必须直接或间接引用core Spring Boot starter (<code>spring-boot-starter</code>)(间接引用:即,如果自己的 starter 依赖于另一个 starter,则无需添加它).如果一个项目仅使用自定义启动器创建,则 Spring Boot 的核心功能将因核心启动器的存在而启用.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.4 Feature: 日志</title>
    <url>/posts/5951.html</url>
    <content><![CDATA[<h5 id="日志-Logging"><a href="#日志-Logging" class="headerlink" title="日志(Logging)"></a>日志(Logging)</h5><ol start="4">
<li><h5 id="日志-Logging-1"><a href="#日志-Logging-1" class="headerlink" title="日志(Logging)"></a>日志(Logging)</h5>Spring Boot使用<code>Commons Logging</code>进行所有内部日志记录,也保持底层日志实现开放.提供了Java Util Logging,Log4J2和Logback的默认配置.在每中情形下,日志都配置成优先使用控制台输出,文件输出也是可选的.<br>默认情况下,如果使用<code>Starters</code>,日志会使用<code>Logback </code>.还包括合适的Logback路由,以确保使用Java Util Logging,Commons Logging,Log4J或SLF4J的从属库都能正常工作.<blockquote>
<p>建议:</p>
<p>​    因为Java中有很多日志框架,所以如果对上面列出的日志框架感到疑惑,也不要担心.通常来说,您无需更改日志记录依赖项,Spring Boot默认值也可以正常工作.</p>
<p>建议:</p>
<p>​    当部署应用到servlet容器或者应用服务器上,通过Java Util Logging API执行的日志记录不会路由到应用程序的日志中.这样可以防止容器或其他已部署到容器中的应用程序执行的日志记录出现在应用程序的日志中.</p>
</blockquote>
<ol>
<li><h6 id="日志格式-Log-Format"><a href="#日志格式-Log-Format" class="headerlink" title="日志格式(Log Format)"></a>日志格式(Log Format)</h6><p>Spring Boot中默认的日志格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</span><br><span class="line">2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span><br><span class="line">2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: &#x27;dispatcherServlet&#x27; to [/]</span><br><span class="line">2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: &#x27;hiddenHttpMethodFilter&#x27; to: [/*]</span><br></pre></td></tr></table></figure>
<p>输出的都是下面的条目:</p>
<ul>
<li>日期和时间:毫秒精度,易于排序.</li>
<li>日志级别:<code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code>, 或者 <code>TRACE</code>.</li>
<li>线程ID</li>
<li><code>---</code>区别实际日志消息的开始.</li>
<li>线程名:在方括号中(控制输出时,可能会被截断)</li>
<li>Logger 名:通常是class名(经常简写)</li>
<li>日志消息.<blockquote>
<p>注意:</p>
<p>​    Logback没有<code>FATAL</code>级别,别映射到了<code>ERROR</code>.</p>
</blockquote>
</li>
</ul>
</li>
<li><h6 id="控制台输出-Console-Output"><a href="#控制台输出-Console-Output" class="headerlink" title="控制台输出(Console Output)"></a>控制台输出(Console Output)</h6><p>默认的日志配置是当有日志输出时,就会把消息打到控制台上.默认情况,会<code>ERROR</code>,<code>WARN</code>和<code>INFO</code>级别的日志消息会记录.可以在启动应用是使用<code>--debug</code>标志位来开启”debug”模式.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myapp.jar --debug</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    也可以在<code>application.properties</code>指定<code>debug=true</code>.<br>当开启debug模式时,一些核心日志器（嵌入式容器,Hibernate和Spring Boot）会输出更多信息.开启debug模式并不能输出所有<code>DEBUG</code>级别的日志.<br>同样的,也可以在启动应用的使用<code>--trace</code>(或者在<code>application.properties</code>中,设置<code>trace=true</code>).这样做可以为某些核心logger（包括嵌入式容器,Hibernate数据库生成以及整个Spring产品组合）启用跟踪记录.</p>
</blockquote>
<ol>
<li><h6 id="彩色输出-Color-coded-Output"><a href="#彩色输出-Color-coded-Output" class="headerlink" title="彩色输出(Color-coded Output)"></a>彩色输出(Color-coded Output)</h6>如果终端支持<code>ANSI</code>,色彩输出可以提高可读性.可以将<code>spring.output.ansi.enabled</code>设置为支持的值,从而覆盖默认检测.<br>使用<code>％clr</code>转换字配置颜色编码.最简单的形式,转换器通过日志级别来对输出进行上色,如下所示:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%clr(%5p)</span><br></pre></td></tr></table></figure>
下面的表格描述的是日志级别和对应的颜色:<table>
<thead>
<tr>
<th>日志级别</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td><code>FATAL</code></td>
<td>红色</td>
</tr>
<tr>
<td><code>ERROR</code></td>
<td>红色</td>
</tr>
<tr>
<td><code>WARN</code></td>
<td>黄色</td>
</tr>
<tr>
<td><code>INFO</code></td>
<td>绿色</td>
</tr>
<tr>
<td><code>DEBUG</code></td>
<td>绿色</td>
</tr>
<tr>
<td><code>TRACE</code></td>
<td>绿色</td>
</tr>
<tr>
<td>同样,转换也提供了配置项,可以用来指定颜色或者风格.比如,想要让文本是黄色,可以如下设置:</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;yellow&#125;</span><br></pre></td></tr></table></figure>
支持下面的颜色和风格:<ul>
<li><code>blue</code></li>
<li><code>cyan</code></li>
<li><code>faint</code></li>
<li><code>green</code></li>
<li><code>magenta</code></li>
<li><code>red</code></li>
<li><code>yellow</code></li>
</ul>
</li>
</ol>
</li>
<li><h6 id="文件输出-File-Output"><a href="#文件输出-File-Output" class="headerlink" title="文件输出(File Output)"></a>文件输出(File Output)</h6><p>默认情况下,Spring Boot只会在控制台输出日志,并不会写到配置文件中.如果想要控制台输出之外,将日志写入到日志文件中,需要设置<code>logging.file.name</code>或者<code>logging.file.path</code>属性(比如在<code>application.properties</code>中配置).<br>下面的表格描述了<code>logging.*</code>属性可以怎样搭配使用:</p>
<table>
<thead>
<tr>
<th><strong>logging.file.name</strong></th>
<th><strong>logging.file.path</strong></th>
<th><strong>例子</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>(none)</em></td>
<td><em>(none)</em></td>
<td></td>
<td>只在控制台输出.</td>
</tr>
<tr>
<td>指定文件名</td>
<td>(none)</td>
<td><code>my.log</code></td>
<td>日志写入到指定文件中.文件路径可以是绝对路径,相对路径</td>
</tr>
<tr>
<td><em>(none)</em></td>
<td>指定目录</td>
<td><code>/var/log</code></td>
<td>将<code>spring.log</code>写入到指定目录.可以是绝对路径或者相对路径.</td>
</tr>
<tr>
<td>日志文件达到10 MB时会循环,并且与控制台输出一样,默认情况下会记录<code>ERROR</code>级别,<code>WARN</code>级别和<code>INFO</code>级别的消息.</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>​    日志配置与实际的日志记录基础结构无关.因此,Spring Boot不会管理特定的配置属性（例如Logback的<code>logback.configurationFile</code>）.</p>
</blockquote>
</li>
<li><h6 id="文件旋转-File-Rotation"><a href="#文件旋转-File-Rotation" class="headerlink" title="文件旋转(File Rotation)"></a>文件旋转(File Rotation)</h6><p>如果使用Logback,可以使用<code>application.properties</code>或<code>application.yaml</code>配置微调log rotation.对于其他的日志系统,需要手动直接配置rotation的配置.(比如,如果使用Log4J2,可以添加一个<code>log4j.xml</code>).</p>
<p>下面是支持的rotation策略:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>logging.logback.rollingpolicy.file-name-pattern</code></td>
<td>创建日志存档的文件名</td>
</tr>
<tr>
<td>`logging.logback.rollingpolicy.clean-history-on-start</td>
<td>应在应用程序启动时进行日志归档清理</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.max-file-size</code></td>
<td>归档前日志文件的最大大小.</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.total-size-cap</code></td>
<td>删除日志存档之前可以使用的最大值.</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.max-history</code></td>
<td>保留日志存档的天数（默认为7）</td>
</tr>
</tbody></table>
</li>
<li><h6 id="日志级别-Log-Levels"><a href="#日志级别-Log-Levels" class="headerlink" title="日志级别(Log Levels)"></a>日志级别(Log Levels)</h6><p>对于所有的支持日志系统,都可以在Spring <code>Environment</code>(比如<code>application.properties</code>)中使用<code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code>. 其中<code>level</code>指的是<code>TRACE</code>,<code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code>,<code>FATAL</code> <code>OFF</code>. <code>root</code>logger可以使用<code>logging.level.root</code>进行配置.</p>
<p>下面的例子展示了在<code>application.properties</code>中的配置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.root</span>=<span class="string">warn</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.web</span>=<span class="string">debug</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate</span>=<span class="string">error</span></span><br></pre></td></tr></table></figure>

<p>也可以使用环境变量来配置日志等级.比如,<code>LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG</code>,将会把<code>org.springframework.web</code>设置为<code>DEBUG</code>.</p>
<blockquote>
<p>注意:</p>
<p>​    上面的方法只能适用于包级别的日志.因为relaxed 绑定总是把环境变量转成小写,这样就无法为单个类配置日志.如果想要给一个类配置日志,可以使用<code>SPRING_APPLICATION_JSON</code>变量.</p>
</blockquote>
</li>
<li><h6 id="日志组-Log-Groups"><a href="#日志组-Log-Groups" class="headerlink" title="日志组(Log Groups)"></a>日志组(Log Groups)</h6><p>能够将相关logger组合在一起通常可以很有用,以便可以同时配置所有logger. 例如,您可能通常会更改所有与Tomcat相关的记录器的记录级别,但是您不容易记住顶层软件包.</p>
<p>为了解决这个问题,Spring Boot允许您在Spring <code>Environment</code>中定义日志记录组.例如,以下是通过将“ tomcat”组添加到<code>application.properties</code>来定义它的方法：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.group.tomcat</span>=<span class="string">org.apache.catalina,org.apache.coyote,org.apache.tomcat</span></span><br></pre></td></tr></table></figure>

<p>定义过后,可以如下改变logger的入职级别:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.tomcat</span>=<span class="string">trace</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot包含以下预定义的日志记录组,它们可以直接使用:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>Loggers</th>
</tr>
</thead>
<tbody><tr>
<td>web</td>
<td><code>org.springframework.core.codec</code>,<code>org.springframework.http</code>,<code>org.springframework.web</code>,<code>org.springframework.boot.actuate.endpoint.web</code>,<code>org.springframework.boot.web.servlet.ServletContextInitializerBeans</code></td>
</tr>
<tr>
<td>sql</td>
<td><code>org.springframework.jdbc.core</code>,<code>org.hibernate.SQL</code>,<code>org.jooq.tools.LoggerListener</code></td>
</tr>
</tbody></table>
</li>
<li><h6 id="使用使用日志关闭hook-Using-a-Log-Shutdown-Hook"><a href="#使用使用日志关闭hook-Using-a-Log-Shutdown-Hook" class="headerlink" title="使用使用日志关闭hook (Using a Log Shutdown Hook)"></a>使用使用日志关闭hook (Using a Log Shutdown Hook)</h6><p>为了在应用程序终止时释放logger资源,提供了一个关闭hook,该hook将在JVM退出时触发日志系统清理.只要应用不是以war文件形式部署,shutdown hook会自动注册.如果应用有一个复杂的context曾姐姐后,那么shutdown hook未必能够满足需求. 如果不是,禁用shutdown hook,并调查基础日志系统直接提供的选项.例如,Logback提供了上下文选择器,该选择器允许在其自己的上下文中创建每个Logger.可以使用<code>logging.register-shutdown-hook</code>属性禁用关闭挂钩.将其设置为<code>false</code>将禁用注册. 可以在<code>application.properties</code>或<code>application.yaml</code>文件中设置属性:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.register-shutdown-hook</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="自定义日志配置-Custom-Log-Configuration"><a href="#自定义日志配置-Custom-Log-Configuration" class="headerlink" title="自定义日志配置(Custom Log Configuration)"></a>自定义日志配置(Custom Log Configuration)</h6><p>可以通过在类路径上包含适当的库来激活各种日志记录系统,并可以通过在类路径的根目录或以下Spring <code>Environment</code>属性指定的位置中提供适当的配置文件来进一步自定义日志文件：<code>logging.config</code>.</p>
<p>您可以通过使用<code>org.springframework.boot.logging.LoggingSystem</code>系统属性,来强制Spring Boot使用特定的日志记录系统. 该值应该是<code>LoggingSystem</code>实现的完全限定的类名. 您也可以使用<code>none</code>完全禁用Spring Boot的日志记录配置.</p>
<blockquote>
<p>注意:</p>
<p>​    由于日志记录是在创建<code>ApplicationContext</code>之前初始化的,因此无法从Spring <code>@Configuration</code>文件中的<code>@PropertySources</code>控制日志记录. 更改日志记录系统或完全禁用它的唯一方法是通过系统属性.</p>
</blockquote>
<p>根据您的日志记录系统,将加载以下文件：</p>
<table>
<thead>
<tr>
<th>日志系统</th>
<th>自定义</th>
</tr>
</thead>
<tbody><tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, <code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code>或者<code>log4j2.xml</code></td>
</tr>
<tr>
<td>JDK (Java Util Logging)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody></table>
<blockquote>
<p>注意:</p>
<p>​    如果可能,我们建议您在日志配置中使用-spring变体（例如,logback-spring.xml而不是logback.xml）.如果使用标准配置位置,Spring将无法完全控制日志初始化.</p>
<p>警告:</p>
<p>​    从“可执行jar”运行时，Java Util Logging存在一些已知的类加载问题，这些问题会导致问题。 建议在“可执行jar”运行时,尽可能避免使用它。</p>
</blockquote>
<p>为了帮助进行定制，如下表所述，一些其他属性从Spring <code>Environment</code>转移到System属性：</p>
<table>
<thead>
<tr>
<th><strong>Spring Environment</strong></th>
<th><strong>System Property</strong></th>
<th><strong>注释</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>logging.exception-conversion-word</code></td>
<td><code>LOG_EXCEPTION_CONVERSION_WORD</code></td>
<td>记录异常时使用的转换字。</td>
</tr>
<tr>
<td><code>logging.file.name</code></td>
<td><code>LOG_FILE</code></td>
<td>如果定义，它将在默认日志配置中使用。</td>
</tr>
<tr>
<td><code>logging.file.path</code></td>
<td><code>LOG_PATH</code></td>
<td>如果定义，它将在默认日志配置中使用。</td>
</tr>
<tr>
<td><code>logging.pattern.console</code></td>
<td><code>CONSOLE_LOG_PATTERN</code></td>
<td>控制台上使用的日志模式（stdout）。</td>
</tr>
<tr>
<td><code>logging.pattern.dateformat</code></td>
<td><code>LOG_DATEFORMAT_PATTERN</code></td>
<td>记录日期格式的添加模式。</td>
</tr>
<tr>
<td><code>logging.charset.console</code></td>
<td><code>CONSOLE_LOG_CHARSET</code></td>
<td>用于控制台日志记录的字符集。</td>
</tr>
<tr>
<td><code>logging.pattern.file</code></td>
<td><code>FILE_LOG_PATTERN</code></td>
<td>文件中使用的日志模式（如果启用<code>LOG_FILE</code>）。</td>
</tr>
<tr>
<td><code>logging.charset.file</code></td>
<td><code>FILE_LOG_CHARSET</code></td>
<td>用于文件记录的字符集（如果启用了<code>LOG_FILE</code>）。</td>
</tr>
<tr>
<td><code>logging.pattern.level</code></td>
<td><code>LOG_LEVEL_PATTERN</code></td>
<td>渲染日志级别时使用的格式（默认为<code>％5p</code>）。</td>
</tr>
<tr>
<td><code>PID</code></td>
<td><code>PID</code></td>
<td>当前进程ID（如果发现并且尚未将其定义为OS环境变量时）。</td>
</tr>
</tbody></table>
<p>如果您使用的是Logback，还将转换以下属性：</p>
<table>
<thead>
<tr>
<th><strong>Spring Environment</strong></th>
<th><strong>System Property</strong></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>logging.logback.rollingpolicy.file-name-pattern</code></td>
<td><code>LOGBACK_ROLLINGPOLICY_FILE_NAME_PATTERN</code></td>
<td>滚动日志文件名的模式（默认<code>$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;.%i.gz</code>).</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.clean-history-on-start</code></td>
<td><code>LOGBACK_ROLLINGPOLICY_CLEAN_HISTORY_ON_START</code></td>
<td>是否在启动时清除存档日志文件.</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.max-file-size</code></td>
<td><code>LOGBACK_ROLLINGPOLICY_MAX_FILE_SIZE</code></td>
<td>最大日志文件大小。</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.total-size-cap</code></td>
<td><code>LOGBACK_ROLLINGPOLICY_TOTAL_SIZE_CAP</code></td>
<td>要保留的日志备份的总大小。</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.max-history</code></td>
<td><code>LOGBACK_ROLLINGPOLICY_MAX_HISTORY</code></td>
<td>要存档的日志备份的总大小。</td>
</tr>
</tbody></table>
<p>所有受支持的日志记录系统在解析其配置文件时都可以查阅系统属性。 有关示例，请参见<code>spring-boot.jar</code>中的默认配置：</p>
<ul>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml">Logback</a></li>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml">Log4j 2</a></li>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties">Java Util logging</a></li>
</ul>
<blockquote>
<p>建议:</p>
<p>​    如果要在日志记录属性中使用占位符，则应使用Spring Boot的语法而不是基础框架的语法.值得注意的是，如果使用Logback，则应使用<code>：</code>作为属性名称与其默认值之间的分隔符，而不应使用<code>:-</code>.</p>
<p>建议:</p>
<p>​    您可以通过重写<code>LOG_LEVEL_PATTERN</code>（或者使用<code>Logback</code>的<code>logging.pattern.level</code>）来将MDC和其他临时内容添加到日志行.例如，如果使用<code>logging.pattern.level = user:％X&#123;user&#125;％5p</code>，则默认日志格式包含“user”的MDC条目（如果存在），如以下示例所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;2019-08-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller</span><br><span class="line">&gt;Handling authenticated request</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
</li>
<li><h6 id="Logback扩展-Logback-Extensions"><a href="#Logback扩展-Logback-Extensions" class="headerlink" title="Logback扩展(Logback Extensions)"></a>Logback扩展(Logback Extensions)</h6>Spring Boot包含许多Logback扩展,可以帮助进行高级配置.您可以在<code>logback-spring.xml</code>配置文件中使用这些扩展.<blockquote>
<p>注意:</p>
<p>​    由于标准<code>logback.xml</code>配置文件加载得太早，因此不能在其中使用扩展。 需要使用<code>logback-spring.xml</code>或定义<code>logging.config</code>属性.</p>
<p>警告:</p>
<p>​    这些扩展不能与Logback的配置扫描一起使用.如果尝试这样做，则对配置文件进行更改会导致类似于以下记录之一的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]</span><br><span class="line">&gt;ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><h5 id="带指定profile的的配置"><a href="#带指定profile的的配置" class="headerlink" title="带指定profile的的配置"></a>带指定profile的的配置</h5>通过<code>&lt;springProfile&gt;</code>标签，您可以根据激活的Spring profile,来有选择地引入或排除部分配置.在<code>&lt;configuration&gt;</code>元素内的任何位置都支持配置profile.使用name属性指定那个profile应用这些配置.<code>&lt;springProfile&gt;</code>标签可以包含profile名（例如,<code>staging</code>）或profile表达式.使用profile表达式能够表达更复杂的关于profile的逻辑.比如<code>production &amp; (eu-central | eu-west)</code>.有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/core.html#beans-definition-profiles-java">参考指南</a> 。 以下清单显示了三个样本概要文件:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev | staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;!production&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="环境属性-Environment-Properties"><a href="#环境属性-Environment-Properties" class="headerlink" title="环境属性(Environment Properties)"></a>环境属性(Environment Properties)</h6><code>&lt;springProperty&gt;</code>标签,可以从Spring <code>Environment</code>中属性的属性，暴露给Logback使用.如果想从<code>Logback</code>配置中访问<code>application.properties</code>文件中的值，这样做很有用.该标签的工作方式类似于<code>Logback</code>的标准<code>&lt;property&gt;</code>标签.但是，不是直接指定<code>value</code>，而是指定了属性的<code>source</code>（来自<code>Environment</code>）.如果需要将属性存储在<code>local</code>范围以外的其他位置，则可以使用<code>scope</code>属性.如果需要备用值（如果未在<code>Environment</code>中设置该属性），则可以使用<code>defaultValue</code>属性.以下示例显示如何公开在Logback中使用的属性：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fluentHost&quot;</span> <span class="attr">source</span>=<span class="string">&quot;myapp.fluentd.host&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">defaultValue</span>=<span class="string">&quot;localhost&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FLUENT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remoteHost</span>&gt;</span>$&#123;fluentHost&#125;<span class="tag">&lt;/<span class="name">remoteHost</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>    <code>source</code>必须在短横线形式下指定（例如<code>my.property-name</code>）.但是,可以使用relaxed规则将属性添加到<code>Environment</code>中.<br>ment`中.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>5.2 Deploy:  部署到云</title>
    <url>/posts/37726.html</url>
    <content><![CDATA[<ol start="2">
<li><h5 id="部署到云-Deploying-to-the-Cloud"><a href="#部署到云-Deploying-to-the-Cloud" class="headerlink" title="部署到云(Deploying to the Cloud)"></a>部署到云(Deploying to the Cloud)</h5><p>Spring Boot 的可执行 jar 是为大多数流行的云 PaaS(平台即服务)提供商准备的.这些提供商往往要求”自带容器”.他们管理应用进程(不是专门的 Java 应用程序),因此需要一个中间层,使开发者的应用程序适应云中正在运行的进程的概念.</p>
<p>两个流行的云提供商 Heroku 和 Cloud Foundry 采用”buildpack”方法.buildpack 将部署的代码包装在启动应用所需的所有内容中. 它可能是 JDK 和对 <code>java</code> 的调用,嵌入式 Web 服务器或成熟的应用程序服务器.buildpack 是可插拔的,但理想情况下,应该尽可能少地自定义.这减少了不受控制的功能的占用空间. 它最大限度地减少了开发和生产环境之间的差异.</p>
<p>理想情况下,应用程序,就像一个 Spring Boot 可执行 jar,将运行所需的一切都打包在其中.</p>
<ol>
<li><h6 id="Cloud-Foundry"><a href="#Cloud-Foundry" class="headerlink" title="Cloud Foundry"></a>Cloud Foundry</h6><p>Cloud Foundry 提供了默认构建包,如果没有指定其他构建包,这些构建包就会发挥作用.Cloud Foundry Java buildpack 对包括 Spring Boot 在内的 Spring 应用程序有很好的支持.可以部署独立的可执行 jar 应用程序以及传统的 <code>.war</code> 打包应用程序.</p>
<p>构建应用程序(例如,通过使用 <code>mvn clean package</code>)并安装 cf 命令行工具后,使用 <code>cf push</code> 命令部署应用程序,替换已编译的 <code>.jar</code> 的路径.在推送应用程序之前,请确保已使用 cf 命令行客户端登录. 以下行显示使用 <code>cf push</code> 命令部署应用程序:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cf push acloudyspringtime -p target/demo-0.0.1-SNAPSHOT.jar</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    在前面的示例中,将 <code>acloudyspringtime</code> 替换为给 cf 作为应用程序名称的任何值.</p>
</blockquote>
<p>如果同一目录中存在 Cloud Foundry <code>manifest.yml</code> 文件,则会考虑该文件.此时,<code>cf</code> 开始上传您的应用程序,生成类似于以下示例的输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Uploading acloudyspringtime... OK</span><br><span class="line">Preparing to start acloudyspringtime... OK</span><br><span class="line">-----&gt; Downloaded app package (8.9M)</span><br><span class="line">-----&gt; Java Buildpack Version: v3.12 (offline) | https://github.com/cloudfoundry/java-buildpack.git#6f25b7e</span><br><span class="line">-----&gt; Downloading Open Jdk JRE 1.8.0_121 from https://java-buildpack.cloudfoundry.org/openjdk/trusty/x86_64/openjdk-1.8.0_121.tar.gz (found in cache)</span><br><span class="line">       Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.6s)</span><br><span class="line">-----&gt; Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https://java-buildpack.cloudfoundry.org/memory-calculator/trusty/x86_64/memory-calculator-2.0.2_RELEASE.tar.gz (found in cache)</span><br><span class="line">       Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize=104857K -Xms681574K -XX:MetaspaceSize=104857K</span><br><span class="line">-----&gt; Downloading Container Certificate Trust Store 1.0.0_RELEASE from https://java-buildpack.cloudfoundry.org/container-certificate-trust-store/container-certificate-trust-store-1.0.0_RELEASE.jar (found in cache)</span><br><span class="line">       Adding certificates to .java-buildpack/container_certificate_trust_store/truststore.jks (0.6s)</span><br><span class="line">-----&gt; Downloading Spring Auto Reconfiguration 1.10.0_RELEASE from https://java-buildpack.cloudfoundry.org/auto-reconfiguration/auto-reconfiguration-1.10.0_RELEASE.jar (found in cache)</span><br><span class="line">Checking status of app &#x27;acloudyspringtime&#x27;...</span><br><span class="line">  0 of 1 instances running (1 starting)</span><br><span class="line">  ...</span><br><span class="line">  0 of 1 instances running (1 starting)</span><br><span class="line">  ...</span><br><span class="line">  0 of 1 instances running (1 starting)</span><br><span class="line">  ...</span><br><span class="line">  1 of 1 instances running (1 running)</span><br><span class="line"></span><br><span class="line">App started</span><br></pre></td></tr></table></figure>

<p>恭喜！ 该应用程序现已上线！</p>
<p>应用程序上线后,可以使用 <code>cf apps</code> 命令验证已部署应用程序的状态,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cf apps</span></span><br><span class="line">Getting applications in ...</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">name                 requested state   instances   memory   disk   urls</span><br><span class="line">...</span><br><span class="line">acloudyspringtime    started           1/1         512M     1G     acloudyspringtime.cfapps.io</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>一旦 Cloud Foundry 确认应用程序已部署,应该能够在给定的 URI 中找到该应用程序.在前面的示例中,可以在 <a href="https://acloudyspringtime.cfapps.io/">https://acloudyspringtime.cfapps.io/</a> 找到它.</p>
<ol>
<li><h6 id="绑定到服务-Binding-to-Services"><a href="#绑定到服务-Binding-to-Services" class="headerlink" title="绑定到服务(Binding to Services)"></a>绑定到服务(Binding to Services)</h6><p>默认情况下,有关应用的元数据以及服务连接信息作为环境变量公开给应用程序(例如:<code>$VCAP_SERVICES</code>).这个架构决定是由于 Cloud Foundry 的多语言(任何语言和平台都可以作为 buildpack 支持)的性质而决定的.作用在进程作用域的环境变量与语言无关.</p>
<p>环境变量并不总是最简单的 API,因此 Spring Boot 会自动提取它们并将数据扁平化为可以通过 Spring 的 <code>Environment</code> 抽象访问的属性,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String instanceId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instanceId = environment.getProperty(<span class="string">&quot;vcap.application.instance_id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有 Cloud Foundry 属性都以 <code>vcap</code> 为前缀. 可以使用 <code>vcap</code> 属性访问应用程序信息(例如应用程序的公共 URL)和服务信息(例如数据库凭据).</p>
</li>
<li><h6 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h6><p>Spring Boot 通过检查环境中的”<code>*_SERVICE_HOST</code>“和”<code>*_SERVICE_PORT</code>“变量来自动检测 Kubernetes 部署环境.可以使用 <code>spring.main.cloud-platform</code> 配置属性覆盖此检测.</p>
<ol>
<li><h6 id="Kubernetes-Container-Lifecycle"><a href="#Kubernetes-Container-Lifecycle" class="headerlink" title="Kubernetes Container Lifecycle"></a>Kubernetes Container Lifecycle</h6><p>当 Kubernetes 删除应用实例时,关闭过程同时涉及多个子系统:shutdown hooks,取消注册服务,从负载均衡器中移除实例……由于此关闭处理并行发生(并且由于分布式系统的性质),因此存在一个窗口,在此期间流量可以路由到已开始关闭处理的 pod.</p>
<p>可以在 preStop 处理程序中配置sleep execution ,避免将请求路由到已经开始关闭的 pod.睡眠时间应该足够长,以便新请求停止路由到 pod,其持续时间会因部署而异.preStop 处理程序可以通过 Pod 配置文件中的 PodSpec 进行配置,如下所示:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example-image</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 10&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>一旦 <code>pre-stop</code> 钩子完成,SIGTERM 将被发送到容器并开始正常关闭,并且允许任何剩余的正在进行的请求完成.</p>
</li>
</ol>
</li>
<li><h6 id="Heroku"><a href="#Heroku" class="headerlink" title="Heroku"></a>Heroku</h6><p>Heroku 是另一个流行的 PaaS 平台.要自定义 Heroku 构建,需要提供一个 <code>Procfile</code>,它提供部署应用程序所需的指令.. Heroku 分配一个端口供 Java 应用程序使用,然后确保路由到外部 URI 的工作正常.</p>
<p>必须将应用程序配置为监听正确的端口. 以下示例显示了入门 REST 应用程序的 <code>Procfile</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web: java -Dserver.port=$PORT -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>Spring Boot 使 <code>-D</code> 参数可以像访问 Spring Environment 实例属性一样访问.<code>server.port</code> 配置属性被提供给嵌入式 Tomcat,Jetty 或 Undertow 实例,然后在启动时使用该端口.<code>$PORT</code> 环境变量由 Heroku PaaS 分配.</p>
<p>需要做的应该就这么多. Heroku 部署最常见的部署工作流是 <code>git push</code> 代码到生产环境,如下面的例子所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push heroku main</span></span><br></pre></td></tr></table></figure>

<p>这将输出以下结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initializing repository, done.</span><br><span class="line">Counting objects: 95, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (78/78), done.</span><br><span class="line">Writing objects: 100% (95/95), 8.66 MiB | 606.00 KiB/s, done.</span><br><span class="line">Total 95 (delta 31), reused 0 (delta 0)</span><br><span class="line"></span><br><span class="line">-----&gt; Java app detected</span><br><span class="line">-----&gt; Installing OpenJDK 1.8... done</span><br><span class="line">-----&gt; Installing Maven 3.3.1... done</span><br><span class="line">-----&gt; Installing settings.xml... done</span><br><span class="line">-----&gt; Executing: mvn -B -DskipTests=true clean install</span><br><span class="line"></span><br><span class="line">       [INFO] Scanning for projects...</span><br><span class="line">       Downloading: https://repo.spring.io/...</span><br><span class="line">       Downloaded: https://repo.spring.io/... (818 B at 1.8 KB/sec)</span><br><span class="line">        ....</span><br><span class="line">       Downloaded: https://s3pository.heroku.com/jvm/... (152 KB at 595.3 KB/sec)</span><br><span class="line">       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/target/...</span><br><span class="line">       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/pom.xml ...</span><br><span class="line">       [INFO] ------------------------------------------------------------------------</span><br><span class="line">       [INFO] BUILD SUCCESS</span><br><span class="line">       [INFO] ------------------------------------------------------------------------</span><br><span class="line">       [INFO] Total time: 59.358s</span><br><span class="line">       [INFO] Finished at: Fri Mar 07 07:28:25 UTC 2014</span><br><span class="line">       [INFO] Final Memory: 20M/493M</span><br><span class="line">       [INFO] ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">-----&gt; Discovering process types</span><br><span class="line">       Procfile declares types -&gt; web</span><br><span class="line"></span><br><span class="line">-----&gt; Compressing... done, 70.4MB</span><br><span class="line">-----&gt; Launching... done, v6</span><br><span class="line">       https://agile-sierra-1405.herokuapp.com/ deployed to Heroku</span><br><span class="line"></span><br><span class="line">To git@heroku.com:agile-sierra-1405.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br></pre></td></tr></table></figure>

<p>应用现在应该在 Heroku 上启动并运行.</p>
</li>
<li><h6 id="OpenShift"><a href="#OpenShift" class="headerlink" title="OpenShift"></a>OpenShift</h6><p>OpenShift 有许多资源描述了如何部署 Spring Boot 应用程序,包括:</p>
<ul>
<li><a href="https://blog.openshift.com/using-openshift-enterprise-grade-spring-boot-deployments/">Using the S2I builder</a></li>
<li><a href="https://access.redhat.com/documentation/en-us/reference_architectures/2017/html-single/spring_boot_microservices_on_red_hat_openshift_container_platform_3/">Architecture guide</a></li>
<li><a href="https://blog.openshift.com/using-spring-boot-on-openshift/">Running as a traditional web application on Wildfly</a></li>
<li><a href="https://blog.openshift.com/openshift-commons-briefing-96-cloud-native-applications-spring-rhoar/">OpenShift Commons Briefing</a></li>
</ul>
</li>
<li><h6 id="Amazon-Web-Services-AWS"><a href="#Amazon-Web-Services-AWS" class="headerlink" title="Amazon Web Services (AWS)"></a>Amazon Web Services (AWS)</h6><p>Amazon Web Services 提供了多种安装 Spring Boot 的应用的方法,可以是传统的 Web 应用程序 (war),也可以是带有嵌入式 Web 服务器的可执行 jar 文件.</p>
<p>选项包括:</p>
<ul>
<li>AWS Elastic Beanstalk</li>
<li>AWS Code Deploy</li>
<li>AWS OPS Works</li>
<li>AWS Cloud Formation</li>
<li>AWS Container Registry</li>
</ul>
<p>每个都有不同的功能和定价模型. 在本文档中,我们描述了使用 AWS Elastic Beanstalk 的方法.</p>
<ol>
<li><h6 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h6><p>如官方 <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html">Elastic Beanstalk Java guide</a> 指南中所述,有两个主要选项来部署 Java 应用程序. 可以使用”Tomcat 平台”或”Java SE 平台”.</p>
<h6 id="Using-the-Tomcat-Platform"><a href="#Using-the-Tomcat-Platform" class="headerlink" title="Using the Tomcat Platform"></a>Using the Tomcat Platform</h6><p>此选项适用于生成 war 文件的 Spring Boot 项目. 无需特殊配置. 只需要遵循官方指南.</p>
<h6 id="Using-the-Java-SE-Platform"><a href="#Using-the-Java-SE-Platform" class="headerlink" title="Using the Java SE Platform"></a>Using the Java SE Platform</h6><p>此选项适用于生成 jar 文件,并运行嵌入式 Web 容器的 Spring Boot 项目.Elastic Beanstalk 环境在端口 <code>80</code> 上运行一个 nginx 实例来代理在端口 5000 上运行的真正的应用.要配置它,请将以下行添加到 <code>application.properties</code> 文件中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port=5000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    <em>上传二进制文件而不是源文件</em></p>
<p>​    默认情况下,Elastic Beanstalk 上传源代码并在 AWS 中编译它们.但是,最好改为上传二进制文件.为此,请将类似于以下内容的行添加到 <code>.elasticbeanstalk/config.yml</code> 文件中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;deploy:artifact: target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>



<p>建议:</p>
<p>​    <em>通过设置环境类型降低性能开销</em></p>
<p>​    默认情况下,Elastic Beanstalk 环境是负载平衡的.负载均衡器的成本很高.为避免该成本,请将环境类型设置为”Single instance”,如 <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity">the Amazon documentation</a>中所述. 还可以使用 CLI 和以下命令创建单实例环境:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;eb create -s</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>这是访问 AWS 的最简单方法之一,但还有更多内容需要介绍,例如如何将 Elastic Beanstalk 集成到任何 CI/CD 工具中,使用 Elastic Beanstalk Maven 插件而不是 CLI,等等. 有一篇 <a href="https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/">blog post</a> 更详细地介绍了这些主题.</p>
</li>
</ol>
</li>
<li><h6 id="Boxfuse-和Amazon-网络服务"><a href="#Boxfuse-和Amazon-网络服务" class="headerlink" title="Boxfuse 和Amazon 网络服务"></a>Boxfuse 和Amazon 网络服务</h6><p>Boxfuse 的工作原理是将您的 Spring Boot 可执行 jar 或 war 转换为最小的 VM 镜像,该镜像可以以不可修改的方式在 VirtualBox 或 AWS 上部署.Boxfuse 与 Spring Boot 深度集成,并使用 Spring Boot 配置文件中的信息自动配置端口和健康检查 URL.Boxfuse 将这些信息用于它生成的图像以及它提供的所有资源(实例,安全组,弹性负载均衡器等).</p>
<p>如果创建了 Boxfuse 账户,将其连接到 AWS 账户,安装了最新版本的 Boxfuse 客户端,并确保应用程序已由 Maven 或 Gradle 构建(例如,通过使用 <code>mvn clean package</code>),可以使用类似于以下的命令将 Spring Boot 应用程序部署到 AWS:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> boxfuse run myapp-1.0.jar -env=prod</span></span><br></pre></td></tr></table></figure>

<p>如果当前目录中存在 <code>boxfuse.conf</code> 文件,则使用该文件.</p>
<blockquote>
<p>建议:</p>
<p>​    默认情况下,Boxfuse 在启动时激活一个名为 <code>boxfuse</code> 的 Spring 配置文件.如果可执行 jar 或 war 包含 <code>application-boxfuse.properties</code> 文件,则 Boxfuse 将根据其包含的属性进行配置.</p>
</blockquote>
<p>此时,<code>boxfuse</code> 为应用程序创建一个镜像,上传它,并在 AWS 上配置和启动必要的资源,产生类似于以下示例的输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fusing Image for myapp-1.0.jar ...Image fused in 00:06.838s (53937 K) -&gt; axelfontaine/myapp:1.0Creating axelfontaine/myapp ...Pushing axelfontaine/myapp:1.0 ...Verifying axelfontaine/myapp:1.0 ...Creating Elastic IP ...Mapping myapp-axelfontaine.boxfuse.io to 52.28.233.167 ...Waiting for AWS to create an AMI for axelfontaine/myapp:1.0 in eu-central-1 (this may take up to 50 seconds) ...AMI created in 00:23.557s -&gt; ami-d23f38cfCreating security group boxfuse-sg_axelfontaine/myapp:1.0 ...Launching t2.micro instance of axelfontaine/myapp:1.0 (ami-d23f38cf) in eu-central-1 ...Instance launched in 00:30.306s -&gt; i-92ef9f53Waiting for AWS to boot Instance i-92ef9f53 and Payload to start at https://52.28.235.61/ ...Payload started in 00:29.266s -&gt; https://52.28.235.61/Remapping Elastic IP 52.28.233.167 to i-92ef9f53 ...Waiting 15s for AWS to complete Elastic IP Zero Downtime transition ...Deployment completed successfully. axelfontaine/myapp:1.0 is up and running at https://myapp-axelfontaine.boxfuse.io/</span><br></pre></td></tr></table></figure>

<p>应用程序现在应该在 AWS 上启动并运行.请参阅关于 <a href="https://boxfuse.com/blog/spring-boot-ec2.html">在 EC2 上部署 Spring Boot 应用程序</a> 以及 <a href="https://boxfuse.com/blog/spring-boot-ec2.html">Boxfuse Spring Boot 集成文档</a> ) 开始使用 Maven 构建来运行应用程序.</p>
</li>
<li><h6 id="Google-Cloud"><a href="#Google-Cloud" class="headerlink" title="Google Cloud"></a>Google Cloud</h6><p>Google Cloud 有多个选项可用于启动 Spring Boot 应用程序.最容易的可能是 App Engine,但也可以找到在带有 Container Engine 的容器中或在带有 Compute Engine 的虚拟机上运行 Spring Boot 的方法.</p>
<p>要在 App Engine 中运行,可以先在 UI 中创建一个项目,它设置唯一标识符并设置 HTTP 路由.向项目添加一个 Java 应用程序并将其留空,然后使用 Google Cloud SDK 从命令行或 CI build将 Spring Boot 应用程序推送到该插槽中.</p>
<p>App Engine Standard 要求使用 WAR 打包. 按照 <a href="https://github.com/GoogleCloudPlatform/java-docs-samples/tree/master/appengine-java8/springboot-helloworld/README.md">these steps</a>将 App Engine 标准应用程序部署到 GCP.</p>
<p>或者,App Engine Flex 要求创建一个 <code>app.yaml</code> 文件来描述应用程序所需的资源.通常,将此文件放在 <code>src/main/appengine</code> 中,它应该类似于以下文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">service: defaultruntime: javaenv: flexruntime_config:  jdk: openjdk8handlers:- url:</span> <span class="string">/.*</span>  <span class="attr">script:</span> <span class="string">this</span> <span class="string">field</span> <span class="string">is</span> <span class="string">required,</span> <span class="attr">but ignoredmanual_scaling:  instances: 1health_check:  enable_health_check: Falseenv_variables:  ENCRYPT_KEY:</span> <span class="string">your_encryption_key_here</span></span><br></pre></td></tr></table></figure>

<p>可以通过添加项目 ID 到构建配置中来部署应用程序(例如,使用 Maven 插件),如以下示例所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.cloud.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>appengine-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>        <span class="tag">&lt;<span class="name">project</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">project</span>&gt;</span>    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后使用 <code>mvn appengine:deploy</code> 进行部署(如果需要先进行身份验证,则构建失败).</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>5.3 Deploy:  安装 Spring Boot 应用</title>
    <url>/posts/40038.html</url>
    <content><![CDATA[<ol start="3">
<li><h5 id="安装-Spring-Boot-应用程序-Installing-Spring-Boot-Applications"><a href="#安装-Spring-Boot-应用程序-Installing-Spring-Boot-Applications" class="headerlink" title="安装 Spring Boot 应用程序(Installing Spring Boot Applications)"></a>安装 Spring Boot 应用程序(Installing Spring Boot Applications)</h5><p>除了使用 <code>java -jar</code> 运行 Spring Boot 应用程序之外,还可以为 Unix 系统制作完全可执行的应用程序.一个完整的可执行的 jar 可以像任何其他可执行二进制文件一样执行,也可以用 <code>init.d</code> 或 <code>systemd</code> 注册.这有助于在生产环境中安装和管理 Spring Boot 应用程序.</p>
<blockquote>
<p>警告:</p>
<p>​    完全可执行的 jars 通过在文件前面嵌入一个额外的脚本来工作.目前,一些工具不接受这种格式,因此并不总能用这种技术.例如,<code>jar -xf</code> 可能无法提取已被制作成完全可执行的 jar 或 war.建议仅在打算直接执行时才使 jar 或 war 完全可执行,而不是使用 <code>java -jar</code> 运行它或将其部署到 servlet 容器.</p>
<p>警告:</p>
<p>​    无法使 zip64 格式的 jar 文件完全可执行.尝试这样做会导致 jar 文件在直接执行或使用 <code>java -jar</code> 执行时报告为损坏.包含一个或多个 zip64 格式嵌套 jar 的标准格式 jar 文件可以是完全可执行的.</p>
</blockquote>
<p>要使用 Maven 创建”完全可执行”的 jar,请使用以下插件配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executable</span>&gt;</span>true<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下示例显示了等效的 Gradle 配置:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">bootJar &#123;</span><br><span class="line">    launchScript()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后,可以通过输入 <code>./my-application.jar</code>(其中 <code>my-application</code> 是artifact的名称)来运行应用程序.</p>
<ol>
<li><h6 id="支持的操作系统-Supported-Operating-Systems"><a href="#支持的操作系统-Supported-Operating-Systems" class="headerlink" title="支持的操作系统(Supported Operating Systems)"></a>支持的操作系统(Supported Operating Systems)</h6><p>默认脚本支持大多数 Linux 发行版,并在 CentOS 和 Ubuntu 上进行了测试.其他平台,例如 OS X 和 FreeBSD,需要使用自定义的 <code>EmbeddedLaunchScript</code>.</p>
</li>
<li><h6 id="Unix-Linux-服务"><a href="#Unix-Linux-服务" class="headerlink" title="Unix/Linux 服务"></a>Unix/Linux 服务</h6><p>使用 <code>init.d</code> 或 <code>systemd</code> 可以轻松地将 Spring Boot 应用程序作为 Unix/Linux 服务启动.</p>
<ol>
<li><h6 id="安装为-init-d-服务-System-V-Installation-as-an-init-d-Service-System-V"><a href="#安装为-init-d-服务-System-V-Installation-as-an-init-d-Service-System-V" class="headerlink" title="安装为 init.d 服务(System V)(Installation as an init.d Service (System V))"></a>安装为 init.d 服务(System V)(Installation as an init.d Service (System V))</h6><p>如果将 Spring Boot 的 Maven 或 Gradle 插件配置为生成完全可执行的 jar,并且不使用自定义的 <code>EmbeddedLaunchScript</code>,则应用可以用作 <code>init.d</code> 服务.为此,将 jar 符号链接到 <code>init.d</code> 以支持标准的<code>start</code>,<code>stop</code>,<code>restart</code>和<code>status</code>命令.</p>
<p>该脚本支持以下功能:</p>
<ul>
<li>以拥有 jar 文件的用户身份启动服务</li>
<li>使用 <code>/var/run/&lt;appname&gt;/&lt;appname&gt;.pid</code> 跟踪应用程序的 PID</li>
<li>将控制台日志写入 <code>/var/log/&lt;appname&gt;.log</code></li>
</ul>
<p>假设 <code>/var/myapp</code> 中安装了 Spring Boot 应用程序,要将 Spring Boot 应用程序安装为 <code>init.d</code> 服务,请创建一个符号链接,如下所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp</span></span><br></pre></td></tr></table></figure>

<p>安装后,可以按照平常的方式启动和停止服务. 例如,在基于 Debian 的系统上,可以使用以下命令启动它:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> service myapp start</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果应用程序无法启动,请检查写入 <code>/var/log/&lt;appname&gt;.log</code> 的日志文件是否有错误.</p>
</blockquote>
<p>还可以使用标准操作系统工具将应用程序标记为自动启动. 例如,在 Debian 上,可以使用以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> update-rc.d myapp defaults &lt;priority&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="Securing-an-init-d-Service"><a href="#Securing-an-init-d-Service" class="headerlink" title="Securing an init.d Service"></a>Securing an init.d Service</h6><blockquote>
<p>建议:</p>
<p>​    以下是关于如何保护作为 <code>init.d</code> 服务运行的 Spring Boot 应用程序的一组指南.</p>
</blockquote>
<p>当以 root 身份执行时,就像使用 root 启动 init.d 服务一样,默认的可执行脚本以 <code>RUN_AS_USER</code> 环境变量中指定的用户身份运行应用程序.当未设置环境变量时,将使用拥有 jar 文件的用户.永远不应该以 root 身份运行 Spring Boot 应用程序,因此 <code>RUN_AS_USER</code> 永远不应该是 root,并且应用的 jar 文件不应该由 root 拥有.相反,创建一个特定用户来运行应用并设置 <code>RUN_AS_USER</code> 环境变量或使用 <code>chown</code> 使其成为 jar 文件的所有者,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chown bootapp:bootapp your-app.jar</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下,默认的可执行脚本以 <code>bootapp</code> 用户身份运行应用程序.</p>
<blockquote>
<p>建议:</p>
<p>​    为了减少应用程序的用户帐户被盗用的可能性,应该考虑阻止它使用登录 shell.例如,可以将帐户的 shell 设置为 <code>/usr/sbin/nologin</code>.</p>
</blockquote>
<p>还应该采取措施防止修改应用的 jar 文件.首先配置它的权限,使其不能写入,只能由其所有者读取或执行,如下例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 500 your-app.jar</span></span><br></pre></td></tr></table></figure>

<p>其次,如果应用或运行它的帐户受到损害,还应该采取措施限制损害.如果攻击者确实获得了访问权限,他们可以使 jar 文件可写并更改其内容. 防止这种情况的一种方法是使用 <code>chattr</code> 使其不可变,如以下示例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chattr +i your-app.jar</span></span><br></pre></td></tr></table></figure>

<p>这将防止任何用户(包括 root)修改 jar.</p>
<p>如果 root 用于控制应用的服务,并且使用 <code>.conf</code> 文件自定义其启动,则 <code>.conf</code> 文件将由 root 用户读取和evaluate.应相应地加以保护.使用 <code>chmod</code> 使文件只能由所有者读取,并使用 <code>chown</code> 使 root 成为所有者,如下例所示:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 400 your-app.conf$ sudo chown root:root your-app.conf</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="安装为-systemd-服务-Installation-as-a-systemd-Service"><a href="#安装为-systemd-服务-Installation-as-a-systemd-Service" class="headerlink" title="安装为 systemd 服务( Installation as a systemd Service)"></a>安装为 systemd 服务( Installation as a systemd Service)</h6><p><code>systemd</code> 是 System V init 系统的继承者,现在被许多现代 Linux 发行版使用.虽然可以继续使用 <code>systemd</code> 的 <code>init.d</code> 脚本,但也可以使用 <code>systemd</code> 的”service”脚本启动 Spring Boot 应用程序.</p>
<p>假设在 <code>/var/myapp</code> 中安装了 Spring Boot 应用程序,要将 Spring Boot 应用程序安装为 <code>systemd</code> 服务,则创建一个名为 <code>myapp.service</code> 的脚本并将其放置在 <code>/etc/systemd/system</code> 目录中. 以下脚本提供了一个示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]Description=myappAfter=syslog.target[Service]User=myappExecStart=/var/myapp/myapp.jarSuccessExitStatus=143[Install]WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重要:</p>
<p>​    请记住更改应用程序的<code>Description</code>,<code>User</code>和<code>ExecStart</code>字段.</p>
<p>注意:</p>
<p>​    <code>ExecStart</code> 字段没有声明脚本操作命令,这意味着默认使用运行命令.</p>
</blockquote>
<p>请注意,与作为 <code>init.d</code> 服务运行时不同,运行应用程序的用户,PID 文件和控制台日志文件由 <code>systemd</code> 本身管理,因此必须使用”service”脚本中的适当字段进行配置.</p>
<p>要将应用程序标记为在系统启动时自动启动,请使用以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> myapp.service</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="自定义启动脚本-Customizing-the-Startup-Script"><a href="#自定义启动脚本-Customizing-the-Startup-Script" class="headerlink" title="自定义启动脚本(Customizing the Startup Script)"></a>自定义启动脚本(Customizing the Startup Script)</h6><p>可以通过多种方式自定义由 Maven 或 Gradle 插件编写的默认嵌入式启动脚本.对于大多数人来说,使用默认脚本和一些自定义通常就足够了.如果发现无法自定义所需的内容,请使用 <code>EmbeddedLaunchScript</code> 选项完全编写自己的文件.</p>
<h6 id="写入时自定义启动脚本"><a href="#写入时自定义启动脚本" class="headerlink" title="写入时自定义启动脚本"></a>写入时自定义启动脚本</h6><p>在写入 jar 文件时自定义启动脚本的元素通常是有意义的.例如,<code>init.d</code> 脚本可以提供”description”. 由于预先知道描述(并且不需要更改),因此最好在生成 jar 时提供它.</p>
<p>要自定义写入的元素,请使用 Spring Boot Maven 插件的 <code>EmbeddedLaunchScriptProperties</code> 选项或 Spring Boot Gradle 插件的 <code>launchScript</code> 的 properties 属性( <a href="https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#packaging-executable-configuring-launch-script"><code>properties</code> property of the Spring Boot Gradle plugin’s <code>launchScript</code></a>.).</p>
<p>默认脚本支持以下属性替换:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Gradle default</th>
<th>Maven default</th>
</tr>
</thead>
<tbody><tr>
<td><code>mode</code></td>
<td>脚本模式.</td>
<td><code>auto</code></td>
<td><code>auto</code></td>
</tr>
<tr>
<td><code>initInfoProvides</code></td>
<td>“INIT INFO”的”提供”部分</td>
<td><code>$&#123;task.baseName&#125;</code></td>
<td><code>$&#123;project.artifactId&#125;</code></td>
</tr>
<tr>
<td><code>initInfoRequiredStart</code></td>
<td>“INIT INFO”的”Required-Start”部分.</td>
<td><code>$remote_fs $syslog $network</code></td>
<td><code>$remote_fs $syslog $network</code></td>
</tr>
<tr>
<td><code>initInfoRequiredStop</code></td>
<td>“INIT INFO”的”Required-Stop”部分.</td>
<td><code>$remote_fs $syslog $network</code></td>
<td><code>$remote_fs $syslog $network</code></td>
</tr>
<tr>
<td><code>initInfoDefaultStart</code></td>
<td>“INIT INFO”的”Default-Start”部分.</td>
<td><code>2 3 4 5</code></td>
<td><code>2 3 4 5</code></td>
</tr>
<tr>
<td><code>initInfoDefaultStop</code></td>
<td>“初始化信息”的”默认停止”部分.</td>
<td><code>0 1 6</code></td>
<td><code>0 1 6</code></td>
</tr>
<tr>
<td><code>initInfoShortDescription</code></td>
<td>“INIT INFO”的”Short-Description”部分.</td>
<td><code>$&#123;project.description&#125;</code> 的单行版本(回退到 <code>$&#123;task.baseName&#125;</code>)</td>
<td><code>$&#123;project.name&#125;</code></td>
</tr>
<tr>
<td><code>initInfoDescription</code></td>
<td>“INIT INFO”的”描述”部分.</td>
<td><code>$&#123;project.description&#125;</code>(回退到 <code>$&#123;task.baseName&#125;</code>)</td>
<td><code>$&#123;project.description&#125;</code>(回退到 <code>$&#123;project.name&#125;</code>)</td>
</tr>
<tr>
<td><code>initInfoChkconfig</code></td>
<td>“INIT INFO”的<code>chkconfig</code>部分</td>
<td><code>2345 99 01</code></td>
<td><code>2345 99 01</code></td>
</tr>
<tr>
<td><code>confFolder</code></td>
<td><code>CONF_FOLDER</code> 的默认值</td>
<td>包含 jar 的文件夹</td>
<td>包含 jar 的文件夹</td>
</tr>
<tr>
<td><code>inlinedConfScript</code></td>
<td>对应内联在默认启动脚本中的文件脚本的引用. 这可用于在加载任何外部配置文件之前设置环境变量,例如<code>JAVA_OPTS</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>logFolder</code></td>
<td><code>LOG_FOLDER</code> 的默认值. 仅对 <code>init.d</code> 服务有效</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>logFilename</code></td>
<td><code>LOG_FILENAME</code> 的默认值. 仅对 <code>init.d</code> 服务有效</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>pidFolder</code></td>
<td><code>PID_FOLDER</code> 的默认值. 仅对 <code>init.d</code> 服务有效</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>pidFilename</code></td>
<td><code>PID_FOLDER</code> 中 PID 文件名称的默认值. 仅对 <code>init.d</code> 服务有效</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>useStartStopDaemon</code></td>
<td>是否应该使用 <code>start-stop-daemon</code> 命令(当它可用时)来控制进程</td>
<td><code>true</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>stopWaitTime</code></td>
<td><code>STOP_WAIT_TIME</code> 的默认值(以秒为单位). 仅对 <code>init.d</code> 服务有效</td>
<td>60</td>
<td>60</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="在运行时自定义脚本-Customizing-a-Script-When-It-Runs"><a href="#在运行时自定义脚本-Customizing-a-Script-When-It-Runs" class="headerlink" title="在运行时自定义脚本(Customizing a Script When It Runs)"></a>在运行时自定义脚本(Customizing a Script When It Runs)</h6><p>jar 写好后需要自定义的脚本项,可以使用环境变量或配置文件.</p>
<p>默认脚本支持以下环境属性:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>MODE</code></td>
<td>操作的”模式”. 默认值取决于 jar 的构建方式,但通常是 <code>auto</code>(这意味着它试图通过检查它是否是名为 <code>init.d</code> 的目录中的符号链接来猜测它是否是一个 init 脚本). 可以将其显式设置为 <code>service</code>,以便 `stop</td>
</tr>
<tr>
<td><code>RUN_AS_USER</code></td>
<td>将用于运行应用程序的用户. 未设置时,将使用拥有 jar 文件的用户.</td>
</tr>
<tr>
<td><code>USE_START_STOP_DAEMON</code></td>
<td>是否应使用”<code>start-stop-daemon</code>“命令(如果可用)来控制进程. 默认为”真”.</td>
</tr>
<tr>
<td><code>PID_FOLDER</code></td>
<td>pid 文件夹的根名称(默认为<code>/var/run</code>).</td>
</tr>
<tr>
<td><code>LOG_FOLDER</code></td>
<td>放置日志文件的文件夹的名称(默认为<code>/var/log</code>).</td>
</tr>
<tr>
<td><code>CONF_FOLDER</code></td>
<td>从中读取 .conf 文件的文件夹的名称(默认与 jar-file 相同的文件夹).</td>
</tr>
<tr>
<td><code>LOG_FILENAME</code></td>
<td><code>LOG_FOLDER</code> 中日志文件的名称(默认为 <code>&lt;appname&gt;.log</code>).</td>
</tr>
<tr>
<td><code>APP_NAME</code></td>
<td>应用程序的名称. 如果 jar 是从符号链接运行的,则脚本会猜测应用程序名称. 如果它不是符号链接或者想明确设置应用程序名称,这可能很有用.</td>
</tr>
<tr>
<td><code>RUN_ARGS</code></td>
<td>传递给程序(Spring Boot 应用程序)的参数.</td>
</tr>
<tr>
<td><code>JAVA_HOME</code></td>
<td><code>java</code> 可执行文件的位置默认使用 <code>PATH</code> 发现,但如果 <code>$JAVA_HOME/bin/java</code> 中有一个可执行文件,你可以显式设置它.</td>
</tr>
<tr>
<td><code>JAVA_OPTS</code></td>
<td>JVM 启动时传递给它的选项.</td>
</tr>
<tr>
<td><code>JARFILE</code></td>
<td>jar 文件的显式位置,以防脚本用于启动实际上并未嵌入的 jar.</td>
</tr>
<tr>
<td><code>DEBUG</code></td>
<td>如果不为空,则在 shell 进程上设置 <code>-x</code> 标志,允许查看脚本中的逻辑.</td>
</tr>
<tr>
<td><code>STOP_WAIT_TIME</code></td>
<td>在强制关闭之前停止应用程序时等待的时间(以秒为单位)(默认为”60”).</td>
</tr>
</tbody></table>
<blockquote>
<p>注意:</p>
<p>​    <code>PID_FOLDER</code>,<code>LOG_FOLDER</code> 和 <code>LOG_FILENAME</code> 变量仅对 <code>init.d</code> 服务有效. 对于”<code>systemd</code>“,使用”service”脚本进行等效的自定义.</p>
</blockquote>
<p>除了 <code>JARFILE</code> 和 <code>APP_NAME</code> 之外,可以使用 <code>.conf</code> 文件配置上一节中列出的设置.该文件应该在 jar 文件旁边,并且具有相同的名称,但后缀为 <code>.conf</code> 而不是 <code>.jar</code>. 例如,名为 <code>/var/myapp/myapp.jar</code> 的 jar 使用名为 <code>/var/myapp/myapp.conf</code> 的配置文件,如下例所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=-Xmx1024MLOG_FOLDER=/custom/log/folder</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果不喜欢在 jar 文件旁边放置配置文件,可以设置一个 <code>CONF_FOLDER</code> 环境变量来自定义配置文件的位置.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="Microsoft-Windows-服务-Microsoft-Windows-Services"><a href="#Microsoft-Windows-服务-Microsoft-Windows-Services" class="headerlink" title="Microsoft Windows 服务(Microsoft Windows Services)"></a>Microsoft Windows 服务(Microsoft Windows Services)</h6><p>可以使用 <a href="https://github.com/kohsuke/winsw"><code>winsw</code></a> 将 Spring Boot 应用程序作为 Windows 服务启动.</p>
<p>A (<a href="https://github.com/snicol/spring-boot-daemon">单独维护的示例</a>) 描述了如何为 Spring Boot 应用程序创建 Windows 服务的分步说明.</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>4.6 Acuator: Metrics</title>
    <url>/posts/47604.html</url>
    <content><![CDATA[<ol start="6">
<li><h5 id="检测-Metrics"><a href="#检测-Metrics" class="headerlink" title="检测(Metrics)"></a>检测(Metrics)</h5><p>Spring Boot Actuator 为 <code>Micrometer</code> 提供依赖管理和自动配置,支持众多监控系统的应用Metrics facade ,包括:</p>
<ul>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.appoptics">AppOptics</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.atlas">Atlas</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.datadog">Datadog</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.dynatrace">Dynatrace</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.elastic">Elastic</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.ganglia">Ganglia</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.graphite">Graphite</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.humio">Humio</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.influx">Influx</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.jmx">JMX</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.kairos">KairosDB</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.newrelic">New Relic</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.prometheus">Prometheus</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.signalfx">SignalFx</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.simple">Simple (in-memory)</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.stackdriver">Stackdriver</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.statsd">StatsD</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.wavefront">Wavefront</a></p>
<blockquote>
<p>建议:</p>
<p>​    要了解有关 Micrometer 功能的更多信息,请参阅其 <a href="https://micrometer.io/docs">参考文档</a>,尤其是 <a href="https://micrometer.io/docs/concepts">概念部分</a>.</p>
</blockquote>
</li>
</ul>
<ol>
<li><h6 id="开始-Getting-started"><a href="#开始-Getting-started" class="headerlink" title="开始(Getting started)"></a>开始(Getting started)</h6><p>Spring Boot 自动配置一个复合 <code>MeterRegistry</code> ,并为类路径上每个受支持的实现注册到复合中.在运行时classpath中依赖 <code>micrometer-registry-&#123;system&#125;</code> 足以让 Spring Boot 配置registry.</p>
<p>大多数注册中心都有共同的特征. 例如,即使 <code>Micrometer</code> registry实现在类路径上,也可以禁用特定registry. 例如,禁用 Datadog:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.datadog.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>还可以禁用所有registry,除非registry特定属性另有说明,如以下示例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.defaults.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot 还将所有自动配置的registry添加到 <code>Metrics</code> 类上的全局静态复合registry,除非明确告诉它不要:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.use-global-registry</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>可以注册任意数量的 <code>MeterRegistryCustomizer</code> bean 以进一步配置registry,例如应用公共标签,然后再向registry注册任何meters:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMeterRegistryConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MeterRegistryCustomizer&lt;MeterRegistry&gt; <span class="title">metricsCommonTags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (registry) -&gt; registry.config().commonTags(<span class="string">&quot;region&quot;</span>, <span class="string">&quot;us-east-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过更具体地了解泛型类型,将自定义应用于特定的registry实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMeterRegistryConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MeterRegistryCustomizer&lt;GraphiteMeterRegistry&gt; <span class="title">graphiteMetricsNamingConvention</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (registry) -&gt; registry.config().namingConvention(<span class="keyword">this</span>::name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">name</span><span class="params">(String name, Meter.Type type, String baseUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Boot 还配置了可以通过配置或专用注解标记控制的 <a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.supported">built-in instrumentation</a>.</p>
</li>
<li><h6 id="支持的监控系统-Supported-Monitoring-Systems"><a href="#支持的监控系统-Supported-Monitoring-Systems" class="headerlink" title="支持的监控系统(Supported Monitoring Systems)"></a>支持的监控系统(Supported Monitoring Systems)</h6><ol>
<li><h6 id="AppOptics"><a href="#AppOptics" class="headerlink" title="AppOptics"></a>AppOptics</h6><p>默认情况下,AppOptics registry会定期将metric推送到 <code>api.appoptics.com/v1/measurements</code>. 要将指标导出到 SaaS AppOptics,必须提供 API token :</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.appoptics.api-token</span>=<span class="string">YOUR_TOKEN</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h6><p>默认情况下,metrics会导出到在本地机器上运行的 Atlas. 可以使用以下命令提供要使用的 Atlas 服务器的位置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.atlas.uri</span>=<span class="string">https://atlas.example.com:7101/api/v1/publish</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Datadog"><a href="#Datadog" class="headerlink" title="Datadog"></a>Datadog</h6><p>Datadog registry定期将指标推送到 datadoghq. 要将指标导出到 Datadog,必须提供 API key :</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.datadog.api-key</span>=<span class="string">YOUR_KEY</span></span><br></pre></td></tr></table></figure>

<p>还可以更改指标发送到 Datadog 的时间间隔:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.datadog.step</span>=<span class="string">30s</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Dynatrace"><a href="#Dynatrace" class="headerlink" title="Dynatrace"></a>Dynatrace</h6><p>Dynatrace registry 定期将metrics 推送到配置的 URI. 要将指标导出到 Dynatrace,必须提供 API token,设备 ID 和 URI:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.dynatrace.api-token</span>=<span class="string">YOUR_TOKEN</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.device-id</span>=<span class="string">YOUR_DEVICE_ID</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.uri</span>=<span class="string">YOUR_URI</span></span><br></pre></td></tr></table></figure>

<p>还可以更改指标发送到 Dynatrace 的时间间隔:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.dynatrace.step</span>=<span class="string">30s</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Elastic"><a href="#Elastic" class="headerlink" title="Elastic"></a>Elastic</h6><p>默认情况下,指标会导出到在本地机器上运行的 Elastic. 可以使用以下属性提供要使用的Elastic 服务器的位置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.elastic.host</span>=<span class="string">https://elastic.example.com:8086</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Ganglia"><a href="#Ganglia" class="headerlink" title="Ganglia"></a>Ganglia</h6><p>默认情况下,metrics会导出到在本地计算机上运行的 Ganglia. 要使用的 Ganglia 服务器主机和端口可以通过以下方式提供:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.ganglia.host</span>=<span class="string">ganglia.example.com</span></span><br><span class="line"><span class="meta">management.metrics.export.ganglia.port</span>=<span class="string">9649</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Graphite"><a href="#Graphite" class="headerlink" title="Graphite"></a>Graphite</h6><p>默认情况下,metrics会导出到在本地计算机上运行的 Graphite. 可以使用以下方式提供要使用的 Graphite 服务器主机和端口:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.graphite.host</span>=<span class="string">graphite.example.com</span></span><br><span class="line"><span class="meta">management.metrics.export.graphite.port</span>=<span class="string">9004</span></span><br></pre></td></tr></table></figure>

<p>Micrometer 提供了一个默认的 <code>HierarchicalNameMapper</code>,用于管理维度仪表 ID 如何映射到平面层次名称.</p>
<blockquote>
<p>建议:</p>
<p>​    要控制此行为,请定义 <code>GraphiteMeterRegistry</code> 并提供自己的 <code>HierarchicalNameMapper</code>.除非定义自己的,否则提供自动配置的 <code>GraphiteConfig</code> 和 <code>Clock bean</code>:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGraphiteConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GraphiteMeterRegistry <span class="title">graphiteMeterRegistry</span><span class="params">(GraphiteConfig config, Clock clock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GraphiteMeterRegistry(config, clock, <span class="keyword">this</span>::toHierarchicalName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toHierarchicalName</span><span class="params">(Meter.Id id, NamingConvention convention)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="Humio"><a href="#Humio" class="headerlink" title="Humio"></a>Humio</h6><p>默认情况下,Humio registry会定期将指标推送到 <code>cloud.humio.com</code>. 要将指标导出到 SaaS Humio,必须提供 API token:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.humio.api-token</span>=<span class="string">YOUR_TOKEN</span></span><br></pre></td></tr></table></figure>

<p>还应该配置一个或多个标签来识别指标将被推送到的数据源:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.humio.tags.alpha</span>=<span class="string">a</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.tags.bravo</span>=<span class="string">b</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Influx"><a href="#Influx" class="headerlink" title="Influx"></a>Influx</h6><p>默认情况下,指标会导出到使用默认配置在本地计算机上运行的 Influx v1 实例.要将指标导出到 InfluxDB v2,请配置用于写入指标的<code>org</code>,<code>bucket</code>和身份验证<code>token</code>.可以使用以下方法提供要使用的 Influx 服务器的位置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.influx.uri</span>=<span class="string">https://influx.example.com:8086</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h6><p>Micrometer 提供了到 JMX 的分层映射,主要是作为一种廉价且可移植的本地查看metrics的方式.默认情况下,指标导出到指标 JMX 域. 可以使用以下方式提供要使用的域:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.jmx.domain</span>=<span class="string">com.example.app.metrics</span></span><br></pre></td></tr></table></figure>

<p>Micrometer 提供了一个默认的 <code>HierarchicalNameMapper</code>,用于管理维度仪表 ID 如何映射到平面层次名称.</p>
<blockquote>
<p>建议:</p>
<p>​    要控制此行为,请定义 <code>JmxMeterRegistry</code> 并提供自己的 <code>HierarchicalNameMapper</code>.除非自己定义,否则会提供自动配置的 <code>JmxConfig </code>和 <code>Clock</code> bean:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJmxConfiguration</span> </span>&#123;    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> JmxMeterRegistry <span class="title">jmxMeterRegistry</span><span class="params">(JmxConfig config, Clock clock)</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> JmxMeterRegistry(config, clock, <span class="keyword">this</span>::toHierarchicalName);    &#125;    <span class="function"><span class="keyword">private</span> String <span class="title">toHierarchicalName</span><span class="params">(Meter.Id id, NamingConvention convention)</span> </span>&#123;        <span class="keyword">return</span> ...    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="KairosDB"><a href="#KairosDB" class="headerlink" title="KairosDB"></a>KairosDB</h6><p>默认情况下,指标会导出到在本地计算机上运行的 KairosDB. 可以使用以下命令提供要使用的 KairosDB 服务器的位置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.kairos.uri</span>=<span class="string">https://kairosdb.example.com:8080/api/v1/datapoints</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="New-Relic"><a href="#New-Relic" class="headerlink" title="New Relic"></a>New Relic</h6><p>New Relic registry定期将指标推送到 New Relic. 要将指标导出到 New Relic,必须提供 API key和帐户 ID:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.newrelic.api-key</span>=<span class="string">YOUR_KEY</span></span><br><span class="line"><span class="meta">management.metrics.export.newrelic.account-id</span>=<span class="string">YOUR_ACCOUNT_ID</span></span><br></pre></td></tr></table></figure>

<p>还可以更改指标发送到 New Relic 的时间间隔:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.newrelic.step</span>=<span class="string">30s</span></span><br></pre></td></tr></table></figure>

<p>默认情况下,metrics 是通过 REST 调用发布的,但也可以使用 Java 代理 API,如果在类路径上有它:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.newrelic.client-provider-type</span>=<span class="string">insights-agent</span></span><br></pre></td></tr></table></figure>

<p>最后,可以通过定义自己的 <code>NewRelicClientProvider</code> bean 来完全控制.</p>
</li>
<li><h6 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h6><p>Prometheus 期望抓取或轮询单个应用程序实例以获取metrics.Spring Boot 在 <code>/actuator/prometheus</code> 提供了一个可用的actuator endpoint,以显示具有适当格式的 <code>Prometheus</code> 抓取.</p>
<blockquote>
<p>建议:</p>
<p>​    endpoint默认不可用,必须公开.</p>
</blockquote>
<p>这是添加到 <code>prometheus.yml</code> 的 <code>scrape_config</code>示例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;spring&#x27;</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">&#x27;/actuator/prometheus&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;HOST:PORT&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>对于可能存在时间不够长而无法抓取的临时或批处理作业,可以使用 Prometheus Pushgateway 将其metrics 公开给 Prometheus.要启用 Prometheus Pushgateway 支持,将以下依赖项添加到项目中:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_pushgateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当类路径上存在 Prometheus Pushgateway 依赖项并且 <code>management.metrics.export.prometheus.pushgateway.enabled</code> 属性设置为 <code>true</code> 时,会自动配置 <code>PrometheusPushGatewayManager</code> bean.这管理将指标推送到 Prometheus Pushgateway.</p>
<p><code>PrometheusPushGatewayManager</code> 可以使用 <code>management.metrics.export.prometheus.pushgateway</code> 下的属性进行调整.对于高级配置,还可以提供自己的 <code>PrometheusPushGatewayManager</code> bean.</p>
</li>
<li><h6 id="SignalFx"><a href="#SignalFx" class="headerlink" title="SignalFx"></a>SignalFx</h6><p>SignalFx registry定期将指标推送到 SignalFx. 要将指标导出到 SignalFx,必须提供的access token:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.signalfx.access-token</span>=<span class="string">YOUR_ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure>

<p>还可以更改指标发送到 SignalFx 的时间间隔:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.signalfx.step</span>=<span class="string">30s</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h6><p>Micrometer 附带一个简单的内存后端,如果没有配置其他registry,它会自动作为备用. 这使可以查看<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.endpoint">metrics endpoint</a>中收集了哪些metrics .</p>
<p>只要使用任何其他可用后端,内存后端就会自行禁用. 还可以明确禁用它:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.simple.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Stackdriver"><a href="#Stackdriver" class="headerlink" title="Stackdriver"></a>Stackdriver</h6><p>Stackdriver registry会定期将指标推送到 Stackdriver. 要将指标导出到 SaaS Stackdriver,必须提供 Google Cloud project  ID:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.stackdriver.project-id</span>=<span class="string">my-project</span></span><br></pre></td></tr></table></figure>

<p>还可以更改指标发送到 Stackdriver 的时间间隔:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.stackdriver.step</span>=<span class="string">30s</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="StatsD"><a href="#StatsD" class="headerlink" title="StatsD"></a>StatsD</h6><p>StatsD registry地通过 UDP 将指标快速地推送到 StatsD 代理.默认情况下,指标会导出到在本地计算机上运行的 StatsD 代理. 要使用的 StatsD 代理主机,端口和协议可以通过以下方式提供:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.statsd.host</span>=<span class="string">statsd.example.com</span></span><br><span class="line"><span class="meta">management.metrics.export.statsd.port</span>=<span class="string">9125</span></span><br><span class="line"><span class="meta">management.metrics.export.statsd.protocol</span>=<span class="string">udp</span></span><br></pre></td></tr></table></figure>

<p>还可以更改要使用的 StatsD 线路协议(默认为 Datadog):</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.statsd.flavor</span>=<span class="string">etsy</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Wavefront"><a href="#Wavefront" class="headerlink" title="Wavefront"></a>Wavefront</h6><p>Wavefront registry定期将指标推送到 Wavefront. 如果直接将指标导出到 Wavefront,则必须提供 API token :</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.wavefront.api-token</span>=<span class="string">YOUR_API_TOKEN</span></span><br></pre></td></tr></table></figure>

<p>或者,可以使用 Wavefront sidecar 或在环境中设置的内部代理,将指标数据转发到 Wavefront API 主机:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.wavefront.uri</span>=<span class="string">proxy://localhost:2878</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果将指标发布到 Wavefront 代理,则主机必须采用 <code>proxy://HOST:PORT</code> 格式.</p>
</blockquote>
<p>还可以更改指标发送到 Wavefront 的时间间隔:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.export.wavefront.step</span>=<span class="string">30s</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h6 id="支持的Metrics和Meters-Supported-Metrics-and-Meters"><a href="#支持的Metrics和Meters-Supported-Metrics-and-Meters" class="headerlink" title="支持的Metrics和Meters(Supported Metrics and Meters)"></a>支持的Metrics和Meters(Supported Metrics and Meters)</h6><p>Spring Boot 为各种技术提供自动仪表注册.在大多数情况下,开箱即用的默认值将提供可发布的合理指标给到所有支持的监控系统.</p>
<ol>
<li><h6 id="JVM-Metrics"><a href="#JVM-Metrics" class="headerlink" title="JVM Metrics"></a>JVM Metrics</h6><p>自动配置将使用核心 Micrometer 类启用 JVM 指标. JVM 指标发布在 <code>jvm.</code> meter名下.</p>
<p>提供了以下 JVM 指标:</p>
<ul>
<li>各种内存和缓冲池详细信息</li>
<li>与垃圾回收相关的统计信息</li>
<li>线程利用率</li>
<li>加载/卸载的类数</li>
</ul>
</li>
<li><h6 id="System-Metrics"><a href="#System-Metrics" class="headerlink" title="System Metrics"></a>System Metrics</h6><p>自动配置将使用核心 Micrometer 类启用系统指标. 系统指标在<code>system.</code>和<code>process.</code>meter names下发布.</p>
<p>提供了以下系统指标:</p>
<ul>
<li>CPU 指标</li>
<li>文件描述符指标</li>
<li>正常运行时间指标(应用程序运行的时间量以及绝对启动时间的固定量表)</li>
</ul>
</li>
<li><h6 id="Logger-Metrics"><a href="#Logger-Metrics" class="headerlink" title="Logger Metrics"></a>Logger Metrics</h6><p>自动配置为 Logback 和 Log4J2 启用事件指标. 详细信息发布在 <code>log4j2.events.</code> 或 <code>logback.events.</code> meter 名下.</p>
</li>
<li><h6 id="Spring-MVC-Metrics"><a href="#Spring-MVC-Metrics" class="headerlink" title="Spring MVC Metrics"></a>Spring MVC Metrics</h6><p>自动配置启用对 Spring MVC controller和函数式程序处理的所有请求的检测.默认情况下,metric生成的名称为 <code>http.server.requests</code>.可以通过设置 <code>management.metrics.web.server.request.metric-name</code> 属性来自定义名称.</p>
<p><code>@Controller</code> 类和 <code>@RequestMapping</code> 方法支持 <code>@Timed</code> 注解.如果不想记录所有 Spring MVC 请求的指标,可以将 <code>management.metrics.web.server.request.autotime.enabled</code> 设置为 <code>false</code> 并使用 <code>@Timed</code> 注解.</p>
<p>默认情况下,Spring MVC 相关metrics标记有以下信息:</p>
<table>
<thead>
<tr>
<th><strong>Tag</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>exception</code></td>
<td>处理请求时抛出的任何异常的简单类名。</td>
</tr>
<tr>
<td><code>method</code></td>
<td>请求的方法（例如，<code>GET</code> 或 <code>POST</code>）</td>
</tr>
<tr>
<td><code>outcome</code></td>
<td>请求的结果基于响应的状态代码。 1xx 是“<code>INFORMATIONAL</code>”，2xx 是“<code>SUCCESS</code>”，3xx 是“<code>REDIRECTION</code>”，4xx 是“<code>CLIENT_ERROR</code>”，5xx 是“<code>SERVER_ERROR</code>”</td>
</tr>
<tr>
<td><code>status</code></td>
<td>响应的 HTTP 状态代码（例如，<code>200</code> 或 <code>500</code>）</td>
</tr>
<tr>
<td><code>uri</code></td>
<td>如果可能，在变量替换之前请求的 URI 模板（例如，<code>/api/person/&#123;id&#125;</code>）</td>
</tr>
</tbody></table>
<p>要添加到默认标签,请提供一个或多个实现 <code>WebMvcTagsContributor</code> 的 <code>@Bean</code>.要替换默认标签,请提供一个实现 <code>WebMvcTagsProvider</code> 的 <code>@Bean</code>.</p>
<blockquote>
<p>建议:</p>
<p>​    在某些情况下,Web 控制器中处理的异常不会记录为请求指标标记.应用可以通过将处理的异常设置为请求属性来选择加入和记录异常.</p>
</blockquote>
</li>
<li><h6 id="Spring-WebFlux-Metrics"><a href="#Spring-WebFlux-Metrics" class="headerlink" title="Spring WebFlux Metrics"></a>Spring WebFlux Metrics</h6><p>自动配置启用对 Spring WebFlux controller和functional handler的所有请求的检测.默认情况下,metrics生成的名称为 <code>http.server.requests</code>.可以通过设置 <code>management.metrics.web.server.request.metric-name</code> 属性来自定义名称.</p>
<p><code>@Controller</code> 类和 <code>@RequestMapping</code> 方法支持 <code>@Timed</code> 注解.如果不想记录所有 Spring WebFlux 请求的metrics ,可以将 <code>management.metrics.web.server.request.autotime.enabled</code> 设置为 <code>false</code> 并使用 <code>@Timed</code> 注解.</p>
<p>默认情况下,WebFlux 相关metrics 标记有以下信息:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>exception</code></td>
<td>处理请求时抛出的任何异常的简单类名。</td>
<td></td>
</tr>
<tr>
<td><code>method</code></td>
<td>请求的方法（例如，<code>GET</code> 或 <code>POST</code>）</td>
<td></td>
</tr>
<tr>
<td><code>outcome</code></td>
<td>请求的结果基于响应的状态代码。 1xx 是“<code>INFORMATIONAL</code>”，2xx 是“<code>SUCCESS</code>”，3xx 是“<code>REDIRECTION</code>”，4xx 是“<code>CLIENT_ERROR</code>”，5xx 是“<code>SERVER_ERROR</code>”</td>
<td></td>
</tr>
<tr>
<td><code>status</code></td>
<td>响应的 HTTP 状态代码（例如，<code>200</code> 或 <code>500</code>）</td>
<td></td>
</tr>
<tr>
<td><code>uri</code></td>
<td>如果可能，在变量替换之前请求的 URI 模板（例如，<code>/api/person/&#123;id&#125;</code>）</td>
<td></td>
</tr>
</tbody></table>
<p>要添加到默认标签,提供一个或多个实现 <code>WebFluxTagsContributor</code> 的 <code>@Bean</code>. 要替换默认标签,提供一个实现 <code>WebFluxTagsProvider</code> 的 <code>@Bean</code>.</p>
<blockquote>
<p>建议:</p>
<p>​    在某些情况下,controller和handler函数中处理的异常不会作为request metrics tags 记录.应用程序可以将异常设为请求属性来选择加入和记录异常.</p>
</blockquote>
</li>
<li><h6 id="Jersey-Server-Metrics"><a href="#Jersey-Server-Metrics" class="headerlink" title="Jersey Server Metrics"></a>Jersey Server Metrics</h6><p>只要 Micrometer 的 <code>micrometer-jersey2</code> 模块在类路径上,自动配置就会启用检测Jersey JAX-RS 实现所处理的所有请求的.默认情况下,metrics 生成的名称为 <code>http.server.requests</code>. 可以通过设置 <code>management.metrics.web.server.request.metric-name</code> 属性来自定义名称.</p>
<p>请求处理类和方法支持<code>@Timed</code> 注解.如果不想记录所有 Jersey 请求的指标,可以将 <code>management.metrics.web.server.request.autotime.enabled</code> 设置为 <code>false</code> 并专门使用 <code>@Timed</code> 注解.</p>
<p>默认情况下,Jersey 服务器指标标记有以下信息:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>exception</code></td>
<td>处理请求时抛出的任何异常的简单类名。</td>
</tr>
<tr>
<td><code>method</code></td>
<td>请求的方法（例如，<code>GET</code> 或 <code>POST</code>）</td>
</tr>
<tr>
<td><code>outcome</code></td>
<td>请求的结果基于响应的状态代码。 1xx 是“<code>INFORMATIONAL</code>”，2xx 是“<code>SUCCESS</code>”，3xx 是“<code>REDIRECTION</code>”，4xx 是“<code>CLIENT_ERROR</code>”，5xx 是“<code>SERVER_ERROR</code>”</td>
</tr>
<tr>
<td><code>status</code></td>
<td>响应的 HTTP 状态代码（例如，<code>200</code> 或 <code>500</code>）</td>
</tr>
<tr>
<td><code>uri</code></td>
<td>如果可能，在变量替换之前请求的 URI 模板（例如，<code>/api/person/&#123;id&#125;</code>）</td>
</tr>
</tbody></table>
<p>要自定义标签,请提供一个实现 JerseyTagsProvider 的 <code>@Bean</code>.</p>
</li>
<li><h6 id="HTTP-Client-Metrics"><a href="#HTTP-Client-Metrics" class="headerlink" title="HTTP Client Metrics"></a>HTTP Client Metrics</h6><p>Spring Boot Actuator 管理 <code>RestTemplate</code> 和 <code>WebClient</code> 的检测.为此,必须注入自动配置的builder并使用它来创建实例:</p>
<ul>
<li><code>RestTemplateBuilder</code> 用于 <code>RestTemplate</code></li>
<li><code>WebClient.Builder</code> 用于 <code>WebClient</code></li>
</ul>
<p>也可以手动应用负责此检测的定制器,即 <code>MetricsRestTemplateCustomizer</code> 和 <code>MetricsWebClientCustomizer</code>.</p>
<p>默认情况下,metrics生成的名称为 <code>http.client.requests</code>. 可以通过设置 <code>management.metrics.web.client.request.metric-name</code> 属性来自定义名称.</p>
<p>默认情况下,由检测客户端生成的metrics 标记有以下信息:</p>
<table>
<thead>
<tr>
<th><strong>Tag</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>exception</code></td>
<td>处理请求时抛出的任何异常的简单类名。</td>
</tr>
<tr>
<td><code>method</code></td>
<td>请求的方法（例如，<code>GET</code> 或 <code>POST</code>）</td>
</tr>
<tr>
<td><code>outcome</code></td>
<td>请求的结果基于响应的状态代码。 1xx 是“<code>INFORMATIONAL</code>”，2xx 是“<code>SUCCESS</code>”，3xx 是“<code>REDIRECTION</code>”，4xx 是“<code>CLIENT_ERROR</code>”，5xx 是“<code>SERVER_ERROR</code>”</td>
</tr>
<tr>
<td><code>status</code></td>
<td>响应的 HTTP 状态代码（例如，<code>200</code> 或 <code>500</code>）</td>
</tr>
<tr>
<td><code>uri</code></td>
<td>如果可能，在变量替换之前请求的 URI 模板（例如，<code>/api/person/&#123;id&#125;</code>）</td>
</tr>
</tbody></table>
<p>要自定义标签,并根据客户端,可以提供一个实现 <code>RestTemplateExchangeTagsProvider</code> 或 <code>WebClientExchangeTagsProvider</code> 的 <code>@Bean</code>.<code>RestTemplateExchangeTags</code> 和 <code>WebClientExchangeTags</code> 中提供有方便的静态函数.</p>
</li>
<li><h6 id="Tomcat-Metrics"><a href="#Tomcat-Metrics" class="headerlink" title="Tomcat Metrics"></a>Tomcat Metrics</h6><p>仅当启用 <code>MBeanRegistry</code> 时,自动配置才会启用 Tomcat 的检测.默认情况下,<code>MBeanRegistry</code> 是禁用的,但可以通过将 <code>server.tomcat.mbeanregistry.enabled</code> 设置为 <code>true</code> 来启用它.</p>
<p>metric tomcat的发布在<code>tomcat.</code> meter名下.</p>
</li>
<li><h6 id="Cache-Metrics"><a href="#Cache-Metrics" class="headerlink" title="Cache Metrics"></a>Cache Metrics</h6><p>使用<code>cache</code>为前缀的metrics 启动时,自动配置在启动时启用所有可用的<code>Cache</code>的检测.缓存检测是针对基本metric进行标准化的. 还可以使用其他特定于缓存的指标.</p>
<p>支持以下缓存库:</p>
<ul>
<li>Caffeine</li>
<li>EhCache 2</li>
<li>Hazelcast</li>
<li>Any compliant JCache (JSR-107) implementation</li>
<li>Redis</li>
</ul>
<p>Metrics 由缓存的名称和从 bean name派生的 <code>CacheManager</code> 的名称标记.</p>
<blockquote>
<p>注意:</p>
<p>​    只有在启动时配置的缓存才会绑定到registry.对于缓存配置中未定义的缓存,例如 在启动阶段后即时或以编程方式创建的缓存,需要显式注册.<code>CacheMetricsRegistrar</code> bean 可用于简化该过程.</p>
</blockquote>
</li>
<li><h6 id="DataSource-Metrics"><a href="#DataSource-Metrics" class="headerlink" title="DataSource Metrics"></a>DataSource Metrics</h6><p>自动配置启用对所有可用 <code>DataSource</code> 对象的检测,其metrics 以 <code>jdbc.connections</code> 为前缀.数据源检测会产生表示池中当前活动,空闲,最大允许和最小允许连接的仪表.</p>
<p>Metrics 也由基于 bean 名称计算得出的 <code>DataSource</code> 的名称标记.</p>
<blockquote>
<p>建议:</p>
<p>​    默认情况下,Spring Boot 为所有支持的数据源提供元数据； 如果最喜欢的数据源不支持开箱即用,可以添加额外的 <code>DataSourcePoolMetadataProvider</code>bean. 有关示例,请参阅 <code>DataSourcePoolMetadataProvidersConfiguration</code>.</p>
</blockquote>
<p>此外,特定于 Hikari 的metrics以 <code>hikaricp</code> 前缀公开. 每个指标都由池的名称标记(可以用 <code>spring.datasource.name</code> 控制).</p>
</li>
<li><h6 id="Hibernate-Metrics"><a href="#Hibernate-Metrics" class="headerlink" title="Hibernate Metrics"></a>Hibernate Metrics</h6><p>如果 <code>org.hibernate:hibernate-micrometer</code> 在类路径上,则所有启用了统计信息的可用 Hibernate <code>EntityManagerFactory</code> 实例都使用名为 <code>hibernate</code> 的metric 进行检测.</p>
<p>Metrics 也由从 bean 名称派生的 <code>EntityManagerFactory</code> 的名称标记.</p>
<p>要启用统计信息,标准 JPA 属性 <code>hibernate.generate_statistics</code> 必须设置为 <code>true</code>. 可以在自动配置的 <code>EntityManagerFactory</code> 上启用它,如以下示例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jpa.properties[hibernate.generate_statistics]</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Spring-Data-Repository-Metrics"><a href="#Spring-Data-Repository-Metrics" class="headerlink" title="Spring Data Repository Metrics"></a>Spring Data Repository Metrics</h6><p>自动配置启用检测,来检测所有对 Spring Data <code>Repository</code> 方法的调用.默认情况下,metrics生成的名称为 <code>spring.data.repository.invocations</code>.可以通过设置 <code>management.metrics.data.repository.metric-name</code> 属性来自定义名称.</p>
<p><code>Repository</code> 类和方法支持 <code>@Timed</code> 注解. 如果不想记录所有的 <code>Repository</code> 调用的metrics ,可以将 <code>management.metrics.data.repository.autotime.enabled</code> 设置为 <code>false</code> 并使用独有的 <code>@Timed</code> 注解.</p>
<p>默认情况下,存储库调用相关metrics标记有以下信息:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>repository</code></td>
<td>源 <code>Repository</code> 的简单类名.</td>
</tr>
<tr>
<td><code>method</code></td>
<td>被调用的 <code>Repository</code> 方法的名称.</td>
</tr>
<tr>
<td><code>state</code></td>
<td>结果状态(<code>SUCCESS</code>,<code>ERROR</code>,<code>CANCELED</code> 或<code>RUNNING</code>).</td>
</tr>
<tr>
<td><code>exception</code></td>
<td>从调用中抛出的任何异常的简单类名.</td>
</tr>
</tbody></table>
<p>要替换默认标签,请提供一个实现 <code>RepositoryTagsProvider</code> 的 <code>@Bean</code>.</p>
</li>
<li><h6 id="RabbitMQ-Metrics"><a href="#RabbitMQ-Metrics" class="headerlink" title="RabbitMQ Metrics"></a>RabbitMQ Metrics</h6><p>自动配置将使用名为 <code>rabbitmq</code> 的metric,从而来启用所有可用 RabbitMQ 连接工厂的instrumentation.</p>
</li>
<li><h6 id="Spring-Integration-Metrics"><a href="#Spring-Integration-Metrics" class="headerlink" title="Spring Integration Metrics"></a>Spring Integration Metrics</h6><p>只要 <code>MeterRegistry</code> bean 可用,Spring Integration 就会自动提供 Micrometer 支持. Metrics 发布在 <code>spring.integration.</code> 下meter name名.</p>
</li>
<li><h6 id="Kafka-Metrics"><a href="#Kafka-Metrics" class="headerlink" title="Kafka Metrics"></a>Kafka Metrics</h6><p>自动配置会分别为自动配置的consumer factory和producer factory注册一个 <code>MicrometerConsumerListener</code> 和 MicrometerProducerListener<code>.还将为</code>StreamsBuilderFactoryBean<code>注册一个</code>KafkaStreamsMicrometerListener`.</p>
</li>
<li><h6 id="MongoDB-Metrics"><a href="#MongoDB-Metrics" class="headerlink" title="MongoDB Metrics"></a>MongoDB Metrics</h6><h6 id="Command-Metrics"><a href="#Command-Metrics" class="headerlink" title="Command Metrics"></a>Command Metrics</h6><p>自动配置将向自动配置的 <code>MongoClient</code> 注册一个 <code>MongoMetricsCommandListener</code>.</p>
<p>为将命令发送给 MongoDB 的底层驱动,会创建一个名为 <code>mongodb.driver.commands</code> 的计时器metric .默认情况下,每个metric 都标有以下信息:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>command</code></td>
<td>发出的命令名称</td>
</tr>
<tr>
<td><code>cluster.id</code></td>
<td>命令被发送到的集群的标识符</td>
</tr>
<tr>
<td><code>server.address</code></td>
<td>命令发送到的服务器地址</td>
</tr>
<tr>
<td><code>status</code></td>
<td>命令的结果 - (<code>SUCCESS</code>, <code>FAILED</code>) 之一</td>
</tr>
</tbody></table>
<p>要替换默认metric标签,定义一个 <code>MongoCommandTagsProvider</code> bean,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommandTagsProviderConfiguration</span> </span>&#123;    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> MongoCommandTagsProvider <span class="title">customCommandTagsProvider</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> CustomCommandTagsProvider();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>要禁用自动配置的command metrics,请设置以下属性:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.mongo.command.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<h6 id="Connection-Pool-Metrics"><a href="#Connection-Pool-Metrics" class="headerlink" title="Connection Pool Metrics"></a>Connection Pool Metrics</h6><p>自动配置将向自动配置的 <code>MongoClient</code> 注册一个 <code>MongoMetricsConnectionPoolListener</code>.</p>
<p>为连接池创建了以下仪表metrics :</p>
<ul>
<li><code>mongodb.driver.pool.size</code> 报告连接池的当前大小,包括空闲和使用中的成员</li>
<li><code>mongodb.driver.pool.checkedout</code> 报告当前使用的连接数</li>
<li><code>mongodb.driver.pool.waitqueuesize</code> 报告池中连接的等待队列的当前大小</li>
</ul>
<p>默认情况下,每个metric 都标有以下信息:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>cluster.id</code></td>
<td>连接池对应的集群标识</td>
</tr>
<tr>
<td><code>server.address</code></td>
<td>连接池对应的服务器地址</td>
</tr>
</tbody></table>
<p>要替换默认metric 标签,定义一个 <code>MongoConnectionPoolTagsProvider</code> bean,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConnectionPoolTagsProviderConfiguration</span> </span>&#123;    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> MongoConnectionPoolTagsProvider <span class="title">customConnectionPoolTagsProvider</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> CustomConnectionPoolTagsProvider();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>要禁用自动配置的连接池metrics,设置以下属性:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.mongo.connectionpool.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="Timed-注解支持"><a href="#Timed-注解支持" class="headerlink" title="@Timed 注解支持"></a>@Timed 注解支持</h6><p><code>io.micrometer.core.annotation</code> 包中的<code>@Timed</code> 注解可以与上面列出的几种支持的技术一起使用.如果支持,注解可以在类级别或方法级别使用.</p>
<p>例如,以下代码显示了如何使用注解来检测 <code>@RestController</code> 中的所有请求映射:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="meta">@Timedpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;    <span class="meta">@GetMapping(&quot;/api/addresses&quot;)</span>    <span class="function"><span class="keyword">public</span> List&lt;Address&gt; <span class="title">listAddress</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> ...    &#125;    <span class="meta">@GetMapping(&quot;/api/people&quot;)</span>    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">listPeople</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> ...    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果只想检测单个映射,则可以在方法上使用注解而不是类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;    <span class="meta">@GetMapping(&quot;/api/addresses&quot;)</span>    <span class="function"><span class="keyword">public</span> List&lt;Address&gt; <span class="title">listAddress</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> ...    &#125;    <span class="meta">@GetMapping(&quot;/api/people&quot;)</span>    <span class="meta">@Timed</span>    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">listPeople</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> ...    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果想更改特定方法的计时细节,还可以组合类级别和方法级别的注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="meta">@Timedpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;    <span class="meta">@GetMapping(&quot;/api/addresses&quot;)</span>    <span class="function"><span class="keyword">public</span> List&lt;Address&gt; <span class="title">listAddress</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> ...    &#125;    <span class="meta">@GetMapping(&quot;/api/people&quot;)</span>    <span class="meta">@Timed(extraTags = &#123; &quot;region&quot;, &quot;us-east-1&quot; &#125;)</span>    <span class="meta">@Timed(value = &quot;all.people&quot;, longTask = true)</span>    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">listPeople</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> ...    &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    带有 <code>longTask = true</code> 的 <code>@Timed</code> 注解将为该方法启用长任务计时器.长任务计时器需要单独的metric名称,并且可以与短任务计时器堆叠.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="注册自定义Metrics"><a href="#注册自定义Metrics" class="headerlink" title="注册自定义Metrics"></a>注册自定义Metrics</h6><p>要注册自定义指标,请将 <code>MeterRegistry</code> 注入组件,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MeterRegistry registry)</span> </span>&#123;        <span class="keyword">this</span>.dictionary = Dictionary.load();        registry.gauge(<span class="string">&quot;dictionary.size&quot;</span>, Tags.empty(), <span class="keyword">this</span>.dictionary.getWords().size());    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果metrics依赖于其他 bean,建议使用 <code>MeterBinder</code> 来注册它们,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMeterBinderConfiguration</span> </span>&#123;    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> MeterBinder <span class="title">queueSize</span><span class="params">(Queue queue)</span> </span>&#123;        <span class="keyword">return</span> (registry) -&gt; Gauge.builder(<span class="string">&quot;queueSize&quot;</span>, queue::size).register(registry);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>MeterBinder</code> 可确保设置正确的依赖关系,并且在检索metric’值时,该 bean 可用.如果发现跨组件或应用重复检测一组metrics ,则 <code>MeterBinder</code> 实现也很有用.</p>
<blockquote>
<p>注意:</p>
<p>​    默认情况下,来自所有 <code>MeterBinder</code> bean 的metric将自动绑定到 Spring 管理的 <code>MeterRegistry</code>.</p>
</blockquote>
</li>
<li><h6 id="自定义单个Metrics"><a href="#自定义单个Metrics" class="headerlink" title="自定义单个Metrics"></a>自定义单个Metrics</h6><p>如果需要将自定义应用到特定 <code>Meter</code> 实例,可以使用 <code>io.micrometer.core.instrument.config.MeterFilter</code> 接口.</p>
<p>例如,如果要将所有以 <code>com.example</code> 开头的仪表 ID 的 <code>mytag.region</code> tag重命名为 <code>mytag.area</code>,则可以执行以下操作:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetricsFilterConfiguration</span> </span>&#123;    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> MeterFilter <span class="title">renameRegionTagMeterFilter</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> MeterFilter.renameTag(<span class="string">&quot;com.example&quot;</span>, <span class="string">&quot;mytag.region&quot;</span>, <span class="string">&quot;mytag.area&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    默认情况下,所有 <code>MeterFilter</code> bean 将自动绑定到 Spring 管理的 <code>MeterRegistry</code>.确保使用 Spring 管理的 <code>MeterRegistry</code> 注册自己的metrics,而不是使用 <code>Metrics</code> 上的任何静态方法.这些使用非 Spring 管理的全局registry.</p>
</blockquote>
<ol>
<li><h6 id="Common-Tags"><a href="#Common-Tags" class="headerlink" title="Common Tags"></a>Common Tags</h6><p>常用标签一般用于对主机,实例,区域,堆栈等操作环境进行维度进行深度探讨.Commons 标签适用于所有meters,可以按照以下示例进行配置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.tags.region</span>=<span class="string">us-east-1management.metrics.tags.stack=prod</span></span><br></pre></td></tr></table></figure>

<p>上面的示例分别为所有值为 <code>us-east-1</code> 和 <code>prod</code> 的meter添加了 <code>region</code> 和 <code>stack</code> 标签.</p>
<blockquote>
<p>注意:</p>
<p>​    如果使用 Graphite,公共标签的顺序很重要.由于使用这种方法无法保证常用标签的顺序,建议 Graphite 用户定义自定义 <code>MeterFilter</code>.</p>
</blockquote>
</li>
<li><h6 id="Per-meter-Properties"><a href="#Per-meter-Properties" class="headerlink" title="Per-meter Properties"></a>Per-meter Properties</h6><p>除了 <code>MeterFilter</code> bean,还可以使用属性在每个meter的基础上应用有限的自定义.每个meter自定义适用于任何以给定名称开头的所有meter ID.例如,以下将禁用 ID 以 <code>example.remote</code> 开头的所有meter.</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.metrics.enable.example.remote</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>以下属性允许单一meter自定义:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>management.metrics.enable</code></td>
<td>是否拒绝仪表发出任何指标.</td>
</tr>
<tr>
<td><code>management.metrics.distribution.percentiles-histogram</code></td>
<td>是否发布适用于计算可聚合(跨维度)百分位数近似值的直方图.</td>
</tr>
<tr>
<td><code>management.metrics.distribution.minimum-expected-value</code>, <code>management.metrics.distribution.maximum-expected-value</code></td>
<td>通过限制预期值的范围来发布更少的直方图桶.</td>
</tr>
<tr>
<td><code>management.metrics.distribution.percentiles</code></td>
<td>发布在您的应用程序中计算的百分位值</td>
</tr>
<tr>
<td><code>management.metrics.distribution.slo</code></td>
<td>使用由您的服务级别目标定义的存储桶发布累积直方图.</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><h6 id="Metrics-Endpoint"><a href="#Metrics-Endpoint" class="headerlink" title="Metrics Endpoint"></a>Metrics Endpoint</h6><p>Spring Boot 提供了一个<code>metrics</code>endpoint,可用于诊断检查应用程序收集的metrics.endpoint默认不可用,必须公开,公开后才可以使用.</p>
<p>导航到 <code>/actuator/metrics</code> 会显示可用meter名的列表.可以将名称作为选择器来深入查看有关meter的信息,例如 <code>/actuator/metrics/jvm.memory.max</code>.</p>
<blockquote>
<p>建议:</p>
<p>​    在此处使用的名称应该与代码中使用的名称相匹配,而不是为监视系统而进行命名约定规范化后所得到的名称.换句话说,如果 <code>jvm.memory.max</code> 在 Prometheus 中显示为 <code>jvm_memory_max</code> 因为它的蛇形命名规范,在检查metricsendpoint中的meter时,仍然应该使用 <code>jvm.memory.max</code> 作为选择器.</p>
</blockquote>
<p>还可以将任意数量的 <code>tag=KEY:VALUE</code> 查询参数添加到 URL 的末尾,以按维度向下获取仪表,例如 <code>/actuator/metrics/jvm.memory.max?tag=area:nonheap</code>.</p>
<blockquote>
<p>建议:</p>
<p>​    报告的测量值是与meter name和标签匹配的所有meters的统计数据的总和.所以在上面的例子中,返回的”Value”统计信息是堆的”Code Cache”,”Compressed Class Space”和”Metaspace”区域的最大内存占用的总和.如果只想查看”Metaspace”的最大值,可以添加一个额外的 <code>tag=id:Metaspace</code>,即 <code>/actuator/metrics/jvm.memory.max?tag=area:nonheap&amp;tag=id:Metaspace</code>.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>3.2 Feature: 外部化配置</title>
    <url>/posts/45157.html</url>
    <content><![CDATA[<h5 id="外部化配置"><a href="#外部化配置" class="headerlink" title="外部化配置"></a>外部化配置</h5><ol start="2">
<li><h5 id="外部化配置-1"><a href="#外部化配置-1" class="headerlink" title="外部化配置"></a>外部化配置</h5>​    Spring Boot允许外部化配置,这样就可以让同一份代码运行在不同环境上.可以使用很多外部配置源,包括Java属性配置文件,YAML文件,环境变量和命令行参数.<br>​    属性值可以直接使用 <code>@Value</code>注入,可以通过Spring的<code>Environment</code>获取,或者通过<code>@ConfigurationProperties</code>绑定到结构化文件中.<br>​    Spring Boot使用一个非常特殊的<code>PropertySource</code>顺序,从而能够合理地覆盖属性值.配置按照如下顺序考虑(靠下元素的值覆盖靠上元素的值):<ol>
<li>默认配置(由指定<code>SpringApplication.setDefaultProperties</code>的)</li>
<li>在<code>@Configuration</code>配置类上的<code>@PropertySource</code>导入的属性.<br>要注意,这样的属性源只有在应用上下文刷新过后,才会被加入<code>Environment</code>中. 对于一些特定的属性来说,这个时间点配置的太晚了.(比如<code>logging.*</code>和<code>spring.main.*</code>都是在刷新开始前读取的)</li>
<li>配置数据(比如<code>application.properties</code>文件)</li>
<li>只有<code>random.*</code>属性的<code>RandomValuePropertySource</code>源</li>
<li>系统环境变量</li>
<li>Java系统变量(<code>System.getProperties()</code>)</li>
<li>来自<code>java:comp/env</code>的属性</li>
<li><code>ServletContext</code>的初始化参数</li>
<li><code>ServletConfig</code>初始化参数</li>
<li>来自<code>SPRING_APPLICATION_JSON</code>的属性(嵌入到环境变量或系统属性中的内联JSON)</li>
<li>命令行参数</li>
<li>测试中的<code>properties</code>属性</li>
<li>测试上的<code>@TestPropertySource</code>注解</li>
<li>开启devtools 时,<code>$HOME/.config/spring-boot</code>目录下的DevTools的全局配置.<br>配置数据文件按照如下顺序:</li>
<li>打包在jar中的应用配置(<code>application.properties</code>和YAML变量)</li>
<li>打包在jar中的指定profile的应用配置文件(<code>application-&#123;profile&#125;.properties</code>和YAML变量)</li>
<li>在打包jar外的应用配置(<code>application.properties</code>和YAML变量)</li>
<li>在打包jar外的指定profile的应用配置文件(<code>application-&#123;profile&#125;.properties</code>和YAML变量)<blockquote>
<p>注意:</p>
<p>建议在整个应用中,使用一种形式的配置.如果在同样的位置同时有<code>.properties</code>和<code>.yml</code>格式的文件,<code>.properties</code>的配置优先.<br>​    提供一个具体的例子,假设正在开发一个<code>@Componet</code>, 使用一个<code>name</code>属性,如下所示:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span>    <span class="keyword">private</span> String name;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>
​    在应用的classpth中(比如在jar中),有一个<code>application.properties</code>,提供了一个<code>name</code>的合理的默认值. 当运行在一个新的环境中,可以在jar的外部提供一个<code>application.properties</code>来覆盖默认的<code>name</code>.对于一次性测试,可以使用特定的命令行参数来切换(比如,<code>java -jar app.jar --name=&quot;Spring&quot;</code>)<blockquote>
<p>建议:</p>
<p>​    <code>env</code>和<code>configprops</code>端点在确定为什么一个属性值是特定的值得时候会很有用.可以使用这两端点去诊断不再预期内的值.</p>
</blockquote>
</li>
<li><h6 id="访问命令行参数"><a href="#访问命令行参数" class="headerlink" title="访问命令行参数"></a>访问命令行参数</h6>​    默认情况下,<code>SpringApplication</code>会把所有的命令行选项参数转换成<code>property</code>并添加到Spring的<code>Environment</code>中.命令行选项参数就是是以<code>--</code>开头的,比如<code>--server.port=9000</code>. 就像之前提到的,命令行参数总是优先于文件属性源.<br>​    如果不想将命令行属性添加到<code>Environment</code>中,可以使用<code>SpringApplication.setAddCommandLineProperties(false)</code>来禁用.</li>
<li><h5 id="JSON应用参数"><a href="#JSON应用参数" class="headerlink" title="JSON应用参数"></a>JSON应用参数</h5>​    环境变量和系统变量经常会有很多限制,这意味着有一些属性名不能使用.为了应对这种情况,<br>Spring Boot允许将属性编码成单个JSON结构.<br>​    当应用启动时,所有的<code>spring.application.json</code>或者<code>SPRING_APPLICATION_JSON</code>属性都会被解析,并且添加到<code>Environment</code>.<br>​    比如,在UN*X shell中,可以将在命令行<code>SPRING_APPLICATION_JSON</code>作为环境变量提供.如下:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> SPRING_APPLICATION_JSON=<span class="string">&#x27;&#123;&quot;my&quot;:&#123;&quot;name&quot;:&quot;test&quot;&#125;&#125;&#x27;</span> java -jar myapp.jar</span></span><br></pre></td></tr></table></figure>
在之前的例子中,在Spring<code>Environment</code>中以<code>my.name=test</code>结尾.使用JSON同样也可以作为系统变量提供.如下:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -Dspring.application.json=<span class="string">&#x27;&#123;&quot;my&quot;:&#123;&quot;name&quot;:&quot;test&quot;&#125;&#125;&#x27;</span> -jar myapp.jar</span></span><br></pre></td></tr></table></figure>
或者可以将使用命令行参数,提供JSON<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myapp.jar --spring.application.json=<span class="string">&#x27;&#123;&quot;my&quot;:&#123;&quot;name&quot;:&quot;test&quot;&#125;&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure>
如果将应用部署到传统的应用服务器上,可以使用叫做<code>java:comp/env/spring.application.json</code>的JNDI变量<blockquote>
<p>注意:</p>
<p>​    尽管JSON中的<code>null</code>会被添加到属性源中,但是<code>PropertySourcesPropertyResolver</code>将<code>null</code>当做一个不存的值.这意味着在更低顺序的JSON属性源不会用<code>null</code>去覆盖已有属性.</p>
</blockquote>
</li>
<li><h5 id="外部应用属性"><a href="#外部应用属性" class="headerlink" title="外部应用属性"></a>外部应用属性</h5>​    当应用启动时,Spring Boot会从以下目录中,自动找到并加载<code>application.properties</code>和<code>application.yaml</code>文件.<ol>
<li>classpath根路径</li>
<li>classpath下的<code>/config</code>包</li>
<li>当前路径</li>
<li>当年目录中的<code>/config</code>子目录</li>
<li><code>/ config</code>子目录的直接子目录<br>以上按照优先级排序(数字小的条目覆盖前面的).来自加载文件的文档作为<code>PropertySources</code>添加到Spring的<code>Environment</code>.<br>​    如果不喜欢<code>application</code>作为配置文件名,可以使用<code>spring.config.name</code>环境属性来更改文件名.也可以使用<code>spring.config.location</code>显式应用环境属性(这是目录位置或文件路径的逗号分隔列表).下面的例子展示如何指定一个不同的名字.<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myproject.jar --spring.config.name=myproject</span></span><br></pre></td></tr></table></figure>
下面例子展示,如何指定两个路径:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myproject.jar --spring.config.location=\</span></span><br><span class="line"><span class="bash">    optional:classpath:/default.properties,\</span></span><br><span class="line"><span class="bash">    optional:classpath:/override.properties</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    如果这些目录是可选的,而并不要求 一定存在,那么可以使用使用<code>optional:</code>前缀.</p>
<p>警告:</p>
<p>​    <code>spring.config.name</code>,<code>spring.config.location</code>,<code>spring.config.additional-location</code>在很早时候就用指定载入那些文件. 这些必须被定义为环境变量属性(通常为系统环境变量,系统属性,或者命令行参数.)<br>如果<code>spring.config.location</code>包含目录(相对于文件),目录必须以<code>/</code>或者取决于系统的<code>File.separator</code>结尾. 在运行时,加载前,将会依照<code>spring.config.name</code>生成的名称来加载这些文件.  如果<code>spring.config.location</code>含有文件,那么就按照原样使用.<br>无论是直接指定还是放到目录中,文件引用必须包含文件扩展名. 最典型的开箱即用的扩展名是<code>.properties</code>,<code>.yaml</code>,<code>.yml</code>.<br>当指定了多个文件领,后面一个可以覆盖前一个的值.<br>通过<code>spring.config.location</code>配置的路径可以覆盖默认的路径.比如,<code>spring.config.location</code>配置是<code>optional:classpath:/custom-config/,optional:file:./custom-config/</code>,完整路径应该是下面这样的:</p>
</blockquote>
</li>
<li><code>optional:classpath:custom-config/</code></li>
<li><code>optional:file:./custom-config/</code><br>如果想要选择添加额外路径,而不是替换原有的,可以使用<code>spring.config.additional-location</code>. 来自其他目录的属性文件可以覆盖默认的路径.比如,如果<code>spring.config.additional-location</code>配置的值是<code>optional:classpath:/custom-config/,optional:file:./custom-config/</code>.那么完整的路径应该是下面这样:</li>
<li><code>optional:classpath:</code></li>
<li><code>optional:classpath:/config/</code></li>
<li><code>optional:file:./</code></li>
<li><code>optional:file:./config/</code></li>
<li><code>optional:file:./config/*/</code></li>
<li><code>optional:classpath:custom-config/</code> (additional-location)</li>
<li><code>optional:file:./custom-config/</code> (additional-location)<br>这个搜索路径能够允许开发真,在一个配置文件中指定默认值, 然后在其他的配置文件中有选择地覆盖特定值.可以在一个默认路径中,使用<code>application.properties</code>(或者其他的通过<code>spring.config.name</code>指定的默认值)为应用提供默认值.这些默认值可以在运行时被自定义的目录中的其他配置文件覆盖.<blockquote>
<p>注意:</p>
<p>​    如果使用的是环境变量而不是系统变量, 大多数操作系统不允许句点分割的key,但是可以使用下划线来替代(比如使用<code>SPRING_CONFIG_NAME</code>而不是<code>spring.config.name</code>).</p>
<p>注意:</p>
<p>​    如果应用是运行在servlet容器或者 应用服务器上,可以使用JNDI配置(在目录<code>java:comp/env</code>)或者servlet容器初始化参数,也可以使用系统变量或者环境变量.</p>
</blockquote>
</li>
<li><h6 id="可选路径"><a href="#可选路径" class="headerlink" title="可选路径"></a>可选路径</h6>默认情况下,如果指定的配置数据文件位置不存在,Spring Boot会抛出<code>ConfigDataLocationNotFoundException</code>异常,应用也不会启动.<br>如果想要指定路径,但是有不介意这个路径是否存在,可以使用<code>optional:</code>前缀.可以在<code>spring.config.location</code>和<code>spring.config.additional-location</code>中指定前缀,同样的在<code>spring.config.import</code>中也可以使用.<br>比如,在启动时,<code>spring.config.import</code>有值<code>optional:file:./myconfig.properties</code>,文件<code>myconfig.properties</code>不需要一定存在.<br>如果想要忽略所有的<code>ConfigDataLocationNotFoundExceptions</code>,并且想要继续启动应用,可以使用<code>spring.config.on-not-found</code>属性,将值设置为<code>ignore</code>. 或者使用 <code>SpringApplication.setDefaultProperties(…)</code>设置或者使用系统系统/环境边浪.</li>
<li><h6 id="带有通配符路径"><a href="#带有通配符路径" class="headerlink" title="带有通配符路径"></a>带有通配符路径</h6>如果过一个文件路径的最后部分包含<code>*</code>符号,会被认为是一个带有通配符的路径.当载入配置时,统配符会被展开,所有的子路径都会被检查.当有多个配置源,又在一些环境中,比如Kubernetes 中,带有通配符的路径将会非常有用.<br>比如,应用中有Redis和MySQL配置,可能回想将两个部分的配置分开来.,同时要求这两个都存在于<code>application.properties</code>文件中.这样就导致了从两个两个路径挂载的,两个独立的的<code>application.properties</code>,比如<code>/config/redis/application.properties</code>,<code>/config/mysql/application.properties</code>.在这个例子中,可以使用带有同通配符的路径<code>config/*/</code>,这样的话,两个路径中的文件都会被处理.<br>默认情况下,在默认搜索路径中,Spring Boot包含了<code>config/*/</code>.这意味着,在jar的外部,<code>/config</code>的所有子目录都会被搜索.<br>在<code>spring.config.location</code>和<code>spring.config.additional-location</code>属性中使用带有通配符的路径.<blockquote>
<p>注意:</p>
<p>​    带有通配符的路径只能够有一个<code>*</code>.或者检索目录形式的<code>/*</code>.或者搜索文件形式的<code>*/&lt;filename&gt;</code>. 带通配符的路径将会根据文件名的绝对路径按字母顺序排序。</p>
<p>建议:</p>
<p>​    带有通配符的路径只能够在外部文件夹使用.在<code>classpath:</code>路径下,不能够使用.</p>
</blockquote>
</li>
<li><h6 id="指定profile的文件-Profile-Specific-Files"><a href="#指定profile的文件-Profile-Specific-Files" class="headerlink" title="指定profile的文件(Profile Specific Files)"></a>指定profile的文件(Profile Specific Files)</h6>像加载应用的属性文件一样,Spring Boot也会按照<code>application-&#123;profile&#125;</code>的规约那样去加载指定profile的配置文件. 比如,如果应用想要使用YAML文件指定了一个叫做<code>prod</code>的profile,那么使用<code>application.yml</code>和<code>application-prod.yml</code>都可以.<br>指定proflie配置文件加载位置和<code>application.properties</code>相同,并且指定profile的配置会没有指定profile的配置. 入股指定了多个profile,最后被应用的会覆盖所有的.比如<code>spring.profiles.active</code>启用了<code>prod,live</code>两个profile,那么<code>application-prod.properties</code>中的值会被<code>application-live.properties</code>中对应的值覆盖.<br><code>Environment</code>有默认的profile(默认叫做<code>[default]</code>),如果没有启用profile,那么会默认使用这个profile.换句话说,没有显式激活profile,那么会使用<code>application-default</code>中的配置.<blockquote>
<p>注意:</p>
<p>​    配置文件只会被加载一次.如果已经直接导入(<code>spring.config.import</code>)了一个指定profile的配置文件,那么它不会再次导入.</p>
</blockquote>
</li>
<li><h6 id="导入其他配置-Importing-Additional-Data"><a href="#导入其他配置-Importing-Additional-Data" class="headerlink" title="导入其他配置( Importing Additional Data)"></a>导入其他配置( Importing Additional Data)</h6>使用<code>spring.config.import</code>能够让应用导入其他位置的更多的配置数据. Spring Boot发现配置了导入之后,就会进行处理, 会立即在声明导入的下面将导入的文档直接插入.<br>比如可以在classpath中的<code>application.properties</code>的文件如下:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">myapp</span></span><br><span class="line"><span class="meta">spring.config.import</span>=<span class="string">optional:file:./dev.properties</span></span><br></pre></td></tr></table></figure>
这样会触发在当前目录下面导入<code>dev.properties</code>(如果文件存在的话).<code>dev.properties</code>的配置的值将会优先于触发导入的文件.在上面的例子中,<code>dev.properties</code>可以指定定义<code>spring.application.name</code>为不同的值.无论声明多少次,导入只会被执行一次.在properties / yaml文件中的单个文档中定义导入的顺序无关紧要.比如,下面的的两个例子实际是一样:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.config.import</span>=<span class="string">my.properties</span></span><br><span class="line"><span class="meta">my.property</span>=<span class="string">value</span></span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.property</span>=<span class="string">value</span></span><br><span class="line"><span class="meta">spring.config.import</span>=<span class="string">my.properties</span></span><br></pre></td></tr></table></figure>
在上面的两个例子中,<code>my.properties</code>文件将会优先于触发导入的文件.<br>使用<code>spring.config.import</code>可以指定多个路径. 路径的载入顺序和定义顺序保持一致,后导入的优先.<blockquote>
<p>建议:</p>
<p>​    Spring Boot包含可插拔式接口,能够支持多个不同的路径地址.默认情况下,可以导入Java配置文件,YAML和配置树.</p>
<p>​    第三方jar包可以提供额外的功能支持(不要求文件是本地的).比如,配置文件从外部仓库中入到,类似Consul, Apache ZooKeeper 或者 Netflix Archaius..</p>
<p>​    如果想要支持自己的路径,可以参照<code>org.springframework.boot.context.config</code>包下的<code>ConfigDataLocationResolver</code>和<code>ConfigDataLoader</code>类.</p>
</blockquote>
</li>
<li><h6 id="导入无扩展名的文件-Importing-Extensionless-Files"><a href="#导入无扩展名的文件-Importing-Extensionless-Files" class="headerlink" title="导入无扩展名的文件(Importing Extensionless Files)"></a>导入无扩展名的文件(Importing Extensionless Files)</h6>有些云平台不支持在挂载文件上添加扩展名.导入这些没有扩展名的文件,需要给Spring Boot一些提示,让Spring Boot知道该如何去加载.可以将将扩展名提示放到<code>[]</code>中.<br>比如,想要将<code>/etc/config/myconfig</code>文件当做yaml导入.可以在<code>application.properties</code>中,使用下面的方式导入:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.config.import</span>=<span class="string">file:/etc/config/myconfig[.yaml]</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="使用配置树-Using-Configuration-Trees"><a href="#使用配置树-Using-Configuration-Trees" class="headerlink" title="使用配置树( Using Configuration Trees)"></a>使用配置树( Using Configuration Trees)</h6>在一些云平台(比如 Kubernetes)运行应用时,经常需要读取平台提供的配置.如果出于上述目的使用环境变量并不是一个常用的办法,这回有一些缺点,尤其是一些值是很民管的数据,比如密码.<br>作为替代环境变量的一种可选方式,很多云平台允许将配置映射到挂载的数据卷中.例如，Kubernetes可以批量安装ConfigMap和Secrets.<br>有两种常用的卷挂载方式:<ol>
<li>一个单独的配置文件,包含很多属性配置(一般使用YAML)</li>
<li>多个文件被写到一个树形目录中,文件名变成key,内容变成value.<br>对于第一种方式,可以直接使用<code>spring.config.import</code>导入YAML或者properties.对于第二种方式,可以使用<code>configtree</code>前缀, 使用该前缀时,Spring Boot知道需要将所有的文件都用作成properties.<br>比如,Kubernetes 如下挂载卷:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">etc/</span><br><span class="line">  config/</span><br><span class="line">    myapp/</span><br><span class="line">      username</span><br><span class="line">      password</span><br></pre></td></tr></table></figure>
文件<code>username</code>的内容应该是一个配置值,<code>password</code>文件内容应该是口令.<br>可以在<code>application.properties</code>或者<code>application.yaml</code>中导入这些属性:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.config.import</span>=<span class="string">optional:configtree:/etc/config/</span></span><br></pre></td></tr></table></figure>
然后就可以像平常一样,从<code>Environment</code>中访问或者注入<code>myapp.username</code>和<code>myapp.password</code>的值.<blockquote>
<p>建议:</p>
<p>​    也可以按照内容需要,将配置树的值同时绑定到<code>String</code>和<code>byte[]</code>类型.<br>如果在同一个父级目录下,有多个配置树需要导入,可以使用通配符的方式导入.以<code>/*/</code>结尾的<code>configtree:</code>路径,会导入所有的直接子目录为配置树.<br>比如,下面的卷:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">etc/</span><br><span class="line">  config/</span><br><span class="line">    dbconfig/</span><br><span class="line">      db/</span><br><span class="line">        username</span><br><span class="line">        password</span><br><span class="line">    mqconfig/</span><br><span class="line">      mq/</span><br><span class="line">        username</span><br><span class="line">        password</span><br></pre></td></tr></table></figure>
可以使用<code>configtree:/etc/config/*/</code>作为导入路径.<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.config.import</span>=<span class="string">optional:configtree:/etc/config/*/</span></span><br></pre></td></tr></table></figure>
这样就会增加<code>db.username</code>,<code>db.password</code>,<code>mq.username</code>, <code>mq.password</code>属性.<blockquote>
<p>注意:</p>
<p>​    使用统配符导入的路径会以字符排序. 如果需要不同的排序方式,则应将每个位置列为单独的导入.<br>配置树也可以用来配置Docker的口令.当Docker群集服务被授予对口令的访问权限时，该口令将安装到容器中.比如,如果叫做<code>db.password</code>的口令别挂载到<code>/run/secrets/</code>位置上,可以使用下面的方式来讲<code>db.password</code>添加到Spring environment中.</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.config.import</span>=<span class="string">optional:configtree:/run/secrets/</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="属性占位符-Property-Placeholders"><a href="#属性占位符-Property-Placeholders" class="headerlink" title="属性占位符( Property Placeholders)"></a>属性占位符( Property Placeholders)</h5><code>application.properties</code>和<code>application.yml</code>中的值在使用的时候,会被先有的<code>Environment</code>过滤,所以可以引用之前定义过得值(比如,来自系统属性). 标准的<code>$ &#123;name&#125;</code>属性-占位符语法可以在值中的任何位置使用.<br>举个例子,比如想要将下面文件的<code>app.description</code>设置为<code>MyApp is a Spring Boot application</code>:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="meta">app.description</span>=<span class="string">$&#123;app.name&#125; is a Spring Boot application</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    您还可以使用此技术来创建现有Spring Boot属性的“简短”变体。有关详细信息，请参见howto.html操作方法。</p>
</blockquote>
</li>
<li><h6 id="处理多文档文件-Working-with-Multi-Document-Files"><a href="#处理多文档文件-Working-with-Multi-Document-Files" class="headerlink" title="处理多文档文件(Working with Multi-Document Files)"></a>处理多文档文件(Working with Multi-Document Files)</h6>Spring Boot允许将一个物理文档分割成多个逻辑文档,每个逻辑文档独立添加.文档按照从上到下的顺序处理.后面的文档属性可以覆盖前面的.<br>对于<code>application.yml</code>文件,可以使用标准的YAML多个文档符号.三个连续的短横杠<code>---</code>表示是一个文档的结尾,也是另一个文档的开头.<br>比如,下面的文件,有两个逻辑文档:<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring.config.activate.on-cloud-platform:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">spring.application.name:</span> <span class="string">MyCloudApp</span></span><br></pre></td></tr></table></figure>
对于<code>application.properties</code>,使用一个特殊的注释<code>#---</code>来分割文档:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="meta">spring.config.activate.on-cloud-platform</span>=<span class="string">kubernetes</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">MyCloudApp</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    属性文件分隔符不得包含任何前导空格，并且必须恰好具有三个连字符。 分隔符之前和之后的行不得为注释。</p>
<p>建议:</p>
<p>​    多文档属性文件通常与激活属性（例如<code>spring.config.activate.on-profile</code>）结合使用</p>
<p>警告:</p>
<p>​    使用<code>@PropertySource</code>或<code>@TestPropertySource</code>批注无法加载多文档属性文件。</p>
</blockquote>
</li>
<li><h6 id="激活属性-Activation-Properties"><a href="#激活属性-Activation-Properties" class="headerlink" title="激活属性(Activation Properties)"></a>激活属性(Activation Properties)</h6>有时候,根据特定的条件,激活特定的属性值很有用.比如,当特定的<code>profile</code>激活时,想要激活相关的属性.<br>使用<code>spring.config.activate.*</code>可以根据条件激活属性文档.<br>有两个激活属性可用:<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>on-profile</td>
<td>符合<code>profile</code>表达式,才会激活文档</td>
</tr>
<tr>
<td>on-cloud-platform</td>
<td>符合<code>CloudPlatform</code>表达式,激活文档</td>
</tr>
<tr>
<td>比如,下面的例子,指定了第二个文档,只有当运行在Kubernetes,并且运行环境是<code>prod</code>或者<code>staging</code>的时候才会激活.</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">myprop</span>=<span class="string">always-set</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="meta">spring.config.activate.on-cloud-platform</span>=<span class="string">kubernetes</span></span><br><span class="line"><span class="meta">spring.config.activate.on-profile</span>=<span class="string">prod | staging</span></span><br><span class="line"><span class="attr">myotherprop</span>=<span class="string">sometimes-set</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="加密属性-Encrypting-Properties"><a href="#加密属性-Encrypting-Properties" class="headerlink" title="加密属性(Encrypting Properties)"></a>加密属性(Encrypting Properties)</h5>Spring Boot没有提供任何内置的支持加密属性值的支持,但是提供了一个必要回调函数点,可以修改Spring <code>Environment</code>中的值.<code>EnvironmentPostProcessor</code>可以允许在应用启动前修改<code>Environment</code>.<br>如果想要一种安全的方式来存储凭证和密码,Spring Cloud Vault项目提供了对在HashiCorp Vault中存储外部化配置的支持.</li>
<li><h5 id="使用YAML"><a href="#使用YAML" class="headerlink" title="使用YAML"></a>使用YAML</h5>YAML是JSON的超集,因此是一种用于指定层次结构配置数据的便捷格式.只要在类路径上具有SnakeYAML库，<code>SpringApplication</code>类就会自动支持YAML作为属性的替代方法。<blockquote>
<p>注意:</p>
<p>​    如果使用了”Starters”,在<code>spring-boot-starter</code>中会自动提供SnakeYAML .</p>
</blockquote>
<ol>
<li><h6 id="将YAML映射到属性-Mapping-YAML-to-Properties"><a href="#将YAML映射到属性-Mapping-YAML-to-Properties" class="headerlink" title="将YAML映射到属性(Mapping YAML to Properties)"></a>将YAML映射到属性(Mapping YAML to Properties)</h6><p>需要将YAML文档从其层次结构格式转换为可以与Spring Environment一起使用的平面结构.比如下面的YAML文档:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environments:</span></span><br><span class="line">  <span class="attr">dev:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://dev.example.com</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Developer</span> <span class="string">Setup</span></span><br><span class="line">  <span class="attr">prod:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://another.example.com</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">Cool</span> <span class="string">App</span></span><br></pre></td></tr></table></figure>
<p>为了能够从<code>Environment</code>中访问这些属性,需要铺平成如下格式:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">environments.dev.url</span>=<span class="string">https://dev.example.com</span></span><br><span class="line"><span class="meta">environments.dev.name</span>=<span class="string">Developer Setup</span></span><br><span class="line"><span class="meta">environments.prod.url</span>=<span class="string">https://another.example.com</span></span><br><span class="line"><span class="meta">environments.prod.name</span>=<span class="string">My Cool App</span></span><br></pre></td></tr></table></figure>
<p>同样的,YAML的列表也要平铺,它们用<code>[index]</code>解引用器表示为属性键.考虑下面的YAML:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line"> <span class="attr">servers:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dev.example.com</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">another.example.com</span></span><br></pre></td></tr></table></figure>

<p>上面会转换成下面:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.servers[0]</span>=<span class="string">dev.example.com</span></span><br><span class="line"><span class="meta">my.servers[1]</span>=<span class="string">another.example.com</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    使用<code>[index]</code>符号的属性应该使用Spring Boot的<code>binder</code>类来绑定到Java的<code>List</code>或者<code>Set</code>.</p>
<p>警告:</p>
<p>​    YAML文件不能够使用<code>@PropertySource</code>和<code>@TestPropertySource</code>注解加载.所以,如果想要使用注解导入,必须使用properties文件.</p>
</blockquote>
</li>
<li><h6 id="直接加载YAML-Directly-Loading-YAML"><a href="#直接加载YAML-Directly-Loading-YAML" class="headerlink" title="直接加载YAML(Directly Loading YAML)"></a>直接加载YAML(Directly Loading YAML)</h6><p>Spring Framework提供两个类来方便加载YAML文件.<code>YamlPropertiesFactoryBean</code>将YAML作为<code>Properties</code>加载.<code>YamlMapFactoryBean</code>将YAML作为<code>Map</code>记载.</p>
<p>如果想要baYAML作为Spring <code>PropertySource</code>,也可以使用<code>YamlPropertySourceLoader</code>类.</p>
</li>
</ol>
</li>
<li><h5 id="配置随机值-Configuring-Random-Values"><a href="#配置随机值-Configuring-Random-Values" class="headerlink" title="配置随机值(Configuring Random Values)"></a>配置随机值(Configuring Random Values)</h5> 在注入随机值时(比如到口令或者测试用例中),<code>RandomValuePropertySource</code>会很有用.可以获取整型,长整型,uuid,或者字符串类型.如下所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.secret</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="meta">my.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">my.bignumber</span>=<span class="string">$&#123;random.long&#125;</span></span><br><span class="line"><span class="meta">my.uuid</span>=<span class="string">$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">my.number-less-than-ten</span>=<span class="string">$&#123;random.int(10)&#125;</span></span><br><span class="line"><span class="meta">my.number-in-range</span>=<span class="string">$&#123;random.int[1024,65536]&#125;</span></span><br></pre></td></tr></table></figure>
<code>random.int*</code>的语法是<code>OPEN value (,max) CLOSE</code>.<code>OPEN,CLOSE</code>是任意字符,<code>value,max</code>是整型.如果<code>max</code>提供,那么<code>value</code>是最小值,<code>max</code>是最大值(最终结果不会包含最大值).</li>
<li><h5 id="配置系统环境属性-Configuring-System-Environment-Properties"><a href="#配置系统环境属性-Configuring-System-Environment-Properties" class="headerlink" title="配置系统环境属性(Configuring System Environment Properties)"></a>配置系统环境属性(Configuring System Environment Properties)</h5>Spring Boot支持给环境属性设置前缀.如果系统环境被多个不同配置的Spring Boot应用共享的话会有用.可以在<code>SpringApplication</code>直接设置系统环境属性.<br>比如,如果想要设置前缀是<code>input</code>,那么属性为<code>remote.timeout</code>将也会在系统环境中被解析成<code>input.remote.timeout</code>.</li>
<li><h6 id="类型安全的配置属性-Type-safe-Configuration-Properties"><a href="#类型安全的配置属性-Type-safe-Configuration-Properties" class="headerlink" title="类型安全的配置属性(Type-safe Configuration Properties)"></a>类型安全的配置属性(Type-safe Configuration Properties)</h6>使用<code>@Value(&quot;$&#123;property&#125;&quot;)</code>来注入配置有时候会非常麻烦,尤其是有多个配置文件,或则配置数据本来就是层级结构的.Spring Boot提供了另一种办法来使用配置,那就是使用一个强类型的bean来管理和验证应用的配置.<ol>
<li><h6 id="JavaBean属性绑定-JavaBean-properties-binding"><a href="#JavaBean属性绑定-JavaBean-properties-binding" class="headerlink" title="JavaBean属性绑定(JavaBean properties binding)"></a>JavaBean属性绑定(JavaBean properties binding)</h6>下面可声明并绑定JavaBean属性的一种方式:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters / setters...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.singleton(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getters / setters...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个POJO定义如下的属性:<ul>
<li><code>my.service.enabled</code>,默认值为false</li>
<li><code>my.service.remote-address</code>,可以从字符串强制转换的类型</li>
<li><code>my.service.security.username</code>,内嵌”sercurity”对象,名字由属性名决定.特别是，返回类型根本不使用，可能是<code>SecurityProperties</code>.</li>
<li><code>my.service.security.password</code></li>
<li><code>my.service.security.roles</code>,有一个<code>String</code>集合,默认值是<code>USET</code><blockquote>
<p>注意:</p>
<p>​    在Spring Boot中,可以获得映射到<code>ConfigurationProperties</code>类的属性,这些都是通过properties,YAML,环境参数等等配置的, 这些都是公开的接口,但是这个类的getters/setters不应该被直接使用.</p>
<p>注意:</p>
<p>​    这种方式依赖于默认的空构造函数，并且getter和setter通常是强制性的，因为绑定是通过标准Java Beans属性描述符进行的，就像在Spring MVC中一样。在以下情况下，可以省略setter:</p>
<ul>
<li>Map集合,因为只要初始化过后,只需要getter,不需要setter,因为可以被绑定器修改.</li>
<li>可以通过索引（通常使用YAML）或使用单个逗号分隔的值（属性）来访问集合和数组。 在后一种情况下，必须使用setter。 我们建议始终为此类类型添加setter。 如果初始化集合，请确保它是可变的（如上例所示）.</li>
<li>如果一个内部POJO属性被初始化(就像<code>Security</code>属性),不要求setter.如果想要绑定器在运行中创建实例,需要设置setter.</li>
</ul>
<p>​    有些人会使用Lombok去自动添加getter和setter.要确保Lombok没有给类生成一个特定的构造函数,构造函数会被容器用来初始化对象.</p>
<p>​    最后，仅考虑标准Java Bean属性，不支持对静态属性的绑定。</p>
</blockquote>
</li>
</ul>
</li>
<li><h6 id="构造器绑定-Constructor-binding"><a href="#构造器绑定-Constructor-binding" class="headerlink" title="构造器绑定(Constructor binding)"></a>构造器绑定(Constructor binding)</h6>上一节中的示例可以用不可变的方式重写，如以下示例所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;my.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fields...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProperties</span><span class="params">(<span class="keyword">boolean</span> enabled, InetAddress remoteAddress, Security security)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">        <span class="keyword">this</span>.remoteAddress = remoteAddress;</span><br><span class="line">        <span class="keyword">this</span>.security = security;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fields...</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Security</span><span class="params">(String username, String password, <span class="meta">@DefaultValue(&quot;USER&quot;)</span> List&lt;String&gt; roles)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">            <span class="keyword">this</span>.roles = roles;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getters...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在开头部分, <code>@ConstructorBinding</code>注解用于表明,这里应该使用构造器绑定.这意味着,绑定器去找一个希望使用的有参构造器进行绑定.<br>标有<code>@ConstructorBinding</code>类的内部成员(比如<code>Security</code>)也会通过构造器绑定.<br>可以使用<code>@DefaultValue</code>来指定默认值,也会进行强制转换,将<code>String</code>转换成未知类型的属性.默认情况下,不弱没有属性被绑到<code>Security</code>,那么将会被赋予<code>null</code>.如果希望即使没有对应的属性绑定到<code>Security</code>上,返回一个不是null的实例,可以使用无参的<code>@DefaultValue</code>的注解:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyProperties</span><span class="params">(<span class="keyword">boolean</span> enabled, InetAddress remoteAddress, <span class="meta">@DefaultValue</span> Security security)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    <span class="keyword">this</span>.remoteAddress = remoteAddress;</span><br><span class="line">    <span class="keyword">this</span>.security = security;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    开启构造器绑定,必须使用<code>@EnableConfigurationProperties</code>或者配置属性搜索.对于有常规的Spring机制(<code>@Component</code>)创建的bean,通过<code>@Bean</code>方式,或者带有<code>@Import</code>的bean,都可以使用构造器注入.</p>
<p>建议:</p>
<p>​    如果类中有多个构造器,那么可以使用<code>@ConstructorBinding</code>来指定应该使用哪一个构造器绑定.</p>
<p>注意:</p>
<p>​    不建议将<code>java.util.Optional</code>与<code>@ConfigurationProperties</code>一起使用，因为它主要旨在用作返回类型.因此，它不太适合配置属性注入.为了与其他类型的属性保持一致，如果声明了Optional属性并且没有任何值，则将绑定null而不是空的Optional.</p>
</blockquote>
</li>
<li><h6 id="启用-ConfigurationProperties注释的类-Enabling-ConfigurationProperties-annotated-types"><a href="#启用-ConfigurationProperties注释的类-Enabling-ConfigurationProperties-annotated-types" class="headerlink" title="启用@ConfigurationProperties注释的类(Enabling @ConfigurationProperties-annotated types)"></a>启用@ConfigurationProperties注释的类(Enabling @ConfigurationProperties-annotated types)</h6>Spring Boot提供了绑定<code>@ConfigurationProperties</code>类型并将其注册为Bean的基础架构.可以逐类启用配置属性，也可以启用与组件扫描类似的方式进行配置属性扫描.<br>有时，用<code>@ConfigurationProperties</code>注释的类可能不适用于扫描，例如，如果您正在开发自己的自动配置，或者想要有条件地启用它们. 在这些情况下,请使用<code>@EnableConfigurationProperties</code>注解指定要处理的类型列表.可以在任何<code>@Configuration</code>类上完成此操作，如以下示例所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SomeProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
要使用配置属性扫描,将<code>@ConfigurationPropertiesScan</code>批注添加到应用程序.通常，它被添加到以<code>@SpringBootApplication</code>标注的主应用程序类中，但是可以将其添加到任何<code>@Configuration</code>类中.默认情况下,将从声明注解的类的包中进行扫描。 如果要定义要扫描的特定程序包，可以按照以下示例所示进行操作：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ConfigurationPropertiesScan(&#123; &quot;com.example.app&quot;, &quot;com.example.another&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    使用配置文件扫描或通过<code>@EnableConfigurationProperties</code>注册<code>@ConfigurationProperties</code>Bean时，该Bean具有常规名称：<prefix>-<fqn>，其中<prefix>是<code>@ConfigurationProperties</code>中指定的,<fqn> 是Bean的完全限定名称。 如果注解没有提供不提供任何前缀，则仅使用Bean的完全限定名称.</p>
<p>在例子中的bean的name是<code>com.example.app-com.example.app.SomeProperties</code><br>推荐只在处理环境时使用<code>@ConfigurationProperties</code>,特别的,不要注入context中的其他bean.对于极端情况,可以使用setter注入,或者任何由framework提供的<code>*Aware</code>的接口(比如<code>EnvironmentAware</code>,如果需要访问<code>Environment</code>).如果还是想要使用构造器注入其他的bean,配置属性的Bean必须使用<code>@Componet</code>注解和使用基于JavaBean的属性绑定.</p>
</blockquote>
</li>
<li><h6 id="使用-ConfigurationProperties注解的类-Using-ConfigurationProperties-annotated-types"><a href="#使用-ConfigurationProperties注解的类-Using-ConfigurationProperties-annotated-types" class="headerlink" title="使用@ConfigurationProperties注解的类(Using @ConfigurationProperties-annotated types)"></a>使用@ConfigurationProperties注解的类(Using @ConfigurationProperties-annotated types)</h6>这种配置风格特别适合与SpringApplication外部YAML配置一起使用,如下:<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">        <span class="attr">remote-address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">        <span class="attr">security:</span></span><br><span class="line">            <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">            <span class="attr">roles:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">USER</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">ADMIN</span></span><br></pre></td></tr></table></figure>
要使用<code>@ConfigurationProperties</code>Bean，可以像使用其他任何Bean一样注入它们，如以下示例所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SomeProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(SomeProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server(<span class="keyword">this</span>.properties.getRemoteAddress());</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    使用<code>@ConfigurationProperties</code>还可以让您生成元数据文件，IDE可以使用这些元数据文件为您自己的键提供自动完成功能</p>
</blockquote>
</li>
<li><h6 id="第三方配置-Third-party-Configuration"><a href="#第三方配置-Third-party-Configuration" class="headerlink" title="第三方配置(Third-party Configuration)"></a>第三方配置(Third-party Configuration)</h6>除了使用<code>@ConfigurationProperties</code>注释类之外，您还可以在公共@Bean方法上使用它。 当您要将属性绑定到控件之外的第三方组件时，这样做特别有用。<br>要从Environment属性配置Bean，请将<code>@ConfigurationProperties</code>添加到其Bean注册中，如以下示例所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdPartyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;another&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnotherComponent <span class="title">anotherComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnotherComponent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
用<code>another</code>前缀定义的任何JavaBean属性都以类似于前面的<code>SomeProperties</code>示例的方式映射到该<code>AnotherComponent</code> bean.</li>
<li><h6 id="Relaxed-Binding-松散绑定"><a href="#Relaxed-Binding-松散绑定" class="headerlink" title="Relaxed Binding(松散绑定?)"></a>Relaxed Binding(松散绑定?)</h6>Spring Boot使用一些relax rules将<code>Environment</code>属性绑定到<code>@ConfigurationProperties</code>bean,因此，<code>Environment</code>属性名称和Bean属性名称之间不需要完全匹配.有用的常见示例包括破折号分隔的环境属性（例如，<code>context-path</code>绑定到<code>contextPath</code>）和大写的环境属性（例如<code>PORT</code>绑定到<code>port</code>）<br>作为示例，请参考以下<code>@ConfigurationProperties</code>类：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my.main-project.person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPersonProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用前面的代码，可以全部使用以下属性名称：<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>my.main-project.person.first-name</code></td>
<td>短横线形式,建议在.properties和.yml文件中使用。</td>
</tr>
<tr>
<td><code>my.main-project.person.firstName</code></td>
<td>标准驼峰命名</td>
</tr>
<tr>
<td><code>y.main-project.person.first_name</code></td>
<td>下划线表示法，是.properties和.yml文件中使用的另一种格式。</td>
</tr>
<tr>
<td><code>MY_MAINPROJECT_PERSON_FIRSTNAME</code></td>
<td>大写格式，在使用系统环境变量时建议使用。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意:</p>
<p>​    注解使用的前缀的值<code>prefix</code>必须是短横杠线的形式(全部都是小写,并使用<code>-</code>分隔,比如<code>my.main-project.person</code>).</p>
</blockquote>
每个配置源的松散绑定规则<table>
<thead>
<tr>
<th>属性源</th>
<th>简单类型</th>
<th>List类型</th>
</tr>
</thead>
<tbody><tr>
<td>Properties</td>
<td>驼峰,短横线,下划线</td>
<td>使用<code>[]</code>或者用逗号分隔</td>
</tr>
<tr>
<td>YAML</td>
<td>驼峰,短横线,下划线</td>
<td>YAML列表语法或者逗号分隔</td>
</tr>
<tr>
<td>环境变量</td>
<td>下划线作为定界符的大写格式</td>
<td>下划线括起来的数值</td>
</tr>
<tr>
<td>系统属性</td>
<td>驼峰,短横线,下划线</td>
<td>使用<code>[]</code>或者用逗号分隔</td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>​    如果可以的话,推荐属性应该以小写短横线形式,比如<code>my.person.first-name=Rod</code></p>
</blockquote>
<ul>
<li><p>绑定Map(Binding Maps)</p>
<p>绑定到Map属性时,可能需要使用特殊的括号符号，以便保留原始key.如果key没有被<code>[]</code>包围，则所有非字母数字字符<code>-</code>或<code>.</code> 被删除。</p>
<p>例如，考虑将以下属性绑定到<code>Map &lt;String，String&gt;</code>：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.map.[/key1]</span>=<span class="string">value1</span></span><br><span class="line"><span class="meta">my.map.[/key2]</span>=<span class="string">value2</span></span><br><span class="line"><span class="meta">my.map./key3</span>=<span class="string">value3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    对于YAML文件，方括号必须用引号引起来，以便正确解析key。</p>
</blockquote>
<p>上面的<code>/ key1</code>，<code>/ key2</code>和<code>key3</code>属性作为Map中的key绑定到Map上.<code>key3</code>的斜杠会被从key中移除,以为它没有被<code>[]</code>包裹.</p>
<p>如果<code>key</code>中包含一个<code>.</code>,那么就需要使用方括号来包裹,此时正在绑定一个非标量的值.比如,绑定<code>a.b=c</code>到<code>Map&lt;String, Object&gt;</code>上,在Map中会添加<code>&#123;&quot;a&quot;=&#123;&quot;b&quot;=&quot;c&quot;&#125;&#125;</code>. 但是如果绑定<code>[a.b]=c</code>,那么<code>&#123;&quot;a.b&quot;=&quot;c&quot;&#125;</code>将会被添加到Map中.</p>
</li>
<li><p>从环境变量绑定(Binding from Environment Variables)</p>
<p>很多操作系统严格限制环境变量的变量名.比如Linux的shell变量只能包含字符(<code>a</code> to <code>z</code> or <code>A</code> to <code>Z</code>), 数字(<code>0</code> to <code>9</code>) ,或者使用下划线的字符(<code>_</code>).按照规范,Unix 的shell变量应该使用大写形式变量名.</p>
<p>Spring Boot的relaxed绑定规则在设计的时候,就尽可能的与这些命名约束想兼容.</p>
<p>要将规范形式的属性名称转换为环境变量名称,可以遵循以下规则：</p>
<ul>
<li>使用下划线(<code>_</code>)替换点(<code>.</code>)</li>
<li>移除短横线(<code>-</code>)</li>
<li>转换成大写.</li>
</ul>
<p>比如,配置属性<code>spring.main.log-startup-info</code>转换成环境变量形式应该是<code>SPRING_MAIN_LOGSTARTUPINFO</code>.</p>
<p>环境变量也可以用来绑定到对象list中.为了绑定<code>List</code>,变量名中的元素号应该使用下划线包围.</p>
<p>比如,配置属性<code>my.service[0].other</code>,应该使用<code>MY_SERVICE_0_OTHER</code>变量名.</p>
</li>
</ul>
</li>
<li><h6 id="合并复杂类型-Merging-Complex-Types"><a href="#合并复杂类型-Merging-Complex-Types" class="headerlink" title="合并复杂类型(Merging Complex Types)"></a>合并复杂类型(Merging Complex Types)</h6>如果在多个位置配置了list，则通过替换整个list来进行覆盖。<br>比如,假设有一个<code>MyPojo</code>对象,有<code>name</code>和<code>description</code>两个属性,属性的默认值位<code>null</code>.下面的例子展示了<code>MyProperties</code>中的<code>MyPojo</code>的list.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MyPojo&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;MyPojo&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
考虑下面的配置:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.list[0].name</span>=<span class="string">my name</span></span><br><span class="line"><span class="meta">my.list[0].description</span>=<span class="string">my description</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="meta">spring.config.activate.on-profile</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">my.list[0].name</span>=<span class="string">my another name</span></span><br></pre></td></tr></table></figure>
如果<code>dev</code>的profile没有被启用,那么 <code>MyProperties.list</code> 只有一个<code>MyPojo</code>,就像上面定义的那样.如果<code>dev</code>的profile启用,那么<code>list</code>中还是只有一个元素(name是<code>my another name</code>,description是<code>null</code>).这个配置没有增加第二个<code>MyPojo</code>到list中,也没有融合元素.<br>当<code>List</code>在多个profile中指定时,只有优先级最高的那个会被使用.考虑下面的例子:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.list[0].name</span>=<span class="string">my name</span></span><br><span class="line"><span class="meta">my.list[0].description</span>=<span class="string">my description</span></span><br><span class="line"><span class="meta">my.list[1].name</span>=<span class="string">another name</span></span><br><span class="line"><span class="meta">my.list[1].description</span>=<span class="string">another description</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="meta">spring.config.activate.on-profile</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">my.list[0].name</span>=<span class="string">my another name</span></span><br></pre></td></tr></table></figure>
在之前的例子中,如果<code>dev</code>profile启用,那么<code>MyProperties.list</code>只有一个<code>MyPojo</code>元素(name是<code>my another name</code>,description 是<code>null</code>).比如YAML,逗号分隔列表和YAML列表均可用于完全覆盖列表的内容.<br>对于<code>Map</code>属性,可以从多个数据源绑定值.但是,对于在多个源的同一个属性,只会使用优先级最高的那个.下面的例子展示了<code>MyProperties</code>中的<code>Map&lt;String, MyPojo&gt;</code>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MyPojo&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, MyPojo&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
考虑接下来的配置文件:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.map.key1.name</span>=<span class="string">my name 1</span></span><br><span class="line"><span class="meta">my.map.key1.description</span>=<span class="string">my description 1</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="meta">spring.config.activate.on-profile</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">my.map.key1.name</span>=<span class="string">dev name 1</span></span><br><span class="line"><span class="meta">my.map.key2.name</span>=<span class="string">dev name 2</span></span><br><span class="line"><span class="meta">my.map.key2.description</span>=<span class="string">dev description 2</span></span><br></pre></td></tr></table></figure>
如果<code>dev</code>profile没有激活,<code>MyProperties.map</code>只包含一个元素<code>key1</code>(name是<code>my name 1</code>,description是 <code>my description 1</code>).如果<code>dev</code>profile启用,那么<code>map</code>将会包含两个元素<code>key1</code>(name为<code>dev name 1</code>,description为<code>my description 1</code>), <code>key2</code>(name为<code>dev name 2</code>和description 为<code>dev description 2</code>).<blockquote>
<p>注意:</p>
<p>​    前面的合并规则不仅适用于文件，还适用于所有属性源中的属性。</p>
</blockquote>
</li>
<li><h6 id="属性转换-Properties-Conversion"><a href="#属性转换-Properties-Conversion" class="headerlink" title="属性转换(Properties Conversion)"></a>属性转换(Properties Conversion)</h6>当属性绑定到 <code>@ConfigurationProperties</code> bean上时,Spring Boot会将外部应用属性配置强制类型转换到正确的类型.如果想要自定义转换的话,可以提供一个<code>ConversionService</code>bean(bean的name为<code>conversionService</code>),或者自定义的属性编辑器(通过<code>CustomEditorConfigurer</code>),或者一个自定的<code>Converters</code>(使用<code>@ConfigurationPropertiesBinding</code>注解标注的bean).<blockquote>
<p>注意:</p>
<p>​    由于在应用程序生命周期中非常早就请求了此bean,因此请确保限制<code>ConversionService</code>使用的依赖项.通常, 您需要的任何依赖项可能在创建时未完全初始化.如果没有配置的key要强制类型转换,可能需要重命名自定义的<code>ConversionService</code>,只需要使用<code>@ConfigurationPropertiesBinding</code>.自定义转换器.</p>
</blockquote>
<h6 id="转换时间-Converting-Durations"><a href="#转换时间-Converting-Durations" class="headerlink" title="转换时间(Converting Durations)"></a>转换时间(Converting Durations)</h6>Spring Boot为表达持续时间提供了专门的支持。 如果使用<code>java.time.Duration</code>属性，则应用程序属性中的以下格式可用：<ul>
<li>常规的<code>Long</code>表示形式（使用毫秒作为默认单位，除非已指定<code>@DurationUnit</code>）</li>
<li><code>java.time.Duration</code>使用的标准ISO-8601格式</li>
<li>数值和时间单位相结合的,更易读的格式（例如10s表示10秒）<br>考虑下面的例子:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DurationUnit(ChronoUnit.SECONDS)</span></span><br><span class="line">    <span class="keyword">private</span> Duration sessionTimeout = Duration.ofSeconds(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Duration readTimeout = Duration.ofMillis(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters / setters...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
表示一个30s的回话,<code>30</code>,<code>PT30S</code>,<code>30s</code>都是相同的. 使用<code>500</code>,<code>PT0.5S</code>或者<code>500ms</code>的任何一种形式,都可以指定超时时间为500ms.<br>也可以使用任何受支持的时间单位,如下:</li>
<li><code>ns</code> 纳秒</li>
<li><code>us</code> 微秒</li>
<li><code>ms</code>  毫秒</li>
<li><code>s</code>    秒</li>
<li><code>m</code>    分钟</li>
<li><code>h</code>    小时</li>
<li><code>d</code>    天<br>默认的时间单位是毫秒,可以使用<code>@DurationUnit</code>修改.正如上面的例子那样.<br>如果选择的是构造器绑定, 属性也可以使用.如下所示<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fields...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProperties</span><span class="params">(<span class="meta">@DurationUnit(ChronoUnit.SECONDS)</span> <span class="meta">@DefaultValue(&quot;30s&quot;)</span> Duration sessionTimeout,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@DefaultValue(&quot;1000ms&quot;)</span> Duration readTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sessionTimeout = sessionTimeout;</span><br><span class="line">        <span class="keyword">this</span>.readTimeout = readTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    如果要升级<code>Long</code>属性，不是字节单位,要确保指定单位（使用<code>@DurationUnit</code>）。 这样做可以提供透明的升级路径，同时支持更丰富的格式。</p>
</blockquote>
<h6 id="转换日期-Converting-periods"><a href="#转换日期-Converting-periods" class="headerlink" title="转换日期(Converting periods)"></a>转换日期(Converting periods)</h6>除了时间之外,Spring Boot也使用了<code>java.time.Period</code>类型.下面是可以在<code>application.properties</code>中使用的格式:</li>
<li>常规的int表示形式（使用天作为默认单位，除非已指定<code>@PeriodUnit</code>）</li>
<li><code>java.time.Period</code>使用的标准ISO-8601格式</li>
<li>数值和单位组合的更简单格式（例如<code>1y3d</code>表示1年零3天）<br>在简单格式中,支持下面的单位:</li>
<li><code>y</code> 年</li>
<li><code>m</code> 月</li>
<li><code>w</code> 日</li>
<li><code>d</code> 天<blockquote>
<p>注意:</p>
<p><code>java.time.Period</code>类型从不实际存储星期数，是表示7天的简写.</p>
</blockquote>
<h6 id="转换数据大小-Converting-Data-Sizes"><a href="#转换数据大小-Converting-Data-Sizes" class="headerlink" title="转换数据大小(Converting Data Sizes)"></a>转换数据大小(Converting Data Sizes)</h6>Spring Framework有个<code>DataSize</code>数值类型,用来字节来表示大小.如果想要有个<code>DataSize</code>属性,在应用配置中,可以使用下面的格式:</li>
<li>常规的Long表示形式（除非已指定<code>@DataSizeUnit</code>，否则使用字节作为默认单位）</li>
<li>数值和单位组成的更可读的格式(例如10MB表示10兆字节).<br>考虑下面的例子:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DataSizeUnit(DataUnit.MEGABYTES)</span></span><br><span class="line">    <span class="keyword">private</span> DataSize bufferSize = DataSize.ofMegabytes(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSize sizeThreshold = DataSize.ofBytes(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters/setters...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用<code>10</code>或者<code>10M</code>来指定<code>bufferSize</code>为10兆字节都是一样的效果.可以使用<code>256</code>或者<code>256B</code>来指定<code>sizeThreshold</code>为256字节.<br>可以使用如下支持的单位:</li>
<li><code>B</code> for bytes</li>
<li><code>KB</code> for kilobytes</li>
<li><code>MB</code> for megabytes</li>
<li><code>GB</code> for gigabytes</li>
<li><code>TB</code> for terabytes<br>默认的单位是字节,可以使用<code>@DataSizeUnit</code>来修改,就像上面的例子.<br>如果是选择构造器绑定,也可使用同样的属性.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fields...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProperties</span><span class="params">(<span class="meta">@DataSizeUnit(DataUnit.MEGABYTES)</span> <span class="meta">@DefaultValue(&quot;2MB&quot;)</span> DataSize bufferSize,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@DefaultValue(&quot;512B&quot;)</span> DataSize sizeThreshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bufferSize = bufferSize;</span><br><span class="line">        <span class="keyword">this</span>.sizeThreshold = sizeThreshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    如果要升级Long属性，如果原来的单位不是字节,确保定义单位（使用<code>@DataSizeUnit</code>）。 这样做可以提供透明的升级路径，同时支持更丰富的格式。</p>
</blockquote>
</li>
</ul>
</li>
<li><h6 id="ConfigurationProperties校验-Validation"><a href="#ConfigurationProperties校验-Validation" class="headerlink" title="@ConfigurationProperties校验(Validation)"></a><code>@ConfigurationProperties</code>校验(Validation)</h6>当使用了<code>@Validated</code>注解,Spring Boot会尝试检验<code>@ConfigurationProperties</code>标注的类.可以在配置类上直接使用<code>JSR-303 javax.validation</code>约束注解.为此，确保您的类路径上有兼容的JSR-303实现，然后将约束注解添加到字段中，如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my.service&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters/setters...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    可以在标有 <code>@Bean</code>的创建配置属性的方法上,添加<code>@Validated</code>,来触发校验.<br>为确保始终为嵌套属性触发验证，即使未找到任何属性，也必须使用<code>@Valid</code>注解相关的字段.下面的示例基于前面的<code>MyProperties</code>示例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my.service&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters/setters...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotEmpty</span></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getters/setters...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以添加一个叫做<code>configurationPropertiesValidator</code>的bean,来添加一个自定义的<code>Validator</code>.<code>@Bean</code>方法必须声明为静态方法.配置属性的validator在应用生命周期的很早期就被创建,将<code>@Bean</code>方法声明为静态方法是为了创建bean的时候,不需要去初始化<code>@Configuration</code>类.这样做避免了由早期实例化引起的任何问题.<blockquote>
<p>建议:</p>
<p>​    <code>spring-boot-actuator</code>模块包含一个端点，该端点公开了所有<code>@ConfigurationProperties</code> Bean.用浏览器访问<code>/actuator/configprops</code>或则使用同样的JMX端点.</p>
</blockquote>
</li>
<li><h6 id="对比-ConfigurationProperties-与-Value"><a href="#对比-ConfigurationProperties-与-Value" class="headerlink" title="对比@ConfigurationProperties 与. @Value"></a>对比<code>@ConfigurationProperties</code> 与. <code>@Value</code></h6><code>@Value</code>注解是容器的一个核心功能,但是不能提供具有类型安全的属性配置.下面的表哥总结了<code>@ConfigurationProperties</code>和<code>@Value</code>支持的功能:<table>
<thead>
<tr>
<th>功能</th>
<th><strong>@ConfigurationProperties</strong></th>
<th><strong>@Value</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Relaxed绑定</td>
<td>支持</td>
<td>部分支持</td>
</tr>
<tr>
<td>元数据支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><code>SpEL</code>表达式</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<blockquote>
<p>注意:</p>
<p>​    如果确实想要使用<code>@Value</code>,建议使用规范形式（例如，kebab-case只使用小写字母）来引用属性名. 这将允许Spring Boot使用与Relaxed绑定<code>@ConfigurationProperties</code>时相同的逻辑.比如,<code>@Value(&quot;&#123;demo.item-price&#125;&quot;)</code>会选择<code>demo.item-price</code>,和<code>application.properties</code>文件中的<code>demo.itemPrice</code>格式,和系统环境中的<code>DEMO_ITEMPRICE</code>.如果使用的是<code>@Value(&quot;&#123;demo.itemPrice&#125;&quot;)</code>, <code>demo.item-price</code>和<code>DEMO_ITEMPRICE</code>不会使用.<br>如果相位自己的组件配置属性key,推荐使用<code>@ConfigurationProperties</code>将他们按组编入的POJO中.这样做,可以在bean中注入一个结构化,类型安全的队形.<br>在解析这些文件并填充环境时，不会处理来自应用程序属性文件的<code>SpEL</code>表达式。但是在<code>@Value</code>中使用<code>SpEL</code>.如果应用程序属性文件中属性的值是<code>SpEL</code>表达式，则在通过@Value进行使用时将对其进行评估.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>3.26 Feature: 测试</title>
    <url>/posts/27280.html</url>
    <content><![CDATA[<h5 id="3-26-测试-Testing"><a href="#3-26-测试-Testing" class="headerlink" title="3.26 测试(Testing)"></a>3.26 测试(Testing)</h5><ol start="26">
<li><h5 id="测试-Testing"><a href="#测试-Testing" class="headerlink" title="测试(Testing)"></a>测试(Testing)</h5><p>Spring Boot 提供了许多工具和注解来帮助测试应用.测试支持由两个模块提供:<code>spring-boot-test</code> 包含核心项,<code>spring-boot-test-autoconfigure</code> 支持自动配置测试.</p>
<p>大多数开发人员使用 <code>spring-boot-starter-test</code> “Starter”,它导入 Spring Boot 测试模块以及 JUnit Jupiter,AssertJ,Hamcrest 和许多其他有用的库.</p>
<blockquote>
<p>建议:</p>
<p>​    如果有使用 JUnit 4 的测试,则可以使用 JUnit 5 的vintage引擎来运行它们.要使用vintage引擎,添加对 <code>junit-vintage-engine</code> 的依赖,如以下示例所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> &gt;<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>hamcrest-core</code> 被排除在 <code>org.hamcrest:hamcrest</code> 之外,它是 <code>spring-boot-starter-test</code> 的一部分.</p>
<ol>
<li><h6 id="测试范围依赖-Test-Scope-Dependencies"><a href="#测试范围依赖-Test-Scope-Dependencies" class="headerlink" title="测试范围依赖(Test Scope Dependencies)"></a>测试范围依赖(Test Scope Dependencies)</h6><p><code>spring-boot-starter-test</code> “Starter”(在<code>test</code> <code>scope</code>内)包含以下提供的库:</p>
<ul>
<li>JUnit 5:用于Java 应用单元测试标准.</li>
<li>Spring Test &amp; Spring Boot Test:对 Spring Boot 应用提供的工具和集成测试.</li>
<li>AssertJ:流式的断言库.</li>
<li>Hamcrest:匹配器对象库(也称为约束或谓词).</li>
<li>Mockito: Java 模拟框架.</li>
<li>JSONassert:JSON 的断言库.</li>
<li>JsonPath:JSON 的 XPath.</li>
</ul>
<p>通常发现这些公共库在编写测试时很有用.如果这些库不适合需要,可以添加自己的其他测试依赖项.</p>
</li>
<li><h6 id="测试-Spring-应用程序-Testing-Spring-Applications"><a href="#测试-Spring-应用程序-Testing-Spring-Applications" class="headerlink" title="测试 Spring 应用程序(Testing Spring Applications)"></a>测试 Spring 应用程序(Testing Spring Applications)</h6><p>依赖注入的主要优点之一是它应该使代码更容易进行单元测试.可以使用 <code>new</code> 运算符实例化对象,甚至无需涉及 Spring. 还可以使用模拟对象(<em>mock objects</em>)而不是真正的依赖项.</p>
<p>通常,不仅需要单元测试,还需要集成测试(使用 Spring <code>ApplicationContext</code>).不需要部署应用程序或连接到其他infrastructure就可以执行集成测试,这会非常有用.</p>
<p>Spring Framework 包括一个专门的测试模块,用于此类集成测试.可以直接声明依赖项 <code>org.springframework:spring-test</code> ,或者通过 <code>spring-boot-starter-test</code>“Starter” 的传递性,将其拉取.</p>
<p>如果之前没有使用过 <code>spring-test</code> 模块,您应该首先阅读 Spring Framework 参考文档(<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testing">relevant section</a>)的相关部分.</p>
</li>
<li><h6 id="测试-Spring-Boot-应用程序-Testing-Spring-Boot-Applications"><a href="#测试-Spring-Boot-应用程序-Testing-Spring-Boot-Applications" class="headerlink" title="测试 Spring Boot 应用程序(Testing Spring Boot Applications)"></a>测试 Spring Boot 应用程序(Testing Spring Boot Applications)</h6><p>Spring Boot 应用程序是一个 Spring <code>ApplicationContext</code>,因此通常除了使用 vanilla Spring context执行的测试之外,不需要做任何特别的事情来测试它.</p>
<blockquote>
<p>注意:</p>
<p>​    只有使用 <code>SpringApplication</code> 创建它时,Spring Boot 的外部属配置,日志和其他功能会默认地安装在context中.</p>
</blockquote>
<p>Spring Boot 提供了一个 <code>@SpringBootTest</code> 注解,当需要 Spring Boot 测试功能时,它可以替代 <code>spring-test</code> <code>@ContextConfiguration</code> 注解.注解的工作原理是通过 <code>SpringApplication</code> 创建测试中需要使用的 <code>ApplicationContext</code>.除了<code>@SpringBootTest</code>之外,还提供了许多其他注解,来测试应用程序的更具体的切片.</p>
<blockquote>
<p>建议:</p>
<p>​    如果使用的是 JUnit 4,不要忘记将 <code>@RunWith(SpringRunner.class) </code>添加到测试中,否则注解将被忽略.如果使用的是 JUnit 5,则无需添加 <code>@ExtendWith(SpringExtension.class) </code>作为 <code>@SpringBootTest</code> ,并且其他 <code>@… Test</code> 注解已经用它进行了标注.</p>
</blockquote>
<p>默认情况下,<code>@SpringBootTest</code> 不会启动服务器. 您可以使用 <code>@SpringBootTest</code> 的 <code>webEnvironmen</code>t 属性来进一步优化测试的运行方式:</p>
<ul>
<li><code>MOCK</code>(Default) : 加载一个 web <code>ApplicationContext</code> 并提供web模拟环境.使用此注解时不会启动嵌入式服务器.如果classpath上没有 Web 环境,则此模式会创建普通的的非 Web <code>ApplicationContext</code>.它可以与 <code>@AutoConfigureMockMvc</code> 或 <code>@AutoConfigureWebTestClient</code> 结合使用,用于对 Web 应用进行模拟测试.</li>
<li><code>RANDOM_PORT</code>:加载一个 <code>WebServerApplicationContext</code> 并提供一个真实的 Web 环境. 嵌入式服务器启动并监听随机端口.</li>
<li><code>DEFINED_PORT</code>:加载一个 <code>WebServerApplicationContext</code> 并提供一个真实的 Web 环境.嵌入式服务器启动并监听指定的端口(来自 <code>application.properties</code>)或默认端口 <code>8080</code>.</li>
<li><code>NONE</code>:使用 <code>SpringApplication</code> 加载 <code>ApplicationContext</code> 但不提供任何 web 环境(模拟或其他).</li>
</ul>
<blockquote>
<p>注意:</p>
<p>​    如果测试是<code>@Transactional</code>,它默认在每个测试方法结束时回滚事务.然而,使用带有 <code>RANDOM_PORT</code> 或 <code>DEFINED_PORT</code> ,这种方式隐式地提供了一个真正的 servlet 环境,HTTP 客户端和服务器运行在单独的线程中,因此在事务也在单独的线程中运行.在这种情况下,在服务器上启动的任何事务都不会回滚.</p>
<p>注意:</p>
<p>​    如果应用管理服务器时使用不同的端口,带有 <code>webEnvironment = WebEnvironment.RANDOM_PORT</code> 的 <code>@SpringBootTest</code> 还将在单独的随机端口上启动管理服务器.</p>
</blockquote>
<ol>
<li><h6 id="检测-Web-应用程序类型-Detecting-Web-Application-Type"><a href="#检测-Web-应用程序类型-Detecting-Web-Application-Type" class="headerlink" title="检测 Web 应用程序类型(Detecting Web Application Type)"></a>检测 Web 应用程序类型(Detecting Web Application Type)</h6><p>如果 Spring MVC 可用,则会配置常规的基于 MVC 的应用context. 如果只有 Spring WebFlux,将检测到并配置基于 WebFlux 的应用context.</p>
<p>如果两者都存在,则 Spring MVC 优先.如果要在此场景中测试响应式 Web 应用程序,则必须设置 <code>spring.main.web-application-type</code> 属性:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(properties = &quot;spring.main.web-application-type=reactive&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWebFluxTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="检测测试配置-Detecting-Test-Configuration"><a href="#检测测试配置-Detecting-Test-Configuration" class="headerlink" title="检测测试配置(Detecting Test Configuration)"></a>检测测试配置(Detecting Test Configuration)</h6><p>如果熟悉 Spring 测试框架,可能习惯使用 <code>@ContextConfiguration(classes=… )</code>来指定要加载哪个 Spring <code>@Configuration</code>.或者,可能经常在测试中使用嵌套的 <code>@Configuration</code> 类.</p>
<p>在测试 Spring Boot 应用时,这通常不是必需的. 如果没有明确定义配置时,Spring Boot 的 <code>@*Test</code> 注解就会自动搜索基本配置.</p>
<p>搜索算法从包含测试的包开始工作,直到找到用 <code>@SpringBootApplication</code> 或 <code>@SpringBootConfiguration</code> 标注的类.只要合理构建代码,通常会找到主要配置.</p>
<blockquote>
<p>建议:</p>
<p>​    如果使用测试注解来测试应用的更具体部分,则应避免在主方法的应用类上添加特定于特定区域的配置设置.</p>
<p>​    <code>@SpringBootApplication</code> 的底层组件扫描配置定义了排除过滤器,用于确保切片按预期工作.如果在 <code>@SpringBootApplication</code> 标注的类上使用显式 <code>@ComponentScan</code> 指令,请注意这些过滤器将被禁用.如果正在使用切片,应该再次定义它们.</p>
</blockquote>
<p>如果要自定义主要配置,可以使用嵌套的 <code>@TestConfiguration</code> 类.与替代应用基本配置的嵌套 <code>@Configuration</code> 类不同,除了应用程序的基本配置之外,还要使用嵌套的 <code>@TestConfiguration</code> 类.</p>
<blockquote>
<p>注意:</p>
<p>​    Spring 测试框架在测试中间缓存context.因此,只要测试共享相同的配置(无论怎样被发现),加载上下文的耗时过程只会发生一次.</p>
</blockquote>
</li>
<li><h6 id="排除测试配置-Excluding-Test-Configuration"><a href="#排除测试配置-Excluding-Test-Configuration" class="headerlink" title="排除测试配置(Excluding Test Configuration)"></a>排除测试配置(Excluding Test Configuration)</h6><p>如果应用使用组件扫描(例如,如果使用<code>@SpringBootApplication</code> 或<code>@ComponentScan</code>),可能会发现仅为特定测试创建的top-level配置类意外地随处可见.</p>
<p>正如我们之前看到的,<code>@TestConfiguration</code> 可以用于测试的内部类来自定义主要配置.<code>@TestConfiguration</code>放在顶级类时,表示<code>src/test/java</code>中的类不应该通过扫描获取.然后,可以在需要的地方显式导入该类,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Import(MyTestsConfiguration.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    如果直接使用<code>@ComponentScan</code>(即不通过<code>@SpringBootApplication</code>),则需要使用它注册<code>TypeExcludeFilter</code>. 有关详细信息,参阅<a href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/context/TypeExcludeFilter.html">the Javadoc</a>.</p>
</blockquote>
</li>
<li><h6 id="使用应用参数-Using-Application-Arguments"><a href="#使用应用参数-Using-Application-Arguments" class="headerlink" title="使用应用参数(Using Application Arguments)"></a>使用应用参数(Using Application Arguments)</h6><p>如果应用需要参数,可以让 <code>@SpringBootTest</code> 使用 <code>args</code> 属性注入它们.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(args = &quot;--app.test=one&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplicationArgumentTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applicationArgumentsPopulated</span><span class="params">(<span class="meta">@Autowired</span> ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        assertThat(args.getOptionNames()).containsOnly(<span class="string">&quot;app.test&quot;</span>);</span><br><span class="line">        assertThat(args.getOptionValues(<span class="string">&quot;app.test&quot;</span>)).containsOnly(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="使用模拟环境进行测试-Testing-with-a-mock-environment"><a href="#使用模拟环境进行测试-Testing-with-a-mock-environment" class="headerlink" title="使用模拟环境进行测试(Testing with a mock environment)"></a>使用模拟环境进行测试(Testing with a mock environment)</h6><p>默认情况下,<code>@SpringBootTest</code> 不启动服务器.如果有针对此模拟环境进行测试的 Web 端点,则可以另外配置 <code>MockMvc</code>,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMockMvcTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> MockMvc mvc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mvc.perform(get(<span class="string">&quot;/&quot;</span>)).andExpect(status().isOk()).andExpect(content().string(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果只想专注于 web 层而不是启动完整的 <code>ApplicationContext</code>,请考虑使用 <code>@WebMvcTest</code> 代替.</p>
</blockquote>
<p>或者,可以配置 <code>WebTestClient</code>,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureWebTestClient</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMockWebTestClientTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> WebTestClient webClient)</span> </span>&#123;</span><br><span class="line">        webClient</span><br><span class="line">            .get().uri(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectBody(String.class).isEqualTo(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    在模拟环境中进行测试通常比在完整的 Servlet 容器中运行要快.但是,由于模拟发生在 Spring MVC 层,因此无法直接使用 MockMvc 来测试那些依赖于较低级别 Servlet 容器行为的代码.</p>
<p>例如,Spring Boot 的错误处理是基于 Servlet 容器提供的”错误页面”支持.这意味着,虽然可以按预期测试 MVC 层抛出和处理异常,但您无法直接测试是否呈现了特定的自定义错误页面.如果需要测试这些较低级别的问题,可以启动一个完整运行的服务器,如下一节所述.</p>
</blockquote>
</li>
<li><h6 id="使用正在运行的服务器进行测试-Testing-with-a-running-server"><a href="#使用正在运行的服务器进行测试-Testing-with-a-running-server" class="headerlink" title="使用正在运行的服务器进行测试(Testing with a running server)"></a>使用正在运行的服务器进行测试(Testing with a running server)</h6><p>如果需要启动一个完整运行的服务器,建议使用随机端口.如果使用<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>,则每次测试运行时都会随机选择一个可用端口.</p>
<p><code>@LocalServerPort</code> 注释可用来将实际使用的端口注入到您的测试中.为方便起见,需要对启动的服务器进行 REST 调用的测试可以 <code>@Autowire</code> 一个 <code>WebTestClient</code>,它解析发送到运行中服务器的相关链接,并带有用于验证响应的专用 API,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRandomPortWebTestClientTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> WebTestClient webClient)</span> </span>&#123;</span><br><span class="line">        webClient</span><br><span class="line">            .get().uri(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectBody(String.class).isEqualTo(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个设置需要在classpath上使用 <code>spring-webflux</code>. 如果不能或不会添加 webflux,Spring Boot 还提供了一个 <code>TestRestTemplate</code> 工具:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRandomPortTestRestTemplateTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> TestRestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        String body = restTemplate.getForObject(<span class="string">&quot;/&quot;</span>, String.class);</span><br><span class="line">        assertThat(body).isEqualTo(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="自定义-WebTestClient-Customizing-WebTestClient"><a href="#自定义-WebTestClient-Customizing-WebTestClient" class="headerlink" title="自定义 WebTestClient(Customizing WebTestClient)"></a>自定义 WebTestClient(Customizing WebTestClient)</h6><p>要自定义 <code>WebTestClient</code> bean,请配置 <code>WebTestClientBuilderCustomizer</code> bean.调用<code>WebTestClient.Builder</code>来创建<code>WebTestClient</code>.</p>
</li>
<li><h6 id="使用JMX-Using-JMX"><a href="#使用JMX-Using-JMX" class="headerlink" title="使用JMX(Using JMX)"></a>使用JMX(Using JMX)</h6><p>由于测试context框架缓存context,JMX默认下禁用来防止在同一域上注册相同组件.如果此类测试需要访问 <code>MBeanServer</code>,请考虑将其标记为<code>dirty </code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span><span class="meta">@SpringBootTest(properties = &quot;spring.jmx.enabled=true&quot;)</span><span class="meta">@DirtiesContextclass</span> MyJmxTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MBeanServer mBeanServer;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> <span class="keyword">throws</span> MalformedObjectNameException </span>&#123;        assertThat(<span class="keyword">this</span>.mBeanServer.getDomains()).contains(<span class="string">&quot;java.lang&quot;</span>);        <span class="comment">// ...    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="使用Metrics-Using-Metrics"><a href="#使用Metrics-Using-Metrics" class="headerlink" title="使用Metrics(Using Metrics)"></a>使用Metrics(Using Metrics)</h6><p>无论classpath如何,使用<code>@SpringBootTest</code> 时,除内存支持外的meter registries都不会自动配置.</p>
<p>如果需要将metrics作为集成测试的一部分导出到不同的后端,请使用 <code>@AutoConfigureMetrics</code> 对其进行标注.</p>
</li>
<li><h6 id="模拟和监视Bean-Mocking-and-Spying-Beans"><a href="#模拟和监视Bean-Mocking-and-Spying-Beans" class="headerlink" title="模拟和监视Bean(Mocking and Spying Beans)"></a>模拟和监视Bean(Mocking and Spying Beans)</h6><p>运行测试时,有时需要在应用context中模拟某些组件.例如,可能有一个在开发过程中不可用的远程服务的facade.当想要模拟在真实环境中可能难以触发的故障时,Mocking会很有用.</p>
<p>Spring Boot 包含一个 <code>@MockBean</code> 注解,可用于为 <code>ApplicationContext</code> 中的 bean 定义 Mockito 模拟.可以使用注解添加新 bean 或替换单个现有 bean 定义.注解可以直接用于测试类,测试中的字段或<code>@Configuration</code> 类和字段.在字段上使用时,还会注入创建的模拟实例. Mock bean 在每个测试方法后自动重置.</p>
<blockquote>
<p>注意:</p>
<p>​    如果测试使用 Spring Boot 的测试注解(例如 <code>@SpringBootTest</code>),则会自动启用此功能.要以不同的方式使用此功能,必须显式添加监听器,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@ContextConfiguration(classes = MyConfig.class)</span><span class="meta">@TestExecutionListeners(&#123; MockitoTestExecutionListener.class, ResetMocksTestExecutionListener.class &#125;)</span><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;<span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>以下示例用mock implementation替换现有的 <code>RemoteService</code> bean:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTestclass</span> MyTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> Reverser reverser;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> RemoteService remoteService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;        given(<span class="keyword">this</span>.remoteService.getValue()).willReturn(<span class="string">&quot;spring&quot;</span>);        String reverse = <span class="keyword">this</span>.reverser.getReverseValue(); <span class="comment">// Calls injected RemoteService        assertThat(reverse).isEqualTo(&quot;gnirps&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    <code>@MockBean</code> 不能用于模拟在应用context刷新期间 bean 的执行行为.到执行测试时,应用context 刷新已完成,配置模拟行为为时已晚.在这种情况下,建议使用 <code>@Bean</code> 方法来创建和配置模拟.</p>
</blockquote>
<p>此外,可以使用 <code>@SpyBean</code>来包装任何使用 Mockito <code>spy</code> 的bean. 有关完整的详细信息,请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/test/mock/mockito/SpyBean.html">Javadoc</a>.</p>
<blockquote>
<p>注意:</p>
<p>​    CGLib 代理,例如为作用域 bean 创建的代理,将代理方法声明为 <code>final</code>.这会阻止 Mockito 正常运行,因为默认情况下,它无法模拟或监视<code>final</code>方法.如果想模拟或监视此类 bean,通过将 <code>org.mockito:mockito-inline</code> 添加到应用的测试依赖项来配置 Mockito 从而使用其内联模拟生成器.这允许 Mockito 模拟和监视<code>final</code>方法.</p>
<p>注意:</p>
<p>​    虽然 Spring 的测试框架在测试之间缓存应用context,并为了共享配置复用context,但使用 <code>@MockBean</code> 或 <code>@SpyBean</code> 会影响缓存key,这很可能会增加上下文的数量.</p>
<p>建议:</p>
<p>​    如果使用<code>@SpyBean</code> 来监视带有按名称引用参数的<code>@Cacheable</code> 方法的bean,则应用必须使用<code>-parameters</code> 进行编译.这保证了一旦 bean 被监视,参数名称就可用于缓存infrastructure .</p>
<p>建议:</p>
<p>​    当使用<code>@SpyBean</code> 来监视由 Spring 代理的 bean 时,可能在某些情况下需要移除 Spring 的代理,例如在使用 <code>given</code> 或 <code>when</code> 设置expectation时.使用 <code>AopTestUtils.getTargetObject(yourProxiedSpy)</code>来这样做.</p>
</blockquote>
</li>
<li><h6 id="自动配置测试-Auto-configured-Tests"><a href="#自动配置测试-Auto-configured-Tests" class="headerlink" title="自动配置测试(Auto-configured Tests)"></a>自动配置测试(Auto-configured Tests)</h6><p>Spring Boot 的自动配置系统适用于应用,但有时对于测试来说可能有点太多了.它通常有助于仅加载测试应用”slice”所需的配置部分.例如,测试运行时,可能想要测试 Spring MVC 控制器是否正确映射 URL,并且不想在这些测试中涉及数据库调用,或者可能想要测试 JPA entities,并且对 web 层不感兴趣.</p>
<p><code>spring-boot-test-autoconfigure</code> 模块包含许多注解,可用于自动配置此类”切片”.它们中的每一个都以类似的方式工作,提供一个加载 <code>ApplicationContext</code> 的 <code>@… Test</code> 注解和一个或多个可用于自定义自动配置的 <code>@AutoConfigure…</code> 注解.</p>
<blockquote>
<p>注意:</p>
<p>​    每个slice将组件扫描范围限制为适当的组件并加载一组非常有限的自动配置类.如果需要排除其中之一,大多数<code>@… Test</code> 注解都提供 <code>excludeAutoConfiguration</code> 属性.或者,可以使用<code>@ImportAutoConfiguration#exclude</code>.</p>
<p>注意:</p>
<p>​    不支持在一个测试中使用多个 <code>@… Test</code> 注注解包含多个”slices”.如果需要多个”slices”,请选择其中一个 <code>@… Test</code> 注解并手动包含其他”slices”的 <code>@AutoConfigure</code>… 注解.</p>
<p>建议:</p>
<p>​    也可以将<code>@AutoConfigure…</code> 注解与标准<code>@SpringBootTest</code> 注解一起使用.如果对将应用”切片”不感兴趣,但想要一些自动配置的测试 bean,则可以使用此组合.</p>
</blockquote>
</li>
<li><h6 id="自动配置的-JSON-测试-Auto-configured-JSON-Tests"><a href="#自动配置的-JSON-测试-Auto-configured-JSON-Tests" class="headerlink" title="自动配置的 JSON 测试(Auto-configured JSON Tests)"></a>自动配置的 JSON 测试(Auto-configured JSON Tests)</h6><p>要测试该对象 JSON 序列化和反序列化是否按预期工作,可以使用 <code>@JsonTest</code> 注解.<code>@JsonTest</code> 自动配置支持的 JSON 映射器,它可以是以下库之一:</p>
<ul>
<li>Jackson <code>ObjectMapper</code>,任何<code>@JsonComponent</code> bean 和任何 Jackson <code>Module</code></li>
<li><code>Gson</code></li>
<li><code>Jsonb</code></li>
</ul>
<p>如果需要配置自动配置的元素,可以使用<code>@AutoConfigureJsonTesters</code>注解.Spring Boot 包括基于 AssertJ 的helpers ,它们与 JSONAssert 和 JsonPath 库一起工作,从而检查 JSON 是否按预期显示.<code>JacksonTester</code>,<code>GsonTester</code>,<code>JsonbTester</code> 和 <code>BasicJsonTester</code> 类可分别用于 Jackson,Gson,Jsonb 和 Strings.使用<code>@JsonTest</code> 时,测试类上的任何helper 字段都可以<code>@Autowired</code>.以下示例显示了 Jackson 的测试类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonTestclass</span> MyJsonTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> JacksonTester&lt;VehicleDetails&gt; json;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        VehicleDetails details = <span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>);        <span class="comment">// Assert against a `.json` file in the same package as the test        assertThat(this.json.write(details)).isEqualToJson(&quot;expected.json&quot;);        // Or use JSON path based assertions        assertThat(this.json.write(details)).hasJsonPathStringValue(&quot;@.make&quot;);        assertThat(this.json.write(details)).extractingJsonPathStringValue(&quot;@.make&quot;).isEqualTo(&quot;Honda&quot;);    &#125;    @Test    void deserialize() throws Exception &#123;        String content = &quot;&#123;\&quot;make\&quot;:\&quot;Ford\&quot;,\&quot;model\&quot;:\&quot;Focus\&quot;&#125;&quot;;        assertThat(this.json.parse(content)).isEqualTo(new VehicleDetails(&quot;Ford&quot;, &quot;Focus&quot;));        assertThat(this.json.parseObject(content).getMake()).isEqualTo(&quot;Ford&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    JSON helper 类也可以直接在标准的单元测试中使用. 为此,如果不使用 <code>@JsonTest</code>,请在 <code>@Before</code> 方法中调用helper的 <code>initFields</code> 方法.</p>
</blockquote>
<p>如果使用 Spring Boot 的基于 AssertJ 的helpers 来断言给定 JSON 路径上的数字值,则可能无法使用具体取决于类型的 <code>isEqualTo</code>.相反,您可以使用 AssertJ 的<code>satisfies</code>来断言该值与给定条件匹配.例如,以下示例断言实际数字是浮点值,接近 <code>0.15</code> ,偏移量在 <code>0.01</code> 内.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Testvoid</span> someTest() <span class="keyword">throws</span> Exception &#123;    SomeObject value = <span class="keyword">new</span> SomeObject(<span class="number">0.152f</span>);    assertThat(<span class="keyword">this</span>.json.write(value)).extractingJsonPathNumberValue(<span class="string">&quot;@.test.numberValue&quot;</span>)            .satisfies((number) -&gt; assertThat(number.floatValue()).isCloseTo(<span class="number">0.15f</span>, within(<span class="number">0.01f</span>)));&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="自动配置-Spring-MVC-测试-Auto-configured-Spring-MVC-Tests"><a href="#自动配置-Spring-MVC-测试-Auto-configured-Spring-MVC-Tests" class="headerlink" title="自动配置 Spring MVC 测试(Auto-configured Spring MVC Tests)"></a>自动配置 Spring MVC 测试(Auto-configured Spring MVC Tests)</h6><p>要测试 Spring MVC controller 是否按预期工作,请使用 <code>@WebMvcTest</code> 注解.<code>@WebMvcTest</code> 自动配置 Spring MVC infrastructure 并将扫描的 bean 限制为 <code>@Controller</code>,<code>@ControllerAdvice</code>,<code>@JsonComponent</code>,<code>Converter</code>,<code>GenericConverter</code>,<code>Filter</code>,<code>HandlerInterceptor</code>,<code>WebMvcConfigurer</code> 和 <code>HandlerMethodArgumentResolver</code>.. 使用 <code>@WebMvcTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code>bean.</p>
<blockquote>
<p>建议:</p>
<p>​    如果需要注册额外的组件,例如 Jackson <code>Module</code>,可以通过在测试中使用 <code>@Import</code> 来导入额外的配置类.</p>
</blockquote>
<p>通常,<code>@WebMvcTest</code> 仅限于单个controller,并与 <code>@MockBean</code> 结合使用为所需的协作者提供模拟实现.</p>
<p><code>@WebMvcTest</code> 还自动配置 <code>MockMvc</code>.Mock MVC 提供了一种强大的方法来快速测试 MVC controller,而无需启动完整的 HTTP 服务器.</p>
<blockquote>
<p>建议:</p>
<p>​    还可以通过使用<code>@AutoConfigureMockMvc</code> 对其进行标注,在非<code>@WebMvcTest</code>(例如<code>@SpringBootTest</code>)中自动配置<code>MockMvc</code>.以下示例使用 <code>MockMvc</code>:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>&#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockMvc mvc;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> UserVehicleService userVehicleService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">&quot;sboot&quot;</span>))            .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>));        <span class="keyword">this</span>.mvc.perform(get(<span class="string">&quot;/sboot/vehicle&quot;</span>).accept(MediaType.TEXT_PLAIN))            .andExpect(status().isOk())            .andExpect(content().string(<span class="string">&quot;Honda Civic&quot;</span>));    &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果需要配置自动配置的元素(例如,何时应应用 servlet 过滤器),可以使用 <code>@AutoConfigureMockMvc</code> 注解中的属性.</p>
</blockquote>
<p>如果使用 HtmlUnit 或 Selenium,自动配置还会提供 HtmlUnit <code>WebClient</code> bean 和/或 Selenium <code>WebDriver</code> bean. 以下示例使用 HtmlUnit:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyHtmlUnitTests</span> </span>&#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> WebClient webClient;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> UserVehicleService userVehicleService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">&quot;sboot&quot;</span>)).willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>));        HtmlPage page = <span class="keyword">this</span>.webClient.getPage(<span class="string">&quot;/sboot/vehicle.html&quot;</span>);        assertThat(page.getBody().getTextContent()).isEqualTo(<span class="string">&quot;Honda Civic&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:    </p>
<p>​    默认情况下,Spring Boot 将 <code>WebDriver</code> bean 放在一个特殊的”scope”中,以确保驱动程序在每次测试后退出并注入新实例.如果不想要这种行为,可以将 <code>@Scope(&quot;singleton&quot;)</code> 添加到 <code>WebDriver</code> @Bean 定义中.</p>
<p>警告:</p>
<p>​    Spring Boot 创建的 <code>webDriver</code> scope 将替换所有的用户定义的同名作用域.如果定义自己的 <code>webDriver</code> scope ,可能会发现它在使用 <code>@WebMvcTest</code> 时停止工作.</p>
</blockquote>
<p>如果classpath上有 Spring Security,<code>@WebMvcTest</code> 也会扫描 <code>WebSecurityConfigurer</code> bean.可以使用 Spring Security 的测试支持,而不是为了测试完全禁用安全功能.有关如何使用 Spring Security 的 <code>MockMvc</code> 支持的更多详细信息,请参见 <em><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.testing.with-spring-security">howto.html</a></em>  how-to 部分.</p>
</li>
<li><h6 id="自动配置的-Spring-WebFlux-测试-Auto-configured-Spring-WebFlux-Tests"><a href="#自动配置的-Spring-WebFlux-测试-Auto-configured-Spring-WebFlux-Tests" class="headerlink" title="自动配置的 Spring WebFlux 测试(Auto-configured Spring WebFlux Tests)"></a>自动配置的 Spring WebFlux 测试(Auto-configured Spring WebFlux Tests)</h6><p>要测试 Spring WebFlux controller是否按预期工作,可以使用 <code>@WebFluxTest</code> 注解.<code>@WebFluxTest</code> 自动配置 Spring WebFlux infrastructure 并将扫描的 bean 限制为 <code>@Controller</code>,<code>@ControllerAdvice</code>,<code>@JsonComponent</code>,<code>Converter</code>,<code>GenericConverter</code>,<code>WebFilter</code> 和 <code>WebFluxConfigurer</code>.使用<code>@WebFluxTest</code> 注解时不会扫描常规的<code>@Component</code> 和<code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<blockquote>
<p>建议:</p>
<p>​    如果需要注册额外的组件,比如 Jackson <code>Module</code>,可以在测试中使用 <code>@Import</code> 导入额外的配置类.</p>
</blockquote>
<p>通常,<code>@WebFluxTest</code> 仅限于单个controller,并与 <code>@MockBean</code> 注解结合使用,为所需的协作者提供模拟实现.</p>
<p><code>@WebFluxTest</code> 还自动配置 <code>WebTestClient</code>,它提供了一种强大的方法来快速测试 WebFlux controller,而无需启动完整的 HTTP 服务器.</p>
<blockquote>
<p>建议:</p>
<p>​    还可以通过使用 <code>@AutoConfigureWebTestClient</code> 注解在非<code>@WebFluxTest</code>(例如<code>@SpringBootTest</code>)中自动配置<code>WebTestClient</code>.以下示例显示了一个同时使用 <code>@WebFluxTest</code> 和 <code>WebTestClient</code> 的类:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFluxTest(UserVehicleController.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>&#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> WebTestClient webClient;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> UserVehicleService userVehicleService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">&quot;sboot&quot;</span>))            .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>));        <span class="keyword">this</span>.webClient.get().uri(<span class="string">&quot;/sboot/vehicle&quot;</span>).accept(MediaType.TEXT_PLAIN).exchange()            .expectStatus().isOk()            .expectBody(String.class).isEqualTo(<span class="string">&quot;Honda Civic&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    这个设置仅受 WebFlux 应用支持,因为在模拟 Web 应用中使用 <code>WebTestClient</code> 目前仅适用于 WebFlux.</p>
<p>注意:</p>
<p>​    <code>@WebFluxTest</code> 无法检测通过函数式 Web 框架注册的route.要在context中测试 <code>RouterFunction</code> beans,请考虑通过 <code>@Import</code> 或使用 <code>@SpringBootTest</code> 自己导入 <code>RouterFunction</code>.</p>
<p>注意:</p>
<p>​    <code>@WebFluxTest</code> 无法检测通过 <code>SecurityWebFilterChain</code> 类型的 <code>@Bean</code> 注册的自定义安全配置.要将其包含在测试中,需要通过<code>@Import</code> 或使用<code>@SpringBootTest</code> 导入注册 bean 的配置.</p>
</blockquote>
</li>
<li><h6 id="自动配置的数据-Cassandra-测试-Auto-configured-Data-Cassandra-Tests"><a href="#自动配置的数据-Cassandra-测试-Auto-configured-Data-Cassandra-Tests" class="headerlink" title="自动配置的数据 Cassandra 测试(Auto-configured Data Cassandra Tests)"></a>自动配置的数据 Cassandra 测试(Auto-configured Data Cassandra Tests)</h6><p>可以使用 <code>@DataCassandraTest</code> 来测试 Cassandra 应用程序.默认情况下,它配置一个 <code>CassandraTemplate</code>,扫描 <code>@Table</code> 类,并配置 Spring Data Cassandra 存储库.使用 <code>@DataCassandraTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean. </p>
<p>以下示例显示了在 Spring Boot 中使用 Cassandra 测试的典型设置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataCassandraTestclass</span> MyDataCassandraTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeRepository repository;&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="自动配置的数据-JPA-测试-Auto-configured-Data-JPA-Tests"><a href="#自动配置的数据-JPA-测试-Auto-configured-Data-JPA-Tests" class="headerlink" title="自动配置的数据 JPA 测试(Auto-configured Data JPA Tests)"></a>自动配置的数据 JPA 测试(Auto-configured Data JPA Tests)</h6><p>可以使用 <code>@DataJpaTest</code> 注解来测试 JPA 应用程序.默认情况下,它会扫描 <code>@Entity</code> 类并配置 Spring Data JPA 存储库.如果在classpath上有一个嵌入式数据库可用,它也会配置一个.默认情况下,通过将 <code>spring.jpa.show-sql</code> 属性设置为 <code>true</code> 来记录 SQL 查询.这可以使用注解的 <code>showSql()</code> 属性禁用.</p>
<p>使用 <code>@DataJpaTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>默认情况下,数据 JPA 测试是事务性的,并在每次测试结束时回滚.有关详细信息,请参阅 Spring 框架 <a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a> 中的相关部分.如果这不是想要的,可以为测试或整个class禁用事务,如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><span class="class"><span class="keyword">class</span> <span class="title">MyNonTransactionalTests</span> </span>&#123;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<p>数据 JPA 测试还可以注入一个 <code>TestEntityManager</code> bean,它提供了标准 JPA <code>EntityManager</code> 的替代方案,专为测试而设计.如果要在 <code>@DataJpaTest</code> 实例之外使用 <code>TestEntityManager</code>,还可以使用 <code>@AutoConfigureTestEntityManager</code> 注解.如果需要,也可以使用 JdbcTemplate. 以下示例显示了正在使用的 <code>@DataJpaTest</code> 注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataJpaTestclass</span> MyRepositoryTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> TestEntityManager entityManager;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> UserRepository repository;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="keyword">this</span>.entityManager.persist(<span class="keyword">new</span> User(<span class="string">&quot;sboot&quot;</span>, <span class="string">&quot;1234&quot;</span>));        User user = <span class="keyword">this</span>.repository.findByUsername(<span class="string">&quot;sboot&quot;</span>);        assertThat(user.getUsername()).isEqualTo(<span class="string">&quot;sboot&quot;</span>);        assertThat(user.getEmployeeNumber()).isEqualTo(<span class="string">&quot;1234&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>内存嵌入式数据库通常适用于测试,因为它们速度快且不需要任何安装.但是,如果更喜欢用真实数据库运行测试,则可以使用 <code>@AutoConfigureTestDatabase</code> 注解,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span><span class="meta">@AutoConfigureTestDatabase(replace = Replace.NONE)</span><span class="class"><span class="keyword">class</span> <span class="title">MyRepositoryTests</span> </span>&#123;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="自动配置的-JDBC-测试-Auto-configured-JDBC-Tests"><a href="#自动配置的-JDBC-测试-Auto-configured-JDBC-Tests" class="headerlink" title="自动配置的 JDBC 测试(Auto-configured JDBC Tests)"></a>自动配置的 JDBC 测试(Auto-configured JDBC Tests)</h6><p><code>@JdbcTest</code> 类似于 <code>@DataJpaTest</code>, 但用于只需要数据源而不使用 Spring Data JDBC 的测试.默认情况下,它配置一个内存嵌入式数据库和一个 <code>JdbcTemplate</code>.使用 <code>@JdbcTest</code> 注解时,不会扫描常规的 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>默认情况下,JDBC 测试是事务性的,并在每个测试结束时回滚. 有关详细信息,请参阅 Spring 框架<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a>中的相关部分.如果这不是想要的,可以为测试或整个班级禁用事务管理,如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JdbcTest</span><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><span class="class"><span class="keyword">class</span> <span class="title">MyTransactionalTests</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果更喜欢针对真实数据库运行测试,则可以像使用 <code>DataJpaTest</code> 一样使用 <code>@AutoConfigureTestDatabase</code> 注解.</p>
</li>
<li><h6 id="自动配置的Data-JDBC-测试-Auto-configured-Data-JDBC-Tests"><a href="#自动配置的Data-JDBC-测试-Auto-configured-Data-JDBC-Tests" class="headerlink" title="自动配置的Data JDBC 测试 (Auto-configured Data JDBC Tests)"></a>自动配置的Data JDBC 测试 (Auto-configured Data JDBC Tests)</h6><p><code>@DataJdbcTest</code> 与 <code>@JdbcTest</code> 类似,但用于使用 Spring Data JDBC 存储库的测试.默认情况下,它会配置一个内存嵌入式数据库,一个 <code>JdbcTemplate</code> 和 Spring Data JDBC 存储库.使用 <code>@DataJdbcTest</code> 注解时,不会扫描常规的 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>默认情况下,数据 JDBC 测试是事务性的,并在每个测试结束时回滚. 有关详细信息,请参阅 Spring 框架<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a>中的相关部分.如果这不是想要的,您可以禁用测试或整个测试类的事务管理,如 JDBC 示例中所示.</p>
<p>如果更喜欢针对真实数据库运行测试,则可以像使用 <code>DataJpaTest</code> 一样使用 <code>@AutoConfigureTestDatabase</code> 注解.</p>
</li>
<li><h6 id="自动配置的-jOOQ-测试-Auto-configured-jOOQ-Tests"><a href="#自动配置的-jOOQ-测试-Auto-configured-jOOQ-Tests" class="headerlink" title="自动配置的 jOOQ 测试 (Auto-configured jOOQ Tests)"></a>自动配置的 jOOQ 测试 (Auto-configured jOOQ Tests)</h6><p>可以类似于使用<code>@JdbcTest</code>的方式,来使用<code>@JooqTest</code>,但用于jOOQ 相关的测试.由于 jOOQ 严重依赖于与数据库schema对应的基于 Java 的schema ,因此使用现有的 <code>DataSource</code>.如果想用内存数据库替换它,你可以使用<code>@AutoConfigureTestDatabase</code> 来覆盖这些设置.使用 <code>@JooqTest</code> 注解时不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p><code>@JooqTest</code> 配置一个 <code>DSLContext</code>. 以下示例显示了正在使用的 <code>@JooqTest</code> 注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JooqTestclass</span> MyJooqTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DSLContext dslContext;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<p>JOOQ 测试是事务性的,默认情况下在每个测试结束时回滚.如果这不是想要的,可以禁用测试或整个测试类的事务管理,如 JDBC 示例中所示.</p>
</li>
<li><h6 id="自动配置的-Data-MongoDB-测试-Auto-configured-Data-MongoDB-Tests"><a href="#自动配置的-Data-MongoDB-测试-Auto-configured-Data-MongoDB-Tests" class="headerlink" title="自动配置的 Data  MongoDB 测试 (Auto-configured Data MongoDB Tests)"></a>自动配置的 Data  MongoDB 测试 (Auto-configured Data MongoDB Tests)</h6><p>可以使用<code>@DataMongoTest</code> 来测试 MongoDB 应用.默认情况下,它配置内存中嵌入式 MongoDB(如果可用),配置 <code>MongoTemplate</code>,扫描 <code>@Document</code> 类并配置 Spring Data MongoDB 存储库.使用 <code>@DataMongoTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下类显示了正在使用的 <code>@DataMongoTest</code> 注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataMongoTestclass</span> MyDataMongoDbTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MongoTemplate mongoTemplate;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<p>内存嵌入式 MongoDB 通常适合用来测试,因为它速度快且不需要任何开发人员安装.但是,如果更喜欢针对真实的 MongoDB 服务器运行测试,则应排除嵌入式 MongoDB 自动配置,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyDataMongoDbTests</span> </span>&#123;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="自动配置的-Data-Neo4j-测试-Auto-configured-Data-Neo4j-Tests"><a href="#自动配置的-Data-Neo4j-测试-Auto-configured-Data-Neo4j-Tests" class="headerlink" title="自动配置的 Data  Neo4j 测试(Auto-configured Data Neo4j Tests)"></a>自动配置的 Data  Neo4j 测试(Auto-configured Data Neo4j Tests)</h6><p>可以使用 <code>@DataNeo4jTest</code> 来测试 Neo4j 应用程序.默认情况下,它会扫描 <code>@Node</code> 类,并配置 Spring Data Neo4j 存储库.使用 <code>@DataNeo4jTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下示例显示了在 Spring Boot 中使用 Neo4J 测试的典型设置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataNeo4jTestclass</span> MyDataNeo4jTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeRepository repository;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下,Data Neo4j 测试是事务性的,并在每次测试结束时回滚.有关详细信息,请参阅 Spring 框架参考文档中的<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a>.如果这不是想要的,可以为测试或整个班级禁用事务管理,如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataNeo4jTest</span><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><span class="class"><span class="keyword">class</span> <span class="title">MyDataNeo4jTests</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    响应式访问不支持事务性测试. 如果使用这个风格,则必须如上所述配置 <code>@DataNeo4jTest</code> 测试.</p>
</blockquote>
</li>
<li><h6 id="自动配置的Data-Redis-测试-Auto-configured-Data-Redis-Tests"><a href="#自动配置的Data-Redis-测试-Auto-configured-Data-Redis-Tests" class="headerlink" title="自动配置的Data  Redis 测试(Auto-configured Data Redis Tests)"></a>自动配置的Data  Redis 测试(Auto-configured Data Redis Tests)</h6><p>可以使用<code>@DataRedisTest</code> 来测试Redis 应用.默认情况下,它会扫描 <code>@RedisHash</code> 类并配置 Spring Data Redis 存储库.使用<code>@DataRedisTest</code> 注解时,不会扫描常规的<code>@Component</code> 和<code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下示例显示了正在使用的 <code>@DataRedisTest</code> 注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataRedisTestclass</span> MyDataRedisTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeRepository repository;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="自动配置的Data-LDAP-测试-Auto-configured-Data-LDAP-Tests"><a href="#自动配置的Data-LDAP-测试-Auto-configured-Data-LDAP-Tests" class="headerlink" title="自动配置的Data LDAP 测试(Auto-configured Data LDAP Tests)"></a>自动配置的Data LDAP 测试(Auto-configured Data LDAP Tests)</h6><p>可以使用 <code>@DataLdapTest</code> 来测试 LDAP 应用.默认情况下,它会配置内存中的嵌入式 LDAP(如果可用),配置 <code>LdapTemplate</code>,扫描 <code>@Entry</code> 类并配置 Spring Data LDAP 存储库.使用 <code>@DataLdapTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下示例显示了正在使用的 <code>@DataLdapTest</code> 注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataLdapTestclass</span> MyDataLdapTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> LdapTemplate ldapTemplate;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<p>内存嵌入式 LDAP 通常适合用来测试,因为它速度快且不需要任何开发人员安装.但是,如果更喜欢针对真实 LDAP 服务器运行测试,则应排除嵌入式 LDAP 自动配置,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyDataLdapTests</span> </span>&#123;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="自动配置的-REST-客户端-Auto-configured-REST-Clients"><a href="#自动配置的-REST-客户端-Auto-configured-REST-Clients" class="headerlink" title="自动配置的 REST 客户端(Auto-configured REST Clients)"></a>自动配置的 REST 客户端(Auto-configured REST Clients)</h6><p>可以使用 <code>@RestClientTest</code> 注解来测试 REST 客户端.默认情况下,它会自动配置 Jackson,GSON 和 Jsonb 支持,配置 <code>RestTemplateBuilder</code>,并添加对 <code>MockRestServiceServer</code> 的支持.使用 <code>@RestClientTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean. <code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>应使用<code>@RestClientTest</code> 的 <code>value</code> 或 <code>components</code> 属性指定要测试的特定 bean,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestClientTest(RemoteVehicleDetailsService.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyRestClientTests</span> </span>&#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RemoteVehicleDetailsService service;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockRestServiceServer server;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">getVehicleDetailsWhenResultIsSuccessShouldReturnDetails</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="keyword">this</span>.server.expect(requestTo(<span class="string">&quot;/greet/details&quot;</span>)).andRespond(withSuccess(<span class="string">&quot;hello&quot;</span>, MediaType.TEXT_PLAIN));        String greeting = <span class="keyword">this</span>.service.callRestService();        assertThat(greeting).isEqualTo(<span class="string">&quot;hello&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="自动配置的-Spring-REST-文档测试-Auto-configured-Spring-REST-Docs-Tests"><a href="#自动配置的-Spring-REST-文档测试-Auto-configured-Spring-REST-Docs-Tests" class="headerlink" title="自动配置的 Spring REST 文档测试(Auto-configured Spring REST Docs Tests)"></a>自动配置的 Spring REST 文档测试(Auto-configured Spring REST Docs Tests)</h6><p>可以使用 <code>@AutoConfigureRestDocs</code> 标注在 Mock MVC,REST Assured 或 WebTestClient上,从而在测试中使用 Spring REST Docs.这样, Spring REST Docs 就不需要 JUnit 扩展.</p>
<p><code>@AutoConfigureRestDocs</code> 可用于覆盖默认输出目录(如果使用 Maven,则为 <code>target/generated-snippets</code>,如果您使用 Gradle,则为 <code>build/generated-snippets</code>).它还可以用于配置出现在任何记录的 URI 中的host,scheme和port .</p>
<h6 id="使用-Mock-MVC-自动配置-Spring-REST-Docs-测试-Auto-configured-Spring-REST-Docs-Tests-with-Mock-MVC"><a href="#使用-Mock-MVC-自动配置-Spring-REST-Docs-测试-Auto-configured-Spring-REST-Docs-Tests-with-Mock-MVC" class="headerlink" title="使用 Mock MVC 自动配置 Spring REST Docs 测试(Auto-configured Spring REST Docs Tests with Mock MVC)"></a>使用 Mock MVC 自动配置 Spring REST Docs 测试(Auto-configured Spring REST Docs Tests with Mock MVC)</h6><p><code>@AutoConfigureRestDocs</code> 自定义 <code>MockMvc</code> bean 从而在测试基于 Servlet 的 Web 应用时,使用 Spring REST Docs.可以使用 <code>@Autowired</code> 注入它,并像使用 Mock MVC 和 Spring REST Docs 时通常那样在测试中使用它,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(UserController.class)</span><span class="meta">@AutoConfigureRestDocsclass</span> MyUserDocumentationTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockMvc mvc;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">listUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="keyword">this</span>.mvc.perform(get(<span class="string">&quot;/users&quot;</span>).accept(MediaType.TEXT_PLAIN))            .andExpect(status().isOk())            .andDo(document(<span class="string">&quot;list-users&quot;</span>));    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要更多地控制 Spring REST Docs 配置,比 <code>@AutoConfigureRestDocs</code> 所提供的属性更多,可以使用 <code>RestDocsMockMvcConfigurationCustomizer</code> bean,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestDocsConfiguration</span> <span class="keyword">implements</span> <span class="title">RestDocsMockMvcConfigurationCustomizer</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(MockMvcRestDocumentationConfigurer configurer)</span> </span>&#123;        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="自动配置的-Spring-Web-服务测试-Auto-configured-Spring-Web-Services-Tests"><a href="#自动配置的-Spring-Web-服务测试-Auto-configured-Spring-Web-Services-Tests" class="headerlink" title="自动配置的 Spring Web 服务测试(Auto-configured Spring Web Services Tests)"></a>自动配置的 Spring Web 服务测试(Auto-configured Spring Web Services Tests)</h6><p>可以使用 <code>@WebServiceClientTest</code> 来测试那些使用 Spring Web Services project调用 Web 服务的应用.默认情况下,它配置一个模拟 <code>WebServiceServer</code> bean 并自动自定义 <code>WebServiceTemplateBuilder</code>.</p>
<p>以下示例显示了正在使用的 <code>@WebServiceClientTest</code> 注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServiceClientTest(SomeWebService.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyWebServiceClientTests</span> </span>&#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockWebServiceServer server;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeWebService someWebService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">mockServerCall</span><span class="params">()</span> </span>&#123;        <span class="keyword">this</span>.server            .expect(payload(<span class="keyword">new</span> StringSource(<span class="string">&quot;&lt;request/&gt;&quot;</span>)))            .andRespond(withPayload(<span class="keyword">new</span> StringSource(<span class="string">&quot;&lt;response&gt;&lt;status&gt;200&lt;/status&gt;&lt;/response&gt;&quot;</span>)));        assertThat(<span class="keyword">this</span>.someWebService.test())            .extracting(Response::getStatus)            .isEqualTo(<span class="number">200</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="额外的自动配置和切片-Additional-Auto-configuration-and-Slicing"><a href="#额外的自动配置和切片-Additional-Auto-configuration-and-Slicing" class="headerlink" title="额外的自动配置和切片(Additional Auto-configuration and Slicing)"></a>额外的自动配置和切片(Additional Auto-configuration and Slicing)</h6><p>每个slice提供一个或多个 <code>@AutoConfigure...</code> 注解,这些注解定义作为切片的一部分的自动配置.可以通过创建自定义 <code>@AutoConfigure…</code> 注解或将 <code>@ImportAutoConfiguration</code> 添加到测试中,逐个测试地添加其他自动配置,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JdbcTest</span><span class="meta">@ImportAutoConfiguration(IntegrationAutoConfiguration.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyJdbcTests</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    确保不要使用常规的 <code>@Import</code> 注解来导入自动配置,因为它们是由 Spring Boot 以特定方式处理的.</p>
</blockquote>
<p>或者,对于使用的任何的切片注解,都可以通过在 <code>META-INF/spring.factories</code> 中注册,来添加额外的自动配置,如以下示例所示:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.test.autoconfigure.jdbc.JdbcTest</span>=<span class="string">com.example.IntegrationAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    切片或@<code>AutoConfigure… </code>注解可以通过这种方式自定义,只要它使用<code>@ImportAutoConfiguration</code> 进行元注解.</p>
</blockquote>
</li>
<li><h6 id="用户配置和切片-User-Configuration-and-Slicing"><a href="#用户配置和切片-User-Configuration-and-Slicing" class="headerlink" title="用户配置和切片 (User Configuration and Slicing)"></a>用户配置和切片 (User Configuration and Slicing)</h6><p>如果以合理的方式构建代码,默认情况下将使用 <code>@SpringBootApplication</code> 类作为测试的配置.</p>
<p>然后,重要的是不要在应用程序的主类中使用特定于其功能特定区域的配置设置.</p>
<p>假设使用的是 Spring Batch 并且依赖于它的自动配置. 可以定义 <code>@SpringBootApplication</code> 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableBatchProcessingpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为这个类是测试的源配置,所以任何切片测试实际上都是尝试启动Spring Batch,这绝对不是你想要的.</p>
<p>推荐的方法是将特定于区域的配置移动到与应用程序相同级别的单独 <code>@Configuration</code> 类中,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="meta">@EnableBatchProcessingpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatchConfiguration</span> </span>&#123;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    根据应用程序的复杂性,可能有一个用于自定义的 <code>@Configuration</code> 类,或者每个域区域有一个类.后一种方法允许在其中一个测试中启用它,如有必要,使用 <code>@Import</code> 注解.</p>
</blockquote>
<p>测试切片从扫描中排除 <code>@Configuration</code> 类.例如,对于<code>@WebMvcTest</code>,以下配置不会包含由测试切片加载的应用程序context中给定的 <code>WebMvcConfigurer</code> bean:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebConfiguration</span> </span>&#123;    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">testConfigurer</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;            <span class="comment">// ...        &#125;;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是,下面的配置将导致测试切片加载自定义 <code>WebMvcConfigurer</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<p>另一个混淆源是classpath扫描.假设,当以合理的方式构建代码时,需要扫描一个额外的包.应用可能类似于以下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="meta">@ComponentScan(&#123; &quot;com.example.app&quot;, &quot;com.example.another&quot; &#125;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<p>这样做有效地覆盖了默认的组件扫描指令,但会有副作用,而不管选择哪个切片,都会扫描这两个包.例如,<code>@DataJpaTest</code> 似乎突然扫描应用程序的组件和用户配置.同样,将自定义指令移至单独的类是解决此问题的好方法.</p>
<blockquote>
<p>建议:</p>
<p>​    如果想要的不是这个,可以在测试层次结构中的某处创建一个 <code>@SpringBootConfiguration</code> 来使用.或者,可以为测试指定一个源,这将禁用查找默认源的行为.</p>
</blockquote>
</li>
<li><h6 id="使用-Spock-测试-Spring-Boot-应用程序-Using-Spock-to-Test-Spring-Boot-Applications"><a href="#使用-Spock-测试-Spring-Boot-应用程序-Using-Spock-to-Test-Spring-Boot-Applications" class="headerlink" title="使用 Spock 测试 Spring Boot 应用程序 (Using Spock to Test Spring Boot Applications)"></a>使用 Spock 测试 Spring Boot 应用程序 (Using Spock to Test Spring Boot Applications)</h6><p>Spock 2.x 可用于测试 Spring Boot 应用程序.为此,请在应用程序的构建中添加对 Spock 的 <code>spock-spring</code> 模块的依赖.<code>spock-spring</code> 将 Spring 的测试框架集成到 Spock 中.</p>
</li>
</ol>
</li>
<li><h6 id="测试工具-Test-Utilities"><a href="#测试工具-Test-Utilities" class="headerlink" title="测试工具(Test Utilities)"></a>测试工具(Test Utilities)</h6><p>有一些实用程序类被打包为 <code>spring-boot</code> 的一部分,在测试时通常会很有用.</p>
<ol>
<li><h6 id="ConfigDataApplicationContextInitializer"><a href="#ConfigDataApplicationContextInitializer" class="headerlink" title="ConfigDataApplicationContextInitializer"></a>ConfigDataApplicationContextInitializer</h6><p><code>ConfigDataApplicationContextInitializer</code> 是一个 <code>ApplicationContextInitializer</code>,可以将其应用于测试,用来加载 Spring Boot 的<code>application.properties</code> 文件.当不需要<code>@SpringBootTest</code> 提供的完整功能时,可以使用它,如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(classes = Config.class, initializers = ConfigDataApplicationContextInitializer.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyConfigFileTests</span> </span>&#123;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    单独使用 <code>ConfigDataApplicationContextInitializer</code> 不支持 <code>@Value(&quot;$&#123;… &#125;&quot;)</code> 注入.它唯一的工作是确保 <code>application.properties</code> 文件加载到 Spring 的<code>Environment</code>中.对于<code>@Value</code> 支持,需要另外配置一个 <code>PropertySourcesPlaceholderConfigurer</code> 或使用 <code>@SpringBootTest</code>,它会为自动配置一个.</p>
</blockquote>
</li>
<li><h6 id="TestPropertyValues"><a href="#TestPropertyValues" class="headerlink" title="TestPropertyValues"></a>TestPropertyValues</h6><p><code>TestPropertyValues</code> 允许您快速将属性添加到 <code>ConfigurableEnvironment</code> 或 <code>ConfigurableApplicationContext</code>. 可以使用 <code>key=value</code> 字符串调用它,如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEnvironmentTests</span> </span>&#123;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testPropertySources</span><span class="params">()</span> </span>&#123;        MockEnvironment environment = <span class="keyword">new</span> MockEnvironment();        TestPropertyValues.of(<span class="string">&quot;org=Spring&quot;</span>, <span class="string">&quot;name=Boot&quot;</span>).applyTo(environment);        assertThat(environment.getProperty(<span class="string">&quot;name&quot;</span>)).isEqualTo(<span class="string">&quot;Boot&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="OutputCapture"><a href="#OutputCapture" class="headerlink" title="OutputCapture"></a>OutputCapture</h6><p><code>OutputCapture</code> 是一个 <code>JUnit</code> 扩展,可用于捕获 <code>System.out</code> 和 <code>System.err</code> 输出.要使用 add <code>@ExtendWith(OutputCaptureExtension.class)</code> 并将 <code>CapturedOutput</code> 作为参数注入测试类构造函数或测试方法,如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(OutputCaptureExtension.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyOutputCaptureTests</span> </span>&#123;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testName</span><span class="params">(CapturedOutput output)</span> </span>&#123;        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);        assertThat(output).contains(<span class="string">&quot;World&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="TestRestTemplate"><a href="#TestRestTemplate" class="headerlink" title="TestRestTemplate"></a>TestRestTemplate</h6><p><code>TestRestTemplate</code> 是 Spring 的 <code>RestTemplate</code> 的便捷替代品,在集成测试中很有用.可以获得一个vanilla 模板或一个发送基本 HTTP 身份验证(使用用户名和密码)的模板.在任何一种情况下,模板都是容错的.这意味着它不会在 4xx 和 5xx 错误上引发异常,从而以测试友好的方式运行.相反,可以通过返回的 <code>ResponseEntity</code> 及其状态代码检测此类错误.</p>
<blockquote>
<p>建议:</p>
<p>​    Spring Framework 5.0 提供了一个新的 <code>WebTestClient</code>,适用于 WebFlux 集成测试以及 WebFlux 和 MVC 端到端测试.与 <code>TestRestTemplate</code> 不同,它为断言提供了流式 API.</p>
</blockquote>
<p>建议但不强制使用 Apache HTTP 客户端(4.3.2 或更高版本).如果classpath中有它,<code>TestRestTemplate</code> 会通过适当配置客户端来响应.如果确实使用 Apache 的 HTTP 客户端,则会启用一些额外的对测试友好的功能:</p>
<ul>
<li>不遵循Redirect(因此可以断言响应位置).</li>
<li>Cookie 被忽略(因此模板是无状态的).</li>
</ul>
<p><code>TestRestTemplate</code> 可以直接在集成测试中实例化,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;    <span class="keyword">private</span> TestRestTemplate template = <span class="keyword">new</span> TestRestTemplate();    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        ResponseEntity&lt;String&gt; headers = <span class="keyword">this</span>.template.getForEntity(<span class="string">&quot;https://myhost.example.com/example&quot;</span>, String.class);        assertThat(headers.getHeaders().getLocation()).hasHost(<span class="string">&quot;other.example.com&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>或者,如果将 <code>@SpringBootTest</code> 注解与 <code>WebEnvironment.RANDOM_PORT</code> 或 <code>WebEnvironment.DEFINED_PORT</code> 一起使用,可以注入一个完全配置的 <code>TestRestTemplate</code> 并开始使用它.如有必要,可以通过 <code>RestTemplateBuilder </code>bean 应用其他自定义.任何未指定host和port的 URL 都会自动连接到嵌入式服务器,如以下示例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span><span class="class"><span class="keyword">class</span> <span class="title">MySpringBootTests</span> </span>&#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> TestRestTemplate template;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> </span>&#123;        HttpHeaders headers = <span class="keyword">this</span>.template.getForEntity(<span class="string">&quot;/example&quot;</span>, String.class).getHeaders();        assertThat(headers.getLocation()).hasHost(<span class="string">&quot;other.example.com&quot;</span>);    &#125;    <span class="meta">@TestConfiguration(proxyBeanMethods = false)</span>    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateBuilderConfiguration</span> </span>&#123;        <span class="meta">@Bean</span>        <span class="function">RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">()</span> </span>&#123;            <span class="keyword">return</span> <span class="keyword">new</span> RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(<span class="number">1</span>))                    .setReadTimeout(Duration.ofSeconds(<span class="number">1</span>));        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>3.7 Feature: 开发Web应用</title>
    <url>/posts/5461.html</url>
    <content><![CDATA[<h5 id="开发web应用-Developing-Web-Applications"><a href="#开发web应用-Developing-Web-Applications" class="headerlink" title="开发web应用(Developing Web Applications)"></a>开发web应用(Developing Web Applications)</h5><p>   Spring Boot非常适合于Web应用程序开发.可以使用嵌入式Tomcat,Jetty,Undertow或Netty创建独立的HTTP服务器..大多数Web应用程序都使用<code>spring-boot-starter-web</code>模块来快速启动和运行.还可以选择使用<code>spring-boot-starter-webflux</code>模块构建反应式Web应用程序.</p>
<ol>
<li><h6 id="SpringMVC-The-“Spring-Web-MVC-Framework”"><a href="#SpringMVC-The-“Spring-Web-MVC-Framework”" class="headerlink" title="SpringMVC(The “Spring Web MVC Framework”)"></a>SpringMVC(The “Spring Web MVC Framework”)</h6>Spring Web MVC框架(通常称为” Spring MVC”)是一个丰富的”模型 视图 控制器” Web框架. Spring MVC使可以创建<code>@Controller</code>或<code>@RestController</code>Bean来处理传入的HTTP请求.使用<code>@RequestMapping</code>注解将controller中的方法映射到HTTP.<br>以下代码显示了提供JSON数据的典型<code>@RestController</code>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerRepository customerRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRestController</span><span class="params">(UserRepository userRepository, CustomerRepository customerRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">        <span class="keyword">this</span>.customerRepository = customerRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userRepository.findById(userId).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;user&#125;/customers&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userRepository.findById(userId).map(<span class="keyword">this</span>.customerRepository::findByUser).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository.deleteById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><h6 id="Spring-MVC自动配置-Spring-MVC-Auto-configuration"><a href="#Spring-MVC自动配置-Spring-MVC-Auto-configuration" class="headerlink" title="Spring MVC自动配置(Spring MVC Auto-configuration)"></a>Spring MVC自动配置(Spring MVC Auto-configuration)</h6>Spring Boot为Spring MVC提供了自动配置,可与大多数应用程序一起良好使用.<br>自动配置在Spring的默认设置之上添加了以下功能:<ul>
<li>包含<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>Bean</li>
<li>支持服务静态资源,包括对WebJars的支持</li>
<li>自动注册<code>Converter</code>,<code>GenericConverter</code>和<code>Formatter</code>Bean</li>
<li>支持<code>HttpMessageConverters</code></li>
<li>自动注册<code>MessageCodesResolver</code></li>
<li>静态<code>index.html</code>支持</li>
<li>自动使用<code>ConfigurableWebBindingInitializer</code>Bean<br>如果要保留这些Spring Boot MVC定制并进行更多的MVC定制(拦截器,格式化程序,视图控制器和其他功能),则可以添加自己的类型为<code>WebMvcConfigurer</code>的<code>@Configuration</code>类,但不添加<code>@EnableWebMvc</code>.<br>如果要提供<code>RequestMappingHandlerMapping</code>,<code>RequestMappingHandlerAdapter</code>或<code>ExceptionHandlerExceptionResolver</code>的自定义实例,并且仍然保留Spring Boot MVC的定制化,则可以声明<code>WebMvcRegistrations</code>类型的bean,并使用它提供这些组件的自定义实例.<br>如果要完全控制Spring MVC,则可以添加用<code>@EnableWebMvc</code>标注的自己的<code>@Configuration</code>类,或者按照<code>@EnableWebMvc</code>的Javadoc中的说明的,添加自己的<code>@Configuration</code>标注的的<code>DelegatingWebMvcConfiguration</code>类.<blockquote>
<p>注意:</p>
<p>​    Spring MVC使用的<code>ConversionService</code>与用于从<code>application.properties</code>或<code>application.yaml</code>中用来转换值的<code>ConversionService</code>不同.这意味着<code>Period</code>,<code>Duration</code>和<code>DataSize</code>转换器不可用,<code>@DurationUnit</code>和<code>@DataSizeUnit</code>注解将被忽略.<br>如果要自定义Spring MVC使用的<code>ConversionService</code>,则可以提供一个有<code>addFormatters</code>方法的<code>WebMvcConfigurer</code>bean. 通过此方法,可以注册所需的任何转换器,也可以委托给<code>ApplicationConversionService</code>上可用的静态方法.</p>
</blockquote>
</li>
</ul>
</li>
<li><h6 id="HttpMessageConverters"><a href="#HttpMessageConverters" class="headerlink" title="HttpMessageConverters"></a>HttpMessageConverters</h6>Spring MVC使用<code>HttpMessageConverter</code>接口转换HTTP请求和响应.开箱即用中包含合理的默认设置.例如,Spring Boot可以将对象自动转换为JSON(通过使用Jackson库)或XML(通过使用Jackson XML扩展(如果可用)或通过使用JAXB(如果Jackson XML扩展不可用)).默认情况下,字符串以UTF-8编码.<br>如果需要添加或自定义转换器,则可以使用Spring Boot的<code>HttpMessageConverters</code>类,如以下列表所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpMessageConvertersConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpMessageConverter&lt;?&gt; additional = <span class="keyword">new</span> AdditionalHttpMessageConverter();</span><br><span class="line">        HttpMessageConverter&lt;?&gt; another = <span class="keyword">new</span> AnotherHttpMessageConverter();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上下文中存在的所有<code>HttpMessageConverter</code> bean都将添加到转换器列表中. 您也可以用相同的方法覆盖默认转换器.</li>
<li><h6 id="自定义JSON序列化器和反序列化器-Custom-JSON-Serializers-and-Deserializers"><a href="#自定义JSON序列化器和反序列化器-Custom-JSON-Serializers-and-Deserializers" class="headerlink" title="自定义JSON序列化器和反序列化器( Custom JSON Serializers and Deserializers)"></a>自定义JSON序列化器和反序列化器( Custom JSON Serializers and Deserializers)</h6>如果使用Jackson来序列化和反序列化JSON数据,则可能要实现自己的<code>JsonSerializer</code>和<code>JsonDeserializer</code>类.自定义序列化程序通常是通过模块向Jackson注册的,但是Spring Boot提供了可选的<code>@JsonComponent</code>注解,这使得直接注册Spring Bean更加容易.您可以直接在<code>JsonSerializer</code>,<code>JsonDeserializer</code>或<code>KeyDeserializer</code>实现上使用<code>@JsonComponent</code>注解.您还可以在包含serializers/deserializers  作为内部类的类上使用它,如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJsonComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(MyObject value, JsonGenerator jgen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            jgen.writeStringField(<span class="string">&quot;name&quot;</span>, value.getName());</span><br><span class="line">            jgen.writeNumberField(<span class="string">&quot;age&quot;</span>, value.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyObject <span class="title">deserialize</span><span class="params">(JsonParser jsonParser, DeserializationContext ctxt)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">            ObjectCodec codec = jsonParser.getCodec();</span><br><span class="line">            JsonNode tree = codec.readTree(jsonParser);</span><br><span class="line">            String name = tree.get(<span class="string">&quot;name&quot;</span>).textValue();</span><br><span class="line">            <span class="keyword">int</span> age = tree.get(<span class="string">&quot;age&quot;</span>).intValue();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyObject(name, age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用Jackson时,<code>ApplicationContext</code>中的所有<code>@JsonComponent</code>bean都会自动注册. 因为<code>@JsonComponent</code>是使用<code>@Component</code>进行元注释的,所以通常的组件扫描规则适用.<br>Spring Boot还提供了<code>JsonObjectSerializer</code>和<code>JsonObjectDeserializer</code>基类,这些基类在序列化对象时为标准Jackson版本提供了有用的替代方法.<br>可以将上面的示例重写为使用<code>JsonObjectSerializer / JsonObjectDeserializer</code>,如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJsonComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> <span class="keyword">extends</span> <span class="title">JsonObjectSerializer</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">serializeObject</span><span class="params">(MyObject value, JsonGenerator jgen, SerializerProvider provider)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            jgen.writeStringField(<span class="string">&quot;name&quot;</span>, value.getName());</span><br><span class="line">            jgen.writeNumberField(<span class="string">&quot;age&quot;</span>, value.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> <span class="keyword">extends</span> <span class="title">JsonObjectDeserializer</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> MyObject <span class="title">deserializeObject</span><span class="params">(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec,</span></span></span><br><span class="line"><span class="params"><span class="function">                JsonNode tree)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String name = nullSafeValue(tree.get(<span class="string">&quot;name&quot;</span>), String.class);</span><br><span class="line">            <span class="keyword">int</span> age = nullSafeValue(tree.get(<span class="string">&quot;age&quot;</span>), Integer.class);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyObject(name, age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="消息解析器-MessageCodesResolver"><a href="#消息解析器-MessageCodesResolver" class="headerlink" title="消息解析器(MessageCodesResolver)"></a>消息解析器(MessageCodesResolver)</h6>Spring MVC有一种生成error code的策略,该错误码用于当发生绑定错误时,显示错误消息:<code>MessageCodesResolver</code>.如果您设置<code>spring.mvc.message-codes-resolver-format</code>属性<code>PREFIX_ERROR_CODE</code>或<code>POSTFIX_ERROR_CODE</code>,Spring Boot会为创建一个.</li>
<li><h6 id="静态资源-Static-Content"><a href="#静态资源-Static-Content" class="headerlink" title="静态资源(Static Content)"></a>静态资源(Static Content)</h6>默认情况下,Spring Boot提供类路径中的<code>/static目录</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF / resources</code>)或<code>ServletContext</code>的根目录中静态内容.它使用Spring MVC中的<code>ResourceHttpRequestHandler</code>,所以可以通过添加自己的<code>WebMvcConfigurer</code>并覆盖<code>addResourceHandlers</code>方法来修改该行为.<br>在一个单独的Web应用程序中,容器中的默认Servlet被启用并且作为备用项.如果Spring不处理请求,那么就会从ServletContext的根目录提供内容.在大多数情况下,这不会发生(除非修改默认的MVC配置),因为Spring始终可以使用DispatcherServlet处理请求.<br>默认情况下,资源映射在<code>/**</code>上,但是您可以使用<code>spring.mvc.static-path-pattern</code>属性对其进行调整. 例如,将所有资源重定位到<code>/resources/**</code>可以如下实现:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.static-path-pattern</span>=<span class="string">/resources/**</span></span><br></pre></td></tr></table></figure>
您还可以使用<code>spring.web.resources.static-locations</code>属性来自定义静态资源路径(可以用目录位置列表替换默认值).根Servlet上下文路径<code>&quot;/&quot;</code>也会自动添加为路径.<br>除了前面提到的”标准”静态资源路径,Webjar格式也有特殊情况. 如果jar文件以Webjars格式打包,则从jar文件中提供路径为<code>/webjars/**</code>的所有资源.<blockquote>
<p>建议:</p>
<p>​    如果您的应用程序打包为jar,则不要使用<code>src/main/webapp</code>目录. 尽管此目录是一个通用标准,但它仅适用于war打包,并且如果生成jar,大多数构建工具都将其默默地忽略它.<br>Spring Boot还支持Spring MVC提供的高级资源处理功能,允许使用一些功能,例如缓存清除静态资源或在Webjars中使用版本无关的URL.<br>想要使用在Webjar中使用版本无关的URL,需要添加<code>webjars-locator-core</code>依赖.然后在Webjar中声明.比如使用JQuery,添加<code>/webjars/jquery/jquery.min.js</code>会变成<code>/webjars/jquery/x.y.z/jquery.min.js</code>,其中<code>x.y.z</code>就是Webjar的版本.<br>注意:</p>
<p>​    如果使用JBoss,则需要声明<code>webjars-locator-jboss-vfs</code>依赖,而不是<code>webjars-locator-core</code>. 否则,所有Webjar都解析为404.<br>要使用缓存清除,以下配置可为所有静态资源配置缓存清除解决方案,并在URL中有效地添加内容哈希,例如<code>&lt;link href =&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code></p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.web.resources.chain.strategy.content.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.web.resources.chain.strategy.content.paths</span>=<span class="string">/**</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    <code>ResourceUrlEncodingFilter</code>是为Thymeleaf和FreeMarker自动配置的,这可以在运行时,在模板中写入资源链接.使用JSP时,应该手动声明此过滤器. 当前尚不自动支持其他模板引擎,但可以与自定义模板<code> macros/helpers</code>一起使用,也可以与<code>ResourceUrlProvider</code>一起使用.<br>当加载动态资源时,例如,当使用JavaScript模块加载器时,不能重命名文件. 这就是为什么支持其他策略并且可以组合的原因. “fixed”策略在URL中添加静态的版本字符串,而不更改文件名,如以下示例所示:</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.web.resources.chain.strategy.content.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.web.resources.chain.strategy.content.paths</span>=<span class="string">/**</span></span><br><span class="line"><span class="meta">spring.web.resources.chain.strategy.fixed.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.web.resources.chain.strategy.fixed.paths</span>=<span class="string">/js/lib/</span></span><br><span class="line"><span class="meta">spring.web.resources.chain.strategy.fixed.version</span>=<span class="string">v12</span></span><br></pre></td></tr></table></figure>
通过这种配置,在<code>&quot;/js/lib/&quot;</code>目录下的JavaScript模块使用固定的版本控制策略(<code>&quot;/v12/js/lib/mymodule.js&quot;</code>),而其他资源仍使用内容策略(<link href =" / css / spring-2a2d595e6ed9a0b24f027f2b63b134d6.css" />).<blockquote>
<p>建议:</p>
<p>​    该功能已在专门的[博客文章][<a href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources]%E5%92%8CSpring">https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources]和Spring</a> Framework的[参考文档][<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/web.html#mvc-config-static-resources]%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BA%86%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E">https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/web.html#mvc-config-static-resources]中进行了详细说明</a>.</p>
</blockquote>
</li>
<li><h6 id="欢迎页面-Welcome-Page"><a href="#欢迎页面-Welcome-Page" class="headerlink" title="欢迎页面(Welcome Page)"></a>欢迎页面(Welcome Page)</h6>Spring Boot支持静态和模板两种欢迎页面. 它首先在配置的静态内容路径中查找index.html文件. 如果未找到,则寻找<code>index</code>模板. 如果找到任何一个,它将自动用作应用程序的欢迎页面.</li>
<li><h6 id="路径匹配和内容协商-Path-Matching-and-Content-Negotiation"><a href="#路径匹配和内容协商-Path-Matching-and-Content-Negotiation" class="headerlink" title="路径匹配和内容协商(Path Matching and Content Negotiation)"></a>路径匹配和内容协商(Path Matching and Content Negotiation)</h6>Spring MVC可以根据请求路径,将其映射到对应的处理器上(例如,Controller方法上的<code>@GetMapping</code>注解).<br>Spring Boot默认选择禁用后缀模式匹配,这意味着<code>&quot;GET /projects/spring-boot.json&quot;</code>之类的请求将不会映射到<code>@GetMapping(&quot;/projects/spring-boot&quot;)上</code>.这被认为是Spring MVC应用程序的最佳实践.过去,这个功能在HTTP客户端不能发送合适的”Accept请求头的时候很有用. 我们需要确保将正确的Content-Type发送给客户端. 如今,内容协商(Content Negotiation)已更可靠.<br>还有其他方法来处理不能够连续正确发送”Accept”请求头的HTTP客户端.不是使用后缀匹配,而是使用查询参数,来保证请求正确映射.<code>&quot;GET /projects/spring-boot?format=json&quot;</code>映射到<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
或者使用一个不同的参数名<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.mvc.contentnegotiation.parameter-name</span>=<span class="string">myparam</span></span><br></pre></td></tr></table></figure>
大多数标准媒体类型都可以开箱即用地支持,但也可以定义新的类型:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.contentnegotiation.media-types.markdown</span>=<span class="string">text/markdown</span></span><br></pre></td></tr></table></figure>
后缀模式匹配已被弃用,并将在以后的版本中删除. 如果了解了注意事项,但仍希望的应用程序使用后缀模式匹配,则需要以下配置:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.contentnegotiation.favor-path-extension</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.mvc.pathmatch.use-suffix-pattern</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
从Spring Framework 5.3开始,Spring MVC支持了多种实现策略,用于将请求路径匹配到Controller处理程序. 它以前仅支持<code>AntPathMatcher</code>策略,但现在还提供<code>PathPatternParser</code>. Spring Boot现在提供一个配置属性供您选择和选择新策略:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.pathmatch.matching-strategy</span>=<span class="string">path-pattern-parser</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    <code>PathPatternParser</code>是一种优化的implementation,但限制一些路径匹配变量的使用,并且与后缀模式匹配(<code>spring.mvc.pathmatch.use-suffix-pattern</code>,<code>spring.mvc.pathmatch.use-registered-suffix-pattern</code>)和将以Servlet开头的请求(<code>spring.mvc.servlet.path</code>)映射到<code>DispatcherServlet</code>不兼容.</p>
</blockquote>
</li>
<li><h6 id="ConfigurableWebBindingInitializer"><a href="#ConfigurableWebBindingInitializer" class="headerlink" title="ConfigurableWebBindingInitializer"></a>ConfigurableWebBindingInitializer</h6>Spring MVC使用<code>WebBindingInitializer</code>来为特定请求初始化<code>WebDataBinder</code>. 如果创建自己的<code>ConfigurableWebBindingInitializer</code> 的<code>@Bean</code>,Spring Boot会自动配置Spring MVC来使用它.</li>
<li><h6 id="模板引擎-Template-Engines"><a href="#模板引擎-Template-Engines" class="headerlink" title="模板引擎(Template Engines)"></a>模板引擎(Template Engines)</h6>​    除了REST Web服务之外,您还可以使用Spring MVC来提供动态HTML内容. Spring MVC支持各种模板技术,包括Thymeleaf,FreeMarker和JSP. 同样,许多其他模板引擎包括它们自己的Spring MVC集成.<br>Spring Boot包括对以下模板引擎的自动配置支持:<ul>
<li>FreeMarker</li>
<li>Groovy</li>
<li>Thymeleaf</li>
<li>Mustache<blockquote>
<p>建议:</p>
<p>​    如果可能,应避免使用JSP. 将它们与嵌入式Servlet容器一起使用时,存在几个已知的限制.<br>当您使用这些模板引擎的默认配置的时,将自动从<code>src/main/resources/templates</code>中获取模板.<br>建议:</p>
<p>​    取决于运行应用程序的方式,IDE可能不一样,比如使用classpath. 从IDE的main方法运行应用程序选择路径,与使用Maven或Gradle或从打包的jar运行应用程序时选择的路径可能会不一样. 这可能导致Spring Boot无法找到期望中的模板. 如果遇到此问题,可以在IDE中重新设置类路径,以首先放置模块的类和资源.</p>
</blockquote>
</li>
</ul>
</li>
<li><h6 id="错误处理-Error-Handling"><a href="#错误处理-Error-Handling" class="headerlink" title="错误处理(Error Handling)"></a>错误处理(Error Handling)</h6>默认情况下,Spring Boot提供了一个<code>/error</code>映射,用来以合理的方式处理所有错误,并且它已在servlet容器中注册为全局的错误页面.对于机器客户端,它将生成JSON响应,其中包含错误,HTTP状态和异常消息的详细信息. 对于浏览器客户端,会显示一个”whitelabel”错误视图,显示相同的错误数据(要对其进行自定义,请添加一个可解析<code>error</code>的<code>View</code>).<br>如果要自定义默认错误处理行为,有很多<code>server.error</code>属性,可以设置.<br>如果想完全替换默认行为,可以实现<code>ErrorController</code>并注册该类型的bean,或者添加类型为<code>ErrorAttributes</code>的bean来使用现有机制,但是替换其内容.<blockquote>
<p>建议:</p>
<p>​    <code>BasicErrorController</code>可用作自定义<code>ErrorController</code>的基类. 如果您想为新的Content-type添加处理程序(默认是专门处理text / html并为其他所有内容提供后备功能),则此功能特别有用. 为此,继承<code>BasicErrorController</code>,添加具有<code>@ProductMapping</code>且具有<code>Produces</code>属性的公共方法,并创建新类型的Bean.</p>
</blockquote>
您还可以定义一个带有<code>@ControllerAdvice</code>注解的类,去设置指定的controller或者exception返回JSON格式格式内容,可以如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(basePackageClasses = SomeController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerAdvice</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MyException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) &#123;</span><br><span class="line">        HttpStatus status = getStatus(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> MyErrorBody(status.value(), ex.getMessage()), status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HttpStatus <span class="title">getStatus</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Integer code = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);</span><br><span class="line">        HttpStatus status = HttpStatus.resolve(code);</span><br><span class="line">        <span class="keyword">return</span> (status != <span class="keyword">null</span>) ? status : HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在前面的示例中,如果<code>SomeController</code>包中抛出了<code>MyException</code> ,则将使用自定义错误类型的JSON形式返回,而不是<code>ErrorAttributes</code>形式.<br>在某些情况下, <a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.supported.spring-mvc">metrics infrastructure</a>不会记录在控制器级别被处理的错误. 可以将处理的异常设为request attribute,那么就可以确保将此类异常被记录在 metrics infrastructure中.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(CustomException.class)</span></span><br><span class="line">    <span class="function">String <span class="title">handleCustomException</span><span class="params">(HttpServletRequest request, CustomException ex)</span> </span>&#123;</span><br><span class="line">        request.setAttribute(ErrorAttributes.ERROR_ATTRIBUTE, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;errorView&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="自定义错误处理页面-Custom-Error-Pages"><a href="#自定义错误处理页面-Custom-Error-Pages" class="headerlink" title="自定义错误处理页面(Custom Error Pages)"></a>自定义错误处理页面(Custom Error Pages)</h6>如果要给定状态代码显示自定义HTML错误页面,可以在<code>/error</code>目录下添加错误文件. 错误页面可以是静态HTML(即添加到任何静态资源目录下),也可以使用模板来构建. 文件名应为准确的状态码或系列掩码.<br>例如,要将404映射到静态HTML文件,您的目录结构如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- public/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure>
要讲所有的<code>5xx</code>错误映射到FreeMarker模板上,目录结构如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.ftlh</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure>
对于更复杂的映射,还可以添加实现<code>ErrorViewResolver</code>接口的bean,如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorViewResolver</span> <span class="keyword">implements</span> <span class="title">ErrorViewResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use the request or status to optionally return a ModelAndView</span></span><br><span class="line">        <span class="keyword">if</span> (status == HttpStatus.INSUFFICIENT_STORAGE) &#123;</span><br><span class="line">            <span class="comment">// We could add custom model values here</span></span><br><span class="line">            <span class="keyword">new</span> ModelAndView(<span class="string">&quot;myview&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
您还可以使用常规的Spring MVC功能,例如<code>@ExceptionHandler</code>方法和<code>@ControllerAdvice</code>. 然后,<code>ErrorController</code>获得所有未处理的异常.<h6 id="映射Spring-MVC之外的错误页面-Mapping-Error-Pages-outside-of-Spring-MVC"><a href="#映射Spring-MVC之外的错误页面-Mapping-Error-Pages-outside-of-Spring-MVC" class="headerlink" title="映射Spring MVC之外的错误页面(Mapping Error Pages outside of Spring MVC)"></a>映射Spring MVC之外的错误页面(Mapping Error Pages outside of Spring MVC)</h6>对于没有Spring MVC的应用,可以使用<code>ErrorPageRegistrar</code>接口直接注册<code>ErrorPages</code>. 此抽象接口直接与基础嵌入式servlet容器一起使用,即使您没有Spring MVC <code>DispatcherServlet</code>,它也可以使用.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorPagesConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorPageRegistrar <span class="title">errorPageRegistrar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>::registerErrorPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="string">&quot;/400&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    如果您注册了一个最终由过滤器处理的路径(这在某些非Spring Web框架(如Jersey和Wicket)中很常见)的错误页面,则必须将过滤器显式注册为<code>ERROR</code>dispatcher,如 下面的例子:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilterConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;MyFilter&gt; <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyFilter&gt; registration = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;(<span class="keyword">new</span> MyFilter());</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意,默认的<code>FilterRegistrationBean</code>不包含<code>ERROR</code>dispatcher.<h6 id="在war部署中处理错误"><a href="#在war部署中处理错误" class="headerlink" title="在war部署中处理错误"></a>在war部署中处理错误</h6>当部署到servlet容器时,Spring Boot使用错误页面过滤器将具有错误状态的请求转发到适当的错误页面.这是很有必须的,因为Servlet规范没有提供用于注册错误页面的API.根据war文件部所署到的容器以及应用程序使用的技术,可能需要一些其他配置.<br>如果response尚未提交,则错误页面过滤器只能将请求转发到正确的错误页面.缺省情况下,WebSphere Application Server 8.0及更高版本在成功完成servlet的服务方法后提交响应.您应该通过将<code>com.ibm.ws.webcontainer.invokeFlushAfterService</code>设置为<code>false</code>来禁用此行为.<br>如果您使用的是Spring Security,并且想访问基本的错误页面,则必须配置Spring Security的过滤器,从而在分发错误的时候,过滤器能够被调用.为此,要将<code>spring.security.filter.dispatcher-types</code>属性设置为<code>async</code>,<code>error</code>,<code>forward</code>,<code>request</code>.</li>
<li><h6 id="Spring-HATEOAS"><a href="#Spring-HATEOAS" class="headerlink" title="Spring HATEOAS"></a>Spring HATEOAS</h6>如果使用超媒体开发RESTful API,Spring Boot为Spring HATEOAS提供自动配置能够适用于大多数应用. 使用自动配置,就不用使用<code>@EnableHypermediaSupport</code>,并且还注册了很多的bean,从而更容器构建基于超媒体的引用,包括<code>LinkDiscoverers</code>(用于支持客户端),还有一个配置过的<code>ObjectMapper</code>将response转换成想要的形式.通过设置很多的<code>spring.jackson.*</code>属性 来配置<code>ObjectMapper</code>,或者也可以使用<code>Jackson2ObjectMapperBuilder</code>.<br>可以使用<code>@EnableHypermediaSupport</code>来配置Spring HATEOAS.要注意,这样做之前要禁用<code>ObjectMapper</code>的自定义.</li>
<li><h6 id="跨域资源共享支持-CORS-Support"><a href="#跨域资源共享支持-CORS-Support" class="headerlink" title="跨域资源共享支持(CORS Support)"></a>跨域资源共享支持(CORS Support)</h6>跨域资源共享(CORS)是W3C规范,大多数浏览器都实现了该规范.这个规范可以以一种更灵活的方式来指定那些跨域请求要被验证,而不是式样一些安全性更低,功能更弱的方式,比如IFRAME 和JSONP.<br>在4.2的版本中,Spring MVC支持了CORS. 不需要任何额外配置,只需要应用中的controller方法上使用<code>@CrossOrigin</code>注解就可以.可以通过注册一个实现<code>WebMvcConfigurer</code>bean,使用<code>addCorsMappings(CorsRegistry)</code>方法来实现全局的CORS配置.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCorsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/api/**&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="Spring-WebFlux框架-The-“Spring-WebFlux-Framework”"><a href="#Spring-WebFlux框架-The-“Spring-WebFlux-Framework”" class="headerlink" title="Spring WebFlux框架(The “Spring WebFlux Framework”)"></a>Spring WebFlux框架(The “Spring WebFlux Framework”)</h5>Spring WebFlux是Spring Framework5.0的新的响应式网络框架.不同于Spring MVC,它并不需要Servlet API,是完全异步非阻塞的.通过Reacotr project实现了Reactive Streams.<br>Spring WebFlux有两种风格:函数式和基于注解式.基于注解式和Spring MVC的模式,如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerRepository customerRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRestController</span><span class="params">(UserRepository userRepository, CustomerRepository customerRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">        <span class="keyword">this</span>.customerRepository = customerRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userRepository.findById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;user&#125;/customers&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userRepository.findById(userId).flatMapMany(<span class="keyword">this</span>.customerRepository::findByUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository.deleteById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
“WebFlux.fn”,是函数式的变种,它将路由配置从请求的实际处理分离开来.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRoutingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">monoRouterFunction</span><span class="params">(MyUserHandler userHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> route(</span><br><span class="line">                GET(<span class="string">&quot;/&#123;user&#125;&quot;</span>).and(ACCEPT_JSON), userHandler::getUser).andRoute(</span><br><span class="line">                GET(<span class="string">&quot;/&#123;user&#125;/customers&quot;</span>).and(ACCEPT_JSON), userHandler::getUserCustomers).andRoute(</span><br><span class="line">                DELETE(<span class="string">&quot;/&#123;user&#125;&quot;</span>).and(ACCEPT_JSON), userHandler::deleteUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUserCustomers</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">deleteUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
WebFlux是Spring Framework框架的一部分.可以看看相关参考文档.<blockquote>
<p>建议:</p>
<p>​    可以根据需要定义任意数量的<code>RouterFunction</code>bean,从而对路由进行模块化. 如果需要使用优先级,可以对bean进行设置顺序.<br>开始前,要再应用中添加<code>spring-boot-starter-webflux</code>:<br>注意:</p>
<p>​    如果再应用中同时配置了,<code>spring-boot-starter-web</code>和<code>spring-boot-starter-webflux</code>,那么应用会默认配置使用<code>Spring MVC</code>,而不是WebFlux. 之所以会这样,是因为很多开发者添加<code>spring-boot-starter-webflux</code>到Spring MVC项目中来使用响应式的<code>WebClient</code>.也可以使用<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code>来强制设置应用程序的类型.</p>
</blockquote>
<ol>
<li><h6 id="Spring-WebFlux的自动配置-Spring-WebFlux-Auto-configuration"><a href="#Spring-WebFlux的自动配置-Spring-WebFlux-Auto-configuration" class="headerlink" title="Spring WebFlux的自动配置(Spring WebFlux Auto-configuration)"></a>Spring WebFlux的自动配置(Spring WebFlux Auto-configuration)</h6>Spring Boot提供的Spring WebFlux的自动配置和很多应用都可以良好配合使用.自动配置在Spring的默认设置之上添加了以下功能:<ul>
<li>为HttpMessageReader和HttpMessageWriter实例配置编解码器</li>
<li>支持服务静态内容,包括对WebJar的支持<br>如果想要保留现有的Spring Boot WebFlux功能,并且想要添加额外的功能配,可以添加<code>@Configuration</code>标注的<code>WebFluxConfigurer</code>类但是<em><strong>不使用</strong></em><code>@EnableWebFlux</code>.<br>如果想要彻底控制Spring WebFlux,可以使用<code>@EnableWebFlux</code>标注的<code>@Configuration</code>类.</li>
</ul>
</li>
<li><h6 id="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器-HTTP-Codecs-with-HttpMessageReaders-and-HttpMessageWriters"><a href="#带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器-HTTP-Codecs-with-HttpMessageReaders-and-HttpMessageWriters" class="headerlink" title="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器(HTTP Codecs with HttpMessageReaders and HttpMessageWriters)"></a>带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器(HTTP Codecs with HttpMessageReaders and HttpMessageWriters)</h6>Spring WebFlux使用<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>接口来转换HTTP请求和响应.通过判断在classpath中是否存在这两个库,使用<code>CodecConfigurer</code>来为他们配置了合理的默认配置.<br>Spring Boot为编解码器提供了配置属性,<code>spring.codec.*</code>.它还通过使用<code>CodecCustomizer</code>实例应用进一步的自定义.例如,<code>spring.jackson.*</code>配置key被应用于Jackson编解码器上.<br>如果需要添加或自定义编解码器,则可以创建一个自定义<code>CodecCustomizer</code>组件,如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCodecsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CodecCustomizer <span class="title">myCodecCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (configurer) -&gt; &#123;</span><br><span class="line">            configurer.registerDefaults(<span class="keyword">false</span>);</span><br><span class="line">            configurer.customCodecs().register(<span class="keyword">new</span> ServerSentEventHttpMessageReader());</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="静态内容-Static-Content"><a href="#静态内容-Static-Content" class="headerlink" title="静态内容(Static Content)"></a>静态内容(Static Content)</h6>默认情况下,Spring Boot从类路径中名为<code>/static</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>)的目录中提供静态内容.使用的是Spring WebFlux的<code>ResourceWebHandler</code>,因此可以通过添加自己的<code>WebFluxConfigurer</code>和重写<code>addResourceHandlers</code>方法来修改行为.<br>默认情况下,资源映射在<code>/**</code> 上,但是可以通过设置<code>spring.webflux.static-path-pattern</code>属性来对其进行调整. 例如,将所有资源重定位到<code>/resources/**</code>可以实现如下:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.webflux.static-path-pattern</span>=<span class="string">/resources/**</span></span><br></pre></td></tr></table></figure>
您还可以使用<code>spring.web.resources.static-locations</code>自定义静态资源位置.这样做会将默认值替换为目录路径列表.如果这样做,将会在自定义路径中检测默认欢迎页面. 因此,如果启动时任何一个路径下有index.html,则它是应用程序的主页.<br>除了前面列出的”标准”静态资源路径外,Webjar内容有特殊情况. 如果jar文件以Webjars格式打包,则服务jar文件中路径为<code>/webjars/**</code>的所有资源.<blockquote>
<p>建议:</p>
<p>​    Spring WebFlux应用程序不依赖Servlet API,因此不能将它们部署为war文件,也不要使用<code>src/main/webapp</code>目录.</p>
</blockquote>
</li>
<li><h6 id="欢迎页面-Welcome-Page-1"><a href="#欢迎页面-Welcome-Page-1" class="headerlink" title="欢迎页面(Welcome Page)"></a>欢迎页面(Welcome Page)</h6>Spring Boot支持静态和模板欢迎页面. 它首先在配置的静态内容路径中查找<code>index.html</code>文件. 如果未找到,则寻找<code>index</code>模板. 如果找到任何一个,就默认作为应用程序的欢迎页面.</li>
<li><h6 id="模板引擎-Template-Engines-1"><a href="#模板引擎-Template-Engines-1" class="headerlink" title="模板引擎(Template Engines)"></a>模板引擎(Template Engines)</h6>除了REST Web服务之外,您还可以使用Spring WebFlux来提供动态HTML内容. Spring WebFlux支持各种模板技术,包括Thymeleaf,FreeMarker和Mustache.<br>Spring Boot对以下模板引擎支持自动配置:<ul>
<li><a href="https://freemarker.apache.org/docs/">FreeMarker</a></li>
<li><a href="https://www.thymeleaf.org/">Thymeleaf</a></li>
<li><a href="https://mustache.github.io/">Mustache</a><br>当使用模板引擎和相关默认配置时,将从<code>src/main/resources/templates</code>中自动获取模板.</li>
</ul>
</li>
<li><h6 id="错误处理-Error-Handling-1"><a href="#错误处理-Error-Handling-1" class="headerlink" title="错误处理(Error Handling)"></a>错误处理(Error Handling)</h6>Spring Boot提供了一个<code>WebExceptionHandler</code>,可以一种合理的方式来处理所有错误.它在处理顺序中的位置紧靠WebFlux提供的处理程序之前,这些处理程序是最后一个.对于机器客户端,会使用JSON形式来响应错误信息,HTTP状态,和异常消息.对于浏览器客户端,有一个”whitelabel”错误处理程序,以HTML格式呈现与JSON相同的数据. 还可以提供自己的HTML模板来显示错误.<br>自定义功能的第一步是使用现有机制,但替换或增加错误内容. 为此,可以添加类型为<code>ErrorAttributes</code>的bean.<br>如果更改错误处理行为,可以实现<code>ErrorWebExceptionHandler</code>并注册该类型的bean.由于<code>ErrorWebExceptionHandler</code>的级别很低,因此Spring Boot还提供了一个方便的<code>AbstractErrorWebExceptionHandler</code>,可让您以WebFlux函数式风格处理错误,如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorWebExceptionHandler</span> <span class="keyword">extends</span> <span class="title">AbstractErrorWebExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyErrorWebExceptionHandler</span><span class="params">(ErrorAttributes errorAttributes, Resources resources,</span></span></span><br><span class="line"><span class="params"><span class="function">            ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorAttributes, resources, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="title">getRoutingFunction</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(<span class="keyword">this</span>::acceptsXml, <span class="keyword">this</span>::handleErrorAsXml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">acceptsXml</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.headers().accept().contains(MediaType.APPLICATION_XML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">handleErrorAsXml</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        BodyBuilder builder = ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">        <span class="comment">// ... additional builder calls</span></span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
为了更完整的画面,您还可以直接将<code>DefaultErrorWebExceptionHandler</code>子类化并重写特定方法.<br>在某些情况下,<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.supported.spring-webflux">metrics infrastructure</a>不会记录在controller或handler函数处理的错误. 应用程序可以将被处理的异常设为请求属性, 从而保证这样的异常能不被request metrics记录:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandlingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Rendering <span class="title">userProfile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(IllegalStateException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Rendering <span class="title">handleIllegalState</span><span class="params">(ServerWebExchange exchange, IllegalStateException exc)</span> </span>&#123;</span><br><span class="line">        exchange.getAttributes().putIfAbsent(ErrorAttributes.ERROR_ATTRIBUTE, exc);</span><br><span class="line">        <span class="keyword">return</span> Rendering.view(<span class="string">&quot;errorView&quot;</span>).modelAttribute(<span class="string">&quot;message&quot;</span>, exc.getMessage()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="自定义错误页面-Custom-Error-Pages"><a href="#自定义错误页面-Custom-Error-Pages" class="headerlink" title="自定义错误页面(Custom Error Pages)"></a>自定义错误页面(Custom Error Pages)</h6>如果要指定状态代码显示自定义HTML错误页面,可以将文件添加到<code>/error</code>目录下. 错误页面可以是静态HTML(即添加到任何静态资源目录下),也可以使用模板构建. 文件名应为具体的状态码或系列掩码.<br>例如,要将<code>404</code>映射到静态HTML文件,目录结构如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- public/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure>
要使用Mustache模板映射所有<code>5xx</code>错误,目录结构如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.mustache</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="网络过滤器-Web-Filters"><a href="#网络过滤器-Web-Filters" class="headerlink" title="网络过滤器(Web Filters)"></a>网络过滤器(Web Filters)</h6>Spring WebFlux提供了一个<code>WebFilter</code>接口,可以实现该接口来过滤HTTP请求-响应交换.在如果在应用context中找到的<code>WebFilter</code>bean,将自动用于过滤每个交换.如果过滤器的顺序很重要,则可以实现<code>Ordered</code>或使用<code>@Order</code>进行标注.<br>Spring Boot自动配置会配置Web过滤器. 这样做时,将使用下表中显示的顺序:<table>
<thead>
<tr>
<th>过滤器</th>
<th>顺序</th>
</tr>
</thead>
<tbody><tr>
<td><code>MetricsWebFilter</code></td>
<td><code>Ordered.HIGHEST_PRECEDENCE</code> + 1</td>
</tr>
<tr>
<td><code>WebFilterChainProxy</code>(Spring Security)</td>
<td>-100</td>
</tr>
<tr>
<td><code>HttpTraceWebFilter</code></td>
<td><code>Ordered.LOWEST_PRECEDENCE</code> - 10</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><h6 id="JAX-RS和Jersey-JAX-RS-and-Jersey"><a href="#JAX-RS和Jersey-JAX-RS-and-Jersey" class="headerlink" title="JAX-RS和Jersey( JAX-RS and Jersey)"></a>JAX-RS和Jersey( JAX-RS and Jersey)</h6>如果您选择RESTendpoint的JAX-RS编程模型,则可以使用可用的实现之一来代替Spring MVC. Jersey和Apache CXF开箱即用.CXF要求您在应用context中将其<code>Servlet</code>或<code>Filter</code>注册为<code>@Bean</code>.Jersey提供了一些本地的Spring支持,因此我们在Spring Boot中还与starter一起为其提供了自动配置支持.<br>要开始使用Jersey,添加依赖<code>spring-boot-starter-jersey</code>,然后需要一个<code>ResourceConfig</code>类型的<code>@Bean</code>,在其中注册所有endpoint,如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJerseyConfig</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyJerseyConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        register(MyEndpoint.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告:</p>
<p>​    Jersey对扫描可执行文档的支持非常有限.例如,在运行可执行的war文件时,它无法扫描在完全可执行的jar文件或<code>WEB-INF/classs</code>中找到的包中的endpoint.为了避免这种限制,不应该使用<code>packages</code>方法,并且应该使用<code>register</code>方法分别注册endpoint,如前面的示例所示.<br>对于更高级的自定义,可以注册实现<code>ResourceConfigCustomizer</code>的任意数量的Bean.<br>所有注册的endpoint都应该是带有HTTP资源注释的<code>@Components</code>(<code>@GET</code>和其他注释),如以下示例所示:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Path(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEndpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由于端点是Spring <code>@Component</code>,因此其生命周期由Spring管理,您可以使用<code>@Autowired</code>注解进行注入依赖,并使用<code>@Value</code>注解注入外部配置.默认情况下,Jersey servlet被注册并映射到<code>/*</code>. 您可以通过将<code>@ApplicationPath</code>添加到<code>ResourceConfig</code>来更改映射.</li>
<li><h6 id="嵌入式Servlet容器支持-Embedded-Servlet-Container-Support"><a href="#嵌入式Servlet容器支持-Embedded-Servlet-Container-Support" class="headerlink" title="(嵌入式Servlet容器支持)Embedded Servlet Container Support"></a>(嵌入式Servlet容器支持)Embedded Servlet Container Support</h6>Spring Boot包括对嵌入式Tomcat,Jetty和Undertow服务器的支持. 大多数开发人员使用合适的”starter”来获取被配置完整的实例. 默认情况下,嵌入式服务器在端口<code>8080</code>上监听HTTP请求.<ol>
<li><h6 id="Servlet-过滤器和监听器-Servlets-Filters-and-listeners"><a href="#Servlet-过滤器和监听器-Servlets-Filters-and-listeners" class="headerlink" title="Servlet,过滤器和监听器(Servlets, Filters, and listeners)"></a>Servlet,过滤器和监听器(Servlets, Filters, and listeners)</h6>使用嵌入式Servlet容器时,可以通过使用Spring bean或扫描Servlet组件来注册Servlet规范中的servlet,过滤器和所有侦听器(例如<code>HttpSessionListener</code>).<h6 id="以Spring-Bean的方式注册Servlets-过滤器和监听器-Registering-Servlets-Filters-and-Listeners-as-Spring-Beans"><a href="#以Spring-Bean的方式注册Servlets-过滤器和监听器-Registering-Servlets-Filters-and-Listeners-as-Spring-Beans" class="headerlink" title="以Spring Bean的方式注册Servlets, 过滤器和监听器(Registering Servlets, Filters, and Listeners as Spring Beans)"></a>以Spring Bean的方式注册Servlets, 过滤器和监听器(Registering Servlets, Filters, and Listeners as Spring Beans)</h6>所有的,作为Spring bean的,Servlet,Filter或Servlet * Listener实例被注册到嵌入式容器中. 如果要在配置过程中引用<code>application.properties</code>中的值,这种方式会特别方便.<br>默认情况下,如果context包含单个Servlet,则将其映射到<code>/</code>. 对于多个servlet bean,bean名称用作路径前缀. 过滤器映射到 <code>/*</code>.<br>如果基于约定的映射不够灵活,则可以使用 <code>ServletRegistrationBean</code>,<code>FilterRegistrationBean</code>和<code>ServletListenerRegistrationBean</code>类进行完全控制.<br>通常来说,Filter bean无序是不安全的. 如果需要特定的顺序,则应使用<code>@Order</code>标注<code>Filter</code>或使其实现<code>Ordered</code>.您不能通过使用<code>@Order</code>标注<code>Filter</code>的bean方法来配置Filter的顺序.如果无法将<code>Filter</code>类添加<code>@Order</code>或实现<code>Ordered</code>,则必须为<code>Filter</code>定义<code>FilterRegistrationBean</code>并使用<code>setOrder(int</code>方法设置bean的顺序.避免配置一个在<code>Ordered.HIGHEST_PRECEDENCE</code>上读取request body的过滤器,因为它可能与应用应用使用的字符编码配置冲突.如果Servlet过滤器包装了请求,则配置它的时候,应使用小于或等于<code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code>的顺序.<blockquote>
<p>建议:</p>
<p>​    要查看应用程序中每个filter的顺序,可以为<code>Web</code>日志记录组(<code>logging.level.web = debug</code>)启用debug级别的日志记录. 然后,将在启动时记录已注册过滤器的详细信息,包括其顺序和URL模式.</p>
<p>警告:</p>
<p>​    注册Filter Bean时务必小心,因为它们是在应用程序生命周期中很早就初始化的. 如果需要注册与其他bean交互的Filter,考虑改用<code>DelegatingFilterProxyRegistrationBean</code>.</p>
</blockquote>
</li>
<li><h6 id="Servlet上下文环境初始化"><a href="#Servlet上下文环境初始化" class="headerlink" title="Servlet上下文环境初始化"></a>Servlet上下文环境初始化</h6>嵌入式Servlet容器不会直接执行Servlet 3.0+ <code>javax.servlet.ServletContainerInitializer</code>接口或Spring的<code>org.springframework.web.WebApplicationInitializer</code>接口.这是一个有意的设计决定,目的在于降低以war方式运行第三方库可能破坏Spring Boot应用的风险.<br>如果需要在Spring Boot应用程序中执行servlet上下文初始化,则应该注册一个实现<code>org.springframework.boot.web.servlet.ServletContextInitializer</code>接口的bean.只有一个方法<code>onStartup</code>,提供对<code>ServletContext</code>的访问,在必要时可以用作已有的<code>WebApplicationInitializer</code>的适配器.<h6 id="扫描Servlet-过滤器和侦听器-Scanning-for-Servlets-Filters-and-listeners"><a href="#扫描Servlet-过滤器和侦听器-Scanning-for-Servlets-Filters-and-listeners" class="headerlink" title="扫描Servlet,过滤器和侦听器(Scanning for Servlets, Filters, and listeners)"></a>扫描Servlet,过滤器和侦听器(Scanning for Servlets, Filters, and listeners)</h6>当使用嵌入式容器时,可以使用<code>@ServletComponentScan</code>来对<code>@WebServlet</code>,<code>@WebFilter</code>和<code>@WebListener</code>标注的类进行自动注册.<blockquote>
<p>建议:</p>
<p>​    <code>@ServletComponentScan</code>在独立容器中无效,在独立容器中使用的是容器内置的发现机制.</p>
</blockquote>
</li>
<li><h6 id="ServletWebServerApplicationContext"><a href="#ServletWebServerApplicationContext" class="headerlink" title="ServletWebServerApplicationContext"></a>ServletWebServerApplicationContext</h6>在后台,Spring Boot使用另一种类型的<code>ApplicationContext</code>来支持嵌入式servlet容器.<code>ServletWebServerApplicationContext</code>是<code>WebApplicationContext</code>的一种特殊类型,它通过搜索单个<code>ServletWebServerFactory</code>bean来自我引导启动.通常,<code>TomcatServletWebServerFactory</code>,<code>JettyServletWebServerFactory</code>或<code>UndertowServletWebServerFactory</code>都已经被自动配置.<blockquote>
<p>注意:</p>
<p>​    通常,不需要了解这些实现类. 大多数应用程序都是自动配置的,并且代表开发者创建了相应的<code>ApplicationContext</code>和<code>ServletWebServerFactory</code>.</p>
</blockquote>
</li>
<li><h6 id="自定义内置Servlet容器-Customizing-Embedded-Servlet-Containers"><a href="#自定义内置Servlet容器-Customizing-Embedded-Servlet-Containers" class="headerlink" title="自定义内置Servlet容器(Customizing Embedded Servlet Containers)"></a>自定义内置Servlet容器(Customizing Embedded Servlet Containers)</h6>可以通过使用Spring <code>Environment</code>属性来配置常见的servlet容器设置. 通常,可以在<code>application.properties</code>或<code>application.yaml</code>文件中定义属性.<br>常用服务器设置包括:<ul>
<li>网络设置:监听传入HTTP请求的端口(<code>server.port</code>),绑定到<code>server.address</code>接口地址,等等.</li>
<li>会话设置:会话是持久性(<code>server.servlet.session.persistent</code>),会话超时(<code>server.servlet.session.timeout</code>),会话数据位置(<code>server.servlet.session.store-dir</code>)和会话cookie 配置(<code>server.servlet.session.cookie.*</code>).</li>
<li>错误管理:错误页面的位置(<code>server.error.path</code>)等.</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.webserver.configure-ssl">SSL</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.webserver.enable-response-compression">HTTP compression</a><br>Spring Boot尝试尽可能多地公开通用设置,但这不是可能的. 对于这些情况,专用名称空间提供针对服务器的自定义项(请参阅<code>server.tomcat</code>和<code>server.undertow</code>). 例如,可以给嵌入式servlet容器的特定功能配置访问日志.<blockquote>
<p>建议:</p>
<p>​    有关完整列表,请参见<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>类.</p>
</blockquote>
</li>
</ul>
<h6 id="编程方式进行自定义-Programmatic-Customization"><a href="#编程方式进行自定义-Programmatic-Customization" class="headerlink" title="编程方式进行自定义(Programmatic Customization)"></a>编程方式进行自定义(Programmatic Customization)</h6>如果您需要以编程方式配置嵌入式servlet容器,则可以注册一个实现<code>WebServerFactoryCustomizer</code>接口的Spring Bean.<br><code>WebServerFactoryCustomizer</code>提供对<code>ConfigurableServletWebServerFactory</code>的访问,其中包括许多自定义设置方法. 以下示例显示以编程方式设置端口:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebServerFactoryCustomizer</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory server)</span> </span>&#123;</span><br><span class="line">        server.setPort(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>TomcatServletWebServerFactory</code>,<code>JettyServletWebServerFactory</code>和<code>UndertowServletWebServerFactory</code>是<code>ConfigurableServletWebServerFactory</code>的实现,分别对Tomcat,Jetty和Undertow提供额外自定义定义方法.以下示例显示如何自定义<code>TomcatServletWebServerFactory</code>,<code>TomcatServletWebServerFactory</code>提供针对Tomcat的配置选项:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTomcatWebServerFactoryCustomizer</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">TomcatServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(TomcatServletWebServerFactory server)</span> </span>&#123;</span><br><span class="line">        server.addConnectorCustomizers((connector) -&gt; connector.setAsyncTimeout(Duration.ofSeconds(<span class="number">20</span>).toMillis()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="直接自定义ConfigurableServletWebServerFactory-Customizing-ConfigurableServletWebServerFactory-Directly"><a href="#直接自定义ConfigurableServletWebServerFactory-Customizing-ConfigurableServletWebServerFactory-Directly" class="headerlink" title="直接自定义ConfigurableServletWebServerFactory (Customizing ConfigurableServletWebServerFactory Directly)"></a>直接自定义ConfigurableServletWebServerFactory (Customizing ConfigurableServletWebServerFactory Directly)</h6>更高级的使用方式,就要继承<code>ServletWebServerFactory</code>,可以自己暴露一个这样的bean.<br>很多配置项都提供了setter. 如果您需要做一些更奇特的操作,还提供了几个protected方法形式的”hook(回调函数)”. 有关详细信息,请参见 <a href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html">source code documentation</a> .<blockquote>
<p>注意:</p>
<p>​    自动配置的customizers 仍会应用在自定义工厂中,因此请谨慎使用该选项.</p>
</blockquote>
</li>
<li><h6 id="JSP限制-JSP-Limitations"><a href="#JSP限制-JSP-Limitations" class="headerlink" title="JSP限制(JSP Limitations)"></a>JSP限制(JSP Limitations)</h6>运行使用嵌入式Servlet容器(并打包为可执行归档文件)的Spring Boot应用时,对JSP的支持存在一些限制.<ul>
<li>对于Jetty和Tomcat,如果使用war包装,可以工作. 使用<code>java -jar</code>启动时,可执行的war可以工作,并且可以被部署到任何标准容器中.使用可执行jar时,不支持JSP.</li>
<li>Undertow不支持JSP.</li>
<li>创建自定义<code>error.jsp</code>页面不会覆盖默认错误处理视图. 应改用自定义错误页面.</li>
</ul>
</li>
</ol>
</li>
<li><h5 id="嵌入式响应式服务器支持-Embedded-Reactive-Server-Support"><a href="#嵌入式响应式服务器支持-Embedded-Reactive-Server-Support" class="headerlink" title="嵌入式响应式服务器支持(Embedded Reactive Server Support)"></a>嵌入式响应式服务器支持(Embedded Reactive Server Support)</h5>Spring Boot支持以下嵌入式响应式Web服务器:Reactor Netty,Tomcat,Jetty和Undertow. 大多数开发者使用合适”启动器”来获取完全已经配:置的实例. 默认情况下,嵌入式服务器在端口8080上侦听HTTP请求.</li>
<li><h6 id="响应式服务器资源配置-Reactive-Server-Resources-Configuration"><a href="#响应式服务器资源配置-Reactive-Server-Resources-Configuration" class="headerlink" title="响应式服务器资源配置(Reactive Server Resources Configuration)"></a>响应式服务器资源配置(Reactive Server Resources Configuration)</h6>当对Reactor Netty或Jetty服务器进行自动配置时,Spring Boot将创建为服务器实例创建指定的bean,这些bean提供HTTP资源:<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>.<br>默认情况下,在以下情况,这些资源还将与Reactor Netty和Jetty客户端共享,以实现最佳性能:<ul>
<li>服务器和客户端使用相同的技术</li>
<li>客户端实例是使用Spring Boot自动配置的<code>WebClient.Builder</code>bean构建的<br>通过提供自定义的<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>bean,开发者可以覆盖Jetty和Reactor Netty的资源配置-这将同时应用于客户端和服务器.<br>可以在”<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.webclient.runtime">WebClient Runtime section</a>“部分中了解有关客户端资源配置的更多信息.</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>4.2 Actuator:  Endpoints</title>
    <url>/posts/40082.html</url>
    <content><![CDATA[<h5 id="Endpoints"><a href="#Endpoints" class="headerlink" title="Endpoints"></a>Endpoints</h5><p>Actuator endpoint 可以用来监控应用并与之交互。 Spring Boot 包含许多内置endpoint，并允许添加自己的endpoint。例如，<code>health</code>endpoint提供基本的应用程序健康信息。</p>
<p>每个单独的endpoint都可以通过 HTTP 或 JMX 启用或禁用和公开（远程访问）。当启用和公开endpoint时，它是可用的。内置endpoint只有在可用时才会自动配置。大多数应用程序通过 HTTP 公开，其中endpoint 的 ID 以及 <code>/actuator</code> 的前缀映射到 URL。例如，默认情况下，<code>health</code> endpoint映射到<code>/actuator/health</code>.</p>
<p>以下与技术无关的endpoint可用：</p>
<table>
<thead>
<tr>
<th><strong>ID</strong></th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>auditevents</code></td>
<td>公开当前应用程序的audit 事件信息。 需要一个 <code>AuditEventRepository</code> bean。</td>
</tr>
<tr>
<td><code>beans</code></td>
<td>显示应用程序中所有 Spring bean 的完整列表。</td>
</tr>
<tr>
<td><code>caches</code></td>
<td>公开可用的缓存。</td>
</tr>
<tr>
<td><code>conditions</code></td>
<td>显示在配置和自动配置类上评估的conditions ,以及匹配或不匹配的原因。</td>
</tr>
<tr>
<td><code>configprops</code></td>
<td>显示所有<code>@ConfigurationProperties</code> 的列表。</td>
</tr>
<tr>
<td><code>env</code></td>
<td>从 Spring 的 <code>ConfigurableEnvironment</code> 公开属性。</td>
</tr>
<tr>
<td><code>flyway</code></td>
<td>显示已经应用的所有 <code>Flyway</code> 数据库迁移。 需要一个或多个 <code>Flyway</code> bean。</td>
</tr>
<tr>
<td><code>health</code></td>
<td>显示应用程序运行状况信息。</td>
</tr>
<tr>
<td><code>httptrace</code></td>
<td>显示 HTTP 跟踪信息（默认情况下，最后 100 个 HTTP 请求-响应交换）。需要一个 <code>HttpTraceRepository</code> bean。</td>
</tr>
<tr>
<td><code>info</code></td>
<td>显示任意应用程序信息。</td>
</tr>
<tr>
<td><code>integrationgraph</code></td>
<td>显示 Spring 集成图。 需要依赖 <code>spring-integration-core</code>。</td>
</tr>
<tr>
<td><code>loggers</code></td>
<td>显示和修改应用程序中loggers的配置。</td>
</tr>
<tr>
<td><code>liquibase</code></td>
<td>显示已应用的所有的 Liquibase 数据库迁移。 需要一个或多个 <code>Liquibase</code> bean。</td>
</tr>
<tr>
<td><code>metrics</code></td>
<td>显示当前应用程序的“metrics”信息。</td>
</tr>
<tr>
<td><code>mappings</code></td>
<td>显示所有 <code>@RequestMapping</code> 路径的整理列表。</td>
</tr>
<tr>
<td><code>quartz</code></td>
<td>显示有关 Quartz 调度程序作业的信息。</td>
</tr>
<tr>
<td><code>scheduledtasks</code></td>
<td>显示应用程序中的计划任务。</td>
</tr>
<tr>
<td><code>sessions</code></td>
<td>允许从 Spring Session 支持的会话存储中检索和删除用户会话。需要使用 Spring Session 的基于 Servlet 的 Web 应用程序。</td>
</tr>
<tr>
<td>shutdown</td>
<td>让应用程序正常关闭。 默认禁用。</td>
</tr>
<tr>
<td>startup</td>
<td>显示 <code>ApplicationStartup</code> 收集的启动步骤数据.需要使用 <code>BufferingApplicationStartup</code> 配置 <code>SpringApplication</code>。</td>
</tr>
<tr>
<td><code>threaddump</code></td>
<td>执行线程转储。</td>
</tr>
</tbody></table>
<p>如果应用程序是 Web 应用程序（Spring MVC、Spring WebFlux 或 Jersey），可以使用以下附加endpoint：</p>
<table>
<thead>
<tr>
<th><strong>ID</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>heapdump</code></td>
<td>返回一个 <code>hprof</code> 堆转储文件。 要求 HotSpot JVM。</td>
</tr>
<tr>
<td><code>jolokia</code></td>
<td>通过 HTTP 公开 JMX bean（当classpath上Jolokia 在时，不适用于 WebFlux）。</td>
</tr>
<tr>
<td><code>logfile</code></td>
<td>返回日志文件的内容（如果已设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性）.支持使用 HTTP <code>Range</code> header来检索日志文件的部分内容。</td>
</tr>
<tr>
<td><code>prometheus</code></td>
<td>以 Prometheus 服务器可以抓取的格式公开指标。需要依赖 <code>micrometer-registry-prometheus</code>.</td>
</tr>
</tbody></table>
<ol>
<li><h6 id="开启-Endpoints-Enabling-Endpoints"><a href="#开启-Endpoints-Enabling-Endpoints" class="headerlink" title="开启 Endpoints(Enabling Endpoints)"></a>开启 Endpoints(Enabling Endpoints)</h6><p>默认情况下，除<code>shutdown</code>之外的所有endpoint都处于启用状态。要启用endpoint，请使用其 <code>management.endpoint.&lt;id&gt;.enabled</code> 属性。以下示例启用关闭endpoint：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoint.shutdown.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>如果希望endpoint启用是opt-in而不是opt-out，将 <code>management.endpoints.enabled-by-default</code> 属性设置为 <code>false</code> 并使用endpoint的<code>enabled</code>选择重新加入。以下示例启用 <code>info</code> endpoint并禁用所有其他endpoint：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.enabled-by-default</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">management.endpoint.info.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>   禁用的endpoint从应用context中完全删除。如果只想改变endpoint公开的技术，请改用 <code>include</code> 和 <code>exclude</code> 属性。</p>
</blockquote>
</li>
<li><h6 id="暴露-Endpoints-Exposing-Endpoints"><a href="#暴露-Endpoints-Exposing-Endpoints" class="headerlink" title="暴露 Endpoints(Exposing Endpoints)"></a>暴露 Endpoints(Exposing Endpoints)</h6><p>由于Endpoints 可能包含敏感信息，因此应仔细考虑何时公开它们。下表显示了内置endpoint的默认暴露：</p>
<table>
<thead>
<tr>
<th><strong>ID</strong></th>
<th><strong>JMX</strong></th>
<th><strong>Web</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>auditevents</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>beans</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>caches</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>conditions</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>configprops</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>env</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>flyway</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>health</code></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><code>heapdump</code></td>
<td>N/A</td>
<td>No</td>
</tr>
<tr>
<td><code>httptrace</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>info</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>integrationgraph</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>jolokia</code></td>
<td>N/A</td>
<td>No</td>
</tr>
<tr>
<td><code>logfile</code></td>
<td>N/A</td>
<td>No</td>
</tr>
<tr>
<td><code>loggers</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>liquibase</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>metrics</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>mappings</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>prometheus</code></td>
<td>N/A</td>
<td>No</td>
</tr>
<tr>
<td><code>quartz</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>scheduledtasks</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>sessions</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>shutdown</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>startup</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>threaddump</code></td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody></table>
<p>要更改公开的endpoint，请使用以下特定于技术的<code>include</code>和<code>exclude</code>属性：</p>
<table>
<thead>
<tr>
<th><strong>Property</strong></th>
<th><strong>Default</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>management.endpoints.jmx.exposure.exclude</code></td>
<td></td>
</tr>
<tr>
<td><code>management.endpoints.jmx.exposure.include</code></td>
<td><code>*</code></td>
</tr>
<tr>
<td><code>management.endpoints.web.exposure.exclude</code></td>
<td></td>
</tr>
<tr>
<td><code>management.endpoints.web.exposure.include</code></td>
<td><code>health</code></td>
</tr>
</tbody></table>
<p><code>include</code> 属性列出了公开的endpoint的 ID。<code>exclude</code> 属性列出不应公开的endpoint的 ID。<code>exclude</code> 属性优先于 <code>include</code> 属性。<code>include</code>和<code>exclude</code>属性都可以使用endpoint ID 列表进行配置。</p>
<p>例如，要停止通过 JMX 公开所有endpoint并仅公开 <code>health</code> 和 <code>info</code> endpoint，请使用以下属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.jmx.exposure.include</span>=<span class="string">health,info</span></span><br></pre></td></tr></table></figure>

<p><code>*</code> 可用于选择所有endpoint。例如，要通过 HTTP 公开除了 <code>env</code> 和 <code>beans</code> endpoint之外的所有内容，请使用以下属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.exclude</span>=<span class="string">env,beans</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>   <code>*</code> 在 YAML 中具有特殊含义，因此如果要包含（或排除）所有endpoint，请务必添加引号。</p>
<p>注意:</p>
<p>   如果应用公开，强烈建议也保护您的endpoint(<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.endpoints.security">secure your endpoints</a>)。</p>
<p>建议:</p>
<p>   如果想实现自己的endpoint何时公开策略，可以注册一个 <code>EndpointFilter</code> bean。</p>
</blockquote>
</li>
<li><h6 id="保护-HTTP-endpoint-Securing-HTTP-Endpoints"><a href="#保护-HTTP-endpoint-Securing-HTTP-Endpoints" class="headerlink" title="保护 HTTP endpoint(Securing HTTP Endpoints)"></a>保护 HTTP endpoint(Securing HTTP Endpoints)</h6><p>应该像保护任何其他敏感 URL 一样注意保护 HTTP endpoint。如果存在 Spring Security，则默认情况下使用 Spring Security 的内容协商策略来保护endpoint。如果存在 Spring Security，则默认情况下使用 Spring Security 的内容协商策略来保护endpoint。如果希望为 HTTP endpoint配置自定义安全性，例如只允许具有特定角色的用户访问它们，Spring Boot 提供了一些方便的 <code>RequestMatcher</code> 对象，可以与 Spring Security 结合使用。</p>
<p>典型的 Spring Security 配置可能类似于以下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySecurityConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityFilterChain <span class="title">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint())</span><br><span class="line">                .authorizeRequests((requests) -&gt; requests.anyRequest().hasRole(<span class="string">&quot;ENDPOINT_ADMIN&quot;</span>));</span><br><span class="line">        http.httpBasic();</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的示例使用 <code>EndpointRequest.toAnyEndpoint()</code> 将请求匹配到任何endpoint，然后确保所有endpoint都具有 <code>ENDPOINT_ADMIN</code> 角色。<code>EndpointRequest</code> 上还提供了其他几种匹配器方法。</p>
<p>如果想要在防火墙后面部署应用程序，可能希望无需身份验证即可访问所有执行器endpoint。可以通过更改 <code>management.endpoints.web.exposure.include</code> 属性来实现，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure>

<p>此外，如果存在 Spring Security，需要添加自定义安全配置，以允许对endpoint进行未经身份验证的访问，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySecurityConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityFilterChain <span class="title">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint())</span><br><span class="line">                .authorizeRequests((requests) -&gt; requests.anyRequest().permitAll());</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>   在上面的两个示例中，配置仅适用于actuator endpoints。由于 Spring Boot 的安全配置会在 <code>SecurityFilterChain</code> bean 存在时完全退出，因此需要配置一个额外的 <code>SecurityFilterChain</code> bean，其规则适用于应用程序的其余部分。</p>
</blockquote>
</li>
<li><h6 id="配置-Endpoints-Configuring-Endpoints"><a href="#配置-Endpoints-Configuring-Endpoints" class="headerlink" title="配置 Endpoints(Configuring Endpoints)"></a>配置 Endpoints(Configuring Endpoints)</h6><p>endpoint自动缓存那些无参读取操作的响应。要配置endpoint缓存响应的时间量，请使用其 <code>cache.time-to-live</code> 属性。以下示例将 beans endpoint的缓存的生存时间设置为 10 秒：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoint.beans.cache.time-to-live</span>=<span class="string">10s</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>   前缀 <code>management.endpoint.&lt;name&gt;</code> 用于配置标识唯一的endpoint。</p>
</blockquote>
</li>
<li><h6 id="Actuator-Web-endpoint的超媒体-Hypermedia-for-Actuator-Web-Endpoints"><a href="#Actuator-Web-endpoint的超媒体-Hypermedia-for-Actuator-Web-Endpoints" class="headerlink" title="Actuator Web endpoint的超媒体(Hypermedia for Actuator Web Endpoints)"></a>Actuator Web endpoint的超媒体(Hypermedia for Actuator Web Endpoints)</h6><p>添加了“discovery page”，其中包含指向所有endpoint的链接。 默认情况下，“discovery page”在 <code>/actuator</code> 上可用。</p>
<p>要禁用“discovery page”，请将以下属性添加到应用属性中：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.discovery.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>配置自定义管理context路径后，“discovery page”会自动从 <code>/actuator</code> 移动到管理context的根目录。例如，如果管理上下文路径是 <code>/management</code>，则可从 <code>/management</code>获取发现页面.当管理上下文路径设置为 <code>/</code> 时，将禁用发现页面来防止与其他映射发生冲突。</p>
</li>
<li><h6 id="CORS-Support"><a href="#CORS-Support" class="headerlink" title="CORS Support"></a>CORS Support</h6><p>跨域资源共享 (CORS) 是一种 W3C 规范，可以以灵活的方式指定哪些类型的跨域请求被授权。如果使用 Spring MVC 或 Spring WebFlux，则可以配置 Actuator 的 Web endpoint以支持此类场景。</p>
<p>默认情况下禁用 CORS 支持，并且只有设置 <code>management.endpoints.web.cors.allowed-origins</code> 属性后开启。以下配置允许来自 <code>example.com</code> 域的 <code>GET</code> 和 <code>POST</code> 调用：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.cors.allowed-origins</span>=<span class="string">https://example.com</span></span><br><span class="line"><span class="meta">management.endpoints.web.cors.allowed-methods</span>=<span class="string">GET,POST</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="实现自定义Endpoint-Implementing-Custom-Endpoints"><a href="#实现自定义Endpoint-Implementing-Custom-Endpoints" class="headerlink" title="实现自定义Endpoint(Implementing Custom Endpoints)"></a>实现自定义Endpoint(Implementing Custom Endpoints)</h6><p>如果添加一个用<code>@Endpoint</code> 注解的<code>@Bean</code>，任何用<code>@ReadOperation</code>、<code>@WriteOperation</code> 或<code>@DeleteOperation</code> 注解标注的方法都会自动通过JMX 公开，在Web 应用程序中，也通过HTTP 公开。endpoint可以使用 Jersey、Spring MVC 或 Spring WebFlux 通过 HTTP 公开。 如果 Jersey 和 Spring MVC 都可用，则将使用 Spring MVC。</p>
<p>以下示例公开了一个返回自定义对象的读取操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReadOperation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CustomData <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomData(<span class="string">&quot;test&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用<code>@JmxEndpoint</code> 或<code>@WebEndpoint</code> 编写特定于技术的endpoint。这些endpoint仅限于它们各自的技术。例如，<code>@WebEndpoint</code> 仅通过 HTTP 而不是通过 JMX 公开。</p>
<p>可以使用 <code>@EndpointWebExtension</code> 和 <code>@EndpointJmxExtension</code> 编写特定于技术的扩展.这些注解可以提供特定于技术来扩充现有endpoint。</p>
<p>最后，如果需要访问特定于 web 框架的功能，可以实现 Servlet 或 Spring <code>@Controller</code> 和 <code>@RestController</code> endpoint，但代价是它们无法通过 JMX 或在使用不同的 web 框架时可用。</p>
<ol>
<li><h6 id="接收输入-Receiving-Input"><a href="#接收输入-Receiving-Input" class="headerlink" title="接收输入(Receiving Input)"></a>接收输入(Receiving Input)</h6><p>endpoint上的操作通过其参数接收输入。当通过 Web 公开时，这些参数的值取自 URL 的请求参数和 JSON 请求体。当通过 JMX 公开时，参数被映射到 MBean 操作的参数。 默认需要参数。可以通过使用<code>@javax.annotation.Nullable</code> 或<code>@org.springframework.lang.Nullable</code> 来使它们成为optional。</p>
<p>JSON 请求体中的每个根属性都可以映射到endpoint的一个参数。 考虑以下 JSON 请求正文：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;counter&quot;</span>: <span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可用于调用采用 <code>String name</code> 和 <code>int counter</code> 参数的写操作，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WriteOperation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateData</span><span class="params">(String name, <span class="keyword">int</span> counter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// injects &quot;test&quot; and 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>   由于endpoint与技术无关，因此只能在方法签名中指定简单类型。特别是使用<code>CustomData</code>类型定义一个<code>name</code>来声明参数和<code>counter</code>属性不被支持. </p>
<p>注意:  </p>
<p>   为了允许将输入映射到操作方法的参数，实现endpoint的 Java 代码应该使用 <code>-parameters</code> 编译，实现endpoint的 Kotlin 代码应该使用 <code>-java-parameters</code> 编译.如果使用 Spring Boot 的 Gradle 插件或使用 Maven 和 <code>spring-boot-starter-parent</code>，这将自动进行。</p>
</blockquote>
<h6 id="输入类型转换"><a href="#输入类型转换" class="headerlink" title="输入类型转换"></a>输入类型转换</h6><p>如有必要，传递给endpoint操作方法的参数会自动转换为所需的类型。在调用操作方法之前，通过 JMX 或 HTTP 请求接收的输入将使用 <code>ApplicationConversionService</code> 的实例以及通过 <code>@EndpointConverter</code> 限定的任何 <code>Converter</code> 或 <code>GenericConverter</code> bean 转换为所需的类型。</p>
</li>
<li><h6 id="自定义-Web-endpoint-Custom-Web-Endpoints"><a href="#自定义-Web-endpoint-Custom-Web-Endpoints" class="headerlink" title="自定义 Web endpoint(Custom Web Endpoints)"></a>自定义 Web endpoint(Custom Web Endpoints)</h6><p><code>@Endpoint</code>、<code>@WebEndpoint</code> 或 <code>@EndpointWebExtension</code> 上的操作都会使用 Jersey、Spring MVC 或 Spring WebFlux 通过 HTTP 自动公开。如果 Jersey 和 Spring MVC 都可用，则将使用 Spring MVC。</p>
<h6 id="Web-endpoint请求谓词-Web-Endpoint-Request-Predicates"><a href="#Web-endpoint请求谓词-Web-Endpoint-Request-Predicates" class="headerlink" title="Web endpoint请求谓词(Web Endpoint Request Predicates)"></a>Web endpoint请求谓词(Web Endpoint Request Predicates)</h6><p>在 Web 公开endpoint上的每个操作,都会自动生成请求谓词。</p>
<h6 id="路径-Path"><a href="#路径-Path" class="headerlink" title="路径(Path)"></a>路径(Path)</h6><p>谓词的路径由endpoint的 ID 和在网络公开上的endpoint的基本路径决定。默认的基本路径是 <code>/actuator</code>。例如，具有 ID <code>sessions</code>的endpoint将使用 <code>/actuator/sessions</code> 作为谓词中的路径。</p>
<p>通过<code>@Selector</code>标注操作方法的一个或多个参数，可以进一步自定义路径.这样的参数作为路径变量添加到路径谓词中。当调用endpoint操作时，变量的值被传递到操作方法中。如果要捕获所有剩余的路径元素，可以将<code>@Selector(Match=ALL_REMAINING) </code>添加到最后一个参数并使其成为与 <code>String[]</code> 转换为兼容的类型.</p>
<h6 id="HTTP-方法-HTTP-method"><a href="#HTTP-方法-HTTP-method" class="headerlink" title="HTTP 方法(HTTP method)"></a>HTTP 方法(HTTP method)</h6><p>谓词的HTTP方法由操作类型决定，如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>Operation</strong></th>
<th><strong>HTTP method</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>@ReadOperation</code></td>
<td><code>GET</code></td>
</tr>
<tr>
<td><code>@WriteOperation</code></td>
<td><code>POST</code></td>
</tr>
<tr>
<td><code>@DeleteOperation</code></td>
<td><code>DELETE</code></td>
</tr>
</tbody></table>
<h6 id="Consumes"><a href="#Consumes" class="headerlink" title="Consumes"></a>Consumes</h6><p>对于使用请求体的<code>@WriteOperation</code>（HTTP <code>POST</code>），谓词的consumes 子句是<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>.对于所有其他操作，consumes 子句为空。</p>
<h6 id="Produces"><a href="#Produces" class="headerlink" title="Produces"></a>Produces</h6><p>谓词的produces 子句可以由<code>@DeleteOperation</code>、<code>@ReadOperation</code> 和<code>@WriteOperation</code> 注解的<code>produces</code>属性确定。该属性是可选的。 如果未使用，则生产子句会自动确定。</p>
<p>如果操作方法返回 <code>void</code> 或 <code>Void</code>，那么produces 子句为空。如果操作方法返回<code>org.springframework.core.io.Resource</code>，那么produces子句就是<code>application/octet-stream</code>.对于所有其他操作，生产子句是 <code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。</p>
<h6 id="Web-Endpoint-响应状态-Web-Endpoint-Response-Status"><a href="#Web-Endpoint-响应状态-Web-Endpoint-Response-Status" class="headerlink" title="Web Endpoint 响应状态(Web Endpoint Response Status)"></a>Web Endpoint 响应状态(Web Endpoint Response Status)</h6><p>endpoint 操作的默认响应状态取决于操作类型（读取、写入或删除）以及操作返回的内容（如果有）。</p>
<p><code>@ReadOperation</code> 返回一个值，响应状态将为 200 (OK)。 如果它没有返回值，则响应状态将为 404（未找到）。</p>
<p>如果<code>@WriteOperation</code> 或<code>@DeleteOperation</code> 返回一个值，则响应状态将为 200（OK）。 如果它没有返回值，则响应状态将为 204（无内容）。</p>
<p>如果在没有必需参数的情况下调用操作，或者带有无法转换为必需类型的参数，则操作方法不会被调用并且响应状态为 400（Bad Request）。</p>
<h6 id="Web-Endpoint-范围请求-Web-Endpoint-Range-Requests"><a href="#Web-Endpoint-范围请求-Web-Endpoint-Range-Requests" class="headerlink" title="Web Endpoint 范围请求(Web Endpoint Range Requests)"></a>Web Endpoint 范围请求(Web Endpoint Range Requests)</h6><p>HTTP 范围请求可用于请求部分 HTTP 资源。使用 Spring MVC 或 Spring Web Flux 时，返回 <code>org.springframework.core.io.Resource</code> 的操作会自动支持范围请求。</p>
<blockquote>
<p>注意:</p>
<p>   使用 Jersey 时不支持范围请求。</p>
</blockquote>
<h6 id="Web-Endpoint安全"><a href="#Web-Endpoint安全" class="headerlink" title="Web Endpoint安全"></a>Web Endpoint安全</h6><p>Web endpoint或特定于 Web 的endpoint扩展上的操作可以接收当前 <code>java.security.Principal</code> 或 <code>org.springframework.boot.actuate.endpoint.SecurityContext</code> 作为方法参数。前者通常与<code>@Nullable</code> 结合使用，为经过身份验证和未经身份验证的用户提供不同的行为。后者通常用于使用 <code>isUserInRole(String)</code>方法来执行授权检查。</p>
</li>
<li><h6 id="Servlet-Endpoints"><a href="#Servlet-Endpoints" class="headerlink" title="Servlet Endpoints"></a>Servlet Endpoints</h6><p>通过实现一个用 <code>@ServletEndpoint</code> 注解的类，同时实现了<code>Supplier&lt;EndpointServlet&gt;</code>，可以将 Servlet 作为Endpoint公开. Servlet endpoint提供了与 Servlet 容器的更深层次的集成，但以可移植性为代价。旨在用于将现有 Servlet 作为endpoint公开。对于新endpoint，应尽可能首选 <code>@Endpoint</code> 和 <code>@WebEndpoint</code> 注解。</p>
</li>
<li><h6 id="Controller-Endpoint"><a href="#Controller-Endpoint" class="headerlink" title="Controller Endpoint"></a>Controller Endpoint</h6><p><code>@ControllerEndpoint</code> 和 <code>@RestControllerEndpoint</code> 可用于实现那些仅由 Spring MVC 或 Spring WebFlux 公开的endpoint。方法使用 Spring MVC 和 Spring WebFlux 的标准注解（例如 <code>@RequestMapping</code> 和 <code>@GetMapping</code>）进行映射，endpoint的 ID 用作路径的前缀。Controller endpoint提供了与 Spring 的 Web 框架更深入的集成，但以可移植性为代价。应尽可能首选<code>@Endpoint</code> 和<code>@WebEndpoint</code> 注解。</p>
</li>
</ol>
</li>
<li><h6 id="健康信息-Health-Information"><a href="#健康信息-Health-Information" class="headerlink" title="健康信息(Health Information)"></a>健康信息(Health Information)</h6><p>可以使用健康信息来检查正在运行的应用的状态。 当生产系统出现故障时，监控软件通常使用它来提醒。健康endpoint公开的信息取决于 <code>management.endpoint.health.show-details</code> 和 <code>management.endpoint.health.show-components</code> 属性，可以使用以下值之一进行配置：</p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>never</code></td>
<td>永远不会显示详细信息。</td>
</tr>
<tr>
<td><code>when-authorized</code></td>
<td>仅向授权用户显示详细信息。 可以使用<code>management.endpoint.health.roles</code> 配置授权角色。</td>
</tr>
<tr>
<td><code>always</code></td>
<td>给所有用户显示详细信息。</td>
</tr>
</tbody></table>
<p>默认值是<code>never</code>。 当一个用户担任一个或多个endpoint角色时，被认为是被授权的。如果endpoint没有配置角色（默认），所有通过身份验证的用户都被认为是授权的。可以使用 <code>management.endpoint.health.roles</code> 属性配置角色。</p>
<blockquote>
<p>注意:</p>
<p>   如果已保护应用并希望始终使用，安全配置必须允许经过身份验证和未经身份验证的用户访问health endpoint。</p>
</blockquote>
<p>Health information是从 <code>HealthContributorRegistry</code> 的内容中收集的（默认情况下， <code>ApplicationContext</code>中定义的所有 <code>HealthContributor</code> 实例）。Spring Boot 包含许多自动配置的 <code>HealthContributor</code>，也可以编写自己的。</p>
<p><code>HealthContributor</code> 可以是 <code>HealthIndicator</code> 或 <code>CompositeHealthContributor</code>. <code>HealthIndicator</code> 提供实际的健康信息，包括<code>Status</code>. <code>CompositeHealthContributor</code> 提供了其他 <code>HealthContributor</code> 的组合.总之，参与者形成了一个树结构来表示整个系统的健康状况。</p>
<p>默认情况下，最终系统运行状况由 <code>StatusAggregator</code> 派生，它根据状态的列表,对来自每个 <code>HealthIndicator</code> 的状态进行排序。排序列表中的第一个状态用作整体健康状态。如果没有 <code>HealthIndicator</code> 返回 <code>StatusAggregator</code> 已知的状态，则使用 <code>UNKNOWN</code> 状态。</p>
<blockquote>
<p>建议:</p>
<p>   <code>HealthContributorRegistry</code> 可用于在运行时注册和取消注册health indicator。</p>
</blockquote>
<ol>
<li><h6 id="自动配置的health-indicator-Auto-configured-HealthIndicators"><a href="#自动配置的health-indicator-Auto-configured-HealthIndicators" class="headerlink" title="自动配置的health indicator(Auto-configured HealthIndicators)"></a>自动配置的health indicator(Auto-configured HealthIndicators)</h6><p>Spring Boot 会在适当的时候自动配置以下 <code>HealthIndicator</code>。还可以通过使用下表中列出的key配置 <code>management.health.key.enabled</code> 来启用/禁用选定的指标。</p>
<table>
<thead>
<tr>
<th><strong>Key</strong></th>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>cassandra</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraDriverHealthIndicator.java"><code>CassandraDriverHealthIndicator</code></a></td>
<td>检查 Cassandra 数据库是否已启动。</td>
</tr>
<tr>
<td><code>couchbase</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseHealthIndicator.java"><code>CouchbaseHealthIndicator</code></a></td>
<td>检查 Couchbase 集群是否已启动。</td>
</tr>
<tr>
<td><code>db</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jdbc/DataSourceHealthIndicator.java"><code>DataSourceHealthIndicator</code></a></td>
<td>检查是否可以获得到“DataSource”的连接。</td>
</tr>
<tr>
<td><code>diskspace</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/system/DiskSpaceHealthIndicator.java"><code>DiskSpaceHealthIndicator</code></a></td>
<td>检查磁盘空间不足。</td>
</tr>
<tr>
<td><code>elasticsearch</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/elasticsearch/ElasticsearchRestHealthIndicator.java"><code>ElasticsearchRestHealthIndicator</code></a></td>
<td>检查 Elasticsearch 集群是否已启动。</td>
</tr>
<tr>
<td><code>hazelcast</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/hazelcast/HazelcastHealthIndicator.java"><code>HazelcastHealthIndicator</code></a></td>
<td>检查 Hazelcast 服务器是否已启动。</td>
</tr>
<tr>
<td><code>influxdb</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/influx/InfluxDbHealthIndicator.java"><code>InfluxDbHealthIndicator</code></a></td>
<td>检查 InfluxDB 服务器是否已启动。</td>
</tr>
<tr>
<td><code>jms</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jms/JmsHealthIndicator.java"><code>JmsHealthIndicator</code></a></td>
<td>检查 JMS 代理是否已启动。</td>
</tr>
<tr>
<td><code>ldap</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/ldap/LdapHealthIndicator.java"><code>LdapHealthIndicator</code></a></td>
<td>检查 LDAP 服务器是否已启动。</td>
</tr>
<tr>
<td><code>mail</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mail/MailHealthIndicator.java"><code>MailHealthIndicator</code></a></td>
<td>检查邮件服务器是否已启动。</td>
</tr>
<tr>
<td><code>mongo</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoHealthIndicator.java"><code>MongoHealthIndicator</code></a></td>
<td>检查 Mongo 数据库是否已启动。</td>
</tr>
<tr>
<td><code>neo4j</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/neo4j/Neo4jHealthIndicator.java"><code>Neo4jHealthIndicator</code></a></td>
<td>检查 Neo4j 数据库是否已启动。</td>
</tr>
<tr>
<td><code>ping</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/PingHealthIndicator.java"><code>PingHealthIndicator</code></a></td>
<td>始终以“<code>UP</code>”响应。</td>
</tr>
<tr>
<td><code>rabbit</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/amqp/RabbitHealthIndicator.java"><code>RabbitHealthIndicator</code></a></td>
<td>检查 Rabbit 服务器是否已启动。</td>
</tr>
<tr>
<td><code>redis</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisHealthIndicator.java"><code>RedisHealthIndicator</code></a></td>
<td>检查 Redis 服务器是否已启动。</td>
</tr>
<tr>
<td><code>solr</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/solr/SolrHealthIndicator.java"><code>SolrHealthIndicator</code></a></td>
<td>检查 Solr 服务器是否已启动。</td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>   可以通过设置 <code>management.health.defaults.enabled</code> 属性来禁用它们。</p>
</blockquote>
<p>其他 <code>HealthIndicators</code> 可用,但默认情况下没有启用：</p>
<table>
<thead>
<tr>
<th><strong>Key</strong></th>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>livenessstate</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/availability/LivenessStateHealthIndicator.java"><code>LivenessStateHealthIndicator</code></a></td>
<td>公开“Liveness”应用程序可用性状态。</td>
</tr>
<tr>
<td><code>readinessstate</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/availability/ReadinessStateHealthIndicator.java"><code>ReadinessStateHealthIndicator</code></a></td>
<td>公开“Readiness”应用程序可用性状态。</td>
</tr>
</tbody></table>
</li>
<li><h6 id="编写自定义HealthIndicators-Writing-Custom-HealthIndicators"><a href="#编写自定义HealthIndicators-Writing-Custom-HealthIndicators" class="headerlink" title="编写自定义HealthIndicators(Writing Custom HealthIndicators)"></a>编写自定义HealthIndicators(Writing Custom HealthIndicators)</h6><p>要提供自定义健康信息，可以注册实现 <code>HealthIndicator</code> 接口的 Spring bean。需要提供 <code>health()</code> 方法的实现并返回 <code>Health</code> 响应。<code>Health</code> 响应应包括状态，并且可以包括可选显示的其他详细信息。以下代码显示了一个示例 <code>HealthIndicator</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;        <span class="keyword">int</span> errorCode = check();        <span class="keyword">if</span> (errorCode != <span class="number">0</span>) &#123;            <span class="keyword">return</span> Health.down().withDetail(<span class="string">&quot;Error Code&quot;</span>, errorCode).build();        &#125;        <span class="keyword">return</span> Health.up().build();    &#125;    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">()</span> </span>&#123;        <span class="comment">// perform some specific health check        return ...    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>   给定 <code>HealthIndicator</code> 的标识符是不带 <code>HealthIndicator</code> 后缀的 bean 的名称（如果存在）。 在前面的示例中，健康信息在名为 <code>my</code> 的条目中可用。</p>
</blockquote>
<p>除了 Spring Boot 预定义的 <code>Status</code> 类型之外，<code>Health</code> 还可以返回一个自定义 <code>Status</code> 来表示新的系统状态。在这种情况下，还需要提供 <code>StatusAggregator</code> 接口的自定义实现，或者必须使用 <code>management.endpoint.health.status.order</code> 配置属性来配置默认实现。</p>
<p>例如，假设 <code>HealthIndicator</code> 实现正在使用code为 <code>FATAL</code> 的新的<code>Status</code>。要配置严重性顺序，请将以下属性添加到您的应用程序属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.status.order</span>=<span class="string">fatal,down,out-of-service,unknown,up</span></span><br></pre></td></tr></table></figure>

<p>响应中的 HTTP 状态代码反映了整体健康状况。默认情况下，<code>OUT_OF_SERVICE</code> 和 <code>DOWN</code> 映射到 503。任何未映射的健康状态（包括 <code>UP</code>）映射到 200。如果通过 HTTP 访问health endpoint，可能还想注册自定义状态映射.配置自定义映射会禁用 <code>DOWN</code> 和 <code>OUT_OF_SERVICE</code> 的默认映射。如果要保留默认映射，则必须与所有自定义映射一起显式配置。例如，以下属性将 <code>FATAL</code> 映射到 503（服务不可用）并保留 <code>DOWN</code> 和 <code>OUT_OF_SERVICE</code> 的默认映射：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.status.http-mapping.down</span>=<span class="string">503management.endpoint.health.status.http-mapping.fatal=503management.endpoint.health.status.http-mapping.out-of-service=503</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>   如果需要更多控制，可以定义自己的 <code>HttpCodeStatusMapper</code> bean。</p>
</blockquote>
<p>下表显示了内置状态的默认状态映射：</p>
<table>
<thead>
<tr>
<th><strong>Status</strong></th>
<th><strong>Mapping</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>DOWN</code></td>
<td><code>SERVICE_UNAVAILABLE</code> (<code>503</code>)</td>
</tr>
<tr>
<td><code>OUT_OF_SERVICE</code></td>
<td><code>SERVICE_UNAVAILABLE</code> (<code>503</code>)</td>
</tr>
<tr>
<td><code>UP</code></td>
<td>默认没有映射，所以 HTTP 状态是 200</td>
</tr>
<tr>
<td><code>UNKNOWN</code></td>
<td>默认没有映射，所以 HTTP 状态是 200</td>
</tr>
</tbody></table>
</li>
<li><h6 id="响应式健康指示器-Reactive-Health-Indicators"><a href="#响应式健康指示器-Reactive-Health-Indicators" class="headerlink" title="响应式健康指示器(Reactive Health Indicators)"></a>响应式健康指示器(Reactive Health Indicators)</h6><p>对于响应式应用程序，例如使用 Spring WebFlux 的应用程序，<code>ReactiveHealthContributor</code> 提供了一个非阻塞方式来获取应用程序健康状况。与传统的 <code>HealthContributor</code> 类似，健康信息是从 <code>ReactiveHealthContributorRegistry</code> 的内容中收集的（默认情况下，您<code>ApplicationContext</code> 中定义的所有 <code>HealthContributor</code> 和 <code>ReactiveHealthContributor</code> 实例）。在弹性调度器上执行的响应式 API的常规 <code>HealthContributor</code>不被检查。</p>
<blockquote>
<p>建议:</p>
<p>   在响应式应用程序中，应使用 <code>ReactiveHealthContributorRegistry</code> 在运行时注册和取消注册健康指示器。如果需要注册一个普通的 <code>HealthContributor</code>，应该使用 <code>ReactiveHealthContributor#adapt</code> 来包装它。</p>
</blockquote>
<p>要从响应式 API 提供自定义健康信息，可以注册实<code>ReactiveHealthIndicator</code> 接口的 Spring bean。以下代码显示了一个示例 <code>ReactiveHealthIndicator</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactiveHealthIndicator</span> <span class="keyword">implements</span> <span class="title">ReactiveHealthIndicator</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> Mono&lt;Health&gt; <span class="title">health</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> doHealthCheck().onErrorResume((exception) -&gt;            Mono.just(<span class="keyword">new</span> Health.Builder().down(exception).build()));    &#125;    <span class="function"><span class="keyword">private</span> Mono&lt;Health&gt; <span class="title">doHealthCheck</span><span class="params">()</span> </span>&#123;        <span class="comment">// perform some specific health check        return ...    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>   要自动处理错误，考虑从 <code>AbstractReactiveHealthIndicator</code> 扩展。</p>
</blockquote>
</li>
<li><h6 id="自动配置的-ReactiveHealthIndicators-Auto-configured-ReactiveHealthIndicators"><a href="#自动配置的-ReactiveHealthIndicators-Auto-configured-ReactiveHealthIndicators" class="headerlink" title="自动配置的 ReactiveHealthIndicators(Auto-configured ReactiveHealthIndicators)"></a>自动配置的 ReactiveHealthIndicators(Auto-configured ReactiveHealthIndicators)</h6><p>在适当的时候，Spring Boot 会自动配置以下 <code>ReactiveHealthIndicators</code>：</p>
<table>
<thead>
<tr>
<th><strong>Key</strong></th>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>cassandra</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraDriverReactiveHealthIndicator.java"><code>CassandraDriverReactiveHealthIndicator</code></a></td>
<td>检查 Cassandra 数据库是否已启动。</td>
</tr>
<tr>
<td><code>couchbase</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseReactiveHealthIndicator.java"><code>CouchbaseReactiveHealthIndicator</code></a></td>
<td>检查 Couchbase 集群是否已启动。</td>
</tr>
<tr>
<td><code>elasticsearch</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/elasticsearch/ElasticsearchReactiveHealthIndicator.java"><code>ElasticsearchReactiveHealthIndicator</code></a></td>
<td>检查 Elasticsearch 集群是否已启动。</td>
</tr>
<tr>
<td><code>mongo</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoReactiveHealthIndicator.java"><code>MongoReactiveHealthIndicator</code></a></td>
<td>检查 Mongo 数据库是否已启动。</td>
</tr>
<tr>
<td><code>neo4j</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/neo4j/Neo4jReactiveHealthIndicator.java"><code>Neo4jReactiveHealthIndicator</code></a></td>
<td>检查 Neo4j 数据库是否已启动。</td>
</tr>
<tr>
<td><code>redis</code></td>
<td><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisReactiveHealthIndicator.java"><code>RedisReactiveHealthIndicator</code></a></td>
<td>检查 Redis 服务器是否已启动。</td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<pre><code>如有必要，响应式indicator会取代常规indicator。 此外，任何未明确处理的 `HealthIndicator` 都会自动包装。
</code></pre>
</blockquote>
</li>
<li><h6 id="健康组-Health-Groups"><a href="#健康组-Health-Groups" class="headerlink" title="健康组(Health Groups)"></a>健康组(Health Groups)</h6><p>将健康indicator根据使用目的编成不同的组,这个有时候会很有用。</p>
<p>要创建health indicator group，可以使用 <code>management.endpoint.health.group.&lt;name&gt;</code> 属性并指定要包含或排除的health indicator ID 列表。例如，要创建仅包含database indicator的组，可以定义以下内容：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.group.custom.include</span>=<span class="string">db</span></span><br></pre></td></tr></table></figure>

<p>然后，可以通过点击 <code>localhost:8080/actuator/health/custom</code> 来检查结果.</p>
<p>同样，要创建一个组,从组中排除数据库指标并包括所有其他指标，可以定义以下内容：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.group.custom.exclude</span>=<span class="string">db</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，组将继承与系统运行状况相同的 <code>StatusAggregator</code> 和 <code>HttpCodeStatusMapper</code> 设置，但是，也可以在每个组的基础上定义这些设置。如果需要，也可以覆盖 <code>show-details</code> 和 <code>roles</code> 属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.group.custom.show-details</span>=<span class="string">when-authorizedmanagement.endpoint.health.group.custom.roles=adminmanagement.endpoint.health.group.custom.status.order=fatal,upmanagement.endpoint.health.group.custom.status.http-mapping.fatal=500management.endpoint.health.group.custom.status.http-mapping.out-of-service=500</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>   如果需要注册自定义 <code>StatusAggregator</code> 或 <code>HttpCodeStatusMapper</code> bean 以与组一起使用，则可以使用 <code>@Qualifier(&quot;groupname&quot;)</code>。</p>
</blockquote>
</li>
<li><h6 id="数据源安全-DataSource-Health"><a href="#数据源安全-DataSource-Health" class="headerlink" title="数据源安全(DataSource Health)"></a>数据源安全(DataSource Health)</h6><p><code>DataSource</code> 健康指示器显示标准数据源和路由数据源 bean 的健康状况。路由数据源的健康状况包括其每个目标数据源的健康状况。在health endpoint的响应中，每个路由数据源的目标都使用其路由key命名。如果不想在指标的输出中包含路由数据源，请将 <code>management.health.db.ignore-routing-data-sources</code> 设置为 true。</p>
</li>
</ol>
</li>
<li><h6 id="Kubernetes-探测器-Kubernetes-Probes"><a href="#Kubernetes-探测器-Kubernetes-Probes" class="headerlink" title="Kubernetes 探测器(Kubernetes Probes)"></a>Kubernetes 探测器(Kubernetes Probes)</h6><p>部署在 Kubernetes 上的应用程序可以通过 Container Probes 提供有关其内部状态的信息。根据 Kubernetes 配置，kubelet 将调用这些探测器并对结果做出反应。</p>
<p>Spring Boot 开箱即用地管理应用程序可用性状态。如果部署在 Kubernetes 环境中，执行器将从 <code>ApplicationAvailability</code> 接口收集“Liveness”和“Readiness”信息，并在专用健康指示器中使用该信息：<code>LivenessStateHealthIndicator</code> 和 <code>ReadinessStateHealthIndicator</code>。这些indicator将显示在全局health endpoint（<code>“/actuator/health”</code>）上。 将使用健康组将它们作为单独的 HTTP 探测器公开：<code>“/actuator/health/liveness”</code>和<code>“/actuator/health/readiness”</code>。</p>
<p>然后，可以使用以下endpoint信息配置您的 Kubernetes infrastructure：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ivenessProbe:  httpGet:    path: /actuator/health/liveness    port:</span> <span class="string">&lt;actuator-port&gt;</span>  <span class="attr">failureThreshold: ...  periodSeconds: ...readinessProbe:  httpGet:    path: /actuator/health/readiness    port:</span> <span class="string">&lt;actuator-port&gt;</span>  <span class="attr">failureThreshold: ...  periodSeconds:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>   <code>&lt;actuator-port&gt;</code> 应设置为执行器endpoint可用的端口。如果设置了<code>“management.server.port”</code>属性，它可能是主要的 Web 服务器端口，或者一个单独的管理端口。</p>
</blockquote>
<p>仅当应用程序在 Kubernetes 环境中运行时才会自动启用这些健康组。可以使用 <code>management.endpoint.health.probes.enabled</code> 配置属性在任何环境中启用它们。</p>
<blockquote>
<p>注意:</p>
<p>   如果应用的启动时间比配置的活跃期长，Kubernetes 会提到<code>“startupProbe”</code>作为可能的解决方案。这里不一定需要<code>“startupProbe”</code>，因为<code>“readinessProbe”</code>会一直失败直到在所有启动任务完成，请查看 <a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.endpoints.kubernetes-probes.lifecycle">how Probes behave during the application lifecycle</a>。</p>
<p>警告:</p>
<p>   如果 Actuator endpoint部署在单独的管理context中，请注意endpoint不会使用与主应用程序相同的 Web 基础设施（端口、连接池、框架组件）。在这种情况下，即使主应用程序不能正常工作（例如，它不能接受新连接），探测检查也可能成功。</p>
</blockquote>
<ol>
<li><h6 id="使用-Kubernetes-探测器检查外部状态-Checking-External-State-with-Kubernetes-Probes"><a href="#使用-Kubernetes-探测器检查外部状态-Checking-External-State-with-Kubernetes-Probes" class="headerlink" title="使用 Kubernetes 探测器检查外部状态(Checking External State with Kubernetes Probes)"></a>使用 Kubernetes 探测器检查外部状态(Checking External State with Kubernetes Probes)</h6><p>Actuator 将“liveness”和“readiness”探测器配置为健康组；这意味着他们可以使用所有健康组功能。例如，可以配置额外的health indicator：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.group.readiness.include</span>=<span class="string">readinessState,customCheck</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，Spring Boot 不会向这些组添加其他health indicator。</p>
<p>“liveness”探测器不应依赖于外部系统的健康检查。如果应用的 Liveness State 被破坏，Kubernetes 将尝试通过重新启动应用程序实例来解决该问题。这意味着如果外部系统出现故障（例如数据库、Web API、外部缓存），Kubernetes 可能会重新启动所有应用程序实例并造成级联故障。</p>
<p>至于“readiness”探测器，应用程序开发人员必须谨慎选择检查外部系统，即 Spring Boot 在“readiness”探测器中不包含任何额外的健康检查。如果应用实例的状态是未就绪，Kubernetes 不会将流量路由到该实例。一些外部系统可能不会被应用程序实例共享，在这种情况下，它们可以很自然地包含在就绪探测中。其他外部系统可能对应用程序不是必需的（应用程序可能有断路器和回退），在这种情况下，它们绝对不应该被包含在内。不幸的是，外部系统被所有应用程序实例共享是很常见的，并且必须做出判断调用：将其包含在readiness probe中，并期望在外部服务关闭时应用程序停止服务，或者忽略它并处理堆栈更高层的故障，例如 在调用者中使用断路器。</p>
<blockquote>
<p>注意:</p>
<p>   如果应用的所有实例都未就绪，则 <code>type=ClusterIP</code> 或 <code>NodePort</code> 的 Kubernetes 服务将不接受任何传入连接。由于没有连接，因此没有 HTTP 错误响应（503 等）。<code>type=LoadBalancer</code> 的服务可能接受也可能不接受连接，具体取决于provider。具有显式 Ingress 的 Service 也会以依赖于实现的方式进行响应 - Ingress 服务本身必须决定如何处理来自下游的“connection refused”。很可能在负载均衡器和入口的情况下,可能出现HTTP 503 。</p>
</blockquote>
<p>此外，如果应用使用 Kubernetes 自动缩放，它可能会对被从负载均衡器中取出的应用做出不同的反应，具体取决于其自动缩放器配置。</p>
</li>
<li><h6 id="应用程序生命周期和探测状态-Application-Lifecycle-and-Probe-States"><a href="#应用程序生命周期和探测状态-Application-Lifecycle-and-Probe-States" class="headerlink" title="应用程序生命周期和探测状态(Application Lifecycle and Probe States)"></a>应用程序生命周期和探测状态(Application Lifecycle and Probe States)</h6><p>Kubernetes Probes 支持的一个重要方面是它与应用程序生命周期的一致性。<code>AvailabilityState</code> 是应用在内存中的内部状态，与公开该状态的实际探测器之间存在显着差异：根据应用程序生命周期的阶段，探测器可能不可用。</p>
<p>Spring Boot 在启动和关闭期间发布 Application Events，Probes 可以监听此类事件并暴露 <code>AvailabilityState</code> 信息。</p>
<p>下表显示了不同阶段的 <code>AvailabilityState</code> 和 HTTP 连接器的状态。</p>
<p>当 Spring Boot 应用程序启动时：</p>
<table>
<thead>
<tr>
<th><strong>Startup phase</strong></th>
<th><strong>LivenessState</strong></th>
<th><strong>ReadinessState</strong></th>
<th><strong>HTTP server</strong></th>
<th><strong>Notes</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Starting</td>
<td><code>BROKEN</code></td>
<td><code>REFUSING_TRAFFIC</code></td>
<td>Not started</td>
<td>Kubernetes 会检查“活跃度”探测器，如果时间过长，则重新启动应用程序。</td>
</tr>
<tr>
<td>Started</td>
<td><code>CORRECT</code></td>
<td><code>REFUSING_TRAFFIC</code></td>
<td>Refuses requests</td>
<td>应用程序上下文被刷新。 应用程序执行启动任务，但尚未接收流量。</td>
</tr>
<tr>
<td>Ready</td>
<td><code>CORRECT</code></td>
<td><code>ACCEPTING_TRAFFIC</code></td>
<td>Accepts requests</td>
<td>启动任务完成。 应用程序正在接收流量。</td>
</tr>
</tbody></table>
<p>当 Spring Boot 应用程序关闭时：</p>
<table>
<thead>
<tr>
<th>Shutdown phase</th>
<th>Liveness State</th>
<th>Readiness State</th>
<th>HTTP server</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>Running</td>
<td><code>CORRECT</code></td>
<td><code>ACCEPTING_TRAFFIC</code></td>
<td>Accepts requests</td>
<td>已请求关闭。</td>
</tr>
<tr>
<td>Graceful shutdown</td>
<td><code>CORRECT</code></td>
<td><code>REFUSING_TRAFFIC</code></td>
<td>New requests are rejected</td>
<td>如果启用，<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.graceful-shutdown">正常关闭处理正在进行的请求</a>。</td>
</tr>
<tr>
<td>Shutdown complete</td>
<td>N/A</td>
<td>N/A</td>
<td>Server is shut down</td>
<td>应用程序上下文关闭，应用程序关闭。</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><h6 id="应用信息-Application-Information"><a href="#应用信息-Application-Information" class="headerlink" title="应用信息(Application Information)"></a>应用信息(Application Information)</h6><p>应用程序信息公开从 <code>ApplicationContext</code> 中定义的所有 <code>InfoContributor</code> bean 收集的各种信息.Spring Boot 包含许多自动配置的 <code>InfoContributor</code> bean，可以编写自己的 bean。</p>
<ol>
<li><h6 id="自动配置的-InfoContributors-Auto-configured-InfoContributors"><a href="#自动配置的-InfoContributors-Auto-configured-InfoContributors" class="headerlink" title="自动配置的 InfoContributors(Auto-configured InfoContributors)"></a>自动配置的 InfoContributors(Auto-configured InfoContributors)</h6><p>在适当的时候，Spring Boot 会自动配置以下 <code>InfoContributor</code> bean：</p>
<table>
<thead>
<tr>
<th align="center">Name</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.java"><code>EnvironmentInfoContributor</code></a></td>
<td align="center">在 <code>info</code> 键下暴露 <code>Environment</code> 中的所有键。</td>
</tr>
<tr>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/GitInfoContributor.java"><code>GitInfoContributor</code></a></td>
<td align="center">如果 <code>git.properties</code> 文件可用，则公开 git 信息。</td>
</tr>
<tr>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/BuildInfoContributor.java"><code>BuildInfoContributor</code></a></td>
<td align="center">如果<code>META-INF/build-info.properties</code>文件可用，则公开构建信息。</td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>   可以通过设置 <code>management.info.defaults.enabled</code> 属性来禁用它们。</p>
</blockquote>
</li>
<li><h6 id="自定义应用信息-Custom-Application-Information"><a href="#自定义应用信息-Custom-Application-Information" class="headerlink" title="自定义应用信息(Custom Application Information)"></a>自定义应用信息(Custom Application Information)</h6><p>可以通过设置 <code>info.*</code> Spring 属性来自定义 info endpoint公开的数据。<code>info</code> key下的所有 <code>Environment</code> 属性都会自动公开。例如，可以将以下设置添加到 <code>application.properties</code> 文件中：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">info.app.encoding</span>=<span class="string">UTF-8info.app.java.source=11info.app.java.target=11</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>   还可以在构建时展开信息属性，而不是对这些值进行硬编码。假设使用 Maven，可以按如下方式重写前面的示例：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;info.app.encoding</span>=<span class="string">@project.build.sourceEncoding@info.app.java.source=@java.version@info.app.java.target=@java.version@</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><h6 id="Git提交信息-Git-Commit-Information"><a href="#Git提交信息-Git-Commit-Information" class="headerlink" title="Git提交信息(Git Commit Information)"></a>Git提交信息(Git Commit Information)</h6><p><code>info</code> endpoint的另一个有用功能是它能够在构建项目时发布有关 <code>git</code> 源代码存储库状态的信息。如果 <code>GitProperties</code> bean 可用，则可以使用 <code>info</code> endpoint来公开这些属性。</p>
<blockquote>
<p>建议:</p>
<p>   如果 <code>git.properties</code> 文件在类路径的根目录下可用，则 <code>GitProperties</code> bean 是自动配置的。</p>
</blockquote>
<p>默认情况下，endpoint公开 <code>git.branch</code>、<code>git.commit.id</code> 和 <code>git.commit.time</code> 属性（如果存在）。如果不希望endpoint响应中出现这些属性中的任何一个，则需要将它们从 <code>git.properties</code> 文件中排除。如果要显示完整的git信息（即<code>git.properties</code>的全部内容），使用<code>management.info.git.mode</code>属性，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.info.git.mode</span>=<span class="string">full</span></span><br></pre></td></tr></table></figure>

<p>要完全禁用 <code>info</code> endpoint的 git commit 信息，请将 <code>management.info.git.enabled</code> 属性设置为 <code>false</code>，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.info.git.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="构建信息-Build-Information"><a href="#构建信息-Build-Information" class="headerlink" title="构建信息(Build Information)"></a>构建信息(Build Information)</h6><p>如果 <code>BuildProperties</code> bean 可用，则 <code>info</code> endpoint还可以发布有关您建的信息。如果类路径中有 <code>META-INF/build-info.properties</code> 文件，就会发生这种情况。</p>
<blockquote>
<p>建议:</p>
<p>   Maven 和 Gradle 插件都可以生成该文件。</p>
</blockquote>
</li>
<li><h6 id="编写自定义-InfoContributor-Writing-Custom-InfoContributors"><a href="#编写自定义-InfoContributor-Writing-Custom-InfoContributors" class="headerlink" title="编写自定义 InfoContributor(Writing Custom InfoContributors)"></a>编写自定义 InfoContributor(Writing Custom InfoContributors)</h6><p>要提供自定义应用信息，可以注册实现 <code>InfoContributor</code> 接口的 Spring bean。</p>
<p>以下示例提供了一个具有单个值的<code>example</code>条目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInfoContributor</span> <span class="keyword">implements</span> <span class="title">InfoContributor</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contribute</span><span class="params">(Info.Builder builder)</span> </span>&#123;        builder.withDetail(<span class="string">&quot;example&quot;</span>, Collections.singletonMap(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>));    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果访问 <code>info</code> endpoint，应该会看到包含以下附加条目的响应：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    <span class="attr">&quot;example&quot;</span>: &#123;        <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;value&quot;</span>    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Actuator</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB存储引擎</title>
    <url>/posts/64693.html</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><h3 id="数据库与实例概念"><a href="#数据库与实例概念" class="headerlink" title="数据库与实例概念"></a>数据库与实例概念</h3><ol>
<li>数据库: 屋里操作系统文件以及其他形式的文件类型的集合.比如ibd,frm</li>
<li>实例: 后台线程和内存组成.在操作系统上表现为一个进程.</li>
</ol>
<h3 id="MySQL体系结构-1"><a href="#MySQL体系结构-1" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p>连接池组件<br>管理服务和工具(备份,恢复,管理)<br>SQL接口组件<br>查询分析器组件<br>查询优化器组件<br>缓冲(cache)组件<br>插件式存储引擎<br>物理文件(redo,undo,index,log)</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul>
<li>InnoDB:面向OLTP</li>
<li>MyISAM:不支持事务,表锁,面向OLAP</li>
<li>Memory:数据全部放在内存中,关机丢失,适用于临时数据</li>
</ul>
<h3 id="连接MySQL方式"><a href="#连接MySQL方式" class="headerlink" title="连接MySQL方式"></a>连接MySQL方式</h3><ul>
<li>TCP/IP: mysql -h host -u username -p password</li>
<li>命名管道和共享内存</li>
<li>UNIX套接字</li>
</ul>
<h2 id="Inno存储引擎"><a href="#Inno存储引擎" class="headerlink" title="Inno存储引擎"></a>Inno存储引擎</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>高性能,高可用,高扩展. 支持ACID,<br>特点:行锁设计,支持MVCC,支持外键,一致性非锁定读</p>
<h3 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h3><ul>
<li><p>后台线程</p>
<ul>
<li><p>Master线程</p>
<p>功能:<br>异步刷新缓冲池数据,保证数据一致性,包括:脏页,合并插入缓冲(insert buffer),undo页回收</p>
<ul>
<li><p>工作方式</p>
<p>日志缓冲落盘<br>合并插入缓冲 (merge Insert Buffer)<br>刷新脏页<br>删除无用undo页(full purge,要判断版本信息)</p>
</li>
<li><p>innodb_adaptive_flushing(自适应刷新)</p>
<p>判断redo log和速度来决定最适合刷新脏页的数量</p>
</li>
</ul>
</li>
<li><p>IO Thread</p>
<p>用于AIO请求的回调<br>有4个分别是:</p>
<pre><code>write,(4个)
read, (4个)
insert buffer,
log IO thread
</code></pre>
</li>
<li><p>Purge Thread</p>
<p>用来回收undo页,以及删除delete_flag 标为删除的记录.</p>
</li>
<li><p>Page Cleaner Thread</p>
<p>用于脏页刷新操作</p>
</li>
</ul>
</li>
<li><p>内存</p>
<ul>
<li><p>缓冲池</p>
<p>作用:</p>
<pre><code>用于缓冲磁盘与CPU之间的速度差.存储页.
</code></pre>
<p>FIX:</p>
<pre><code>将页从磁盘中读取到内存的过程
</code></pre>
<p>命中:</p>
<pre><code>若在缓冲池中直接找到页,称作命中
</code></pre>
<p>为了提高整体性能,在数据修改时,先修改缓冲池的页,然后通过CheckPoint机制刷新回磁盘.</p>
<p>配置:</p>
<pre><code>可以配置多个缓冲池实例,通过hash进行页分配,减少竞争,提升并发. 
</code></pre>
<p> 即使缓冲池再大,远比数据表大,仍然会进行磁盘IO,比如将脏页异步写入磁盘,每次事务提交时将日志写入重做文件中.</p>
<ul>
<li><p>数据页</p>
<ul>
<li>落盘时需要doublewrite</li>
</ul>
</li>
<li><p>索引页</p>
</li>
<li><p>insert buffer</p>
</li>
<li><p>自适应哈希AHI</p>
</li>
<li><p>锁信息</p>
</li>
<li><p>数据字典</p>
</li>
</ul>
</li>
<li><p>LRU list</p>
<ol>
<li><p>LRU list<br> 管理页,频繁使用页在list前端,最少使用在后端.用于淘汰页.<br> 不同于传统LRU,加入了midpoint位置.新读取的页不是放到首部,而是放到midpoint位置.算法称为mindpoint insertion strategy. 可以使用innodb_old_blocks_pct控制.默认为5/8.</p>
</li>
<li><p>mindpoint insertion strategy:<br> new list ——- minpoint–oldlist<br> 如果直接将页加入到lru的首段,可能会导致热点数据被刷出.比如索引或者数据的扫描操作,需要访问大量的页,如果仅这次使用,会导致热点数据被移除,而下次读取该数据,有需要进行磁盘IO.<br> 还提供了另一个参数,进一步管理LRU.innodb_old_blocks_time,表示页读取到mid位置后,经过多长时间,再次访问才会被加入LRU列表的热端.</p>
</li>
<li><p>page made young:<br> 指页从old移动到new部分.</p>
</li>
<li><p>page not made young:<br> 指因为设置了innodb_old_blocks_time导致页没有移动</p>
</li>
</ol>
<p>5.缓冲命中率,如果低于95%,则要考虑全表扫描导致LRU列表被污染的问题.查看innodb_buffer_pool_stats 表查看缓冲池运行状态.</p>
<p>6.页压缩</p>
<ul>
<li>页压缩(unzip_LRU)<ol>
<li><p>作用:<br> 将16kb的页压缩为1,2,4,8k.使用unzip_LRU管理</p>
</li>
<li><p>unzip_LRU从内存池分配(有直接用,没有申请大内存,分割):<br> (申请4kb为例)</p>
<ol>
<li>检查4kbunzip_LRU也是否有空闲,若有直接使用</li>
<li>检查8kb列表,<br> 若有,将页分为两个4kb,存放到unzip_LRU列表<br> 没有,则申请16kb,然后将页分成1个8kb,2个4kb,放到列表中.</li>
</ol>
</li>
</ol>
</li>
<li>脏页<ol>
<li>定义:<br> LRU列表中的页,被修改后叫做脏页,<br> 此时缓冲池中数据和磁盘中不一致,会使用checkpoint机制刷新会磁盘</li>
</ol>
<ul>
<li><p>checkpoint</p>
<ol>
<li>目的:<br> 缩短数据库恢复时间(故障时只要恢复checkpoint后的数据)<br> 缓冲池不够用时,刷新脏页,释放空间(根据lru释放)<br> 重做日志不可用时,刷新脏页(重做日志需要保留,不能覆盖)</li>
<li>LSN(log sequence number)<br> 用来标记版本.每个页都有lsn</li>
<li>checkpoint表示已经刷新到磁盘页上的lsn,仅需要恢复checkpoint开始的日志部分.</li>
</ol>
<ul>
<li><p>sharp checkpoint</p>
<p>数据库关闭时,将所有脏页刷新回磁盘.</p>
</li>
<li><p>fuzzy checkpoint</p>
<p>1.使用场景: </p>
<pre><code>在运行时使用.
</code></pre>
<ol start="2">
<li>发生情况<br> Master Thread CheckPoint<br> FLUSH_LRU_LIST CheckPoint<br> Async/Sync Flush Checkpoint<br> Dirty Page too much Checkpoint</li>
</ol>
<ul>
<li><p>Master Thread CheckPoint</p>
<p>每1s或者每10s从缓冲池的脏页列表中刷新一定比例的页回磁盘.异步落盘.查询线程不会阻塞.</p>
</li>
<li><p>FLUSH_LRU_LIST CheckPoint</p>
<p>如果LRU列表中可用页数量少于指定数时触发.<br>可以使用参数指定数量innodb_lru_scan_depth</p>
</li>
<li><p>Async/Sync Flush Checkpoint</p>
<p>重做日志不可用的情况,强制刷新一部分页到磁盘中.从脏页列表选取.</p>
<pre><code>未落盘数据占redo log file 比例
&lt;75%,        
    不需要刷新脏页
75%&lt;  ~ &lt;90%,
     触发Async落盘,指导符合仅阻塞当前用户查询
90%&lt; ~        
    触发Sync落盘,阻塞所有用户查询.(只有在导入大量数据时可能会出现)
</code></pre>
<p>这不刷新操作放到 Page Cleaner Thread,故现在不会阻塞查询</p>
</li>
<li><p>Dirty Page too much Checkpoint</p>
<p>脏页数量太多,强制checkpoint,来保证有足够多的可用页.可以由参数innodb_max_dirty_pages_pct</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Write Ahead Log</p>
<p>当事务提交时,先写redo log,然后再修改页.当由于宕机导致数据丢失时,通过重做日志完成数据的恢复.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Free List</p>
<p>用于表示可用空闲页.<br>数据库刚启动时,LRU列表为空,当需要从数据库中获取页是,就从free列表查找是否存在可用页.若有从Free中移除,加入到LRU中.</p>
</li>
<li><p>Flush List</p>
<p>为脏页列表,用来将脏页刷新会磁盘</p>
</li>
<li><p>重做日志缓冲(redo log buffer)</p>
<p>将redo log放到此区域,然后定时刷新到日志文件.一般每秒刷新.大小可以使用innodb_log_buffer_size控制</p>
<ul>
<li><p>刷新到磁盘情景</p>
<ol>
<li>Master 线程没一秒将buffer刷新到磁盘</li>
<li>事务提交时,刷新</li>
<li>redo log buffer 小于1/2时,刷新</li>
</ol>
</li>
</ul>
</li>
<li><p>额外缓冲池</p>
<p>有一些数据结构内存申请时,需要从额外缓冲池申请.比如缓冲控制对象(buffer control block),记录了一些lru,锁信息.</p>
<h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3></li>
</ul>
</li>
<li><p>插入缓冲</p>
<ul>
<li><p>Insert Buffer</p>
<p>Insert Buffer是物理页的一个组成部分.避免离散读,同时将多个插入操作合并成一个.</p>
<ol>
<li><p>问题:<br> 插入记录时,插入顺序按照主键递增的顺序进行插入.因此插入聚集索引一般是顺序的,不需要磁盘随机读取.插入速度快.<br> 非聚集索引(辅助索引)的插入是慢的,数据页按照主键顺序存放,对于非聚集索引叶子节点的插入不是顺序的,此时需要离散访问非聚集索引页.随机读取导致插入性能差.</p>
</li>
<li><p>定义:<br> 对于非聚集索引的插入或者更新操作,不是每一次都直接插入到索引页中,而是先判断非聚集索引页是否在缓冲池中,若在直接插入;若不在,则先放到一个Insert Buffer对象中. 模拟已经插入的情况. 然后再以一定频率进行Insert Buffer和辅助索引叶子节点的merge(合并操作),这时,通常能将多个插入操作合并到一个操作中,提高了对非聚集索引插入性能.</p>
</li>
</ol>
<ul>
<li><p>使用条件</p>
<p>使用条件:</p>
<pre><code>1.索引是辅助索引
2.索引不是唯一的(unique)
</code></pre>
<p>满足条件,才会使用Insert Buffer</p>
<p>索引不是唯一是因为,插入缓冲时,索引数据库并不去查找索引页来判断索引的唯一性.如果需要查找的话,肯定会导致离散读,导致Insert Buffer失去意义.</p>
</li>
<li><p>可能存在的问题</p>
<ol>
<li>大量插入数据,如果出现宕机,Insert Buffer没有合并到磁盘中,此时恢复需要很长时间,极端情况下可能几个小时.<br>推测:可能是需要重新建立索引</li>
<li>在写密集情况下,可能会导致Insert Buffer占用过多的缓冲池内存(innodb_buffer_pool),默认可以占到一半.(硬编码的)</li>
</ol>
</li>
<li><p>内部实现</p>
<p>Insert Buffer是一个B+树.默认放在共享表空间中.通过idb恢复数据后,还需要repair table重建副主索引.</p>
<ol>
<li><p>非叶子节点:<br> space+marker+offset<br> space:表示表空间<br> marker:用于兼容老版本的insert buffer<br> offset:表示页所在的偏移量.</p>
</li>
<li><p>叶子节点:<br> space+marker+offset+metadata+record<br> metadata:</p>
<pre><code> IBUF_REC_OFFSET_COUNT:给进入Insert Buffer的记录排序,为了支持Change Buffer,只有经过replay,才能得到正确的记录值.
</code></pre>
</li>
<li><p>插入流程:<br> 当一个辅助索引要插入到页(space,offset)时,如果页不再缓冲池中,则引擎根据规则构造一个search key,然后查询Insert Buffer这个B+树,然后将这条记录插入到Insert Buffer B+ 树叶子节点上.</p>
</li>
<li><p>Insert Buffer Bitmap:<br>为了保证Merge Insert Buffer能够必须成功,还需要有一个特殊的页来标记每个辅助索引页(space,page_no)的可用空间.这个页的类型就是Insert Buffer Bitmap</p>
</li>
</ol>
<ul>
<li>Insert Buffer Bitmap<ol start="4">
<li>Insert Buffer Bitmap:<br> 为了保证Merge Insert Buffer能够必须成功,还需要有一个特殊的页来标记每个辅助索引页(space,page_no)的可用空间.这个页的类型就是Insert Buffer Bitmap.<br> 每个Insert Buffer Bitmap页用来追踪256个区,16384个页的可用空间.每个Insert Buffer Bitmap都在16384页的第二个页.<br> 记录了每个辅助索引页的可用剩余空间,是否有记录缓存在Insert Buffer B+ 树中,</li>
</ol>
</li>
</ul>
</li>
<li><p>合并插入缓冲(Merge Insert Buffer)</p>
<p>以下情况,Insert Buffer中的记录合并到真正辅助索引中:</p>
<pre><code>1. 辅助索引页被读取到缓冲池中
2. Insert Buffer Bitmap页追踪到该辅助索引页无可用空间时
3. Master Thread
</code></pre>
<ul>
<li><p>辅助索引页被读取到缓冲池中</p>
<p>在执行select 操作时,要检查 insert buffer bitmap页,确认辅助索引页是否有记录在b+树上.如果有,则将该页的记录插入到辅助索引页中.将多次插入操作合并到一次中.</p>
</li>
<li><p>Insert Buffer Bitmap页追踪到该辅助索引页无可用空间</p>
<p>辅助索引页可用空间小于1/32,强制进行合并操作.即强制读取辅助索引页,将b+树中记录插入辅助索引页中.</p>
</li>
<li><p>Master Thread</p>
<p>每1s或者10s都会merge insert buffer.<br>为了在复杂情况下有良好的公平性,引擎随机选择insert buffer b+树的一个页,读取该页的space已经所需要的数量的页,进行merge.而不是进行有序选择.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Change Buffer</p>
<p>可以视为Insert Buffer升级,可以对DML操作进行缓冲,insert,delete,update. 分别为 insert buffer,delete buffer,change buffer.<br>要求仍然是非唯一索引.<br>可以通过参数控制最大内存使用(innodb_change_buffer_max_size,最大有效值50)</p>
</li>
</ul>
</li>
<li><p>两次写(Double Write)</p>
<ol>
<li>概念:<br> 当写入失效时,先通过页的副本来还原页,再进行重做,这就是doublewrite.保证数据页可靠性</li>
<li>组成<br> doublewrite buffer(内存,2M)<br> 共享表空间连续128个页(磁盘,2M)<br> 3.机制<br> 第一次:脏页刷新时,不直接写磁盘,而是会通过memcpy函数,将脏页复制到doublewrite buffer中.再通过doublewrite buffer分两次,每次将1M顺序写入共享表空间的物理磁盘上.然后马上调用fsync函数,同步磁盘,避免缓冲写导致的问题.因为doublewrite也是连续的,因此顺序写开销不大.<br> 第二次:double页写入后,再将doublewrite buffer中的页写入各个表空间,此时写入是离散的.</li>
</ol>
<p>4.数据恢复:</p>
<pre><code>如果发生崩溃,在恢复过程中,引擎将共享表空间中的doublewrite中找到该页的副本,将其复制到表空间文件,再应用重做日志.
</code></pre>
<ul>
<li><p>部分写失效(partial page write)</p>
<p>概念:</p>
<pre><code>将页写入到表中,但是只写了一部分,发生宕机,称为部分写失效
</code></pre>
<p>redo log无法恢复:</p>
<pre><code>redo log是对物理页的恢复,当物理页发生损坏时,无法恢复数据
</code></pre>
</li>
</ul>
</li>
<li><p>自适应哈希索引(Adaptive Hash Index)</p>
<p>1.概念:</p>
<pre><code>innodb会监控表上索引页的查询.如果观察到建立哈希索引可以带来速度提升,则建立哈希索引.称之为自适应哈希索引.通过B+树页建立AHI,因此速度快,不需要对整个表建立索引.
</code></pre>
<ul>
<li><p>建立AHI条件</p>
<ol>
<li>查询条件限制:<br> a.索引页的访问模式一样: 查询条件(where)一样. 如果不同的查询条件访问到同一个索<br> b.该模式访问了100次</li>
<li>页命访问次数限制:<br> 页通过该模式访问了 1/16*页记录次.</li>
</ol>
</li>
<li><p>使用AHI要求</p>
<p>1.等值查询</p>
<pre><code>哈希索引只能用来搜索等值查询,如果范围查找则不使用哈希索引.
</code></pre>
</li>
</ul>
</li>
<li><p>异步IO(Async IO)</p>
<p>1.概念:</p>
<pre><code>用户发出一个IO请求后,立即发出另一个IO请求,当全部IO请求发送完毕后,等待所有IO操作完成. 提高IOPS.
</code></pre>
<p>InnoDB中所有的read ahead方式读取,都是通过AIO.磁盘刷新也是通过AIO方式.</p>
<ul>
<li><p>IO merge</p>
<p>1.概念:</p>
<pre><code>可以进行IO Merge,将多个IO操作合并成一个IO.判断多个IO的页是否连续,重复,可以将多次IO在一次完成.
比如要访问(6,7),(7,8),(8,8),AIO会判断出三个页是连续的,然后一次读取.
</code></pre>
</li>
</ul>
</li>
<li><p>刷新邻接页(Flush Neighbor Page)</p>
<ol>
<li><p>概念:<br> 当刷新一个脏页时,InnoDB存储引擎会检测页所在区的所有页,如果是脏页,则一起刷新. </p>
</li>
<li><p>建议:<br> 机械硬盘开启,SSD关闭 设置set global innodb_flush_neighbors=0;</p>
</li>
</ol>
<ul>
<li><p>优点</p>
<p>可以通过AIO将多个IO写入操作合并成一个IO操作.在机械磁盘下有显著优势.</p>
</li>
<li><p>缺点</p>
<p>可能将不怎么脏的页写入磁盘,然后该页马上又变成脏页.</p>
</li>
</ul>
</li>
<li><p>预读(Read  Ahead)</p>
<p>Read-Ahead用于异步预取buffer pool中的多个page的一个预测行为。<br>InnoDB使用两种提前预读Read-Ahead算法来提高I/O性能。</p>
<p>Linear read-ahead:线性预读</p>
<pre><code>如果一个extent中的被顺序读取的page超过或者等于   innodb_read_ahead_threshold  参数变量时，Innodb将会异步的将下一个extent读取到buffer pool中，innodb_read_ahead_threshold可以设置为0-64的任何值
</code></pre>
<p>Random read-ahead:随机预读</p>
<pre><code>如果当同一个extent中连续的13个page在buffer pool中发现时，Innodb会将该extent中的剩余page读到buffer pool中。控制参数  innodb_random_read_ahead  默认没有开启。
</code></pre>
<ul>
<li><p>线性预读(Linear read-ahead)</p>
</li>
<li><p>随机预读(Random read-ahead)</p>
<p>默认关闭</p>
</li>
</ul>
</li>
<li><p>启动,关闭和恢复</p>
<ul>
<li><p>关闭</p>
<p>关机动作参数<br>innodb_fast_shutdown:</p>
<pre><code>0 , 完成所有full purge和merge insert buffer,所有脏页刷新回磁盘,会需要很长时间.但是InnoDB引擎升级时必须使用.
1 , 不需要完成full purge和merge insert buffer.只刷新缓冲池中的脏页回磁盘. 
2 ,不full purge 和 merge insert buffer,数据脏页不落盘.将日志写入文件,下次启动恢复.
</code></pre>
<p>恢复动作参数<br>innodb_force_recovery</p>
<pre><code>0 , 需要恢复时,恢复数据
1~6, 忽略恢复数据动作(主键递增),此时DML操作不允许.
</code></pre>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2></li>
</ul>
</li>
</ul>
<h3 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h3><ul>
<li><p>参数</p>
<p>使用 show variables 命令</p>
</li>
<li><p>参数类型</p>
<ul>
<li><p>动态参数</p>
<p>运行时可修改.<br>set [global | session] system_var_name=expr</p>
<p>修改只会在实例声明周期有效,不会修改文件中的参数.重启后使用配置文件参数</p>
</li>
<li><p>静态参数:只读</p>
</li>
</ul>
</li>
</ul>
<h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><ul>
<li><p>错误日志(err log)</p>
<p>– 查看错误日志文件位置<br>show variables like ‘log_error’</p>
</li>
<li><p>二进制日志(binlog)</p>
<ol>
<li>概念:<br> 记录了对MySQL数据库执行更改的所有操作.不包括select show这类操作.如果出现多次修改数据,将数据修改至最初状态,该操作也会被写入到二进制文件.</li>
<li>作用:<br> 恢复(recovery):某些数据恢复需要<br> 复制(replication):主从复制<br> 审计(audit):通过日志进行审计,进行判断有误注入攻击</li>
</ol>
<ul>
<li><p>参数</p>
<p>max_binlog_size: </p>
<pre><code>指定单个二进制日志文件的最大值.超过值,则创建一个新的二进制文件,后缀名+1;
</code></pre>
<p>binlog_cache_size:</p>
<pre><code>使用事务存储引擎是,所有未提交的二进制日志会被记录到一个缓存中,等该事务提交时,直接将缓冲的二进制日志写入二进制文件.缓冲大小由该参数指定. 作用于每个session中,因此设置不宜过大.也不宜过小,mysql会把缓冲文件中的数据写入临时文件.
</code></pre>
<p>sync_binlog:</p>
<pre><code>sync_binlog=[N],表示每写缓冲多少次就同步到磁盘.如果设为sync_binlog=1,表示采用同步磁盘的方式来写二进制,此时不使用操作系统的缓冲.
</code></pre>
<p>binlog_format</p>
<pre><code>-statement ,逻辑sql语句,同步时,会出现不一致的情况.uuid比如
-row    记录表更改情况.
-mix     默认使用statement,在特殊情况下使用row.比如ndb的DML操作,UUID()等不确定函数,用户自定义函数,临时表等.
</code></pre>
<ul>
<li><p>binlog_format</p>
<p>1.优点:</p>
<pre><code>数据恢复和复制更好的可靠性.
</code></pre>
<p>缺点:</p>
<pre><code>导致二进制文件大小增加.存储与网络开销大.
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>慢查询日志(slow query log)</p>
<p>定位存在问题的SQL语句.<br>使用slow_query_log开启慢查询日志<br>使用long_query_time指定慢查询时间,只有大于该时间会被记录</p>
<ul>
<li><p>开启</p>
</li>
<li><p>指定时间</p>
</li>
<li><p>记录没有走索引的查询</p>
</li>
<li><p>mysqldumpslow.pl</p>
<p>可以使用这个工具进行检索查看mysql慢查询.mysql自带</p>
</li>
<li><p>慢查询输出到slow_log表</p>
<p>– 查看日志输出形式,file,table<br>show variables like ‘log_output’<br>– 设置慢查询日志以table形式存储<br>set  global log_output=”table”</p>
<p>slow_log表默认使用CSV存储引擎,可以改为MyISAM,提升搜索效率<br>– 更改slow_log 表存储引擎为MyISAM,提升查询性能<br>set global  slow_query_log=off<br>alter table  mysql.slow_log engine=MyISAM<br>set global  slow_query_log=on</p>
</li>
</ul>
</li>
<li><p>查询日志(log)</p>
<p>查询日志放到mysql.general_log</p>
<h3 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h3></li>
</ul>
<p>UNIX下,mysql.sock,用于本地连接.</p>
<h3 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h3><p>进程ID写入到-&gt; 主机名.pid<br>可以使用参数控制文件位置.pid_file</p>
<h3 id="表结构定义文件-frm"><a href="#表结构定义文件-frm" class="headerlink" title="表结构定义文件.frm"></a>表结构定义文件.frm</h3><p>存放表与视图</p>
<h3 id="存储引擎文件"><a href="#存储引擎文件" class="headerlink" title="存储引擎文件"></a>存储引擎文件</h3><ul>
<li><p>表空间文件</p>
<p>默认表空间:</p>
<pre><code>存储的数据按照表空间进行存放,ibdata1是默认表空间.可以使用参数配置 innodb_data_file_path.可以配置多个,用来实现平均磁盘负载,提高性能.
</code></pre>
<p>innodb_file_per_table: 为每个表设置独立表空间 </p>
<pre><code>独立表空间只存储该表的数据,索引和插入缓冲Bitmap等信息,其余信息还是放在默认表空间中.
</code></pre>
<h3 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h3></li>
</ul>
<p>记录事务日志<br>innodb_log_file_size:<br>    每个重做日志大小</p>
<ul>
<li><p>文件大小的影响</p>
<p>文件太大时,恢复时需要很长时间.<br>文件太小需要频繁切换重做日志文件,同时会导致频繁发生async checkpoint,导致性能抖动.</p>
</li>
<li><p>log block</p>
<p>重做日志都是以512字节进行存储的,</p>
</li>
<li><p>redo log文件格式</p>
<p>redo_log_type + space + page_no + redo_log_body</p>
<pre><code>redo_log_type: 类型
space :表空间
page_no : 页偏移量
redo_log_body: 数据
</code></pre>
</li>
<li><p>写入过程</p>
<p>写入redo log file不是直接写入,而是先写入一个重做日志缓冲 redo log buffer,然后写入文件,log 文件满则循环写入其他文件.</p>
<p>redo log buffer按照512个字节,也就是一个扇区大小进行写入.因为扇区是写入最小单位,因此可以保证写入必定成功.因此在写redo log file 时不需要doublewrite.</p>
<ul>
<li>redo 为什么不需要doublewrite?</li>
</ul>
</li>
<li><p>事务提交时,对redo log的处理</p>
<p>innodb_flush_log_at_trx_commit</p>
<pre><code>-0, 提交时,不将重做日志写入到磁盘的日志文件上,等待主线程刷新
-1(默认), 提交时,将redo log buffer 写入磁盘,还有fsync操作.文件一定写入到文件中
-2, 提交时,将redo log buffer 写入磁盘,没有fsync操作.不能完全保证数据写入文件中. 如果数据库宕机,而系统正常,则可以恢复.
</code></pre>
</li>
<li><p>对比redo log 与 binlog</p>
<ol>
<li>日志范围不同:<br> redo log 只记录InnoDB的事务日志<br> binlog 记录Mysql有关的日志,包括所有引擎.</li>
<li>内容:<br> redo log 记录每个page的物理操作<br> binlog 记录逻辑日志,无论文件记录格式是statement还是row 或者 mixed</li>
<li>写入时间:<br> redo log在事务过程中,不断写入日志文件中.<br> binlog 只在事务提交前提交,只写盘一次.<br> 4.幂等性:<br> redo log是物理操作,所以是幂等的<br> binlog设置为ROW也不是幂等的,比如insert 操作.<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2></li>
</ol>
</li>
</ul>
<h3 id="索引组织表-index-organized-table"><a href="#索引组织表-index-organized-table" class="headerlink" title="索引组织表((index organized table))"></a>索引组织表((index organized table))</h3><p>InnoDB中,表是根据主键顺序进行组织存放的,这种存储方式称为索引组织表(index organized table).</p>
<p>如果没有指定主键或者创建主键.<br>    则会选择表内非空唯一索引(unique not null)为主键.如果有多个,则选择创建的第一个索引.<br>    如果没有索引,则默认添加一个6字节大小的指针作为主键.</p>
<h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>表空间(table space) </p>
<ul>
<li><p>表空间</p>
<p>默认表空间 ibdata1 ,</p>
<pre><code>存储 undo 信息,插入缓冲索引页, 系统事务信息,二次写缓冲.
</code></pre>
<p>单独表空间:    </p>
<pre><code>只存储,数据,索引和插入缓冲bitmap 页
</code></pre>
<ul>
<li><p>段</p>
<p>数据段,索引段,回滚段.</p>
<p>数据段</p>
<pre><code>是B+树叶子节点
</code></pre>
<p>索引段 </p>
<pre><code>B+树非叶子节点
</code></pre>
<ul>
<li><p>区</p>
<p>由连续的页组成,任何情况下大小都为1M.为了保证区中页的连续性,存储引擎每次从磁盘中申请4~5个区. 一个区中有64个连续页.</p>
<p>每个段开始有32个碎片页,使用完后才申请64个连续页,为了对于小表可以在开始时申请较少内存,节省磁盘容量开销.</p>
<ul>
<li><p>页</p>
<p>InnoDB中最小存储单位,.默认大小16KB.<br>可以使用innodb_page_size来修改每个页的大小.</p>
<p>分类:</p>
<pre><code>数据页(B-tree node)
undo页(undo log page)
系统页(system page)
事务数据页(transaction system page)
插入缓冲位图页(inset buffer page)
插入缓冲空闲列表页(insert buffer free list)
未压缩的二进制大对象页(uncompressed BLOB page)
压缩的二进制大对象页(compressed BLOB page)
</code></pre>
<ul>
<li><p>行</p>
<p>每个页,最多允许存放16KB/2-200行数据</p>
<h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>查看show table status<br>Row_Format显示行格式</p>
<ul>
<li><p>Compact行记录格式</p>
<p>高效存储<br>边长字段长度列表 + NULL标志位 + 记录头信息 + 列1数据 … </p>
<p>边长字段长度列表: </p>
<pre><code>那些列是变长的
</code></pre>
<p>记录头信息 :</p>
<pre><code>该行是否删除,下一记录位置,类型,记录数
n_owned
next_record
delete_flag
</code></pre>
<p>不管是char还是varchar类型,compact下,都不占空间</p>
</li>
<li><p>Reduant行记录</p>
<p>格式</p>
<pre><code>边长字段长度列表  + 记录头信息 + 列1数据 ... 
</code></pre>
<p>记录头信息:</p>
<pre><code>n_fields (10bit): 记录中列的数量,只有10位,一次最大支持1023列.
</code></pre>
</li>
<li><p>行溢出数据</p>
<p>InnoDB可以把一条记录中的某些数据存储在真正的数据页面之外.一般是BLOB,LOB这种大对象类型的数据存储在数据页面之外.<br>BLOB可以不将数据放在溢出页面,varchar也可以存放为行溢出数据.</p>
<p>一般情况下,数据存放在数据页中.,类型为B-Tree node,但当发生行溢出时,数据放在Uncompress BLOB页中.</p>
<p>TEXT或者BLOB并不一定总是存放在 Uncompress BLOB 中,只要一个页至少能存放两条记录,那就不需要存到Uncompress BLOB中.但是大多数情况BLOB都会发生行溢出的.</p>
</li>
<li><p>Compressed和Dynamic(默认格式)行记录格式</p>
<p>这两个记录格式,都采用完全行溢出,</p>
<p>compressed 会对其中数据以zlib进行压缩,因此对于BLOB,TEXT,VARCHAR大长度类型对象非常有效存储.</p>
</li>
<li><p>CHAR的行结构存储</p>
<p>char类型被明确视为了变长类型,对于未能占满长度的字符还是填充0x20.在多字符集的情况下,char和varchar类型的实际存储基本没有区别.</p>
<p>比如char(5) ,可以存储 “12345”, 也可以存储 “一二三四五”.不再只根据字节数限制.</p>
<h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3></li>
<li><p>File Header(文件头)</p>
<p>包括:</p>
<pre><code>表空间中页的偏移量
上一页指针
下一页指针
最后被修改的日志序列位置LSN
页的类型()
</code></pre>
</li>
<li><p>Page Header(页头)</p>
<p>记录数据页状态</p>
<pre><code>页中记录数
槽数
索引ID,当前页属于哪个索引
</code></pre>
</li>
<li><p>Infimun和Supremum Record</p>
<p>Infimum,比任何主键值都小的值 ,类似头指针<br>Supremum,比任何主键都大的值 ,类似尾指针</p>
</li>
<li><p>User Records(用户记录,行记录)</p>
<p>存储行记录的内容</p>
</li>
<li><p>Free Space(空闲空间)</p>
<p>空闲空间,也是个链表数据结构.记录删除后,加入该空闲链表.</p>
</li>
<li><p>Page Directory(页目录)</p>
<p>存放这记录的相对位置,记录指针称为槽slot. 洗漱目录,一个槽可能不包含多个目录.</p>
<p>查询过程:</p>
<pre><code>B+树索引不能找到具体的目录,只能找到数据页.找到后,把页载入内存,然后通过Page Directory进行二分查找,找到指定槽,然后查找槽上的记录. 在数据页中的查找速度很快,时间可以忽略.
</code></pre>
</li>
<li><p>File Trailer(文件结尾信息)</p>
<p>file trailer 用于检测页是否完整写入磁盘.<br>File Trailer只有一个FIL_PAGE_END_LSN部分, 8字节,前四字节代表该页的checksum值.后4字节和File Header中的FIL_PAGE_LSN相同. 然后根据结果比对,可以判断页是否完整.</p>
<p>默认情况下,每次从磁盘读取一个页就会检测完整性,可以通过参数控制是否检查<br>– innodb_checksum_algorithm 完整性检查的算法<br>– innodb_checksums 取页的是否做完整性检查</p>
<ul>
<li>完整性检查</li>
</ul>
</li>
</ul>
<h3 id="Named-File-Formats"><a href="#Named-File-Formats" class="headerlink" title="Named File Formats"></a>Named File Formats</h3><p>InnoDB存储通过Named File Format机制来解决不同版本的页兼容性问题.新的文件格式,总是包含之前版本 的页格式</p>
<p>innodb_file_format 用来指定页格式</p>
<ul>
<li><p>Barracuda File Foramt</p>
<ul>
<li><p>Compressed</p>
</li>
<li><p>Dynamic</p>
</li>
<li><p>Antelope File Format</p>
<ul>
<li>Compact</li>
<li>Redundant</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>在information_schema.TABLE_CONSTRAINTS中可以查看约束</p>
<ul>
<li><p>数据完整性</p>
<ul>
<li>实体完整性</li>
<li>域完整性</li>
<li>参照完整性</li>
</ul>
</li>
<li><p>约束和索引的区别</p>
<p>约束是一个逻辑概念,用来保证数据完整性,索引是一个数据结构,既有逻辑概念,也有物理概念.</p>
</li>
<li><p>对错误数据的约束</p>
<p>如果sql_mode设置不合理,则约束会失效.数据库只提示警告,而不是报错.</p>
</li>
<li><p>外键约束</p>
<p>在添加外键的时候,可以添加子表操作.<br>reference_option:</p>
<pre><code>CASCADE: 表示父表进行DELETE或者UPDATE时,字表数据也进行相应操作
SET NULL: 父表更新或删除,字表设置为null
NO ACTION: 父表更新,删除,字表抛出错误,禁止这类操作
RESTRICT:  父表更新,删除,字表抛出错误,禁止这类操作
</code></pre>
<p>添加外键时,mysql 会自动给字段添加索引.</p>
<ul>
<li><p>外键检查</p>
<p>在数据导入时,可以将外键检查关闭,导入完成后,打开外键.</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3></li>
</ul>
</li>
</ul>
<p>虚表,只存在于内存中,没有物理存储.</p>
<ul>
<li><p>作用</p>
<p>应用不关心基表的结构,只需要按照视图定义来取或者更新数据.<br>同时也可以起到一个安全层的作用.</p>
<p>可更新视图,</p>
<pre><code>创建视图时,可以使用 with check option,对更新视图插入的数据进行检查,对于不满足视图条件的数据更新时,会抛出异常,不允许更新.比如插入条件之外的内容.
</code></pre>
</li>
<li><p>物化视图</p>
<p>mysql不支持物化视图,可以使用触发器+辅助表,来实现.</p>
<ul>
<li><p>刷新模式</p>
<p>ON DEMAND :</p>
<pre><code>在用户需要的时候,刷新视图
</code></pre>
<p>ON COMMIT</p>
<pre><code>在基表更新时刷新视图
</code></pre>
</li>
<li><p>刷新方法</p>
<p>FAST</p>
<pre><code>增量刷新,只刷新上次以后的修改
</code></pre>
<p>COMPLETE</p>
<pre><code>完全刷新
</code></pre>
<p>FORCE</p>
<pre><code>如果可以FAST就使用FAST,否则使用COMPLETE
</code></pre>
<p>NEVER</p>
<pre><code>不进行任何刷新
</code></pre>
</li>
<li><p>查询重写</p>
<p>对物化视图的基表进行查询时,如果能通过物化视图直接获得结果,则直接使用物化视图结果.则可以避免聚集或者连接这类复杂操作.</p>
</li>
</ul>
</li>
<li><p>MySQL模拟物化视图</p>
<p>触发器+辅助表</p>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3></li>
</ul>
<p>分区功能不是在存储引擎层实现的.分区的过程是将一个表或者索引分解为多个更小的,可管理的部分.</p>
<p>水平分区:<br>    不同行分配到不同文件中<br>垂直分区:<br>    不同列分配到不同文件中</p>
<p>局部分区:<br>    一个分区中既放索引,又放数据<br>全局分区<br>    数据放在各个分区中,所有数据的索引放在一个对象里</p>
<p>MySQL支持: 水平分区,局部分区<br>使用参数来开启功能.</p>
<p>误区    </p>
<ol>
<li>只要启用分区,性能就高<br> 分区并不一定能够带来性提高,有的会更快,有的会变慢.分区主要用于提升数据的高可用管理.</li>
</ol>
<ul>
<li><p>创建索引注意:</p>
<p>如果表中存在主键或唯一索引时,</p>
<pre><code>分区列必须是唯一索引的一个组成部分.
</code></pre>
<p>如果没有主键或唯一索引时:</p>
<pre><code>可以指定任何一个列为分区列
</code></pre>
<ul>
<li><p>分区修剪(Partition Pruning)</p>
<p>SQL优化器只需要根据检索条件去搜索指定分区,而不会搜索所有分区.这个称为分区修剪,使检索速度大大提高.</p>
<p>但是如果跨了多个分区,可能也会导致检索变慢.</p>
</li>
</ul>
</li>
<li><p>分区类型</p>
<ul>
<li><p>RANGE分区</p>
<p>ALTER TABLE <code>order</code>.<code>t_order</code><br> PARTITION BY RANGE(id)(</p>
<pre><code>partition p0  values less than (10),
    partition p1  values less than (maxvalue)
</code></pre>
<p> );</p>
<p>range分区,主要用于日期类.分区函数仅限于         YEAR(),TO_DAYS(),TO_SECONDS(),UNIX_TIMESTAMP()这类函数进行优化选择. 如果使用自定义</p>
</li>
<li><p>LIST分区</p>
<p>插入多个离散的值.<br>ALTER TABLE <code>order</code>.<code>t_order</code><br> PARTITION BY LIST(id)(</p>
<pre><code>partition p0  values in (1,2,3),
    partition p1  values in (4,5,6)
</code></pre>
<p> );</p>
<p>InnoDB,在插入多个行时,如果中间出现不在定义范围内的数据,则会抛出异常,然后回滚.<br>MyISAM,插入就插入了</p>
</li>
<li><p>HASH分区</p>
<p>目的:</p>
<pre><code>为了将数据均匀地分布到预先定义的各个分区中,保证每个分区的记录数量大致相同.
</code></pre>
<p>定义:</p>
<pre><code>指定分区数量,以及分区的hash值.
ALTER TABLE `order`.`t_order` 
    partition BY HASH(id)
        partitions 4;
</code></pre>
</li>
<li><p>LINEAR HASH分区</p>
<ol>
<li><p>概念:<br> 使用更为复杂的算法来确定新行的分区位置.<br> ALTER TABLE <code>order</code>.<code>t_order</code> </p>
<pre><code> partition BY LINEAR HASH(id)
     partitions 4;
</code></pre>
</li>
<li><p>算法<br> 取分区大于分区数量4的下一个2的幂值V(6)<br> 所在分区N=输入值&amp;(V-1)</p>
<p> 优点: </p>
<pre><code> 增加,删除,合并和拆分分区变得更加快捷,有利于处理大量数据的表.
</code></pre>
<p> 缺点:</p>
<pre><code> 区间的数据分布可能不太均衡
</code></pre>
</li>
</ol>
</li>
<li><p>KEY分区</p>
<p>分区的编号是通过2的幂算法(power-of-two)得到而不是模数算法.</p>
</li>
<li><p>COLUMNS</p>
<p>可以直接使用费整型的数据进行分区,不需要转化成整型.</p>
<p>ALTER TABLE <code>order</code>.<code>t_order</code><br> partition BY RANGE COLUMUNS(id,userId)<br> partitions  p0 values less than(a,b),<br> partitions  p1 values less than(c,d),<br> partitions  p2 values less than(e,f),</p>
<p>包括:</p>
<pre><code>所有整型:INT,SMALLINT等.不包括FLOAT,DECIMAL.
日期类型:DATE和DATETIME.其他不支持.
字符串类型:CHAR,VARCHAR,BINARY.不支持BLOB和TEXT
</code></pre>
</li>
</ul>
</li>
<li><p>子分区</p>
<p>允许在RANGE和LIST的基础上在进行HASH或者KEY的子分区.<br>注意:</p>
<pre><code>在分区表任何分区上使用subpartition明确定义任何分区,就要定义所有分区的子分区.
子分区名字必须唯一
</code></pre>
</li>
<li><p>分区中的NULL值</p>
<p>将NULL值视为最小值.<br>RANGE分区,</p>
<pre><code>插入最左分区
</code></pre>
<p>LIST分区下,</p>
<pre><code>必须指定哪个分区放入NULL值
</code></pre>
<p>HASH和KEY分区,</p>
<pre><code>将NULL值记录返回为0
</code></pre>
</li>
<li><p>分区和性能</p>
<p>对于OLAP,</p>
<pre><code>查询数据多,分区可以提升查询性能
</code></pre>
<p>对于OLTP,</p>
<pre><code>查询数据少,应该注意.如果分区设计不好,会导致严重性能.最坏情况导致扫描多个分区,IO大大增加.
</code></pre>
</li>
<li><p>在表和分区间交换数据</p>
<pre><code>可以使用alter table ... exchange partition语句进行交换.如果非分区表中没有数据,相当于将分区表中数据移到非分区表,导出.如果相反,则是导入.
</code></pre>
<p>要求条件:</p>
<pre><code>两个表结构相同,表不能有分区
非分区表的数据必须在分区的定义内.
非分区表不能有外键
除了alter,insert,create权限外,还需要DROP权限
</code></pre>
<p>注意:</p>
<pre><code>交换不会触发两表的触发器
auto_increment列将会被重置.
</code></pre>
<p>猜测 交换规则:重新建表,然后改名?</p>
<h2 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h2></li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul>
<li><p>B+树索引</p>
<p>B 指的是balance  而不是binary</p>
<p>B+树索引不能找到给定键值的具体行,B+树索引能找到数据行所在的页.然后读取页到内存,再使用二分法查找,获得最终数据.</p>
<p>特点: 高扇出性,直接调用的下级模块的个数多,高度一般都在2~4层.所以有效减少IO次数.</p>
<ul>
<li><p>聚集索引</p>
<p>cluster index:</p>
<pre><code>按照表的主键构造B+ 树,叶子节点中存放的为整张表的行数据,也将聚集索引的叶子节点称为数据页.
每张表只有一个聚集索引,所以查询优化器倾向于使用聚集索引.
</code></pre>
<p>聚集索引不是在存储上面不是连续的.只是在逻辑上是连续的,如果是连续的,则需要很大的维护成本.</p>
<p>排序查找和范围查找很快.不需要进行filesort</p>
<ul>
<li><p>索引页</p>
<p>只存放键值和指向数据页的偏移量.</p>
</li>
<li><p>数据页</p>
<p>存放完整记录</p>
</li>
</ul>
</li>
<li><p>辅助索引</p>
<p>叶子结点并不包含行记录完整数据.叶子结点除了包含键值之外,还有bookmark,即主键值,即聚集索引键.</p>
<p>通过辅助索引查询数据时,会遍历辅助索引,并通过页级别的指针获得主键,然后通过主键索引获得完整记录.</p>
<p>可以通过预读(read ahead)技术,来避免多次的离散操作.</p>
</li>
<li><p>B+ 树索引的分裂</p>
<pre><code>页的分裂并不总是从页的中间记录开始的,这样可能会导致页空间的浪费.比如顺序插入,分裂后,左页不会再有数据插入,空间浪费.
InnoDB根据Page Header中的 PAGE_LAST_INSERT,PAGE_DIRECTION,PAGE_N_DIRECTION信心来判断存储引擎是向左还是向右进行分裂.
若插入是随机的,则从页中间分裂.
若往同一方向进行插入的记录数量为5,并且定位到记录之后还有三条记录,则分裂点为定位到的记录后的第三条记录.否则分裂点记录就是待插入记录.
</code></pre>
</li>
<li><p>索引管理</p>
<ul>
<li><p>查看索引</p>
<p>show index from tablexxx;</p>
<ul>
<li><p>Cardinality</p>
<pre><code>Cardinality:表示索引中唯一值的数目的估计值.其中Cardinality/记录总数,  应该尽可能的接近1.如果非常小,则考虑要删除该索引.
优化器会根据这个值来判断是否使用索引.这个值不是实时更新的,因为这样代价太大.同时这个值只是一个大概值.
</code></pre>
<ul>
<li><p>手动更新Cardinality</p>
<p>Analyze table来更新信息</p>
<pre><code>在某些情况下,索引建立却没有用到的情况,或者对两条基本一样的语句执行EXPLAIN,但是最终结果不一样:一条使用索引,另一个使用全表扫描.最好解决办法是analyze table.
建议在非高峰时间里,对核心表进行analyze table操作,从而使优化器和索引更好的工作.
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>快速索引创建(Fast Index Creation)</p>
<p>在以往的MySQL数据库索引添加或者删除这类DDL操作.MySQL的操作过程是: </p>
<pre><code>创建临时表,表结构为修改的后的表结构
把原表数据导入到临时表
删除原表
重名临时表,为原来的表名.
</code></pre>
<p>传输索引创建(FIC)</p>
<pre><code>先对索引创建表加上一个S锁.在创建过程中不需要重新建表,速度,可用性都得到提升.
删除辅助索引,只需要更新内部视图,将辅助索引空间标记为可用,同时删除索引定义.
问题: 加了S锁,只能对表进行读操作,若有大量事务对表进行写操作,那么数据库服务同样不可用的.此外FIC只限定于辅助索引,对于主键的创建和删除同样需要重建表.
</code></pre>
</li>
<li><p>在线架构改变(Online Schema Change,OSC)</p>
<p>指定时,在事务的读写过程中,仍然可以修改索引.</p>
<pre><code>创建和原表一样的表,并且进行alter操作.
创建deltas表,并且在原表上添加触发器,将对原表的DML操作写入deltas表.
将原表中的数据写入到新表中.为了减少锁定时间,使用分片(chunked)将数据输出到多个外部文件,然后将外部文件导入到copy表中.
导入数据到新表前,删除所有的辅助索引
将分片文件导入到新表.
将OSC过程中,原表的DML操作应用到新表中,
重创辅助索引
再次进行DML日志的回放,这些日志是在创建辅助索引的过程中产生的日志
将新表和旧表名字交换.改名很快,因此阻塞时间很短.
</code></pre>
</li>
<li><p>在线数据定义(Online DDL)</p>
<p>允许辅助索引创建的同时,还允许其他DML操作,包括insert,update,delete.</p>
<p>包括一些DDL操作:</p>
<pre><code>辅助索引的创建与删除
改变自增长值
添加或者删除外键约束
列的重命名
</code></pre>
<p>原理:</p>
<pre><code>在执行或者删除操作时,将insert,update,delete这类DML操作日志写入到一个缓存中.待完成索引创建后,在重做应用到表上,以此达到数据一致性.这个缓存大小由参数innodb_online_alter_log_max_size作修改.
</code></pre>
<p>可以使用新的alter table 语法.同时可以选择索引的创建方式:</p>
<pre><code>alter table tbl_name
| add &#123;index|key&#125; &#123;index_name&#125;
[index_type] (index_col_name,...) [index_option]
algorithm [=] &#123;default|inplace|copy&#125;
lock [=] &#123;default| none|shared|exclusive&#125;
</code></pre>
<p>algorithm 指定了创建或者删除索引的算法,</p>
<pre><code>-copy表示按照创建临时表方式.
-inplace表示索引创建或者删除操作不需要创建临时表.
-default表示根据参数 old_alter_table来判断. 默认为off,表示使用inplace方式.
</code></pre>
<p>lock 部分表示索引创建或删除时对表添加锁的情况.</p>
<pre><code>-none , 对目标表不添加锁,事务仍然可以进行读写操作,不会受到阻塞,可以获得最大并发度.
-share , 类似FIC,索引创建和删除加上一个S锁.可以并发读,但是阻塞写操作.
-exclusive, 执行索引创建或删除操作,对目标加上一个X锁.读写事务都不能进行.
-default ,首先判断当前操作,能否使用none模式,如果不能则判断是否可以使用share模式,最后exclusive.
</code></pre>
<p>​<br>​    </p>
</li>
</ul>
</li>
<li><p>哈希索引</p>
<ul>
<li><p>InnoDB存储引擎中的hash算法</p>
<pre><code>用于字典查找,冲突机制采用除法散列方式.对于缓冲池页的哈希表,在缓冲池中的Page页都有一个chain指针,用它指向相同的哈希函数值的页.
对于除法散列,m的取值略大于2倍的缓冲池页数量的质数.
</code></pre>
<p>页转换成自然数:</p>
<pre><code>    自然数K=space_id&lt;&lt;20+space_id+offset
    space_id左移20位.
</code></pre>
</li>
<li><p>AHI</p>
</li>
</ul>
</li>
<li><p>全文索引</p>
</li>
</ul>
<h3 id="Cardinality-基数"><a href="#Cardinality-基数" class="headerlink" title="Cardinality(基数)"></a>Cardinality(基数)</h3><p>Cardinality:<br>    列中不重复的字段数的预估值.<br>选择性:<br>    字段取值的范围很小,称为低选择性.很多则是高选择性.<br>用作索引的字段,应该要有高选择性,几乎没有重复,用作B+树索引比较合适. 实际应用中, Cardinality/n_rows_in_table应该尽可能地接近1.如果非常小,则要考虑是否有必要加这个索引.</p>
<ul>
<li><p>统计方法</p>
<p>方法:</p>
<pre><code>并不是每次更新操作去统计,开销太大.数据库对Cardinality的统计通过采样(Sample)的方法来完成.
</code></pre>
<p>更新策略:</p>
<pre><code>1. 表中1/16数据已经发生过改变.
2. stat_modified_counter(修改次数)&gt;20,0000,这是防止对一部分数据不断修改,导致第1策略不适用的情况
</code></pre>
<p>采样方法:</p>
<pre><code>随机取得B+树索引中8个叶子节点.统计每个页不同记录个数,然后除以记录总数得到Cardinality. innodb_stats_sample_pages 指定随机取得页数.
</code></pre>
<h3 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h3></li>
<li><p>联合索引</p>
<p>联合索引,只要满足最左匹配,数据就可以走索引.<br>数据也根据键值进行排序.因此,有些情况可以避免使用filesort.</p>
</li>
<li><p>覆盖索引(convering index)</p>
<p>概念:</p>
<pre><code>从辅助索引中就可以查询到记录,不需要再插叙聚集索引中的记录. 
</code></pre>
<p>优点:<br>辅助索引不包含完整行记录,因此大小远远小于聚集索引,同时不需要读取数据页,可以减少IO操作.</p>
<p>在正常情况下,对于(a,b)联合索引,一般不可以选择列b中的查询条件.但是如果是统计操作,并且是覆盖索引,则优化器会进行选择.如下</p>
<pre><code>select count(*) from table where b&gt;xx and b&lt;xxx
</code></pre>
</li>
<li><p>优化器不选择辅助索引的情况</p>
<p>当同时存在主键索引,辅助索引可用时,优化器选择了主键聚集索引,进行了全表扫描,而没有走辅助索引.<br>原因:</p>
<pre><code>用户选择的数据较多,辅助索引不能覆盖到查询信息,因此使用辅助索引后,还要查询一次书签,才能获得数据.虽然辅助索引数据有序,但是对书签的查找是无序的,会变成磁盘离散读操作.如果访问数据量小,则优化器会选择辅助索引,但是当访问数据量大时(比如占到表的20%),优化器会选择聚集索引来查找数据,因为顺序读速快于离散读.
因此,对于不能进行索引覆盖的情况,优化器选择辅助索引的情况是,通过辅助索引查找的数据是少量的.
</code></pre>
<p>如果使用SSD,随机读快速,则可以使用force index 来强制使用某个索引. select * from xxx force index (idx_xxx)</p>
<ul>
<li>优化器什么时候选择辅助索引?</li>
<li>force index(…)</li>
</ul>
</li>
<li><p>索引提示</p>
<p>显式告诉优化器使用那个索引.</p>
<pre><code>优化器错误选择索引
索引很多,优化器选择执行计划时间开销大于SQL语句本身.
</code></pre>
<p>通过index hint 可以强制优化器不进行各个执行路径的成本分析,直接选择指定索引来完成查询.</p>
<ul>
<li><p>Index Hint</p>
<p>select * from t use index(a_idx) where ….</p>
<p>use index 只是告诉优化器可以选择该索引,实际上,优化器还会再根据自己判断进行选择.<br>如果想要强制使用某一索引,可以使用force index</p>
</li>
</ul>
</li>
<li><p>多范围查询优化(Multi-Range Read优化,MRR)</p>
<p>目的:</p>
<pre><code>为了减少磁盘随机访问.对于受限于IO的SQL查询语句可以带来极大提升.适用于range,ref,eq_ref
</code></pre>
<p>优点:</p>
<pre><code>1. 使数据访问变得较为顺序.在插叙辅助索引时,现根据得到的查询结果,按照主键排序,并按照主键排序的顺序进行书签查找.
2. 减少缓冲池中页被替换的次数,比如缓冲池空间小,随机读取会导致页被不断移除,读入.
3. 批量处理对键值的查询操作
</code></pre>
<p>解释1,2: 对于范围查找和join查询,工作方式:</p>
<pre><code>将查询到的辅助索引存放于缓存中,此时是数据排序是使用辅助索引键值
将缓存中的键值根据RowID进行排序
根据RowID的排序来访问实际的数据文件.
</code></pre>
<p>解释3:</p>
<pre><code>还可以将某些范围查询,拆分成键值对,一起进行数据查询.好处是,在拆分过程中,直接过滤一些不符合查询条件的数据.
比如where  0&lt;a and a&lt;100. and b&lt;100 and b &gt;-123 .如果没有MRR,则先读取符合条件a的所有数据,再根据条件b进行筛选,这样导致了符合a不符合b的无用数据读出.如果开启MRR,则查询优化器会讲条件拆分为(0,-122),(0,-121),..,(1,-122)...然后根据拆分条件进行数据查询.
</code></pre>
<p>开启:</p>
<pre><code>可以使用optimizer_switch 中关于mrr的flag来开启MRR.
</code></pre>
<p>read_rnd_buffer_size用来控制键值的缓冲区大小.当大于该值时,则执行器对已经缓存的数据根据RowID进行排序,并通过RowID来获取行数据.</p>
</li>
<li><p>索引下推Index Condition Pushdown(ICP)优化</p>
<p>没有使用索引下推时:</p>
<pre><code>先根据索引来查询满足索引的所有记录,然后根据where条件过滤.
</code></pre>
<p>使用索引下推:</p>
<pre><code>在取出索引的同时,判断是否可以进行where条件过滤,也就是将where的部分过滤操作放到了存储引擎层. 使用ICP优化时,在执行计划Extra可以看到 Using index condition提示.
</code></pre>
<p>所以本质来说，索引下推就是只有符合条件再进行回表，对索引中包含的字段先进行判断，不符合条件的跳过。减少了不必要的回表操作。</p>
<h3 id="全文检索-Full-Text-Search"><a href="#全文检索-Full-Text-Search" class="headerlink" title="全文检索(Full-Text Search)"></a>全文检索(Full-Text Search)</h3><p>  将存储于数据库中的整本书或者文章中的任意内容信息找出来的技术.可以获取全文有关章,节,段落,句,词信息,也可以用来统计和分析.InnoDB支持全文检索</p>
</li>
</ul>
<ul>
<li><p>倒排索引(inverted index)</p>
<p>也是一种索引结构,在辅助表(auxiliary table)存储单词与单词所在文档地址的映射.有两种形式</p>
<pre><code>1.inverted file index &#123;单词,文档ID&#125;
2.full inverted index, 表现形式为&#123;单词,(文档ID,具体位置)&#125;
</code></pre>
</li>
<li><p>InnoDB全文检索</p>
<p>支持全文检索,使用full inverted index方式.</p>
<pre><code>即 &#123;word,(documentID,position)&#125;   &#123;word,ilist&#125;
</code></pre>
<p>在word上设有索引,由于ilist中存放了position信息,因此可以实现proximity search 近似匹配.</p>
<p>为了提高全文检索的并行性能,共有6张auxiliary table,每张表按照word和latin编码分区.<br>auxiliary table 是持久表存放在磁盘上.</p>
<ul>
<li><p>全文检索索引缓存(FTS Index Cache)</p>
<pre><code>FTS Index Cache (全文检索索引缓存),用来提高检索性能.红黑树结构,这意味着在插入数据后,对全文索引的更新还在 FTS Index Cache中,导致auxiliary table 还没有被更新. (并不能实时更新)
</code></pre>
<p>批量插入:</p>
<pre><code>InnoDB存储引擎会批量对auxiliary table进行更新,而不是每次插入后就更新一次auxiliary table.
</code></pre>
<p>查询前merge</p>
<pre><code>当对全文检索进行查询时,auxiliary table会首先在FTS Index Cache中对应的word字段合并到auxiliary table中,然后进行查询
</code></pre>
<p>可以在informat_schema中看到关于FTS_Cache与table的分词信息.</p>
<p>分词写入:</p>
<pre><code>InnoDB存储引擎总是在事务提交时,将分词写入到FTS Index Cache中,然后通过批量更新写入到磁盘,尽在事务提交时发生.
</code></pre>
<p>当数据库关闭或者宕机</p>
<pre><code>当数据库关闭时,FTS Index Cache中的数据会同步到磁盘上的auxiliary table.发生宕机时,会丢失数据.重启数据库后,当用户对表进行全文检索时(检索或者插入),InnoDB会自动读取未完成的文档,然后进行分词操作,再将结果放到FTS Index Cache中.可以通过参数innodb_ft_cache_size 进行设置
</code></pre>
</li>
<li><p>辅助表(Auxiliary Table)</p>
<p>为了辅助全文检索功能,而存在的表.一共有6个表.</p>
<p>INNODB_FT_BEING_DELETED  </p>
<p>INNODB_FT_CONFIG </p>
<pre><code>  配置
</code></pre>
<p>INNODB_FT_DEFAULT_STOPWORD   </p>
<pre><code>忽略分词表
</code></pre>
<p>INNODB_FT_DELETED </p>
<pre><code>  被删除的docId
</code></pre>
<p>INNODB_FT_INDEX_CACHE   </p>
<pre><code>分词索引缓存
</code></pre>
<p>INNODB_FT_INDEX_TABLE   </p>
<pre><code>分词
</code></pre>
</li>
<li><p>FTS_DOC_ID</p>
<p>为了支持索引,比如要有一列与word(分词)进行映射,列被命名为 FTS_DOC_ID,列的类型必须为big int unsigned not null,并且InnoDB会自动改加上FTS_DOC_ID_INDEX的Unique Index.</p>
</li>
<li><p>全文检索的创建</p>
<p>create fulltext index idx_fts on fts_a(body)</p>
</li>
<li><p>分词的逻辑删除</p>
<p>事务提交时,不删除磁盘的Auxiliary table记录,而只删除FTS Cache Index中的记录.对于Auxiliary Table中被删除的记录,InnoDB存储引擎记录其FTS Document ID,并保存在DELETE Auxiliary Table中.</p>
</li>
<li><p>分词的物理删除</p>
<p>对文档的DML并不删除索引中的数据,还会再DELETED表中插入记录,因此,索引会逐渐变得非常大.这是可以手动将无用的索引彻底删除,使用命令 optimize table. 该命令还会进行其他操作,比如重新计算Cardinality,如果只希望对倒排索引操作,可以使用innodb_optimize_fulltext_only来设定.</p>
<p>optimize table <code>order</code>.fts_a</p>
</li>
<li><p>stopword列表(stopword list)</p>
<p>概念:</p>
<pre><code>表示该列表中的word不需要对其进行分词操作.InnoDB中有默认的stopword列表,在information_schema.INNODB_FT_DEFAULT_STOPWORD 中.
</code></pre>
<p>自定义:</p>
<pre><code>可以使用参数 innodb_ft_server_stopword_table来自定义stopword列表.
</code></pre>
</li>
<li><p>限制</p>
<p>每张表只能有一个全文检索的索引;<br>有多列组合而成的全文检索的索引列必须使用相同的字符集和排序规则;<br>不支持没有单词界定符(delimiter)的语言,比如中文,日文,韩文.</p>
</li>
</ul>
</li>
<li><p>全文检索</p>
<ul>
<li><p>语法</p>
<p>match (col1,col2) against (expr [search_modifier])</p>
<p>search_modifier:</p>
<pre><code>in natural language mode
in natural language mode with query expansion
in boolean mode
with query expansion
</code></pre>
<ul>
<li><p>查询模式</p>
<ul>
<li><p>natural language</p>
<p>表示查询带有指定word的文档.是默认模式.在where中使用match函数.<br>select  * from <code>order</code>.fts_a<br>where match (body) against(‘el’ in natural language mode)</p>
<p>查询返回结果是根据相关性(relevance)进行降序排序,相关性越高,排序越靠前.相关性的值是一个非负的浮点数字.0表示没有任何相关性.</p>
<p>计算相关性的条件:</p>
<pre><code>word是否在文档中出现.
word在文档中出现次数
word在索引列中的数量
多少文档包含该word
</code></pre>
</li>
<li><p>Boolean</p>
<p>使用in boolean mode修饰时,插叙字符串前后字符会有特殊含义.支持如下操作符:</p>
<ul>
<li>, 该word必须存在</li>
</ul>
<ul>
<li>,  该word必须不存在<br>没有操作符表示该word 可选,如果有则相关性提高<br>@distance , 表示多个单词之间的距离是否在distance之内,单位是字节,也称为 Proximity Search. 比如 match(body) against (‘“please pot”@30’ in boolean mode)表示字符串please与pot之间的距离必须在30字节以内.<blockquote>
<p>,表示出现该词增加相关性<br>&lt;,表示出现改词降低相关性<br>~,表示允许出现该词,但是出现时,相关性为负</p>
</blockquote>
</li>
</ul>
<p><em>,表示以该单词开头的单词,比如lik</em> ,可以是like 也可以是likes<br>“,表示短语会把整个短语当做一个词查找.</p>
</li>
<li><p>Query  Expansion</p>
<p>扩展查询,这种查询通常是查询的关键词 太短,用户需要implied knowledge(隐含知识).<br>在查询短语中,增加 with query expansion,可以开启blind query expansion(也称为 automatic relevance feedback).</p>
<p>该查询分为两个阶段</p>
<pre><code>第一阶段: 根据单词进行全文索引查询.
第二阶段:根据第一阶段产生的分词再进行一次全文检索的查询.
</code></pre>
<p>注意:</p>
<pre><code>扩展查询会带来许多非相关的查询,因此在使用时,要谨慎.
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注意</p>
<ol>
<li>查询的word在stopword列中,则忽略改词.</li>
<li>查询的词的长度区间不对的,则不会对该词查询.<br>[innodb_ft_min_token_size,innodb_ft_max_token_size]<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>共享锁S(读锁: in share mode)</p>
<p>加上读锁过后,其他事务只能加读锁(锁兼容),不能加写锁-&gt;支持并发读取</p>
</li>
<li><p>排他锁X(for update)</p>
<p>加了排他锁之后,不允许有其他的读/写锁</p>
<h3 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h3></li>
<li><p>行锁</p>
<ul>
<li><p>记录锁(Record Lock)</p>
<p>是行锁的一种,单行记录上的锁.总是会锁住索引记录.</p>
<pre><code>有多个索引时,要分别上锁.
</code></pre>
<p>触发条件:<br>通过主键或者隐式主键,来锁定</p>
</li>
<li><p>间隙锁(Gap Lock)</p>
<p>行锁的一种,锁定一个范围,不包含记录本身<br>用在非唯一索引. 锁住的范围是左右区间<br>当表的相邻ID间出现空隙会形成区间,</p>
</li>
<li><p>临键锁(Next-Key Lock)</p>
<pre><code>行锁的一种,Record Lock + Gap Lock,锁定一个范围,并且锁定记录本身.是InnoDB的行锁默认算法.左开右闭原则.
</code></pre>
<p>设计目的是为了解决幻读问题:<br>Next-Key Lock会把查询出来的记录锁住,同时也会把范围查询的所有间隙锁住,会把相邻的下一个区间(Gap Lock)也会锁住.<br>结合了记录锁和间隙锁的特性,加了Next-Key Lock之后,在范围内数据不允许被修改和插入,避免了在范围查询时出现脏读,重复读,幻读问题<br>触发条件:</p>
<pre><code>范围查询并命中,查询命中了索引
</code></pre>
<p>Next-Key Lock 降级:</p>
<pre><code>当查询的索引含有唯一确定记录的属性时,InnoDB引擎会对Next-Key Lock进行优化,将其降级为Record Lock,即只锁住索引本身,而不是范围.
</code></pre>
<p>强调: 锁降级仅存在查询所有的唯一索引列.若唯一索引列由多个列组成,而查询仅是查询多个唯一索引列中的其中一个,那么查询其实是range类型查询,而不是point类型查询,故InnoDB引擎依然使用Next-Key Lock进行锁定.</p>
<p>在应用层面实现唯一性检查:</p>
<pre><code>(注:InnoDB引擎默认使用一致性非锁定读,)
在事务中使用:
 select * from table where col =xxx  where ... in share mode
此时如果数据不存在,Next-Key Lock也会锁住该范围.就可以实现唯一性检查.
在并发问题下,多个事务检查唯一性,插入,会导致死锁.此时只有一个事务能够成功,其他抛出死锁错误.
</code></pre>
<p>A  -&gt; 开启事务 -&gt; 唯一性检查(共享锁)  -&gt; 插入数据(阻塞)<br>   B - &gt; 开启事务 -&gt; 唯一性检查(共享锁) -&gt; 插入数据(引发死锁,错误)<br>只有一个能够执行成功</p>
<p>数据插入:</p>
<pre><code>数据插入时,会检查插入记录的下一个记录是否被锁.
</code></pre>
<p>​    </p>
</li>
</ul>
</li>
<li><p>页锁</p>
<ul>
<li>粒度介于行锁和表锁中间.折中.</li>
<li>开销/粒度介于行锁和表锁中间;会出现死锁;并发度一般</li>
</ul>
</li>
<li><p>表锁</p>
<ul>
<li>锁住整个表,其他事务访问该表必须等待锁释放</li>
<li>粒度大,加锁简单,容易冲突</li>
</ul>
</li>
</ul>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li><p>意向共享锁(IS:Intention Shared Lock)</p>
<p>事务想要获得一张表中某几行的共享锁.</p>
</li>
<li><p>意向拍他锁(IXIntention Exclusive Lock)</p>
<p>事务想要获得一张表中某几行的排他锁.</p>
<h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3></li>
<li><p>一致性非锁定读(consistent nonblocking read)</p>
<ol>
<li>概念:<br> 指InnoDB存储引擎通过行多版本控制(multi versioning)的方法来读取当前执行时间数据库中行的数据.如果读到的行正在执行DELETE或UPDATE操作,这是读取操作不会因此等待锁释放.相反的,InnoDB存储引擎回去读取行的一个快照.快照是通过undo段来完成的</li>
</ol>
<p>2.作用: </p>
<pre><code>极大的提高了数据库的并发性.是InnoDB引擎默认的读取方式.
</code></pre>
<p>3.读取快照的版本:</p>
<pre><code>根据隔离级别的 不同,读取快照的版本也不一样:
</code></pre>
<p>READ COMMITTED</p>
<pre><code>该级别下,总是读取最新的一份快照.意味着在事务执行中,有其他事务提交数据修改,可以读到.此时违反了ACID中的I,隔离性.
</code></pre>
<p>REAPEATABLE READ</p>
<pre><code>总是读取事务开始时的行数据.
</code></pre>
<p>多版本并发控制(MVCC):</p>
<pre><code>一个行记录可能有不止一个快照数据,一般称这种技术为行多版本技术.由此带来的控制为多版本并发控制(multi veriosn concurrency control)
</code></pre>
</li>
<li><p>一致性锁定读(手动加锁)</p>
<p>锁定读:<br>加X锁:  select … for update<br>加S锁:  select … lock in share mode</p>
</li>
<li><p>自增长与锁</p>
<p>可以使用参数,来控制自增长模式,<br>innodb_autoinc_lock_mode</p>
<pre><code>-0, 使用AUTO_INC Locking方式
-1, 对于确定行数的插入,采用互斥量对内存中的计数器进行累加操作.对于不确定行数的插入(bulk inserts),采用AUTO-INC Locking
-2,全部都采用互斥量,并发插入,性能最高.因为是并发插入,所以自增长的值不是连续,可控的.会导致statement-base replication出现问题,所以必须要使用Row-Base Replication.
</code></pre>
<ul>
<li><p>自增长实现方式</p>
<ul>
<li><p>AUTO-INC Locking</p>
<p>对于自增长字段,执行如下语句,获得计数器值<br>select max(auto_inc_col) from t for update;<br>为了提升性能,不是在事务提交过后才释放,而是该SQL执行完后立即释放.</p>
<p>缺点: 并发插入性能差;</p>
</li>
<li><p>轻量级互斥量实现</p>
<p>提供一种轻量级互斥量的自增长机制,提升了自增长值的插入性能.采用互斥量对内存中的计数器进行累加操作.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外键与锁</p>
<p>对于外键,innodb自动添加索引,为了避免死锁.</p>
<p>修改子表外键值:</p>
<pre><code>对于外键值的插入和更新,首先要查询父表中的记录,即select 父表,此时,不使用一致性非锁定读的方式,因为可能会发生数据不一致的问题.此时使用select ... lock in share mode方式,即主动给父表加S锁.
</code></pre>
<p>数据不一致情况:</p>
<pre><code>如果使用一致性非锁定读,在子表中插入,数据,父表删除记录,导致数据不一致.
</code></pre>
<p>使用S锁:</p>
<pre><code>此时所有对父表操作的事务,都会等待当前事务结束,从而保证数据一致性.
</code></pre>
<ul>
<li><p>为什么外键要添加索引?</p>
<ol>
<li>删除主表记录时或者主子表关联查询时,都会进行全表扫描.<br> 如果字表上有索引,则会使用行锁.没有索引会导致子表频繁锁.</li>
<li>容易导致死锁.<h3 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h3></li>
</ol>
</li>
</ul>
</li>
<li><p>脏读</p>
<p>脏数据:</p>
<pre><code>事务对缓冲池中的行记录的修改,并且还没有被提交(commit)
</code></pre>
<p>脏读:</p>
<pre><code>在不同事务下,当前事务可以读到其他事务未提交的事务,简单来说就是可以读到脏数据.
违反了数据库的隔离性
</code></pre>
</li>
<li><p>不可重复读</p>
<p>不可重复读:</p>
<pre><code>在事务中,读取到了其他事务提交的事务,比如对数据的修改.
</code></pre>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3></li>
</ul>
<p>阻塞:<br>    因为不同锁之间的不兼容性,有些时刻,一个事务中的锁要等待另一个事务中的锁释放占用的资源,这就是阻塞.</p>
<p>默认情况下,InnoDB引擎不会回滚超时引发的错误异常,所有事务执行部分会被提交.</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁:<br>    两个或两个以上的事务在执行过程中,因为争夺资源而造成的一种互相等待的现象.</p>
<ul>
<li><p>示例</p>
<ol>
<li>AB-BA<br> A等待B,B等待A</li>
</ol>
<p>2.当前事务持有了待插入记录的下一个记录的X锁,但是在等待队列中存在一个S锁,则可能会发生死锁.<br>假设数据:1,2,3,5 (主键)</p>
<pre><code>A -&gt;开启事务-&gt;获取3的X锁-&gt;|等待
B-&gt;开启事务-&gt;获取小于5的共享锁,已将获取1,2,5
</code></pre>
<p>若此时A想要插入数据4,则会报死锁.</p>
</li>
<li><p>解决办法</p>
<p>1.超时回滚:</p>
<pre><code>事务超时,回滚事务,让其他事务进行下去.
优点:    
    简单
缺点:    
    可能会让权重大的事务回滚,导致浪费.
</code></pre>
<p>2.等待图(wait-for graph):</p>
<pre><code>资源分配图,主动检测死锁
</code></pre>
<p>检测到死锁后(错误码1213),InnoDB会对抛出异常的事务进行回滚,因此检测到1213错误,不需要手动回滚.</p>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3></li>
</ul>
<p>锁升级:<br>    将当前锁的粒度降低.比如行锁-&gt;页锁-&gt;表锁.<br>    sql server中存在.<br>InnoDB引擎中不存在锁升级,因为不是根据每个记录来产生行锁的,而是根据每个事务访问的每个页进行锁管理的,采用的是位图的方式.因此,不管一个事务锁住页中的一个记录还是多个记录,其开销都是一致的.</p>
<h3 id="查看锁"><a href="#查看锁" class="headerlink" title="查看锁"></a>查看锁</h3><p>– 查看锁<br>select * from information_schema.INNODB_TRX it ;<br>select * from information_schema.INNODB_LOCKS il  ;<br>select * from information_schema.INNODB_LOCK_WAITS il  ;</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul>
<li><p>原子性（Atomicity）</p>
</li>
<li><p>一致性（Consistency）</p>
<ul>
<li><p>实现机制</p>
<p>每写一个事务,都会修改Buffer Pool,从而产生响应的Redo/Undo日志,这些日志信息会被记录到日志文件中.<br>在MySQL中,任何Buffer Pool中的页被刷到磁盘之前,都会先写入到日志文件中.<br>如果Buffer Pool中的数据提交(commit),在此数据库挂了,在数据库再次启动之后,可以通过Redo日志将其恢复出来,以保证脏页写的数据不会丢失.<br>如果数据没有提交(commit),此时数据库挂了,就需要Undo来实现.</p>
</li>
</ul>
</li>
<li><p>隔离性（Isolation）</p>
<p>事务之间不会互相影响.由锁和MVCC机制实现</p>
<ul>
<li><p>隔离级别问题</p>
<ul>
<li><p>脏读</p>
<p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。<br>违反隔离性</p>
</li>
<li><p>可重复读</p>
<p>可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的</p>
</li>
<li><p>不可重复读</p>
<p>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。<br>(针对数据修改 UPDATE)<br>违反一致性</p>
</li>
<li><p>幻读</p>
<p>幻读是针对数据插入（INSERT）操作来说的。<br>假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。<br>(在事务过程中,有新插入数据)</p>
</li>
</ul>
</li>
<li><p>隔离级别</p>
<ul>
<li><p>读未提交（READ UNCOMMITTED）</p>
</li>
<li><p>读提交 （READ COMMITTED）</p>
</li>
<li><p>可重复读 （REPEATABLE READ MySQL默认级别）</p>
</li>
<li><p>串行化 （SERIALIZABLE）</p>
<p>SERIALIZABLE与REPEATABLE READ两者开销几乎一样,甚至SERIALIZABLE可能更优. 一次InnoDB选择REPEATABLE READ不会有任何性能损失,同样,即使用户切换到READ COMMITTED也不会由性能的大幅提升.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>持久性（Durability）</p>
<p>事务执行后,必须写入磁盘</p>
<ul>
<li><p>实现机制</p>
<p>Redo log<br>WAL</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3></li>
</ul>
</li>
<li><p>扁平事务(flat transactions)</p>
<p>三种结果:</p>
<pre><code>1. 事务完成 (最多)
2. 错误回滚
4. 超时回滚
</code></pre>
</li>
<li><p>带有保存点的扁平事务(flat transactions with savepoints)</p>
<p>允许事务执行过程中回滚到同一事务中较早的状态.<br>保存点(savepoint):</p>
<pre><code>用来通知系统应该记住事务当前的状态.
</code></pre>
</li>
<li><p>链事务(chained transactions)</p>
<p>带有保存点事务的缺点: 保存点是易失的,系统崩溃时,所有保存点都会消失.</p>
<p>链式事务:</p>
<pre><code>可以视为带有保存点事务的变种.
</code></pre>
<p>链式事务思想: </p>
<pre><code>提交一个事务,释放不必要的数据对象.并将必要的上下文隐式地传递给下一个要开始的事务.
</code></pre>
<p>对比带有保存点的扁平事务的不同之处:<br>回滚时:</p>
<pre><code>带有保存点能够回滚到任意保存点. 
链式事务只能回滚当前事务,即只能恢复到最近一个保存点.
</code></pre>
<p>锁的处理</p>
<pre><code>带有保存点事务持有所有锁.
链式事务commit后,立即释放当前事务持有的锁.
</code></pre>
</li>
<li><p>分布式事务(distributed transactions)</p>
</li>
<li><p>嵌套事务(nested transactions)</p>
<p>定义</p>
<pre><code>嵌套事务    是一个层次结构框架.有一个顶层事务控制这各个层次事务.顶层事务之下嵌套的事务被称为子事务.
</code></pre>
<p>具体定义:</p>
<pre><code>1. 嵌套事务是由若干事务组成的一个棵树,子树既可以是嵌套事务,也可以是扁平事务.
2.处在叶子节点的是扁平事务.但是每个子事务从根到叶子节点的距离可以是不同的.
3.位于根节点的称作顶层事务,其他事务称为子事务.
4.子事务既可以提交也可以回滚.但是子事务操作并不立即生效,除非其父事务已经提交.(因此可以得出推论,任何子事务都在顶层事务提交后才真正提交.)
5.树中任一事务的回滚都会引起它的子事务一同回滚,故子事务只保留A,C,I特性,不具有D的特性.
(高层事务负责逻辑控制,叶子节点事务负责实际工作.)
</code></pre>
<p>可以使用带有保存点的事务模拟嵌套事务.</p>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3></li>
</ul>
<p>事务的原子性,一致性,持久性是通过数据库的redo log 和 undo log来实现的</p>
<p>对比 redo 和 undo<br>二者都是一种恢复操作: </p>
<p>redo恢复提交事务修改的页操作; 是物理日志,记录页的物理修改操作<br>undo回滚航记录到某个特定版本;记录逻辑日志,根据每行记录惊醒记录.</p>
<ul>
<li><p>redo(事务持久化)</p>
<ol>
<li>概念:<br> 重做日志(redo log)用来实现事务的持久性,即事务ACID中的D.由两部分组成: <ol>
<li>redo log buffer ,是易失的.</li>
<li>redo log file 持久的.</li>
</ol>
</li>
<li>持久化机制(Force Log at Commit)<br> 当事务提交时,必须现将改事务的所有redo log写入到redo log file进行持久化,等到事务commit才算完成.</li>
<li>读写方式<br> redo log 基本都是顺序写的,在数据库运行时,不需要对redo log 文件进行读取操作</li>
<li>redo log数据落盘<br> redo log buffer -&gt; 文件系统缓存 -&gt; 磁盘<br> 为了确保每次数据写入到磁盘,每次写入文件后,都要调用fsync操作.因此,磁盘性能决定了事务提交的性能.<br> 可以有参数控制</li>
</ol>
<ul>
<li><p>重做日志缓冲</p>
</li>
<li><p>重做日志文件</p>
</li>
<li><p>redo log 刷新磁盘策略</p>
<p>innodb_flush_log_at_trx_commit可用来控制重做日志刷新磁盘策略</p>
<pre><code>-0 , 提交事务不写入文件,由master完成.
-1,  每次提交都写redo log ,并且fsync
-2, 仅仅写入文件缓存,没有fsync
</code></pre>
</li>
</ul>
</li>
<li><p>LSN</p>
<p>日志序列号,8字节,单调递增.<br>含义:</p>
<pre><code>重做日志写入量; (记录总日志量)
checkpoint位置 ;
页的版本.
</code></pre>
<p>在页的头部中有LSN,可以用来判断页是否需要恢复操作.</p>
<p>在InnoDB Status中:</p>
<pre><code>Log sequence num 表示LSN
Log flushed up to 表示刷新到重做日志文件位置
Last Checkpoint at 表示刷新到磁盘的lsn
</code></pre>
</li>
<li><p>undo log (MVCC)</p>
<p>功能:</p>
<pre><code>帮助事务回滚及MVCC功能
</code></pre>
<p>位置:</p>
<pre><code>undo放在undo数据库中的undo segement中,这个段称为undo段,存在于共享表空间.
</code></pre>
<p>读写方式:</p>
<pre><code>随机读写
</code></pre>
<ul>
<li><p>事务回滚</p>
<p>为什么是逻辑日志:</p>
<pre><code>是逻辑日志,不是物理操作.因为在并发的环境下,页的结构会发生变化,不能将也恢复到事务开始的样子,否则会影响其他事务.所以保留的是逻辑日志.
</code></pre>
</li>
<li><p>存储管理</p>
<p>采用段的方式管理.InnoDB中有rollback segement,每个会断中记录了1023个undo log segement,在每个undo log segment段中进行undo页申请.</p>
<p>事务提交:</p>
<pre><code>1. 将undo log 放入列表中,用来后面的purge操作
2. 判断undo log页是否可以重用,如果可以的话,分配给其他事务.
</code></pre>
<p>事务提交之后不能够立即删除undo页,因为可能会有其他事务通过undo log来得到行记录之前的版本.所以undo log在事务提交的时候放入一个链表中,最终由purge线程处理.</p>
</li>
<li><p>格式</p>
<ul>
<li><p>insert undo log  针对insert</p>
<p>insert只对当前事务可见,所以事务提交之后,直接删除,不进行purge操作.</p>
</li>
<li><p>update undo log 针对update,delete</p>
<p>该undo log 可能需要提供MVCC机制,因此不能够提交事务时删除.提交时,放入undo log 链表.由purge线程最后删除.</p>
<p>可以分为更新,删除,添加三类.</p>
<p>delete:</p>
<pre><code>删除数据是,不直接删除记录,而是将记录标为已删除,将记录的delete flag设为1,最终删除是在purge完成的.
</code></pre>
<p>对主键的update:</p>
<pre><code>删除记录,重新插入.
</code></pre>
</li>
</ul>
</li>
<li><p>purge</p>
<p>purge用于最终完成delete和update,是因为要支持MVCC,所以记录不能再事务提交时立即删除.</p>
<ul>
<li><p>history list</p>
<p>一个页中可以存储多个事务的undo log.<br>history 列表根据事务提交的顺序,将undo log 进行链接.在执行purge的过程中.先从history list中找到第一个被清理的记录,清理过后,会在当前页中继续寻找是否存在可以被清理的记录. 如果没有,就继续到history list中寻找. 这种先从list中寻找undo log 然后再从page中寻找的模式,是为了避免大量的随机读取操作,从而提高purge效率.</p>
</li>
</ul>
</li>
<li><p>group commit</p>
<pre><code>为了提高磁盘fsync的效率,当前数据库都提供了group commit的功能,即一次fsync可以刷新确保多个事务日志被写入文件.减少磁盘压力,提升数据库性能,对于写入或者更新较为频繁的操作,group commit提升尤为明显.
</code></pre>
<ul>
<li><p>group commit失效</p>
<pre><code>在以前开启二进制日志,会导致group commit功能,为了保证存储引擎层中的事务和二进制日志的一致性,二者使用了两阶段事务.
1.当事务提交时,InnoDB存储引擎进行prepare操作.
2.MySQL数据库上层写入二进制日志.
3.InnoDB存储引擎将日志写入redo file.
</code></pre>
<p>其中步骤2,一旦完成,即使步骤3宕机,也能确保事务提交(redo file 完成,binlog完成). 为了保证保证MySQL数据库上层的二进制日志和InnoDB层提交事务一致. 如果不一致的话,会导致在线备份来重新恢复replication时,可能会发生事务丢失,因为通过binlog日志备份,此时binlog事务提交,而InnoDB层事务没有commit.  为保证顺序一直,使用了锁prepare_commit_mutex锁,导致group commit失效.</p>
</li>
<li><p>Binary Log Group Commit(BLGC)</p>
<p>BLGC事务提交过程:</p>
<pre><code>1.数据库上层进行提交时,先按照顺序将事务放到一个队列中,第一个称为leader,后面称为follower,leader控制follower.
</code></pre>
<p>BLGC分为一下3个步骤:</p>
<pre><code>1. Flush阶段, 将每个事务的二进制写入到内存中.
2. Sync阶段, 将内存中的二进制日志刷新到磁盘中,若队列中多个事务,那么仅一次fsync操作就完成二进制日志的写入,这就是BLGC
3.Commit阶段, leader根据顺序调用存储引擎层事务的提交,InnoDB存储引擎本就支持group commit.
</code></pre>
<p>当一组事务在进行Commit事务时,其他事务可以惊醒Flush阶段,从而使group commit不断生效.</p>
<h3 id="已经执行的语句不会因为后面的异常回滚"><a href="#已经执行的语句不会因为后面的异常回滚" class="headerlink" title="已经执行的语句不会因为后面的异常回滚"></a>已经执行的语句不会因为后面的异常回滚</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>InnoDB中的事务都是原子的,构成事务的每条语句都会提交或者每条语句都会回滚. 一条语句要么完全成功,要么完全回滚.<br>因此一条语句失败并抛出异常时,并不会导致先前已经执行的语句自动回滚.所有执行都会得到保留.  </p>
<p>比如开启事务后,插入两条主键重复的记录,后一条记录会抛出异常, 此时没有commit或者rollback,前一条记录也是成功的.<br>或者第二条记录,字段不符合要求,此时需要显示commit或者rollback.</p>
<h3 id="事务的不良习惯"><a href="#事务的不良习惯" class="headerlink" title="事务的不良习惯"></a>事务的不良习惯</h3><ul>
<li><p>在循环中提交事务</p>
<p>1.每一次提交都会进行一次写redo log<br>2.出现错误时,会导致事务停留在一个未知的位置.<br>因此不应该在一个循环中提交事务.</p>
</li>
<li><p>在存储引擎中进行异常处理</p>
<p>应该把异常交由应用处理</p>
</li>
<li><p>使用长事务</p>
<pre><code>长事务,指的是执行时间较长的事务.当发生异常时,事务的回滚和重新执行的代价很大. 
可以将长事务转化为小批量(mini batch)的事务来处理,发生错误时,也只需要回滚一部分事务.
</code></pre>
<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2></li>
</ul>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>备份方法</p>
<ul>
<li><p>Hot Backup(热备)</p>
<p>在运行中直接备份.也称为Online Backup 在线备份</p>
</li>
<li><p>Cold Backup(冷备)</p>
<p>在数据库停止的情况下备份.<br>备份frm文件,共享表空间文件,独立表空间(*.ibd),重做日志文件.</p>
<p>还要注意,使用脚本运行时,要检查磁盘空间.</p>
<p>优点:</p>
<pre><code>备份简单,恢复简单
恢复速度快,不需要执行SQL,重建索引
</code></pre>
<p>缺点:</p>
<pre><code>冷备文件大,比逻辑文件大很多,因为表空间中存放很多其他数据,比如undo 段,insert buffer.
跨平台不容易.
</code></pre>
</li>
<li><p>Warm Backup(温备)</p>
<p>在数据库运行的情况下备份,但是会对数据库操作有影响,比如加一个全局锁.</p>
</li>
</ul>
</li>
<li><p>备份后的文件内容</p>
<ul>
<li><p>逻辑备份</p>
<p>备份内容是文本内容,可读,是一条条SQL语句,或者表内实际数据组成. 比如mysqldump和select * into outfile.<br>数据恢复速度慢.</p>
<ul>
<li><p>mysqldump</p>
<p>shell中运行mysqldump</p>
<p>mysqldump [arguments] &gt; file_name</p>
<pre><code>-all-databases
-databases db1 db2...
--single-transaction 保证事务一致性. 备份前执行start transaction来获得一致性备份.同时要确保,没有其他执行DDL操作,因为一致性读不能隔离DDL操作.
--lock-tables(-l)  用于MyISAM,InnoDB可以使用.同时备份不同存储引擎表时,可以使用.
--add-drop-table: 在create table前先运行drop database.需要和--all-database 或者 -databases db1...一起使用.
--master-data [=value] ,用于建立replication
    -1, 转存文件中的change master语句
    -2, change master语句会写出SQL注释.
--where ,导出指定条件的数据.
</code></pre>
<ul>
<li><p>导入</p>
<p>mysql -uroot -p &lt;test_backup.sql;</p>
<p>导入前可以关闭外键,导入完成后再建立外键.</p>
</li>
</ul>
</li>
<li><p>select … into outfile </p>
<p>select … into outfile from tablexx where</p>
</li>
</ul>
</li>
<li><p>裸文件备份</p>
<p>辅助数据库的物理文件,可以在运行时或者停止时复制.恢复速度快.</p>
</li>
</ul>
</li>
<li><p>备份内容</p>
<ul>
<li><p>完全备份</p>
<p>进行完整备份</p>
</li>
<li><p>增量备份</p>
<p>只备份更改的部分</p>
</li>
<li><p>日志备份</p>
<p>对数据二级制日志binlog进行备份,通过对完全备份进行重做(replay)来完成数据库的point-int-time恢复工作. MySQL的数据库复制(replication)原理就是异步实时地将二进制日志重做传送并应用到slave数据库.</p>
<h3 id="备份一致性"><a href="#备份一致性" class="headerlink" title="备份一致性"></a>备份一致性</h3></li>
</ul>
</li>
</ul>
<p>备份过后要保证事务一致性. 不能出现事务进行一半.因为支持MVCC,所以只需要开启一个事务,然后备份就可以了.</p>
<p>使用mysqldump,要添加–single-transaction选项,来获得InnoDB存储引擎一致性备份.原理与上面一样.</p>
<h3 id="快照备份"><a href="#快照备份" class="headerlink" title="快照备份"></a>快照备份</h3><p>使用支持快照的文件系统支持的快照功能对数据库进行备份.将所有数据库文件放在同一个文件分区,然后对该分区进行快照操作.</p>
<p>LVM的写时复制(copy-on-write),创建快照时,只复制原始卷中的元数据(meta data),并不会有数据的物理操作.因此创建快照很快.当原始卷上有写操作时,快照会跟踪原始卷块的改变,在改变数据之前,将数据复制到快照的预留空间里.  如果读取未修改的块,则直接读取原始卷,如果已经修改,则读取快照内容.因此,copy-on-write保证了读取快照得到与快照建时的一致性.</p>
<h3 id="复制-replication"><a href="#复制-replication" class="headerlink" title="复制(replication)"></a>复制(replication)</h3><ul>
<li><p>replication工作原理</p>
<p>replication是MySQL提供的高可用的方案.分为三个阶段:</p>
<pre><code>1. master将数据更改记录到binlog中.
2.slave把master的binlog复制到自己的中继日志(relay log)中    
3.slave重做中继日志中的日志,把更改应用到自己的数据库上,以达到数据的最终一致性.
</code></pre>
<p>复制并不是实时的,而是异步实时的,中间存在着主从服务器之间的执行延迟,如果主服务器压力大,会导致延迟很大.可以通过命令show slave status和show master status获得延迟.</p>
</li>
<li><p>快照+复制的备份架构</p>
<p>主从复制,对从使用快照备份.<br>高可用,负载均衡.</p>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2></li>
</ul>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul>
<li><p>缓存</p>
</li>
<li><p>命中率</p>
<p>缓冲池命中率不应该低于99%</p>
<ol>
<li>可以直接查看 show engine status 中关于缓冲池的命中率.</li>
<li>手动计算:<br> show global status like ‘innodb%read%’</li>
</ol>
<p>Innodb_buffer_pool_read_ahead 预读到页次数<br>Innodb_buffer_pool_read_requests 缓冲池中读到页次数<br>Innodb_buffer_pool_reads 磁盘读到页次数<br>命中率 = Innodb_buffer_pool_read_requests /(三者的和)</p>
<h3 id="磁盘-使用SSD"><a href="#磁盘-使用SSD" class="headerlink" title="磁盘:使用SSD"></a>磁盘:使用SSD</h3></li>
<li><p>合理RAID</p>
</li>
</ul>
<h3 id="使用测试工具"><a href="#使用测试工具" class="headerlink" title="使用测试工具"></a>使用测试工具</h3><ul>
<li>sysbench</li>
<li>mysql-tpcc</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>InnoDB存储引擎</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>InnoDB存储引擎</tag>
      </tags>
  </entry>
</search>
