<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Maven</title>
    <url>/posts/38008.html</url>
    <content><![CDATA[<h4 id="Maven入门"><a href="#Maven入门" class="headerlink" title="Maven入门"></a>Maven入门</h4><p>maven是Java平台上的自动化构建工具</p>
<ul>
<li>关于构建的各个环节<ol>
<li>清理：将之前编译得到的旧的class字节码文件删除，为下一次编译做准备。</li>
<li>编译：将Java源代码编译成class字节码。</li>
<li>测试：自动测试，自动调用junit程序。</li>
<li>报告：测试程序执行的结果。</li>
<li>打包：动态Web工程打war包，Java工程打jar包。</li>
<li>安装：Maven特定的概念——将打包得到文件复制到“仓库”中指定的位置。</li>
<li>部署：将动态Web工程生成的war包复制到Servlet容器的指定目录下，使其可以运行。</li>
</ol>
</li>
</ul>
<ol>
<li>创建约定的目录结构<ol>
<li>根目录：工程名</li>
<li>src目录：源码</li>
<li>pom.xml文件：Maven核心配置文件</li>
<li>main目录：存放程序</li>
<li>test目录：存放测试程序</li>
<li>java目录：存放java源文件</li>
<li>resources目录：存放框架或者其他工具的配置文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-app</span><br><span class="line">|-- pom.xml</span><br><span class="line">`-- src</span><br><span class="line">    |-- main</span><br><span class="line">    |   |-- java</span><br><span class="line">    |   |   `-- com</span><br><span class="line">    |   |       `-- mycompany</span><br><span class="line">    |   |           `-- app</span><br><span class="line">    |   |               `-- App.java</span><br><span class="line">    |   `-- resources</span><br><span class="line">    |       `-- META-INF</span><br><span class="line">    |           `-- application.properties</span><br><span class="line">    `-- test</span><br><span class="line">        `-- java</span><br><span class="line">            `-- com</span><br><span class="line">                `-- mycompany</span><br><span class="line">                    `-- app</span><br><span class="line">                        `-- AppTest.java</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>为什么要遵守约定的目录结构？<ol>
<li>Maven负责这个项目的自动化构建，以编译为例，Maven要想自动编译，那么它必须知道Java源文件保存在哪里。</li>
<li>如果自己定义的东西想要让框架或者工具知道，有两种办法：<ol>
<li>以配置的方式明确告诉框架。</li>
<li>遵循框架内部已经存在的约定。<br>比如log4j.xml</li>
<li>约定&gt;配置&gt;编码。</li>
</ol>
</li>
</ol>
</li>
<li>常用Maven命令<ol>
<li>注意：执行与构建过程相关的Maven命令，必须进入pom.xml所在的目录。<br>与构建过程相关的操作：编译、测试、打包。。。</li>
<li>常用命令<ol>
<li>mvn clean：清理。</li>
<li>mvn compile ：编译主程序。</li>
<li>mvn test-compile：编译测试程序。</li>
<li>mvn test：执行测试。</li>
<li>mvn package：打包。</li>
</ol>
</li>
<li>关于联网问题<ol>
<li>Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含在Maven的核心程序中。</li>
<li>当执行Maven命令需要用到某些插件是，Maven核心程序会首先到本地仓库中查找。</li>
<li>Maven核心程序如果在本地仓库中找不到需要的插件，那么会自动连接外网，到中央仓库中下载。</li>
</ol>
</li>
</ol>
</li>
<li>POM<ol>
<li>含义（Project Object Model）项目对象模型。类似于DOM Docment Object Model文档对象模型。</li>
<li>pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置。</li>
<li>坐标<ol>
<li>数学中的坐标<ol>
<li>平面上，使用X、Y两个向量可以唯一确定平面中的任何一个点。</li>
<li>在空间中，使用X、Y、Z三个向量可以唯一定位空间中的任何一个点。</li>
</ol>
</li>
<li>Maven的坐标<br>使用下面三个向量可以在仓库中唯一定位一个Maven工程<ol>
<li>groupId：公司或者组织域名倒序+项目名<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupid</span>&gt;</span>com.proton.projectname<span class="tag">&lt;/<span class="name">groupid</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>artifactId：模块名<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>modulename<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>version：版本<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>Maven工程的坐标与仓库中路径的对应关系<ol>
<li>坐标<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>路径<br>命名规则：参照坐标<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">\repository\org\mybatis\mybatis\3.5.7\mybatis-3.5.7.jar</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>仓库：<ol>
<li>分类：<ol>
<li>本地仓库：当前电脑上部署的仓库目录，为当前电脑上所有Maven工程服务。</li>
<li>远程仓库：<ol>
<li>私服：搭建在局域网中，为局域网范围内的所有Maven工程服务。</li>
<li>中央仓库：架设在Internet上，为世界所有Maven工程服务。</li>
<li>中央仓库镜像：为了分担中央仓库的流量，提升用户访问速度。</li>
</ol>
</li>
</ol>
</li>
<li>仓库中保存的内容：Maven工程<ol>
<li>Mavne自身所需要的插件</li>
<li>第三方框架或者工具的jar包</li>
<li>自己开发的Maven工程。</li>
</ol>
</li>
</ol>
</li>
<li>依赖(dependency)<ol>
<li>Maven解析依赖信息时会到本地仓库中查找被依赖的jar包<br>对于我们自己开发的maven工程，使用 mvn install命令安装后就可以进入仓库。</li>
<li>依赖的范围<ol>
<li>compile<br>compile描述的是jar包在编译阶段是否可用，是否参与到编译中。主程序可以使用范围为compile的依赖。测试程序也可以使用，并且会被打包到最终的包中。<ol>
<li>对主程序是否有效：有效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：参与</li>
<li>典型例子：spring-core</li>
</ol>
</li>
<li>test<br>依赖范围为test依赖，对主程序而不可用，主要用于在测试环境中提供给测试程序测试支持。也不会参与到最终的打包。<ol>
<li>对主程序是否有效：无效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：不参与</li>
<li>典型例子：junit</li>
<li><img src="/.%5CMaven.assets%5Cscope-compile-test.png" alt="image-20210522120546311"></li>
</ol>
</li>
<li>provided<br>描述的是开发阶段。在开发阶段，需要使用一些运行环境的jar包，如果缺少这部分jar包，则开发时编译器报错，而这部分jar包不需要在打包在程序中，在运行环境中会提供，比如tomcat的servlet-api.jar。provided属性标记的jar包，会在开发阶段提供给调用，在部署阶段会被忽略，在运行时，由运行环境中提供。<ol>
<li>对主程序是否有效：有效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：不参与</li>
<li>是否参与部署：不参与</li>
<li>典型例子：servlet-api.jar<br><img src="/.%5CMaven.assets%5Cprovided.png" alt="image-20210522120048328"></li>
</ol>
</li>
</ol>
</li>
<li>依赖的传递性。在pom直接添加的dependency是直接依赖。如果添加的dependency还有其他依赖，则其他依赖被称作传递过来的依赖。<ol>
<li>依赖传递性的好处：可以传递的依赖不必再每个模块工程中都重复声明，只要在最底层的依赖中即可。</li>
<li>注意事项：依赖传递性仅限于compile范围，非compile范围的依赖不能传递。所以在各个模块工程中，针对test或者provided依赖范围，如果需要就得重复声明依赖。</li>
</ol>
</li>
<li>排除依赖：<br>当前工程有个直接依赖A，但是A也有个依赖B，此时如果不希望将B引入到当前工程中，可以对直接依赖的子依赖进行排除。<ol>
<li>依赖排除的场合：<br>当依赖中A存在着不稳定的依赖B，比如spring-core（A）中引入了一个不稳定的依赖common-log（B）。且不希望将不稳定的依赖（B）加入当前项目，则可以将不稳定的部分排除。</li>
<li>配置方式<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.ykproton<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			排除依赖，</span></span><br><span class="line"><span class="comment">			排除过后，被排除的依赖传递性停止，不会继续向上传递</span></span><br><span class="line"><span class="comment"> 		--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>依赖冲突时选择原则<br>​    用于解决多个依赖，同时依赖的jar包的冲突。<ol>
<li><p>路径最短者优先原则。<br>如果A依赖B，B依赖C。C使用D的v1版本，B使用D的v2版本。根据路径最短，D-v1距离A最近。此时真正会使用的是D的v1版本。<br><img src="/.%5CMaven.assets%5Cimage-20210522141414168.png" alt="image-20210522120546311"></p>
</li>
<li><p>路径相同时，先声明者优先。先后顺序指的是dependency标签的顺序。<br><img src="/.%5CMaven.assets%5Cimage-20210522141527255.png" alt="image-20210522120546311"></p>
</li>
</ol>
</li>
<li>统一管理依赖版本<br>工程有很多依赖，如果升级依赖，手动修改每一个依赖的版本，容易出现错误，比如漏改错改。<br>可以使用properties标签内，使用自定义标签统一声明版本号。在使用同一版本的位置，引用自定义标签。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- properties标签可以配置多种属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- myApp.spring.version 为自定义标签 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">myApp.spring.version</span>&gt;</span></span><br><span class="line">    4.2.2.RELEASE</span><br><span class="line">  <span class="tag">&lt;/<span class="name">myApp.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引用自定义标签，$&#123;标签名&#125; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;helloCaller.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>生命周期<ol>
<li>各个构建环节执行的顺序：不能打乱顺序，必须按照既定的正确顺序执行。</li>
<li>Maven的核心应用程序定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。</li>
<li>Maven核心程序为了更好实现自动化构建，按照这一特点执行生命周期中的各个阶段：无论现在要执行生命周期的哪一个阶段，都是从这个生命周期最初的位置开始执行。</li>
<li>插件和目标：<ol>
<li>生命周期各个阶段仅仅定义了要执行什么任务。</li>
<li>各个阶段和插件的目标是对应的。</li>
<li>相似的目标由特定的插件来完成。<table>
<thead>
<tr>
<th>生命周期阶段</th>
<th>插件目标</th>
<th>插件</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>compile</td>
<td>maven-compiler-plugin</td>
</tr>
<tr>
<td>test-compile</td>
<td>testCompile</td>
<td>maven-compiler-plugin</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
</li>
<li>继承<br>　多个子项目都需要某些依赖, 就可以把子项目共同的依赖抽取到父项目中, 子项目通过继承得到这些依赖, 这样也更好的来管理(比如升级, 删除等)。也能解决因为范围为test、provided的依赖不能传递，导致的环境不一致的问题。<br>步骤：<ol>
<li>父项目打包方式修改为pom。<br>可以在父工程中，统一管理项目版本号。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.ykproton<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 此处为pom --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     		......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在子工程中声明对父工程的引用<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.ykproton<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>聚合<br>Java项目，往往是多个模块组成，聚合就是将多个模块整合在一起构建。快速构建<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>mail<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>account<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>聚合的两种结构<ol>
<li>父子结构<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">|-- my-module1</span><br><span class="line">|   `-- pom.xml</span><br><span class="line">|-- my-module2</span><br><span class="line">|   `-- pom.xml</span><br><span class="line">`-- pom.xml</span><br></pre></td></tr></table></figure>
直接指定子项目名即可。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-module1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-module2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>同级结构<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">|-- my-module1</span><br><span class="line">|   `-- pom.xml</span><br><span class="line">|-- my-module2</span><br><span class="line"> |   `-- pom.xml</span><br><span class="line"> `-- parent</span><br><span class="line">     `-- pom.xml</span><br></pre></td></tr></table></figure>
通过相对路径，进行聚合。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../my-module1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../my-module2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇, 第一个Spring Boot工程</title>
    <url>/posts/24668.html</url>
    <content><![CDATA[<h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><h4 id="开发第一个SpringBoot工程"><a href="#开发第一个SpringBoot工程" class="headerlink" title="开发第一个SpringBoot工程"></a>开发第一个SpringBoot工程</h4><ol>
<li><h5 id="创建maven工程，添加依赖"><a href="#创建maven工程，添加依赖" class="headerlink" title="创建maven工程，添加依赖"></a>创建maven工程，添加依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="添加classpath依赖"><a href="#添加classpath依赖" class="headerlink" title="添加classpath依赖"></a>添加classpath依赖</h5>Spring Boot提供了很多的Starter，可以把需要的jar添加到classpath中。<code>spring-boot-starter-parent  </code>是一个特殊的starter，它提供了很多有用的默认配置。但是它不会添加任何依赖。<br>当需要开发指定类型的程序，可以使用其他的starters。因为要开发的是一个web应用，所以需要添加一个<code>spring-boot-starter-web  </code>依赖。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h5>maven的源代码路径在<code>src/main/java</code>,创建如下java文件<code>src/main/java/MyApplication.java</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><h6 id="RestController与-RequestMapping注解"><a href="#RestController与-RequestMapping注解" class="headerlink" title="@RestController与@RequestMapping注解"></a><code>@RestController</code>与<code>@RequestMapping</code>注解</h6>​    <code>@RestController</code>是一种模式注解（stereotype annotation，主要用于表明当前组件在整个项目中的作用，比如@Service、@Repository、@Controllr）。它的作用是让spring和阅读代码的人知道当前class所扮演的角色。<br>​    <code>@RequestMapping</code>注解提供路由信息。它告诉spring，任何的对/的HTTP请求，都会被映射到home方法上。<code>@RestController</code>让spring直接将字符串结果返回给调用者。</li>
<li><h6 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title=" @EnableAutoConfiguration注解"></a><code> @EnableAutoConfiguration</code>注解</h6>​    <code> @EnableAutoConfiguration</code>使用用来让springboot去推测如何配置Spring，主要基于所添加的jar依赖。因为<code>spring-boot-starter-web</code>添加了Tomcat和Spring MVC，自动配置假设当前正在开发一个web应用并作相应的设置。<blockquote>
<p>Starters和自动配置（Auto-configuration）</p>
<p>​    自动配置和“Starters”可以很好的配合，但是这个两个概念并没有直接的关联。可以在sterer之外自由选择jar依赖，Spring Boot会尽可能地自动配置整个应用。</p>
</blockquote>
</li>
<li><h6 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h6>main方法是一个标准的复合Java规范的方法，是整个应用程序的入口。通过调用<code>run</code>方法，main方法完成了对Spring Boot的<code>SpringApplication</code>的代理。<code>SpringApplication</code>启动应用程序，启动Spring，同时自动配置Tomcat服务器。我们需要将<code>MyApplication.class</code>作为参数传递给<code>run</code>方法，从而让<code>SpringApplication</code>知道那个是Spring的基本组件。<code>args</code>数组同时也将命令行参数传递。</li>
<li>可以直接运行项目，并且访问8080端口即可看到输出。</li>
</ol>
</li>
<li><h5 id="创建一个可执行的Jar"><a href="#创建一个可执行的Jar" class="headerlink" title="创建一个可执行的Jar"></a>创建一个可执行的Jar</h5>​    通过创建一个可执行的独立的Jar文件，完成了实例。可执行Jar（有时也被称作“fat jars” 胖jar），是一个包含编译后的class文件和运行时依赖的jar的文档。<blockquote>
<p>可执行Jar和Java</p>
<p>​    Java并没有提供一种标准的方法,去载入嵌套的jar文件(jar文件被包含在一个jar文件内部).如果想要分发一个自包含的应用,可能会有问题.</p>
<p>​    去解决这个问题,许多开发者使用uber jar.一个uber jar把应用所需要的依赖的class文件打包进一个文档.这种方式的问题在于,去看当前应用程序中有哪些库变得很困难.同样,如果存在文件同名的情况,也会导致问题.</p>
</blockquote>
​    去创建一个可执行的jar,需要将<code>spring-boot-maven-plugin</code>添加到<code>pom.xml</code>中.需要再<code>dependency</code>后面添加如下部分.<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

​    调用mvn package命令 ,对程序进行打包.然后在<code>target</code>目录中,可以看到制作完成的jar包<code>myproject-0.0.1-SNAPSHOT.jar</code>.文件应该在10M左右.​    同时也可以看到一个小的多的文件,<code>myproject-0.0.1-SNAPSHOT.jar.original</code>.这个是maven打包的初始的jar,Spring Boot对这个进行再打包.​    运行程序,可以使用<code>java -jar</code>命令来运行打包后的应用.使用<code>ctrl -c</code>结束整个应用.</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>第七篇,Spring Boot之国际化</title>
    <url>/posts/52941.html</url>
    <content><![CDATA[<h5 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h5><p>   Spring Boot支持本地化消息,因此您的应用程序可以迎合不同语言的用户.默认情况下,Spring Boot在类路径的根目录下查找<code>messages</code>资源包的存在.</p>
<blockquote>
<p>注意:</p>
<p>​    当配置的资源束(resource bundle)的默认配置文件可用时,将会自动配置(即默认情况下,<code>messages.properties</code>).如果您的资源包仅包含指定语言的配置文件,则需要添加默认文件. 如果找不到与任何配置的base名匹配的配置文件, 将不会自动配置<code>MessageSource</code>.<br>   可以使用<code>spring.messages</code>命名空间配置资源包的basename以及其他几个属性,如以下示例所示:<br>   <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.messages.basename</span>=<span class="string">messages,config.i18n.messages</span></span><br><span class="line"><span class="meta">spring.messages.fallback-to-system-locale</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><br>建议:</p>
<p>​    <code>spring.messages.basename</code>支持以逗号分隔的locations,可以是包限定符,也可以是从类路径根目录解析的资源.</p>
</blockquote>
<p>   有关更多受支持的选项,请参见<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceProperties.java"><code>MessageSourceProperties</code></a>.</p>
]]></content>
  </entry>
  <entry>
    <title>第八篇,Spring Boot之JSON</title>
    <url>/posts/23342.html</url>
    <content><![CDATA[<h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><p>   Spring Boot提供了三个JSON映射库的集成:</p>
<ul>
<li>Gson</li>
<li>Jackson</li>
<li>JSON-B<br>Jackson是首选的,也是默认库.</li>
</ul>
<ol>
<li><h6 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h6>Spring Boot提供了Jackson的自动配置,并且Jackson是<code>spring-boot-starter-json</code>的一部分. 当Jackson在类路径中,将会自动配置<code>ObjectMapper</code>Bean. 有几个配置属性,用来自定义<code>ObjectMapper</code>的配置.</li>
<li><h6 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h6>针对Gson,Spring Boot自动配置. 当在classpath中有Gson在类中,会自动配置一个<code>Gson</code>bean.有几个<code>spring.gson.*</code>属性配置可以用来自定义配置.为了可以更多的配置,可以使用一个或者多个<code>GsonBuilderCustomizer</code>.</li>
<li><h6 id="JSON-B"><a href="#JSON-B" class="headerlink" title="JSON-B"></a>JSON-B</h6>针对<code>JSON-B</code>自动配置.当在类路径存在JSON-B API其实现类, 将自动配置<code>Jsonb</code>bean. 首选JSON-B的实现是Apache Johnzon, 这个依赖管理已经提供.</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>第五篇,Spring Boot之Profiles</title>
    <url>/posts/25620.html</url>
    <content><![CDATA[<h5 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h5><p>   Spring Profile提供了一种方法,可以将配置文件分离开来,并且只有在特定的环境中可用.<br>   所有的<code>@Component</code>,<code>@Configuration</code>或者<code>@ConfigurationProperties</code>可以使用<code>@Profile</code>来有条件地加载.如下所示:<br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意:</p>
<p>​    如果是通过<code>@ConfigurationProperties</code>和<code>@EnableConfigurationProperties</code>方式注册的bean,而不是自动扫描,<code>@Profile</code>注解应该被标注在使用<code>@EnableConfigurationProperties</code>的配置类上<code>Configuration</code>类上.在这个例子中,<code>@ConfigurationProperties</code>被扫描,<code>@Profile</code>可以被标注 在配置类上.<br>   也可以使用<code>spring.profiles.active</code>的<code>Environment</code>属性,来指定启动哪一个 profile.可以像前面一样的章节中的那样设置这个属性.比如,可以在<code>application.properties</code>,如下所示:<br>   <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev,hsqldb</span></span><br></pre></td></tr></table></figure><br>   也可以在命令行中,使用下面的命令来切换:<br>   <code>--spring.profiles.active=dev,hsqldb</code></p>
</blockquote>
<ol>
<li><h6 id="添加活动配置文件-Adding-Active-Profiles"><a href="#添加活动配置文件-Adding-Active-Profiles" class="headerlink" title="添加活动配置文件(Adding Active Profiles)"></a>添加活动配置文件(Adding Active Profiles)</h6><code>spring.profiles.active</code>和其他的属性遵循一样的顺序规则:最高的<code>PropertySource</code>最终有效.这意味着可以在<code>application.properties</code>中激活profile,然后在命令行中切换profile.<br>有时候,有一个可以增加profile的属性,而不是替换profile的属性,会很有用.<code>SpringApplication</code>入口有一个Java API来设置其他的profile(也就是说,除了那些由spring.profiles.active属性激活的属性之外).可以参照<code>SpringApplication</code>的<code>setAdditionalProfiles()</code>方法.下一章节中会描述,如果给定的profile被激活,profile组可以用来添加并激活profile.</li>
<li><h6 id="profile组-Profile-Groups"><a href="#profile组-Profile-Groups" class="headerlink" title="profile组(Profile Groups)"></a>profile组(Profile Groups)</h6>有时,您在应用程序中定义和使用的配置文件的粒度太细,使用起来很麻烦.比如,可以能需要<code>proddb</code>和<code>prodmq</code>profile来实现各自独立的启用数据库和消息中间件的功能.<br>为了解决这个问题,Spring Boot允许定义profile组.profile组能够允许给一组相关联的profile定义一个逻辑名.<br>比如,可以使用<code>production</code>组,组有<code>proddb</code>和<code>prodmq</code>组成.<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.profiles.group.production[0]</span>=<span class="string">proddb</span></span><br><span class="line"><span class="meta">spring.profiles.group.production[1]</span>=<span class="string">prodmq</span></span><br></pre></td></tr></table></figure>
现在可以使用<code>--spring.profiles.active = production</code>来启动应用程序,以一键激活<code>proddb</code>,<code>proddb</code>和<code>prodmq</code>配置文件.</li>
<li><h6 id="使用编程的方式设置profile-Programmatically-Setting-Profiles"><a href="#使用编程的方式设置profile-Programmatically-Setting-Profiles" class="headerlink" title="使用编程的方式设置profile(Programmatically Setting Profiles)"></a>使用编程的方式设置profile(Programmatically Setting Profiles)</h6>可以在应用启动前,调用<code>SpringApplication.setAdditionalProfiles(…)</code>方法来激活profile.可以实现<code>ConfigurableEnvironment</code>接口来实现指定profile.</li>
<li><h6 id="用于指定profile的配置文件-Profile-specific-Configuration-Files"><a href="#用于指定profile的配置文件-Profile-specific-Configuration-Files" class="headerlink" title="用于指定profile的配置文件(Profile-specific Configuration Files)"></a>用于指定profile的配置文件(Profile-specific Configuration Files)</h6><code>application.properties</code>(或者<code>application.yml</code>)和被<code>@ConfigurationProperties</code>引用的文件的变体都会被作为文件加载.</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>第三篇,Spring Boot之SpringApplication</title>
    <url>/posts/1049.html</url>
    <content><![CDATA[<h4 id="3-Spring-Boot-功能"><a href="#3-Spring-Boot-功能" class="headerlink" title="3. Spring Boot 功能"></a>3. Spring Boot 功能</h4><p>​    这个章节将深入讨论Spring Boot的细节. 在这里可以学习使用,定制一些核心的功能. 如果还没有使用过,则可以阅读前面的内容,来获得基础知识.</p>
<ol>
<li><h5 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h5>​    <code>SpringApplication</code>类提供了一种非常方便的方式去启动Spring应用, 那就是从<code>main()</code>方法启动. 在很多情况下, 可以委派给静态方法<code>SpringApplication.run</code>.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当应用启动时,可以看到输出类似下面的内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::   v2.5.0</span><br><span class="line"></span><br><span class="line">2021-02-03 10:33:25.224  INFO 17321 --- [           main] o.s.b.d.s.s.SpringAppplicationExample    : Starting SpringAppplicationExample using Java 1.8.0_232 on mycomputer with PID 17321 (/apps/myjar.jar started by pwebb)</span><br><span class="line">2021-02-03 10:33:25.226  INFO 17900 --- [           main] o.s.b.d.s.s.SpringAppplicationExample    : No active profile set, falling back to default profiles: default</span><br><span class="line">2021-02-03 10:33:26.046  INFO 17321 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br><span class="line">2021-02-03 10:33:26.054  INFO 17900 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2021-02-03 10:33:26.055  INFO 17900 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.41]</span><br><span class="line">2021-02-03 10:33:26.097  INFO 17900 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2021-02-03 10:33:26.097  INFO 17900 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 821 ms</span><br><span class="line">2021-02-03 10:33:26.144  INFO 17900 --- [           main] s.tomcat.SampleTomcatApplication         : ServletContext initialized</span><br><span class="line">2021-02-03 10:33:26.376  INFO 17900 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#x27;&#x27;</span><br><span class="line">2021-02-03 10:33:26.384  INFO 17900 --- [           main] o.s.b.d.s.s.SpringAppplicationExample    : Started SampleTomcatApplication in 1.514 seconds (JVM running for 1.823)</span><br></pre></td></tr></table></figure>
默认情况下,显示的是<code>INFO</code>的日志,包括一些相关的启动细节,比如启动应用的用户. 如果需要的日志等级不是<code>INFO</code>,可以自己设置. 使用主应用程序类包中的实现版本来确定应用程序版本. 启动信息日志可以使用<code>spring.main.log-startup-info</code>设为<code>false</code>来关闭.这也会关闭应用激活的那个profile的日志信息.<blockquote>
<p>建议:</p>
<p>​    在启动过程中,增加额外的日志, 可以重写<code>SpringApplication</code>的子类中的<code>logStartupInfo(boolean)</code>方法实现.</p>
</blockquote>
<ol>
<li><h6 id="启动失败"><a href="#启动失败" class="headerlink" title="启动失败"></a>启动失败</h6>​    如果应用启动失败, 已经注册的<code>FailureAnalyzers</code>会提供专门的错误消息和具体措施来解决问题. 比如,  当在已经被占用的8080端口上启动应用, 如下的类似的信息将会被输出.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Embedded servlet container failed to start. Port 8080 was already in use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that&#x27;s listening on port 8080 or configure this application to listen on another port.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    Spring Boot提供了很多<code>FailureAnalyzer</code>的实现类, 也可以自己添加自定的类.<br>​    如果没有<code> failure analyzer</code>能够处理异常, 你也可以选择完整的情况报告去帮助更好地理解错误. 为此, 需要开启<code>debug</code>属性,或者开启针对<code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code>的<code>debug</code>日志.<br>​    比如, 想要使用<code>java -jar</code>运行应用, 可以像下面一样开启<code>debug</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myproject-0.0.1-SNAPSHOT.jar --debug</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h6>​    <code>SpringApplication</code>允许应用延迟初始化. 当延迟初始化开启时, bean会在被需要的时候创建,而不是在启动过程中初始化. 开启延迟加载可以减少应用启动时间.在web应用程序中, 开启延迟初始化,导致很多网络相关的bean不会初始化,直到接收网络请求.<br>​    延迟初始化的一个缺点是,可能会推迟发现应用问题的时间点. 如果一个配置出错的bean被延迟初始化,那么在启动过程中不会发生问题,直到这个bean被初始化时才会暴露问题. 同时也要注意, 确保JVM有足够的内存来容纳所有的bean, 而不是只能容乃在启动阶段初始化的bean. 出于这些原因, 延迟初始化没有被默认开启, 并且建议在开启延迟加载前,对JVM的堆内存进行调整.<br>​        延迟初始化可以已编程的方式开启, 使用<code>SpringApplicationBuilder</code>的<code>lazyInitialization</code>方法来开启,或者<code>SpringApplication</code>的<code>setLazyInitialization</code>方法.或者,也可以使用<code>spring.main.lazy-initialization</code>属性来开启.如下所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.main.lazy-initialization</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    如果想要对特定的bean关闭延迟初始化,同时对于程序的剩余部分使用延迟初始化,可以显式地使用注解设置延迟初始化属性.<code>@Lazy(false)</code>.</p>
</blockquote>
</li>
<li><h6 id="自定义Banner"><a href="#自定义Banner" class="headerlink" title="自定义Banner"></a>自定义Banner</h6>​    启动时打印的标志,就是banner.可以增加<code>banner.txt</code>到classpath中,或者设置<code>spring.banner.location</code>属性指向文件,从而改变banner. 如果banner文件中有用不是UTF-8的属性, 可以设置<code>spring.banner.charset</code> 来配置编码. 除了text文件,Spring Boot也支持图片,比如<code>banner.gif</code>,<code>banner.jpg</code>,或者<code>banner.png</code>.可以将图片放到classpath中,或者配置<code>spring.banner.image.location</code>来指定文件. 图片会被转换成ASCII art然后打印所有文本banner上面.<br>在<code>banner.txt</code>文件中,可以使用下面的占位符:<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>${application.version}</td>
<td>应用的版本号,在<code>MANIFEST.MF</code>文件中声明的.<code>Implementation-Version: 1.0</code>会被输出成<code>1.0</code></td>
</tr>
<tr>
<td>${application.formatted-version}</td>
<td>应用程序的版本号格式化后输出,如<code>1.0</code>会格式化成<code>(v1.0)</code></td>
</tr>
<tr>
<td>${spring-boot.version}</td>
<td>使用的Spring Boot版本号.如:<code>2.5.0</code></td>
</tr>
<tr>
<td>${spring-boot.formatted-version}</td>
<td>格式化后的Spring Boot版本号<code>(v2.5.0)</code></td>
</tr>
<tr>
<td><code>$&#123;Ansi.NAME&#125;</code>或<code>$&#123;AnsiColor.NAME&#125;</code></td>
<td>其中NAME是ANSI转义码的名称</td>
</tr>
<tr>
<td>${application.title}</td>
<td>应用的标题,在<code>MANIFEST.MF</code>中声明.比如<code>Implementation-Title: MyApp</code>,输出<code>MyApp</code></td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>​    如果想要以编程的方式实现的话,可以使用<code>SpringApplication.setBanner(…)</code>方法.使用<code>org.springframework.boot.Banner</code>接口并且实现自己的<code>printBanner()</code>方法.<br>可以使用<code>spring.main.banner-mode</code>来指定banner是在<code>System.out</code>(控制台)输出,还是在日志中输出,或者不输出(<code>off</code>).<br>输出的banner以单例的形式注册,名称为<code>springBootBanner</code>.<br>注意:</p>
<p>​    <code>$&#123;application.version&#125;</code>和<code>$&#123;application.formatted-version&#125;</code>属性只有在使用Spring Boot启动器启动时可以使用. 如果使用<code>java -cp &lt;classpath&gt; &lt;mainclass&gt;</code>来运行一个没有打包的jar, 这些值都不能被使用.</p>
<p>​    这也是为什么推荐,使用<code>java org.springframework.boot.loader.JarLauncher</code>来启动没打包的jar. 这样可以在编译classpath和启动应用前,初始化<code>application.*</code>的banner变量.</p>
</blockquote>
</li>
<li><h5 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h5>​    如果默认的<code>SpringApplication</code>不能够满足需求, 可以自定义一个本地的实例并且进行自定义.比如关闭banner,可以这样写:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(MyApplication.class);</span><br><span class="line">        application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    传给<code>SpringApplication</code>构造器的参数是Spring bean的配置源. 在大多数情况下, 这些都是<code>@Configuration</code>类的引用, 但是也可以是<code>@Component</code>类的直接引用.<br>​    也可以使用<code>application.properties</code>来配置<code>SpringApplication</code>.</p>
</blockquote>
</li>
<li><h5 id="Fluent-Builder-API"><a href="#Fluent-Builder-API" class="headerlink" title="Fluent Builder API"></a>Fluent Builder API</h5>​    如果需要构建一个<code>ApplicationContext</code>层级结构(有父子/关系的多个上下文),或者想要使用流式 builder API,可以使用<code>SpringApplicationBuilder</code>.<br>​    <code>SpringApplicationBuilder</code>能够以链式调用多个方法,并且可以包含<code>parent</code>和<code>child</code>方法来创建层级结构.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">        .sources(Parent.class)</span><br><span class="line">        .child(Application.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    创建<code>ApplicationContext</code>层级结构的时候,有一些限制.比如, 网络模块必须包含在<code>child</code>上下文中,<code>Environment</code>被父子上下文环境同时使用.</p>
</blockquote>
</li>
<li><h5 id="应用可用性"><a href="#应用可用性" class="headerlink" title="应用可用性"></a>应用可用性</h5>​    在平台上部署后，应用程序可以使用诸如<code>Kubernetes Probes</code>之类的基础结构向平台提供有关其可用性的信息。Spring Boot对常用的<code>liveness</code>和<code>readiness</code>可用性状态提供了开箱即用的支持.如果使用Spring Boot的<code>actuator</code>,这些状态将会显示为运行状况端点组.<br>​    此外, 可以在自己的bean中注入<code>ApplicationAvailability</code>来获取应用的可用性状态.<ol>
<li><h6 id="活动状态-Liveness-Liveness-State"><a href="#活动状态-Liveness-Liveness-State" class="headerlink" title="活动状态(Liveness Liveness State)"></a>活动状态(Liveness Liveness State)</h6>​    活动状态(<code>liveness</code>)说明应用内部装填是否能够允许应用正常工作,或者依靠自身,从当前失败中恢复过来.如果<code>Liveness</code>状态被打破,意味着应用处于一种不能恢复的状态,并且<code>infrastructure </code>应该重启应用.<blockquote>
<p>注意:</p>
<p>​    通常来说, <code>liveness</code>状态不应该基于白雾检查,比如健康检查.如果是这种方式,那么一个失败的外部系统(数据库,web api,外部缓存)可能会触发平台上的大量重启和级联故障.<br>Spring Boot应用的内部状态主要由<code>ApplicationContext</code>表示.如果应用的上下文环境启动成功,Spring Boot认为应用处于可用状态.只要刷新上下文环境,那么就可以认为应用处于可用状态.</p>
</blockquote>
</li>
<li><h6 id="就绪状态-Readiness-State"><a href="#就绪状态-Readiness-State" class="headerlink" title="就绪状态(Readiness State)"></a>就绪状态(Readiness State)</h6>​    就绪(<code>readiness</code>)表示应用是否处于可以处理流量的状态.失败的就绪状态告诉平台,现在不应将流量路由到应用. 这通常是在启动过程中,或者当<code>CommandLineRunner</code>和<code>ApplicationRunner</code>正在被处理,或者当前过于繁忙, 应用认为不应该处理额外流量.<blockquote>
<p>建议:</p>
<p>​    在启动过程中执行任务是,应该使用<code>CommandLineRunner</code>或者<code>ApplicationRunner</code>来执行,而不是使用Spring的生命周期的回调函数,比如<code>@PostConstruct</code></p>
</blockquote>
</li>
<li><h6 id="管理应用的可用性"><a href="#管理应用的可用性" class="headerlink" title="管理应用的可用性"></a>管理应用的可用性</h6>​    应用中的组件,可以注入<code>ApplicationAvailability</code>并且调用其方法,在任何时候获取当前的可用性.大多数情况下,应用希望能够监听到状态的变化或者去更改状态.<br>​    比如,可以应用的将<code>Readiess</code>状态导出为文件,从而可以在<code>Kubernetes </code>上执行<code>exec Probe</code>去看到这个文件.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReadinessStateExporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChange</span><span class="params">(AvailabilityChangeEvent&lt;ReadinessState&gt; event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getState()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACCEPTING_TRAFFIC:</span><br><span class="line">            <span class="comment">// create file /tmp/healthy</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFUSING_TRAFFIC:</span><br><span class="line">            <span class="comment">// remove file /tmp/healthy</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
当应用崩溃,不能够恢复时,也可以更新应用的可用状态.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocalCacheVerifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocalCacheVerifier</span><span class="params">(ApplicationEventPublisher eventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eventPublisher = eventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLocalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (CacheCompletelyBrokenException ex) &#123;</span><br><span class="line">            AvailabilityChangeEvent.publish(<span class="keyword">this</span>.eventPublisher, ex, LivenessState.BROKEN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="应用事件和监听器"><a href="#应用事件和监听器" class="headerlink" title="应用事件和监听器"></a>应用事件和监听器</h5>​    除了常规的Spring框架时间,比如<code>ContextRefreshEvent</code>,<code>SpringApplication</code>也会发送一些其他的应用事件.<blockquote>
<p>注意:</p>
<p>​    有一些事件实际上在<code>ApplicationContext</code>创建前触发,所以不能够通过<code>@Bean</code>的方式来注册监听器. 可以通过<code>SpringApplication.addListeners(…)</code>或者<code>SpringApplicationBuilder.listeners(…)</code>这两个方法来注册.</p>
<p>​    如果想要自动监听器,而不在乎应用的创建方式,可以在项目中增加一个<code>META-INF/spring.factories</code>文件,在文件中使用<code>org.springframework.context.ApplicationListener</code>的key来引用监听器.比如:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;org.springframework.context.ApplicationListener</span>=<span class="string">com.example.project.MyListener</span></span><br></pre></td></tr></table></figure>
<p>​    应用的时间会按照下面的顺序发送:</p>
</blockquote>
<ol>
<li><code>ApplicationStartingEvent</code><br>启动 -&gt;  <code>触发当前事件</code> -&gt; 其他处理(监听器和初始化注册除外)</li>
<li><code>ApplicationEnvironmentPreparedEvent</code><br>获知要使用的<code>Environment</code> -&gt;<br>​         <code>触发当前事件</code><br>-&gt; 上下文创建</li>
<li><code>ApplicationContextInitializedEvent</code><br><code>ApplicationContext</code>和<code>ApplicationContextInitializers</code>初始化完成 -&gt;<br>​     <code>触发当前事件</code><br>-&gt; 载入bean</li>
<li><code>ApplicationPreparedEvent</code><br>载入bean -&gt; <code>触发当前事件</code> -&gt;  刷新前</li>
<li><code>ApplicationStartedEvent</code><br> 在上下文环境刷新 -&gt; <code>触发当前事件</code> -&gt; 应用或者命令行启动器调用</li>
<li><code>AvailabilityChangeEvent</code><br><code>LivenessState.CORRECT</code>发送 -&gt; <code>触发当前事件</code><br>表明整个应用处于可用状态.</li>
<li><code>ApplicationReadyEvent</code><br> 任何应用或者命令行执行程序启动 -&gt; <code>触发当前事件</code></li>
<li><code>AvailabilityChangeEvent</code><br><code>ReadinessState.ACCEPTING_TRAFFIC</code>发送 -&gt; <code>触发当前事件</code><br>表明整个应用做好准备,接收服务请求.</li>
<li><code>ApplicationFailedEvent</code><br>启动发生错误 -&gt; <code>触发当前事件</code><br>上面只有<code>SpringApplicationEvent</code>s 事件和<code>SpringApplication</code>相关.除了这些之外.下面的事件会在<code>ApplicationPreparedEvent</code>后,<code>ApplicationStartedEvent</code>前触发.</li>
</ol>
<ul>
<li>当<code>WebServer </code>就绪,<code>WebServerInitializedEvent</code>发送. <code>ServletWebServerInitializedEvent</code>和<code>ReactiveWebServerInitializedEvent</code>分别是serlvet和reactive的各自变体.</li>
<li><code>ApplicationContext</code>刷新之后, <code>ContextRefreshedEvent</code>发送.<blockquote>
<p>建议:</p>
<p>​    在很多时候,不需要使用应用的时间,只需要知道有这些事件.在内部, Spring Boot使用事件来处理大量的任务.</p>
<p>注意:</p>
<p>   事件监听器不应该运行那些可能长任务,因为它们都是运行在同一个线程中.如果要运行长任务,可以考虑使用<code>ApplicationRunner</code>或<code>CommandLineRunner</code><br>​    应用事件的发送是使用Spring Framework的事件发送机制发送的.机制的一部分保证了,发送给子上下文环境中的监听器的事件, 也会发送给祖先上下文环境的监听器.因此, 如果应用程序使用SpringApplication实例的层次结构,一个监听器或许能够接收到来自多个实例的同一种应用事件.<br>​    为了让监听器区分事件是来自自身的<code>context</code>,还是后代的<code>context</code>, 应该注入应用的上下文环境,然后比较应用上下文和事件的上下文环境.可以实现<code>ApplicationContextAware</code>接口来注入<code>context</code>,或者如果监听器是一个<code>bean</code>,可以直接使用<code>@Autowired</code>.</p>
</blockquote>
</li>
</ul>
</li>
<li><h5 id="应用环境"><a href="#应用环境" class="headerlink" title="应用环境"></a>应用环境</h5>​    <code>SpringApplication</code>代替开发者创建正确的<code>ApplicationContext</code>,决定<code>WebApplicationType</code>的算法如下:<ul>
<li>如果出现<code>Spring MVC</code>,就使用<code>AnnotationConfigServletWebServerApplicationContext</code>.</li>
<li>如果没出现<code>Spring MVC</code>,并且出现<code>Spring WebFlux</code>,就使用<code>AnnotationConfigReactiveWebServerApplicationContext</code></li>
<li>否则就使用,<code>AnnotationConfigApplicationContext</code><br>​    这意味着,如果在应用中同时使用<code>Spring MVC</code>和<code>Spring WebFlux</code>的<code>client</code>, Spring MVC会被默认使用.可以使用<code>setWebApplicationType(WebApplicationType)</code>来重写.<br>​    也可以使<code>setApplicationContextClass(…)</code>来完全控制<code>ApplicationContext</code>的类型.<blockquote>
<p>建议:</p>
<p>​    当是用<code>SpringApplication</code>进行Junit测试时, 应该调用<code>setWebApplicationType(WebApplicationType.NONE)</code>.</p>
</blockquote>
</li>
</ul>
</li>
<li><h5 id="访问应用参数"><a href="#访问应用参数" class="headerlink" title="访问应用参数"></a>访问应用参数</h5>​    如果要访问传递给<code>SpringApplication.run(…)</code>的参数时,可以注入<code>org.springframework.boot.ApplicationArguments</code>bean.接口<code>ApplicationArguments</code>同时提供了访问原始的数组形式的参数(<code>String[]</code>),也有已经被解析的<code>option</code>和<code>non-option</code>.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> debug = args.containsOption(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        List&lt;String&gt; files = args.getNonOptionArgs();</span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            System.out.println(files);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if run with &quot;--debug logfile.txt&quot; prints [&quot;logfile.txt&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    Spring Boot在Spring环境中也注册了<code>CommandLinePropertySource</code>,这样可以直接使用<code>@Value </code>注解来访问单例形式的应用参数.</p>
</blockquote>
</li>
<li><h5 id="使用ApplicationRunner-或者CommandLineRunner"><a href="#使用ApplicationRunner-或者CommandLineRunner" class="headerlink" title="使用ApplicationRunner 或者CommandLineRunner"></a>使用ApplicationRunner 或者CommandLineRunner</h5>​    如果需要在<code>SpringApplication</code>启动后运行一些代码,可以实现<code>ApplicationRunner</code>或者<code>CommandLineRunner</code>接口.这两个接口都提供了<code>run</code>方法,这个方法在<code>SpringApplication.run(…)</code>完成之前调用.<blockquote>
<p>注意:</p>
<p>​    这种特别适合在应用启动之后,但是在接收流量之前运行任务.<br>​    <code>CommandLineRunner</code>以字符串数组方式访问应用程序参数, <code>ApplicationRunner</code>使用<code>ApplicationArguments</code>.下面的示例,展示的<code>CommandLineRunner</code>和<code>run</code>方法:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
​    如果有使用了多个<code>CommandLineRunner</code>和<code>ApplicationRunner</code>bean,且必须要按照特定顺序调用.可以实现额外的<code>org.springframework.core.Ordered</code>接口,或者使用<code>org.springframework.core.annotation.Order</code>来实现指定顺序调用.</li>
<li><h5 id="应用退出"><a href="#应用退出" class="headerlink" title="应用退出"></a>应用退出</h5>​    每个<code>SpringApplication</code>都在向JVM注册了一个关闭hook,来保证<code>ApplicationContext</code>在退出时能够正常的关闭. 所有的标准的Spring生命周期回调函数(比如<code>DisposableBean</code>接口或者<code>@PreDestroy</code>)都可以被使用.<br>​    此外,如果在调用<code>SpringApplication.exit()</code>时想要返回指定的退出状态码,bean可以实现<code>org.springframework.boot.ExitCodeGenerator</code>接口.退出状态码可以传给<code>System.exit()</code>来返回状态码.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExitCodeGenerator <span class="title">exitCodeGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.exit(SpringApplication.exit(SpringApplication.run(MyApplication.class, args)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
​    当然,<code>ExitCodeGenerator</code>也可以被异常类实现.当发生这些异常时,Spring Boot会返回异常实现类的<code>getExitCode()</code>提供的code.</li>
<li><h5 id="管理员功能"><a href="#管理员功能" class="headerlink" title="管理员功能"></a>管理员功能</h5>​    通过指定<code>spring.application.admin.enabled</code>属性值,可以开启应用中与管理员相关的功能.这将在平台<code>MBeanServer</code>上公开<code>SpringApplicationAdminMXBean</code>.对于任何服务包装器实现，此功能也可能很有用.<blockquote>
<p>建议:</p>
<p>​    如果想要知道应用运行在那个HTTP端口上,可以使用<code>local.server.port</code>来获取属性.</p>
</blockquote>
</li>
<li><h5 id="跟踪应用启动"><a href="#跟踪应用启动" class="headerlink" title="跟踪应用启动"></a>跟踪应用启动</h5>​    在应用启动过程中,<code>SpringApplication</code>和<code>ApplicationContext</code>执行很多关于应用生命周期,bean生命周期,甚至处理应用事件的任务. 使用<code> ApplicationStartup</code>,Spring Framework允许使用<code>StartupStep</code>对象,来可以追踪应用启动.这些数据可以被用来做做分析,或者用来更好地理解应用启动过程.<br>​    在配置<code>SpringApplication</code>实例时,可以使用<code>ApplicationStartup</code>的一个实例比如使用<code>BufferingApplicationStartup</code>,可以如下:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(MyApplication.class);</span><br><span class="line">        application.setApplicationStartup(<span class="keyword">new</span> BufferingApplicationStartup(<span class="number">2048</span>));</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
​    <code>ApplicationStartup</code>的第一个实现,<code>FlightRecorderApplicationStartup</code>由Spring Framework提供.它将特定于Spring的启动事件添加到Java Flight Recorder会话中，旨在对应用程序进行性能分析,并将Spring上下文生命周期与JVM事件相关联(比如内存分配,垃圾回收,类加载…).只要配置过后,可以启用飞行日志来收集数据.<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -XX:StartFlightRecording:filename=recording.jfr,duration=10s -jar demo.jar</span><br></pre></td></tr></table></figure>
      ​    Spring Boot带有<code>BufferingApplicationStartup</code>,这个实现是用来缓冲启动步骤并将数据发送到外部评估系统.应用可以在任何组件中调用<code>BufferingApplicationStartup</code>.此外,Spring Boot Actuator会以JSON文档的形式,输出终端的启动.</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>第二篇,使用Spring Boot</title>
    <url>/posts/42178.html</url>
    <content><![CDATA[<h4 id="使用Spring-Boot"><a href="#使用Spring-Boot" class="headerlink" title="使用Spring Boot"></a>使用Spring Boot</h4><p>这个章节深入研究使用Spring Boot的更多细节.包含了主题有构建系统,自动配置,如何运行程序.也会包含一些使用Spring Boot的最佳实践.虽然Spring Boot没有什么特别特殊的地方(你可以假设这只是另外一个库),但是又仍有一些建议.如果遵循这些建议,可以开发过程更容易.</p>
<ol>
<li><h5 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h5>​    强烈建议选择一个支持依赖管理的构建系统.推荐使用支持Maven Central仓库的工具.推荐使用Maven和Grande.虽然其他的构建系统可以使用Spring Boot.<ol>
<li><h6 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h6>每一个Spring Boot的发布都会提供一份精心挑选的依赖.在实际构建配置工作中,不需要提供任何依赖的版本,Spring Boot管理已经做了管理.当升级Spring Boot是,这些依赖也会保持一致的升级.<br>note:如果有需要的话,也可以指定版本,覆盖Spring Boot的建议.<br>精选的列表包含所有的可以和Spring Boot一起使用的Spring模块,同时这个列表也是精选的第三方库.</li>
<li><h6 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h6>学习如何使用Spring Boot和Maven,可以参考下面网址.<br><a href="https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/reference/htmlsingle/">https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/reference/htmlsingle/</a></li>
<li><h6 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h6>​    Starters是一系列方便的依赖描述符,可以用在应用中.可以一站式解决所有Spring和相关技术栈的依赖,不需要翻遍样例代码,然后复制相关依赖描述符.比如,如果想要使用Spring和JPA,就可以直接包含<code>spring-boot-starter-data-jpa</code>.<br>​    starters包含了很多依赖,使用连续,支持一系列可传递的依赖可以被用来快速构建,运行项目.<blockquote>
<p>在starter的name</p>
<p>​    所有官方的starter都遵循类似的命名模式.<code>spring-boot-starter-*</code>,<code>*</code>是一种特定类型的程序.这种命名结构旨在方便使用者寻找需要的starter.在很多IDE中集成的Maven可以根据名称搜索依赖.</p>
<p>​    第三方的starters不应该以<code>spring-boot</code>,因为这是官方Spring Boot的artifacts.第三方的starter应该使用项目名开头.必须一个第三方的starter工程叫做<code>thirdpartyproject</code>,应该被命名为<code>thirdpartyproject-spring-boot-starter</code>.<br>下面的starter是Spring Boot提供的在<code>org.springframework.boot</code>组中:    </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>spring-boot-starter</code></td>
<td>核心starter,包括自动配置支持,日志和YAML</td>
</tr>
<tr>
<td><code>spring-boot-starter-activemq</code></td>
<td>使用 Apache ActiveMQ的JMS消息的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-amqp</code></td>
<td>使用 Spring AMQP和Rabbit MQ的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-aop</code></td>
<td>使用SpringAOP和AspectJ的面向切面编程的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-artemis</code></td>
<td>使用 Apache Artemis的JMS消息的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-batch</code></td>
<td>使用Spring Batch的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-cache</code></td>
<td>支持Spring Framework的cache的starter</td>
</tr>
<tr>
<td><code>spring-boot-starter-data-cassandra</code></td>
<td>使用 Cassandra distributed database and Spring Data Cassandra的starter</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ol>
</li>
<li><h5 id="组织代码"><a href="#组织代码" class="headerlink" title="组织代码"></a>组织代码</h5>Spring Boot不要求任何的特定代码格式.但是有一些是最好的实践方式.<ol>
<li><h6 id="使用”default”包"><a href="#使用”default”包" class="headerlink" title="使用”default”包"></a>使用”default”包</h6>​    当一个class没有包含<code>package</code>生命是,会被默认放在”default package”.不应该使用默认包的方式,应当尽量避免使用默认包.对于Spring Boot应用来说,在使用<code>@ComponentScan</code>,<code>@ConfigurationPropertiesScan</code>,<code>@entityScan</code>,<code>@SpringBootApplication</code>注解时,可能会导致一些问题,因为每个jar中的每个class都会被读取.<br>tip:推荐遵循Java推荐的包命名方式,使用倒置的域名(com.github….).</li>
<li><h6 id="主程序类的位置"><a href="#主程序类的位置" class="headerlink" title="主程序类的位置"></a>主程序类的位置</h6>​    推荐将主程序类放到包的根路径下,在其他所有的class上级.<code>@SpringBootApplication</code>注解经常放在main所在的类上,这隐式地定义了搜索特定项目的基础包.比如,当写一个JPA应用,<code>@SpringBootApplication</code>注解标注的类所在的包,将会被用来检索<code>@Entity</code>项目.使用包的根路径也可以用来扫描项目中的组件<br>​    tip:如果不想使用<code>@SpringBootApplication</code>,可以改用<code>@EnableAutoConfiguration</code>,<code>@ComponentScan</code>注解来定义导入行为.<br>下面是典型的代码结构:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com</span><br><span class="line"> +- example</span><br><span class="line">     +- myapplication</span><br><span class="line">         +- MyApplication.java</span><br><span class="line">         |</span><br><span class="line">         +- customer</span><br><span class="line">         |   +- Customer.java</span><br><span class="line">         |   +- CustomerController.java</span><br><span class="line">         |   +- CustomerService.java</span><br><span class="line">         |   +- CustomerRepository.java</span><br><span class="line">         |</span><br><span class="line">         +- order</span><br><span class="line">             +- Order.java</span><br><span class="line">             +- OrderController.java</span><br><span class="line">             +- OrderService.java</span><br><span class="line">             +- OrderRepository.java</span><br></pre></td></tr></table></figure>
<code>MyApplication.java</code>文件应该使用<code>@SpringBootApplication</code>来声明<code>main</code>方法:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h6>​    Spring Boot支持使用基于Java的配置.尽管可以使用xml源来配置<code>SpringApplication</code>,仍然推荐使用主要配置源应该是一个<code>@Configuration</code>类.通常来说,使用定义<code>main</code>方法的类作为主要源是一个很好的选择.<br>​    tip:在网络上,发布了很多使用XML配置的例子.如果可以的话,应该尽量使用作用相同的基于Java类的配置方式.尝试搜索<code>Enable*</code>注解可能是一个好的开始.<ol>
<li>导入其他配置类<br>不需要将所有使用<code>@Configuration</code>的类融合成一个单独的类.可以使用<code>@Import</code>注解去导入其他配置类.同样,也可以使用<code>@ComponentScan</code>注解去自动导入是所有类,包括标有<code>@configuration</code>的类.</li>
<li>导入XML配置<br>如果必须要使用基于xml的配置方式,仍然推荐使用使用<code>@Configuration</code>类.在类上使用<code>@ImportResource</code>注解去导入XML配置文件.</li>
</ol>
</li>
<li><h6 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h6>​    Spring Boot自动配置尝试基于已经添加的jar依赖去自动配置应用.比如,<code>HSQLDB</code>在classpath中,并且没有手动配置任何关于数据库连接的Bean,Spring Boot会自动配置一个内存数据库.<br>​    可以在任意一个标有<code>@Configuration</code>的配置类上,添加<code>@EnableAutoConfiguration</code>注解或者<code>@SpringBootApplication</code>注解来启用自动配置.<br>​    tip: 应该只添加一个<code>@SpringBootApplication</code>或者<code>@EnableAutoConfiguration</code>注解,推荐添加其中一个到主要的配置类上.<ol>
<li>逐渐替换自动配置<br>​    自动配置是非侵入的.在任何时候,都可以开始定义自己的配置,去替换自动配置的特定部分.比如,如果增加了自己的<code>DataSource</code>Bean,默认的内置数据库的支持会被替换.<br>​    如果想要知道有些自动配置正在被使用,并且使用的原因是是什么,可以使用<code>--debug</code>模,切换到debug模式.会在控制台输出相关信息.</li>
<li>指定不使用自动配置的类,<br>​    如果希望对指定的类,不使用自动配置.可以使用<code>@SpringBootApplication</code>的exclude属性去禁用自动配置.如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
​    如果类没有在classpath中,可以使用注解的<code>excludeName</code>属性来指定类的全路径名. 如果使用的是<code>@EnableAutoConfiguration</code>而不是<code>@SpringApplication</code>,<code>exclude</code>和<code>excludeName</code>同样可以使用. 最后,还可以使用<code>spring.autoconfigure.exclude</code>属性来指定不需要自动配置的类.<br>​    tip:可以同时在注解和配置文件中指定不要自动注解类<br>​    note: 尽管自动配置类是public的,该类的唯一被认为是公共API的方面是可用于禁用自动配置的类的名称。这些类的实际内容（例如嵌套配置类或Bean方法）仅供内部使用，我们不建议直接使用它们。(不要直接使用配置类的内部配置)</li>
</ol>
</li>
<li><h6 id="Spring-Bean和依赖注入"><a href="#Spring-Bean和依赖注入" class="headerlink" title="Spring Bean和依赖注入"></a>Spring Bean和依赖注入</h6>​    可以选择任何一种Spring提供的定义beans和注入依赖的方式.通常建议使用<em><strong>构造器注入</strong></em>的方式去织入依赖和使用<code>@ComponentScan</code>去发现bean.<br>​    如果和上面提到的代码组织方式一致(将主程序类放到最上层包中),可以使用不含参数的<code>@ComponentScan</code>注解,或者使用<code>@SpringApplication</code>注解,该注解已经隐式地包含<code>@ComponentScan</code>. 程序的所有组件(<code>@Component</code>,<code>@Service</code>,<code>@Repository</code>,<code>@Controller</code> etc)都会自动注册为Spring Bean.<br>​    下面的例子展示的是,<code>@Service</code>Bean使用构造器注入,构造器包含一个<code>RiskAssessor</code>Bean作为参数:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccountService</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果bean有多个构造器,需要使用<code>@AutoWired</code>指定使用哪一个构造器进行构造注入.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccountService</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PrintStream out;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">        <span class="keyword">this</span>.out = System.out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAccountService</span><span class="params">(RiskAssessor riskAssessor, PrintStream out)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">        <span class="keyword">this</span>.out = out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="使用-SpringBootApplication注解"><a href="#使用-SpringBootApplication注解" class="headerlink" title="使用@SpringBootApplication注解"></a>使用<code>@SpringBootApplication</code>注解</h6>​    很多开发者希望在程序中使用自动配置,组件扫描,并且定义额外配置.只需要一个<code>@SpringApplication</code>注解就可以实现三个功能:<ul>
<li><code>@EnableAutoConfiguration</code>,开启自动配置机制</li>
<li><code>@ComponentScan</code>:开启扫描包</li>
<li><code>@Configuration</code>:允许在context中注册额外bean或者导入额外配置类.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// same as @Configuration @EnableAutoConfiguration @ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
note: 这些特性不是强制的,可以选择这些特性的注解去替换掉<code>@SpringBootApplication</code>注解.比如,如果不想使用component scan或者配置属性的.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@Import(&#123; SomeConfiguration.class, AnotherConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在这个例子中,application就像其他任何一个Spring Boot应用程序,除了<code>@Component</code>注解标注的类和<code>@ConfigurationProperties</code>注解标注的类不是自动检测的,还有用户自定义的bean被显式导入之外,并没有什么不同.</li>
<li><h6 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h6>​    将程序打包成jar并且使用嵌入的HTTP server的一个最大的优点,就是可以像运行其他应用程序一样运行应用程序。同样也适用于调试Spring  Boot程序.不需要任何IDE的插件或者扩展.<ol>
<li>从IDE运行<br>将项目导入到IDE中,直接运行.</li>
<li>以运行打包程序方式运行<br>如果使用Maven创建可执行Jar,则可以直接使用<code>java -jar</code> 运行.</li>
<li>使用Maven插件<br>直接使用 mvn 执行 run goal.<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure></li>
<li>热部署形式运行</li>
</ol>
</li>
<li><h6 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h6>​    Spring Boot包含一些额外的开发工具集,可以让开发更加方便.<code>spring-boot-devtools</code>可以被放在任何工程中,以提供开发过程中的功能.添加依赖到Maven中:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
注意:<br>​    当运行整个打包后程序时,发者工具会自动禁用.如果程序是从<code>java -jar</code>方式运行或者是从特殊的类加载器加载是,会被当做是生产环境应用.可以通过使用<code>spring.devtools.restart.enabled</code>系统变量,来控制行为.如果无论什么类加载器,都启用开发工具,设置系统变量<code>-Dspring.devtools.restart.enabled=true</code>.绝对不能在运行devtools有安全风险的生产环境中执行此操作.禁用开发工具,排查相关依赖或者设置系统变量<code>-Dspring.devtools.restart.enabled=false</code>.<br>提示:在maven中,将依赖设为optional,从而禁止devtools的传递性.<ol>
<li><h6 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h6>​    Spring Boot支持的几个库使用缓存来提升性能.比如,template引擎缓存编译后的模板,来避免对模板文件的重复解析.同样的,Spring MVC可以在为静态资源提供服务时将HTTP缓存header添加到响应中。<br>​    虽然缓存在生产环境中有很多好处, 但是在开发过程中, 可能会适得其反,可能会让开发者无法看到刚发布的程序的变化. 出于这个原因,spring-boot-devtools 默认引用缓存项.<br>​    缓存选项通常在<code>application.properties</code>中配置.比如Thymeleaf 提供<code>spring.thymeleaf.cache</code>属性. 不需要手动配置这些属性, <code>spring-boot-devtools</code> 自动设置一些在开发阶段的合理的配置.<br>​    在开发Spring MVC和Spring WebFlux应用时,开发者需要很多关于请求的信息, 开发者工具会自动开启网络部分的<code>DEBUG</code>日志. 这能够提供更多关于请求的信息, 那个handler正在处理, 响应的结果等等. 如果想要日志输出所有的细节(包括潜在敏感信息), 可以开启<code>spring.mvc.log-request-details</code> 或者 <code>spring.codec.log-request-details</code> 配置项.<blockquote>
<p>注意:</p>
<p>如果不想使用默认的开发者工具属性,可以在<code>application.properties</code>中配置关闭:<code>spring.devtools.add-properties = false</code></p>
</blockquote>
</li>
<li><h6 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h6>​    当编译路径中的文件发生改变时, 使用<code>spring-boot-devtools</code>的应用会自动重启. 在IDE中,这是个特性很有用, 可以对代码更改给出快速反应. 默认情况下, classpath目录被监视改变. 需要注意, 特定的资源,比如静态资源和视图模板,不需要改变.<blockquote>
<p>触发重启.</p>
<p>DevTools监视编译路径资源,能够触发重启的唯一方式是编译路径内的更新. 对编译路径下的更新主要取决于使用哪种编译器:</p>
<ul>
<li>推荐打开项目的自动编译属性.<br>注意:</li>
</ul>
<p>如果使用Maven的build插件来实现重启,则必须让<code>forking</code>开启状态.</p>
<p>提示:</p>
<p>​    自动重启能和LiveReload良好的协作. 如果使用JRebel,自动重启会禁用, 以支持动态class的载入.其他的devtools的功能(比如LiveReload和覆盖属性)正常使用</p>
<p>注意:</p>
<p>​    在重启中, DevTools依赖应用上下文环境的钩子函数来关闭.如果金融了shutdown hook, 可能导致不能够正常工作(<code>SpringApplication.setRegisterShutdownHook(false)</code>)</p>
<p>注意:</p>
<p>​    DevTools需要自定义<code>ApplicationContext</code>中的<code>ResourceLoader</code>. 如果应用中已经提供了一个, 会被包装. 在<code>ApplicationContext</code>中直接重写<code>getResource</code>方法不会被支持.<br>Restart vs Reload</p>
<p>​    Spring Boot提供两个classloader来实现restart. 不会改变的类(比如来自第三方的jar)会被加载到叫<code>base</code>的classloader中. 正在开发过程的class会被加载到叫<code>restart</code>的classloader中. 当应用被重启, <code>restart</code>classloader被丢弃, 会重新创建一个. 这种方式意味着, 应用程序通常可以比冷启动快很多, 因为<code>base</code>classloader已经可用并已填充.</p>
<p>​    如果发现重启不够快,或者遇到classloading问题,可以考虑reloading technology, 比如ZeroTurnaround的JRebel. 这些方法通过在加载类时重写类来使它们更适合于重新加载。</p>
</blockquote>
<ol>
<li>记录条件评估中的更改<br>​    默认情况下, 每次应用程序重新启动时，都会记录一个报告，其中显示了条件评估增量。报告显示了应用的自动配置的更改, 比如增加或者移除了bean还有对配置属性的更改.可以关闭报告日志:<code>spring.devtools.restart.log-condition-evaluation-delta=false</code></li>
<li>排除资源<br>​    有些资源改变时, 不需要触发重启. 比如Thymeleaf templates可以就地编辑. 默认情况下, 改变一下目录下的资源时,不会触发重启但是会触发热加载(live reload):<code>/META-INF/maven</code>, <code>/META-INF/resources</code>, <code>/resources</code>, <code>/static</code>, <code>/public</code>, <code>/templates</code>.如果想要自定义排除规则, 可以使用<code>spring.devtools.restart.exclude</code>属性. 比如只想排除<code>/static</code>,<code>/public</code>,可以如下配置:<code>spring.devtools.restart.exclude=static/**,public/**</code><blockquote>
<p>提示:</p>
<p>​    如果想要保持默认配置,并且想增加新的排除规则,可以使用<code>spring.devtools.restart.additional-exclude</code>属性.</p>
</blockquote>
</li>
<li>监视其他路径<br>​    如果想要应用根据其他目录比如不是classpath, 而重启或者重新加载.可以使用<code>spring.devtools.restart.additional-paths</code> 属性来配置其他监视路径.可以使用前面所述的<code>spring.devtools.restart.exclude</code>属性来控制其他路径下的更改是触发完全重启还是实时重新加载。</li>
<li>关闭重启<br>​    如果不想要使用重启功能,可以使用<code>spring.devtools.restart.enabled</code>关闭. 在多数情况下,可以在<code>application.properties</code>. (即使关闭, 也会初始化<code>restart</code> classloader,但是不会监视文件更改).<br>​    如果想要完全关闭重启功能(比如,该功能和其他库发生冲突时),可以在调用<code>SpringApplication.run(…)</code>前,将<code>System</code>的<code>spring.devtools.restart.enabled</code>设置为<code>false</code>.如下:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;spring.devtools.restart.enabled&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用触发文件<br>​    如果使用的IDE不断编译文件,可能只需要在特定的几次触发重启.这种情况下,可以使用触发文件,这种方式是修改特定的文件来触发重启.<blockquote>
<p>注意:</p>
<p>​    对文件的任何更新都会触发检查，但是只有在Devtools检测到有事情要做的情况下，重启才会真正发生。<br>​    使用触发文件, 设置<code>spring.devtools.restart.trigger-file</code>为文件名(不包含任何路径). 文件必须实在classpath中.<br>比如,项目结构如下:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">+- main</span><br><span class="line">   +- resources</span><br><span class="line">      +- .reloadtrigger</span><br></pre></td></tr></table></figure>
<code>trigger-file</code>的配置应该是<code>spring.devtools.restart.trigger-file=.reloadtrigger</code>.<br>当<code>src/main/resources/.reloadtrigger</code>文件更新时,将会重启.</li>
<li>自定义重启类加载器<br>​    正如前面所说, 重启功能是通过使用两个类加载器.在大多数应用中, 可以 很好工作.但是有时也会导致classloading问题.<br>​    默认情况下, IDE打开的工程会使用<code>restart</code>classloader来载入, 任何<code>.jar</code>文件会使用<code>base</code>classloader载入.如果在一个多模块工程中,每个模块都导入到IDE中, 需要做一些自定义的工作.创建<code>META-INF/spring-devtools.properties</code>文件.<br>​    <code>spring-devtools.properties</code>文件包含以<code>restart.exclude</code>和<code>restart.include</code>属性. <code>include</code>标签中的元素会放进<code>restart</code>classloader,并且<code>exclude</code>标签中的元素会被放进<code>base</code>classloader中. 属性值是正则表达式,被应用到class中.如下所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">restart.exclude.companycommonlibs</span>=<span class="string">/mycorp-common-[\\w\\d-\\.]+\\.jar</span></span><br><span class="line"><span class="meta">restart.include.projectcommon</span>=<span class="string">/mycorp-myproj-[\\w\\d-\\.]+\\.jar</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>所有的属性key都必须不同.只要以<code>restart.include.</code>或者<code>restart.exclude.</code></p>
<p>建议:</p>
<p>​    所有来自classpath的<code>META-INF/spring-devtools.properties</code>的属性都会被载入.可以将文件打包到项目中,或者打包到项目需要的库中.</p>
</blockquote>
</li>
<li>已知的局限性<br>​    重启功能不能和通过使用<code>ObjectInputStream</code>来反序列的对象良好工作.如果需要反序列化数据,需要使用Spring的<code>ConfigurableObjectInputStream</code>和<code>Thread.currentThread().getContextClassLoader()</code>的组合.<br>​    很多第三方库反序列化没有考虑到context loader.</li>
</ol>
</li>
<li><h6 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h6>​    <code>spring-boot-devtools</code>内置了 LiveReload server, 当资源更新时,可以用来触发浏览器刷新.对于多种浏览器有很好的支持.<br>​    如果不想开启LiveReload server ,可以配置属<code>spring.devtools.livereload.enabled</code>为<code>false</code><blockquote>
<p>注意:</p>
<p>​    一次只能够运行一个LiveReload server.在运行程序前,应该保证没有其他的LiveReload server 在运行.如果在IDE中运行多个应用, 则只有第一个应用程序有LiveReload 支持.</p>
<p>警告:</p>
<p>​    当文件发生改变时, 为了触发LiveReload ,自动重启功能必须开启.</p>
</blockquote>
</li>
<li><h6 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h6>​    可以配置devtools的全局配置.在<code>$HOME/.config/spring-boot</code>下添加如下任一一个配置文件:<ol>
<li><code>spring-boot-devtools.properties</code></li>
<li><code>spring-boot-devtools.yaml</code></li>
<li><code>spring-boot-devtools.yml</code><br>这些文件中任一一个属性都会被应用到使用devtools的Spring Boot应用中. 比如, 配置总是使用一个trigger file来触发重启, 可以把下面的配置添加到<code>spring-boot-devtools</code>文件中.<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.devtools.restart.trigger-file</span>=<span class="string">.reloadtrigger</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    如果在<code>$HOME/.config/spring-boot</code>目录下没有任何devtools的配置文件, 将会在<code>$HOME</code>目录中,搜索一个叫<code>.spring-boot-devtools.properties</code>文件. 通过这种方式, 可以将devtools的全局配置分享到一个不支持<code>$HOME/.config/spring-boot</code>的老版本Spring Boot上.</p>
<p>注意:</p>
<p>​    在devtools的properties/yaml配置文件中,不支持Profiles.</p>
<p>​    在<code>.spring-boot-devtools.properties</code>配置profiles不会影响到指定的profiel配置文件的加载.  在YAML和properties配置文件中, 不支持配置profile文件名(<code>spring-boot-devtools-&lt;profile&gt;.properties</code>和<code>spring.config.activate.on-profile</code>都不支持)</p>
</blockquote>
</li>
<li>配置文件系统监视器<br>​    <code>FileSystemWatcher</code>的工作原理是, 通过一个特定时间的轮询class的变化,然后等待先前定义好的时间来保证没有其他更多的变化. 因为Spring Boot基本上都是依赖IDE去编译并且把编译好的文件拷贝到Spring Boot可以读取的目录, 在实际的使用过程中, 可能会发现,当devtools重启应用时, 有的对代码的改动反映到应用中. 如果这个问题不断出现, 可以尝试提高<code>spring.devtools.restart.poll-interval</code>和<code>spring.devtools.restart.quiet-period</code>参数值来适应当前的开发环境.<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.devtools.restart.poll-interval</span>=<span class="string">2s</span></span><br><span class="line"><span class="meta">spring.devtools.restart.quiet-period</span>=<span class="string">1s</span></span><br></pre></td></tr></table></figure>
​    被监视的classpath路径,每隔2s会被监视一次变化, 并且经过1s的等待,来保证class没有其他改动.</li>
</ol>
</li>
<li><h6 id="远程应用"><a href="#远程应用" class="headerlink" title="远程应用"></a>远程应用</h6>​    Spring Boot的devtools并不被限制在本地开发, 当运行远程应用是,可以使用其中几项功能. 使用远程支持可能会带来一些安全风险问题. 只有在安全可信任的网络上,或者启动SSL来保障安全的网络上,启用这项功能. 如果上面的两个选项都没有, 那就不应该使用devtools提供的远程支持. 在生产部署的时候,也不应该开启该功能.<br>​    开启这个功能,要保证<code>devtools</code>包含在重新打包的文档中.如下所示.<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludeDevtools</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeDevtools</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
​    还需要设置<code>spring.devtools.remote.secret</code>属性. 应该像重视重要的密码那样重视, 属性值应该唯一且强壮,不应该被轻易猜到或者暴力破解.<br>​    远程devtools支持由两部分支持:接受连接的server端和运行在IDE中的client. 当设置<code>spring.devtools.remote.secret</code>属性时, server端的组件会自动开启. 客户端组件只能手动启动.<ol>
<li>运行远程客户端应用<br>​    远程客户端应用由IDE启动, 需要使用与连接到的远程项目相同的类路径来运行<code>org.springframework.boot.devtools.RemoteSpringApplication</code>.  该应用程序的唯一必需参数是它连接到的远程URL。<br>​    比如,如果使用Eclipse或者 Spring Tools, 并且有一个工程叫做<code>my-app</code>应将部署在云上,可以做一下操作:<ul>
<li>选择在<code>Run</code>菜单中选择<code>Run Configurations…</code></li>
<li>创建一个<code>Java Application</code>d的启动配置</li>
<li>浏览<code>my-app</code>工程</li>
<li>把<code>org.springframework.boot.devtools.RemoteSpringApplication</code>当做main类来使用.</li>
<li>添加<code>https://myapp.cfapps.io</code>(远程url)到<code>Program arguments</code>中.<br>启动后如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .   ____          _                                              __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) &#x27;  \/ _ \  _/ -_) ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /</span><br><span class="line"> =========|_|==============|___/===================================/_/_/_/</span><br><span class="line"> :: Spring Boot Remote :: 2.5.0</span><br><span class="line"></span><br><span class="line">2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-project/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code)</span><br><span class="line">2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy</span><br><span class="line">2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with &#x27;https://&#x27;.</span><br><span class="line">2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729</span><br><span class="line">2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    因为远程客户端使用和实际应用一样的classpath,所以它可以直接读取应用配置文件. 这就是<code>spring.devtools.remote.secret</code>被读取和传递到服务端进行验证的方式.</p>
<p>建议:    </p>
<p>​    建议使用<code>https://</code>作为连接协议,  连接被加密并且密码不会被拦截.</p>
<p>建议:</p>
<p>    如果使用代理连接远程应用.可以配置<code>spring.devtools.remote.proxy.host</code>和<code>spring.devtools.remote.proxy.port</code>属性.</p>
</blockquote>
</li>
</ul>
</li>
<li>远程更新<br>​    远程客户端监视应用的classpath的变化,这个本地启动的方式一样. 任何资源的更新都会被推送到远程应用,并且会触发重启(如果设置的话). 这个功能有时候会很有帮助, 比如迭代一个使用云服务的功能,但是本地没有. 通常来说, 远程更新和重启会比本地全部重新编译部署要快很多.<br>​    在一个很慢的开发环境中, 可能会出现quiet时间太短, 导致对class的更改被分割成了好几批. 在第一批更改上传之后, 服务端被重启.第二批更改不能够发送给服务端, 因为服务端正在重启.<br>​    这通常通过RemoteSpringApplication日志中的警告来，即有关上传某些类失败的消息，并随后重试. 但是这也可能会导致代码的不一致性,可能会导致在第一批更改上传之后, 应用重启失败. 如果不断遇到这些问题,可以尝试增加<code>spring.devtools.restart.poll-interval</code>和<code>spring.devtools.restart.quiet-period</code>的参数值以适应当前的开发环境.<blockquote>
<p>注意:</p>
<p>​    只有当远程客户端启动了,文件才会被监视.如果在启动远程客户端之前改变了文件, 那么文件不会被推送到远程服务器上.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="打包生产环境应用"><a href="#打包生产环境应用" class="headerlink" title="打包生产环境应用"></a>打包生产环境应用</h6>​    可执行Jar一般用在部署生产环境中.因为他们是独立的, 所以非常适合部署在云上.<br>​    其他的适合生产环境的功能,比如运行状况,审核,度量REST或者JMX端点,可以考虑使用<code>spring-boot-actuator</code>.</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>第六篇,Spring Boot之日志</title>
    <url>/posts/5951.html</url>
    <content><![CDATA[<h5 id="日志-Logging"><a href="#日志-Logging" class="headerlink" title="日志(Logging)"></a>日志(Logging)</h5><ol start="4">
<li><h5 id="日志-Logging-1"><a href="#日志-Logging-1" class="headerlink" title="日志(Logging)"></a>日志(Logging)</h5>Spring Boot使用<code>Commons Logging</code>进行所有内部日志记录,也保持底层日志实现开放.提供了Java Util Logging,Log4J2和Logback的默认配置.在每中情形下,日志都配置成优先使用控制台输出,文件输出也是可选的.<br>默认情况下,如果使用<code>Starters</code>,日志会使用<code>Logback </code>.还包括合适的Logback路由,以确保使用Java Util Logging,Commons Logging,Log4J或SLF4J的从属库都能正常工作.<blockquote>
<p>建议:</p>
<p>​    因为Java中有很多日志框架,所以如果对上面列出的日志框架感到疑惑,也不要担心.通常来说,您无需更改日志记录依赖项,Spring Boot默认值也可以正常工作.</p>
<p>建议:</p>
<p>​    当部署应用到servlet容器或者应用服务器上,通过Java Util Logging API执行的日志记录不会路由到应用程序的日志中.这样可以防止容器或其他已部署到容器中的应用程序执行的日志记录出现在应用程序的日志中.</p>
</blockquote>
<ol>
<li><h6 id="日志格式-Log-Format"><a href="#日志格式-Log-Format" class="headerlink" title="日志格式(Log Format)"></a>日志格式(Log Format)</h6><p>Spring Boot中默认的日志格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</span><br><span class="line">2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span><br><span class="line">2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: &#x27;dispatcherServlet&#x27; to [/]</span><br><span class="line">2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: &#x27;hiddenHttpMethodFilter&#x27; to: [/*]</span><br></pre></td></tr></table></figure>
<p>输出的都是下面的条目:</p>
<ul>
<li>日期和时间:毫秒精度,易于排序.</li>
<li>日志级别:<code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code>, 或者 <code>TRACE</code>.</li>
<li>线程ID</li>
<li><code>---</code>区别实际日志消息的开始.</li>
<li>线程名:在方括号中(控制输出时,可能会被截断)</li>
<li>Logger 名:通常是class名(经常简写)</li>
<li>日志消息.<blockquote>
<p>注意:</p>
<p>​    Logback没有<code>FATAL</code>级别,别映射到了<code>ERROR</code>.</p>
</blockquote>
</li>
</ul>
</li>
<li><h6 id="控制台输出-Console-Output"><a href="#控制台输出-Console-Output" class="headerlink" title="控制台输出(Console Output)"></a>控制台输出(Console Output)</h6><p>默认的日志配置是当有日志输出时,就会把消息打到控制台上.默认情况,会<code>ERROR</code>,<code>WARN</code>和<code>INFO</code>级别的日志消息会记录.可以在启动应用是使用<code>--debug</code>标志位来开启”debug”模式.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myapp.jar --debug</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    也可以在<code>application.properties</code>指定<code>debug=true</code>.<br>当开启debug模式时,一些核心日志器（嵌入式容器,Hibernate和Spring Boot）会输出更多信息.开启debug模式并不能输出所有<code>DEBUG</code>级别的日志.<br>同样的,也可以在启动应用的使用<code>--trace</code>(或者在<code>application.properties</code>中,设置<code>trace=true</code>).这样做可以为某些核心logger（包括嵌入式容器,Hibernate数据库生成以及整个Spring产品组合）启用跟踪记录.</p>
</blockquote>
<ol>
<li><h6 id="彩色输出-Color-coded-Output"><a href="#彩色输出-Color-coded-Output" class="headerlink" title="彩色输出(Color-coded Output)"></a>彩色输出(Color-coded Output)</h6>如果终端支持<code>ANSI</code>,色彩输出可以提高可读性.可以将<code>spring.output.ansi.enabled</code>设置为支持的值,从而覆盖默认检测.<br>使用<code>％clr</code>转换字配置颜色编码.最简单的形式,转换器通过日志级别来对输出进行上色,如下所示:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%clr(%5p)</span><br></pre></td></tr></table></figure>
下面的表格描述的是日志级别和对应的颜色:<table>
<thead>
<tr>
<th>日志级别</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td><code>FATAL</code></td>
<td>红色</td>
</tr>
<tr>
<td><code>ERROR</code></td>
<td>红色</td>
</tr>
<tr>
<td><code>WARN</code></td>
<td>黄色</td>
</tr>
<tr>
<td><code>INFO</code></td>
<td>绿色</td>
</tr>
<tr>
<td><code>DEBUG</code></td>
<td>绿色</td>
</tr>
<tr>
<td><code>TRACE</code></td>
<td>绿色</td>
</tr>
<tr>
<td>同样,转换也提供了配置项,可以用来指定颜色或者风格.比如,想要让文本是黄色,可以如下设置:</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;yellow&#125;</span><br></pre></td></tr></table></figure>
支持下面的颜色和风格:<ul>
<li><code>blue</code></li>
<li><code>cyan</code></li>
<li><code>faint</code></li>
<li><code>green</code></li>
<li><code>magenta</code></li>
<li><code>red</code></li>
<li><code>yellow</code></li>
</ul>
</li>
</ol>
</li>
<li><h6 id="文件输出-File-Output"><a href="#文件输出-File-Output" class="headerlink" title="文件输出(File Output)"></a>文件输出(File Output)</h6><p>默认情况下,Spring Boot只会在控制台输出日志,并不会写到配置文件中.如果想要控制台输出之外,将日志写入到日志文件中,需要设置<code>logging.file.name</code>或者<code>logging.file.path</code>属性(比如在<code>application.properties</code>中配置).<br>下面的表格描述了<code>logging.*</code>属性可以怎样搭配使用:</p>
<table>
<thead>
<tr>
<th><strong>logging.file.name</strong></th>
<th><strong>logging.file.path</strong></th>
<th><strong>例子</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>(none)</em></td>
<td><em>(none)</em></td>
<td></td>
<td>只在控制台输出.</td>
</tr>
<tr>
<td>指定文件名</td>
<td>(none)</td>
<td><code>my.log</code></td>
<td>日志写入到指定文件中.文件路径可以是绝对路径,相对路径</td>
</tr>
<tr>
<td><em>(none)</em></td>
<td>指定目录</td>
<td><code>/var/log</code></td>
<td>将<code>spring.log</code>写入到指定目录.可以是绝对路径或者相对路径.</td>
</tr>
<tr>
<td>日志文件达到10 MB时会循环,并且与控制台输出一样,默认情况下会记录<code>ERROR</code>级别,<code>WARN</code>级别和<code>INFO</code>级别的消息.</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>​    日志配置与实际的日志记录基础结构无关.因此,Spring Boot不会管理特定的配置属性（例如Logback的<code>logback.configurationFile</code>）.</p>
</blockquote>
</li>
<li><h6 id="文件旋转-File-Rotation"><a href="#文件旋转-File-Rotation" class="headerlink" title="文件旋转(File Rotation)"></a>文件旋转(File Rotation)</h6><p>如果使用Logback,可以使用<code>application.properties</code>或<code>application.yaml</code>配置微调log rotation.对于其他的日志系统,需要手动直接配置rotation的配置.(比如,如果使用Log4J2,可以添加一个<code>log4j.xml</code>).</p>
<p>下面是支持的rotation策略:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>logging.logback.rollingpolicy.file-name-pattern</code></td>
<td>创建日志存档的文件名</td>
</tr>
<tr>
<td>`logging.logback.rollingpolicy.clean-history-on-start</td>
<td>应在应用程序启动时进行日志归档清理</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.max-file-size</code></td>
<td>归档前日志文件的最大大小.</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.total-size-cap</code></td>
<td>删除日志存档之前可以使用的最大值.</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.max-history</code></td>
<td>保留日志存档的天数（默认为7）</td>
</tr>
</tbody></table>
</li>
<li><h6 id="日志级别-Log-Levels"><a href="#日志级别-Log-Levels" class="headerlink" title="日志级别(Log Levels)"></a>日志级别(Log Levels)</h6><p>对于所有的支持日志系统,都可以在Spring <code>Environment</code>(比如<code>application.properties</code>)中使用<code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code>. 其中<code>level</code>指的是<code>TRACE</code>,<code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code>,<code>FATAL</code> <code>OFF</code>. <code>root</code>logger可以使用<code>logging.level.root</code>进行配置.</p>
<p>下面的例子展示了在<code>application.properties</code>中的配置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.root</span>=<span class="string">warn</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.web</span>=<span class="string">debug</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate</span>=<span class="string">error</span></span><br></pre></td></tr></table></figure>

<p>也可以使用环境变量来配置日志等级.比如,<code>LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG</code>,将会把<code>org.springframework.web</code>设置为<code>DEBUG</code>.</p>
<blockquote>
<p>注意:</p>
<p>​    上面的方法只能适用于包级别的日志.因为relaxed 绑定总是把环境变量转成小写,这样就无法为单个类配置日志.如果想要给一个类配置日志,可以使用<code>SPRING_APPLICATION_JSON</code>变量.</p>
</blockquote>
</li>
<li><h6 id="日志组-Log-Groups"><a href="#日志组-Log-Groups" class="headerlink" title="日志组(Log Groups)"></a>日志组(Log Groups)</h6><p>能够将相关logger组合在一起通常可以很有用,以便可以同时配置所有logger. 例如,您可能通常会更改所有与Tomcat相关的记录器的记录级别,但是您不容易记住顶层软件包.</p>
<p>为了解决这个问题,Spring Boot允许您在Spring <code>Environment</code>中定义日志记录组.例如,以下是通过将“ tomcat”组添加到<code>application.properties</code>来定义它的方法：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.group.tomcat</span>=<span class="string">org.apache.catalina,org.apache.coyote,org.apache.tomcat</span></span><br></pre></td></tr></table></figure>

<p>定义过后,可以如下改变logger的入职级别:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.tomcat</span>=<span class="string">trace</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot包含以下预定义的日志记录组,它们可以直接使用:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>Loggers</th>
</tr>
</thead>
<tbody><tr>
<td>web</td>
<td><code>org.springframework.core.codec</code>,<code>org.springframework.http</code>,<code>org.springframework.web</code>,<code>org.springframework.boot.actuate.endpoint.web</code>,<code>org.springframework.boot.web.servlet.ServletContextInitializerBeans</code></td>
</tr>
<tr>
<td>sql</td>
<td><code>org.springframework.jdbc.core</code>,<code>org.hibernate.SQL</code>,<code>org.jooq.tools.LoggerListener</code></td>
</tr>
</tbody></table>
</li>
<li><h6 id="使用使用日志关闭hook-Using-a-Log-Shutdown-Hook"><a href="#使用使用日志关闭hook-Using-a-Log-Shutdown-Hook" class="headerlink" title="使用使用日志关闭hook (Using a Log Shutdown Hook)"></a>使用使用日志关闭hook (Using a Log Shutdown Hook)</h6><p>为了在应用程序终止时释放logger资源,提供了一个关闭hook,该hook将在JVM退出时触发日志系统清理.只要应用不是以war文件形式部署,shutdown hook会自动注册.如果应用有一个复杂的context曾姐姐后,那么shutdown hook未必能够满足需求. 如果不是,禁用shutdown hook,并调查基础日志系统直接提供的选项.例如,Logback提供了上下文选择器,该选择器允许在其自己的上下文中创建每个Logger.可以使用<code>logging.register-shutdown-hook</code>属性禁用关闭挂钩.将其设置为<code>false</code>将禁用注册. 可以在<code>application.properties</code>或<code>application.yaml</code>文件中设置属性:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.register-shutdown-hook</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="自定义日志配置-Custom-Log-Configuration"><a href="#自定义日志配置-Custom-Log-Configuration" class="headerlink" title="自定义日志配置(Custom Log Configuration)"></a>自定义日志配置(Custom Log Configuration)</h6><p>可以通过在类路径上包含适当的库来激活各种日志记录系统,并可以通过在类路径的根目录或以下Spring <code>Environment</code>属性指定的位置中提供适当的配置文件来进一步自定义日志文件：<code>logging.config</code>.</p>
<p>您可以通过使用<code>org.springframework.boot.logging.LoggingSystem</code>系统属性,来强制Spring Boot使用特定的日志记录系统. 该值应该是<code>LoggingSystem</code>实现的完全限定的类名. 您也可以使用<code>none</code>完全禁用Spring Boot的日志记录配置.</p>
<blockquote>
<p>注意:</p>
<p>​    由于日志记录是在创建<code>ApplicationContext</code>之前初始化的,因此无法从Spring <code>@Configuration</code>文件中的<code>@PropertySources</code>控制日志记录. 更改日志记录系统或完全禁用它的唯一方法是通过系统属性.</p>
</blockquote>
<p>根据您的日志记录系统,将加载以下文件：</p>
<table>
<thead>
<tr>
<th>日志系统</th>
<th>自定义</th>
</tr>
</thead>
<tbody><tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, <code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code>或者<code>log4j2.xml</code></td>
</tr>
<tr>
<td>JDK (Java Util Logging)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody></table>
<blockquote>
<p>注意:</p>
<p>​    如果可能,我们建议您在日志配置中使用-spring变体（例如,logback-spring.xml而不是logback.xml）.如果使用标准配置位置,Spring将无法完全控制日志初始化.</p>
<p>警告:</p>
<p>​    从“可执行jar”运行时，Java Util Logging存在一些已知的类加载问题，这些问题会导致问题。 建议在“可执行jar”运行时,尽可能避免使用它。</p>
</blockquote>
<p>为了帮助进行定制，如下表所述，一些其他属性从Spring <code>Environment</code>转移到System属性：</p>
<table>
<thead>
<tr>
<th><strong>Spring Environment</strong></th>
<th><strong>System Property</strong></th>
<th><strong>注释</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>logging.exception-conversion-word</code></td>
<td><code>LOG_EXCEPTION_CONVERSION_WORD</code></td>
<td>记录异常时使用的转换字。</td>
</tr>
<tr>
<td><code>logging.file.name</code></td>
<td><code>LOG_FILE</code></td>
<td>如果定义，它将在默认日志配置中使用。</td>
</tr>
<tr>
<td><code>logging.file.path</code></td>
<td><code>LOG_PATH</code></td>
<td>如果定义，它将在默认日志配置中使用。</td>
</tr>
<tr>
<td><code>logging.pattern.console</code></td>
<td><code>CONSOLE_LOG_PATTERN</code></td>
<td>控制台上使用的日志模式（stdout）。</td>
</tr>
<tr>
<td><code>logging.pattern.dateformat</code></td>
<td><code>LOG_DATEFORMAT_PATTERN</code></td>
<td>记录日期格式的添加模式。</td>
</tr>
<tr>
<td><code>logging.charset.console</code></td>
<td><code>CONSOLE_LOG_CHARSET</code></td>
<td>用于控制台日志记录的字符集。</td>
</tr>
<tr>
<td><code>logging.pattern.file</code></td>
<td><code>FILE_LOG_PATTERN</code></td>
<td>文件中使用的日志模式（如果启用<code>LOG_FILE</code>）。</td>
</tr>
<tr>
<td><code>logging.charset.file</code></td>
<td><code>FILE_LOG_CHARSET</code></td>
<td>用于文件记录的字符集（如果启用了<code>LOG_FILE</code>）。</td>
</tr>
<tr>
<td><code>logging.pattern.level</code></td>
<td><code>LOG_LEVEL_PATTERN</code></td>
<td>渲染日志级别时使用的格式（默认为<code>％5p</code>）。</td>
</tr>
<tr>
<td><code>PID</code></td>
<td><code>PID</code></td>
<td>当前进程ID（如果发现并且尚未将其定义为OS环境变量时）。</td>
</tr>
</tbody></table>
<p>如果您使用的是Logback，还将转换以下属性：</p>
<table>
<thead>
<tr>
<th><strong>Spring Environment</strong></th>
<th><strong>System Property</strong></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>logging.logback.rollingpolicy.file-name-pattern</code></td>
<td><code>LOGBACK_ROLLINGPOLICY_FILE_NAME_PATTERN</code></td>
<td>滚动日志文件名的模式（默认<code>$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;.%i.gz</code>).</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.clean-history-on-start</code></td>
<td><code>LOGBACK_ROLLINGPOLICY_CLEAN_HISTORY_ON_START</code></td>
<td>是否在启动时清除存档日志文件.</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.max-file-size</code></td>
<td><code>LOGBACK_ROLLINGPOLICY_MAX_FILE_SIZE</code></td>
<td>最大日志文件大小。</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.total-size-cap</code></td>
<td><code>LOGBACK_ROLLINGPOLICY_TOTAL_SIZE_CAP</code></td>
<td>要保留的日志备份的总大小。</td>
</tr>
<tr>
<td><code>logging.logback.rollingpolicy.max-history</code></td>
<td><code>LOGBACK_ROLLINGPOLICY_MAX_HISTORY</code></td>
<td>要存档的日志备份的总大小。</td>
</tr>
</tbody></table>
<p>所有受支持的日志记录系统在解析其配置文件时都可以查阅系统属性。 有关示例，请参见<code>spring-boot.jar</code>中的默认配置：</p>
<ul>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml">Logback</a></li>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml">Log4j 2</a></li>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties">Java Util logging</a></li>
</ul>
<blockquote>
<p>建议:</p>
<p>​    如果要在日志记录属性中使用占位符，则应使用Spring Boot的语法而不是基础框架的语法.值得注意的是，如果使用Logback，则应使用<code>：</code>作为属性名称与其默认值之间的分隔符，而不应使用<code>:-</code>.</p>
<p>建议:</p>
<p>​    您可以通过重写<code>LOG_LEVEL_PATTERN</code>（或者使用<code>Logback</code>的<code>logging.pattern.level</code>）来将MDC和其他临时内容添加到日志行.例如，如果使用<code>logging.pattern.level = user:％X&#123;user&#125;％5p</code>，则默认日志格式包含“user”的MDC条目（如果存在），如以下示例所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;2019-08-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller</span><br><span class="line">&gt;Handling authenticated request</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
</li>
<li><h6 id="Logback扩展-Logback-Extensions"><a href="#Logback扩展-Logback-Extensions" class="headerlink" title="Logback扩展(Logback Extensions)"></a>Logback扩展(Logback Extensions)</h6>Spring Boot包含许多Logback扩展,可以帮助进行高级配置.您可以在<code>logback-spring.xml</code>配置文件中使用这些扩展.<blockquote>
<p>注意:</p>
<p>​    由于标准<code>logback.xml</code>配置文件加载得太早，因此不能在其中使用扩展。 需要使用<code>logback-spring.xml</code>或定义<code>logging.config</code>属性.</p>
<p>警告:</p>
<p>​    这些扩展不能与Logback的配置扫描一起使用.如果尝试这样做，则对配置文件进行更改会导致类似于以下记录之一的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]</span><br><span class="line">&gt;ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><h5 id="带指定profile的的配置"><a href="#带指定profile的的配置" class="headerlink" title="带指定profile的的配置"></a>带指定profile的的配置</h5>通过<code>&lt;springProfile&gt;</code>标签，您可以根据激活的Spring profile,来有选择地引入或排除部分配置.在<code>&lt;configuration&gt;</code>元素内的任何位置都支持配置profile.使用name属性指定那个profile应用这些配置.<code>&lt;springProfile&gt;</code>标签可以包含profile名（例如,<code>staging</code>）或profile表达式.使用profile表达式能够表达更复杂的关于profile的逻辑.比如<code>production &amp; (eu-central | eu-west)</code>.有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/core.html#beans-definition-profiles-java">参考指南</a> 。 以下清单显示了三个样本概要文件:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev | staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;!production&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="环境属性-Environment-Properties"><a href="#环境属性-Environment-Properties" class="headerlink" title="环境属性(Environment Properties)"></a>环境属性(Environment Properties)</h6><code>&lt;springProperty&gt;</code>标签,可以从Spring <code>Environment</code>中属性的属性，暴露给Logback使用.如果想从<code>Logback</code>配置中访问<code>application.properties</code>文件中的值，这样做很有用.该标签的工作方式类似于<code>Logback</code>的标准<code>&lt;property&gt;</code>标签.但是，不是直接指定<code>value</code>，而是指定了属性的<code>source</code>（来自<code>Environment</code>）.如果需要将属性存储在<code>local</code>范围以外的其他位置，则可以使用<code>scope</code>属性.如果需要备用值（如果未在<code>Environment</code>中设置该属性），则可以使用<code>defaultValue</code>属性.以下示例显示如何公开在Logback中使用的属性：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fluentHost&quot;</span> <span class="attr">source</span>=<span class="string">&quot;myapp.fluentd.host&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">defaultValue</span>=<span class="string">&quot;localhost&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FLUENT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remoteHost</span>&gt;</span>$&#123;fluentHost&#125;<span class="tag">&lt;/<span class="name">remoteHost</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>    <code>source</code>必须在短横线形式下指定（例如<code>my.property-name</code>）.但是,可以使用relaxed规则将属性添加到<code>Environment</code>中.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>第四篇,Spring Boot之外部化配置</title>
    <url>/posts/45157.html</url>
    <content><![CDATA[<h5 id="外部化配置"><a href="#外部化配置" class="headerlink" title="外部化配置"></a>外部化配置</h5><ol start="2">
<li><h5 id="外部化配置-1"><a href="#外部化配置-1" class="headerlink" title="外部化配置"></a>外部化配置</h5>​    Spring Boot允许外部化配置,这样就可以让同一份代码运行在不同环境上.可以使用很多外部配置源,包括Java属性配置文件,YAML文件,环境变量和命令行参数.<br>​    属性值可以直接使用 <code>@Value</code>注入,可以通过Spring的<code>Environment</code>获取,或者通过<code>@ConfigurationProperties</code>绑定到结构化文件中.<br>​    Spring Boot使用一个非常特殊的<code>PropertySource</code>顺序,从而能够合理地覆盖属性值.配置按照如下顺序考虑(靠下元素的值覆盖靠上元素的值):<ol>
<li>默认配置(由指定<code>SpringApplication.setDefaultProperties</code>的)</li>
<li>在<code>@Configuration</code>配置类上的<code>@PropertySource</code>导入的属性.<br>要注意,这样的属性源只有在应用上下文刷新过后,才会被加入<code>Environment</code>中. 对于一些特定的属性来说,这个时间点配置的太晚了.(比如<code>logging.*</code>和<code>spring.main.*</code>都是在刷新开始前读取的)</li>
<li>配置数据(比如<code>application.properties</code>文件)</li>
<li>只有<code>random.*</code>属性的<code>RandomValuePropertySource</code>源</li>
<li>系统环境变量</li>
<li>Java系统变量(<code>System.getProperties()</code>)</li>
<li>来自<code>java:comp/env</code>的属性</li>
<li><code>ServletContext</code>的初始化参数</li>
<li><code>ServletConfig</code>初始化参数</li>
<li>来自<code>SPRING_APPLICATION_JSON</code>的属性(嵌入到环境变量或系统属性中的内联JSON)</li>
<li>命令行参数</li>
<li>测试中的<code>properties</code>属性</li>
<li>测试上的<code>@TestPropertySource</code>注解</li>
<li>开启devtools 时,<code>$HOME/.config/spring-boot</code>目录下的DevTools的全局配置.<br>配置数据文件按照如下顺序:</li>
<li>打包在jar中的应用配置(<code>application.properties</code>和YAML变量)</li>
<li>打包在jar中的指定profile的应用配置文件(<code>application-&#123;profile&#125;.properties</code>和YAML变量)</li>
<li>在打包jar外的应用配置(<code>application.properties</code>和YAML变量)</li>
<li>在打包jar外的指定profile的应用配置文件(<code>application-&#123;profile&#125;.properties</code>和YAML变量)<blockquote>
<p>注意:</p>
<p>建议在整个应用中,使用一种形式的配置.如果在同样的位置同时有<code>.properties</code>和<code>.yml</code>格式的文件,<code>.properties</code>的配置优先.<br>​    提供一个具体的例子,假设正在开发一个<code>@Componet</code>, 使用一个<code>name</code>属性,如下所示:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span>    <span class="keyword">private</span> String name;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>
​    在应用的classpth中(比如在jar中),有一个<code>application.properties</code>,提供了一个<code>name</code>的合理的默认值. 当运行在一个新的环境中,可以在jar的外部提供一个<code>application.properties</code>来覆盖默认的<code>name</code>.对于一次性测试,可以使用特定的命令行参数来切换(比如,<code>java -jar app.jar --name=&quot;Spring&quot;</code>)<blockquote>
<p>建议:</p>
<p>​    <code>env</code>和<code>configprops</code>端点在确定为什么一个属性值是特定的值得时候会很有用.可以使用这两端点去诊断不再预期内的值.</p>
</blockquote>
</li>
<li><h6 id="访问命令行参数"><a href="#访问命令行参数" class="headerlink" title="访问命令行参数"></a>访问命令行参数</h6>​    默认情况下,<code>SpringApplication</code>会把所有的命令行选项参数转换成<code>property</code>并添加到Spring的<code>Environment</code>中.命令行选项参数就是是以<code>--</code>开头的,比如<code>--server.port=9000</code>. 就像之前提到的,命令行参数总是优先于文件属性源.<br>​    如果不想将命令行属性添加到<code>Environment</code>中,可以使用<code>SpringApplication.setAddCommandLineProperties(false)</code>来禁用.</li>
<li><h5 id="JSON应用参数"><a href="#JSON应用参数" class="headerlink" title="JSON应用参数"></a>JSON应用参数</h5>​    环境变量和系统变量经常会有很多限制,这意味着有一些属性名不能使用.为了应对这种情况,<br>Spring Boot允许将属性编码成单个JSON结构.<br>​    当应用启动时,所有的<code>spring.application.json</code>或者<code>SPRING_APPLICATION_JSON</code>属性都会被解析,并且添加到<code>Environment</code>.<br>​    比如,在UN*X shell中,可以将在命令行<code>SPRING_APPLICATION_JSON</code>作为环境变量提供.如下:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> SPRING_APPLICATION_JSON=<span class="string">&#x27;&#123;&quot;my&quot;:&#123;&quot;name&quot;:&quot;test&quot;&#125;&#125;&#x27;</span> java -jar myapp.jar</span></span><br></pre></td></tr></table></figure>
在之前的例子中,在Spring<code>Environment</code>中以<code>my.name=test</code>结尾.使用JSON同样也可以作为系统变量提供.如下:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -Dspring.application.json=<span class="string">&#x27;&#123;&quot;my&quot;:&#123;&quot;name&quot;:&quot;test&quot;&#125;&#125;&#x27;</span> -jar myapp.jar</span></span><br></pre></td></tr></table></figure>
或者可以将使用命令行参数,提供JSON<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myapp.jar --spring.application.json=<span class="string">&#x27;&#123;&quot;my&quot;:&#123;&quot;name&quot;:&quot;test&quot;&#125;&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure>
如果将应用部署到传统的应用服务器上,可以使用叫做<code>java:comp/env/spring.application.json</code>的JNDI变量<blockquote>
<p>注意:</p>
<p>​    尽管JSON中的<code>null</code>会被添加到属性源中,但是<code>PropertySourcesPropertyResolver</code>将<code>null</code>当做一个不存的值.这意味着在更低顺序的JSON属性源不会用<code>null</code>去覆盖已有属性.</p>
</blockquote>
</li>
<li><h5 id="外部应用属性"><a href="#外部应用属性" class="headerlink" title="外部应用属性"></a>外部应用属性</h5>​    当应用启动时,Spring Boot会从以下目录中,自动找到并加载<code>application.properties</code>和<code>application.yaml</code>文件.<ol>
<li>classpath根路径</li>
<li>classpath下的<code>/config</code>包</li>
<li>当前路径</li>
<li>当年目录中的<code>/config</code>子目录</li>
<li><code>/ config</code>子目录的直接子目录<br>以上按照优先级排序(数字小的条目覆盖前面的).来自加载文件的文档作为<code>PropertySources</code>添加到Spring的<code>Environment</code>.<br>​    如果不喜欢<code>application</code>作为配置文件名,可以使用<code>spring.config.name</code>环境属性来更改文件名.也可以使用<code>spring.config.location</code>显式应用环境属性(这是目录位置或文件路径的逗号分隔列表).下面的例子展示如何指定一个不同的名字.<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myproject.jar --spring.config.name=myproject</span></span><br></pre></td></tr></table></figure>
下面例子展示,如何指定两个路径:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myproject.jar --spring.config.location=\</span></span><br><span class="line"><span class="bash">    optional:classpath:/default.properties,\</span></span><br><span class="line"><span class="bash">    optional:classpath:/override.properties</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    如果这些目录是可选的,而并不要求 一定存在,那么可以使用使用<code>optional:</code>前缀.</p>
<p>警告:</p>
<p>​    <code>spring.config.name</code>,<code>spring.config.location</code>,<code>spring.config.additional-location</code>在很早时候就用指定载入那些文件. 这些必须被定义为环境变量属性(通常为系统环境变量,系统属性,或者命令行参数.)<br>如果<code>spring.config.location</code>包含目录(相对于文件),目录必须以<code>/</code>或者取决于系统的<code>File.separator</code>结尾. 在运行时,加载前,将会依照<code>spring.config.name</code>生成的名称来加载这些文件.  如果<code>spring.config.location</code>含有文件,那么就按照原样使用.<br>无论是直接指定还是放到目录中,文件引用必须包含文件扩展名. 最典型的开箱即用的扩展名是<code>.properties</code>,<code>.yaml</code>,<code>.yml</code>.<br>当指定了多个文件领,后面一个可以覆盖前一个的值.<br>通过<code>spring.config.location</code>配置的路径可以覆盖默认的路径.比如,<code>spring.config.location</code>配置是<code>optional:classpath:/custom-config/,optional:file:./custom-config/</code>,完整路径应该是下面这样的:</p>
</blockquote>
</li>
<li><code>optional:classpath:custom-config/</code></li>
<li><code>optional:file:./custom-config/</code><br>如果想要选择添加额外路径,而不是替换原有的,可以使用<code>spring.config.additional-location</code>. 来自其他目录的属性文件可以覆盖默认的路径.比如,如果<code>spring.config.additional-location</code>配置的值是<code>optional:classpath:/custom-config/,optional:file:./custom-config/</code>.那么完整的路径应该是下面这样:</li>
<li><code>optional:classpath:</code></li>
<li><code>optional:classpath:/config/</code></li>
<li><code>optional:file:./</code></li>
<li><code>optional:file:./config/</code></li>
<li><code>optional:file:./config/*/</code></li>
<li><code>optional:classpath:custom-config/</code> (additional-location)</li>
<li><code>optional:file:./custom-config/</code> (additional-location)<br>这个搜索路径能够允许开发真,在一个配置文件中指定默认值, 然后在其他的配置文件中有选择地覆盖特定值.可以在一个默认路径中,使用<code>application.properties</code>(或者其他的通过<code>spring.config.name</code>指定的默认值)为应用提供默认值.这些默认值可以在运行时被自定义的目录中的其他配置文件覆盖.<blockquote>
<p>注意:</p>
<p>​    如果使用的是环境变量而不是系统变量, 大多数操作系统不允许句点分割的key,但是可以使用下划线来替代(比如使用<code>SPRING_CONFIG_NAME</code>而不是<code>spring.config.name</code>).</p>
<p>注意:</p>
<p>​    如果应用是运行在servlet容器或者 应用服务器上,可以使用JNDI配置(在目录<code>java:comp/env</code>)或者servlet容器初始化参数,也可以使用系统变量或者环境变量.</p>
</blockquote>
</li>
<li><h6 id="可选路径"><a href="#可选路径" class="headerlink" title="可选路径"></a>可选路径</h6>默认情况下,如果指定的配置数据文件位置不存在,Spring Boot会抛出<code>ConfigDataLocationNotFoundException</code>异常,应用也不会启动.<br>如果想要指定路径,但是有不介意这个路径是否存在,可以使用<code>optional:</code>前缀.可以在<code>spring.config.location</code>和<code>spring.config.additional-location</code>中指定前缀,同样的在<code>spring.config.import</code>中也可以使用.<br>比如,在启动时,<code>spring.config.import</code>有值<code>optional:file:./myconfig.properties</code>,文件<code>myconfig.properties</code>不需要一定存在.<br>如果想要忽略所有的<code>ConfigDataLocationNotFoundExceptions</code>,并且想要继续启动应用,可以使用<code>spring.config.on-not-found</code>属性,将值设置为<code>ignore</code>. 或者使用 <code>SpringApplication.setDefaultProperties(…)</code>设置或者使用系统系统/环境边浪.</li>
<li><h6 id="带有通配符路径"><a href="#带有通配符路径" class="headerlink" title="带有通配符路径"></a>带有通配符路径</h6>如果过一个文件路径的最后部分包含<code>*</code>符号,会被认为是一个带有通配符的路径.当载入配置时,统配符会被展开,所有的子路径都会被检查.当有多个配置源,又在一些环境中,比如Kubernetes 中,带有通配符的路径将会非常有用.<br>比如,应用中有Redis和MySQL配置,可能回想将两个部分的配置分开来.,同时要求这两个都存在于<code>application.properties</code>文件中.这样就导致了从两个两个路径挂载的,两个独立的的<code>application.properties</code>,比如<code>/config/redis/application.properties</code>,<code>/config/mysql/application.properties</code>.在这个例子中,可以使用带有同通配符的路径<code>config/*/</code>,这样的话,两个路径中的文件都会被处理.<br>默认情况下,在默认搜索路径中,Spring Boot包含了<code>config/*/</code>.这意味着,在jar的外部,<code>/config</code>的所有子目录都会被搜索.<br>在<code>spring.config.location</code>和<code>spring.config.additional-location</code>属性中使用带有通配符的路径.<blockquote>
<p>注意:</p>
<p>​    带有通配符的路径只能够有一个<code>*</code>.或者检索目录形式的<code>/*</code>.或者搜索文件形式的<code>*/&lt;filename&gt;</code>. 带通配符的路径将会根据文件名的绝对路径按字母顺序排序。</p>
<p>建议:</p>
<p>​    带有通配符的路径只能够在外部文件夹使用.在<code>classpath:</code>路径下,不能够使用.</p>
</blockquote>
</li>
<li><h6 id="指定profile的文件-Profile-Specific-Files"><a href="#指定profile的文件-Profile-Specific-Files" class="headerlink" title="指定profile的文件(Profile Specific Files)"></a>指定profile的文件(Profile Specific Files)</h6>像加载应用的属性文件一样,Spring Boot也会按照<code>application-&#123;profile&#125;</code>的规约那样去加载指定profile的配置文件. 比如,如果应用想要使用YAML文件指定了一个叫做<code>prod</code>的profile,那么使用<code>application.yml</code>和<code>application-prod.yml</code>都可以.<br>指定proflie配置文件加载位置和<code>application.properties</code>相同,并且指定profile的配置会没有指定profile的配置. 入股指定了多个profile,最后被应用的会覆盖所有的.比如<code>spring.profiles.active</code>启用了<code>prod,live</code>两个profile,那么<code>application-prod.properties</code>中的值会被<code>application-live.properties</code>中对应的值覆盖.<br><code>Environment</code>有默认的profile(默认叫做<code>[default]</code>),如果没有启用profile,那么会默认使用这个profile.换句话说,没有显式激活profile,那么会使用<code>application-default</code>中的配置.<blockquote>
<p>注意:</p>
<p>​    配置文件只会被加载一次.如果已经直接导入(<code>spring.config.import</code>)了一个指定profile的配置文件,那么它不会再次导入.</p>
</blockquote>
</li>
<li><h6 id="导入其他配置-Importing-Additional-Data"><a href="#导入其他配置-Importing-Additional-Data" class="headerlink" title="导入其他配置( Importing Additional Data)"></a>导入其他配置( Importing Additional Data)</h6>使用<code>spring.config.import</code>能够让应用导入其他位置的更多的配置数据. Spring Boot发现配置了导入之后,就会进行处理, 会立即在声明导入的下面将导入的文档直接插入.<br>比如可以在classpath中的<code>application.properties</code>的文件如下:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">myapp</span></span><br><span class="line"><span class="meta">spring.config.import</span>=<span class="string">optional:file:./dev.properties</span></span><br></pre></td></tr></table></figure>
这样会触发在当前目录下面导入<code>dev.properties</code>(如果文件存在的话).<code>dev.properties</code>的配置的值将会优先于触发导入的文件.在上面的例子中,<code>dev.properties</code>可以指定定义<code>spring.application.name</code>为不同的值.无论声明多少次,导入只会被执行一次.在properties / yaml文件中的单个文档中定义导入的顺序无关紧要.比如,下面的的两个例子实际是一样:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.config.import</span>=<span class="string">my.properties</span></span><br><span class="line"><span class="meta">my.property</span>=<span class="string">value</span></span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.property</span>=<span class="string">value</span></span><br><span class="line"><span class="meta">spring.config.import</span>=<span class="string">my.properties</span></span><br></pre></td></tr></table></figure>
在上面的两个例子中,<code>my.properties</code>文件将会优先于触发导入的文件.<br>使用<code>spring.config.import</code>可以指定多个路径. 路径的载入顺序和定义顺序保持一致,后导入的优先.<blockquote>
<p>建议:</p>
<p>​    Spring Boot包含可插拔式接口,能够支持多个不同的路径地址.默认情况下,可以导入Java配置文件,YAML和配置树.</p>
<p>​    第三方jar包可以提供额外的功能支持(不要求文件是本地的).比如,配置文件从外部仓库中入到,类似Consul, Apache ZooKeeper 或者 Netflix Archaius..</p>
<p>​    如果想要支持自己的路径,可以参照<code>org.springframework.boot.context.config</code>包下的<code>ConfigDataLocationResolver</code>和<code>ConfigDataLoader</code>类.</p>
</blockquote>
</li>
<li><h6 id="导入无扩展名的文件-Importing-Extensionless-Files"><a href="#导入无扩展名的文件-Importing-Extensionless-Files" class="headerlink" title="导入无扩展名的文件(Importing Extensionless Files)"></a>导入无扩展名的文件(Importing Extensionless Files)</h6>有些云平台不支持在挂载文件上添加扩展名.导入这些没有扩展名的文件,需要给Spring Boot一些提示,让Spring Boot知道该如何去加载.可以将将扩展名提示放到<code>[]</code>中.<br>比如,想要将<code>/etc/config/myconfig</code>文件当做yaml导入.可以在<code>application.properties</code>中,使用下面的方式导入:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.config.import</span>=<span class="string">file:/etc/config/myconfig[.yaml]</span></span><br></pre></td></tr></table></figure></li>
<li><h6 id="使用配置树-Using-Configuration-Trees"><a href="#使用配置树-Using-Configuration-Trees" class="headerlink" title="使用配置树( Using Configuration Trees)"></a>使用配置树( Using Configuration Trees)</h6>在一些云平台(比如 Kubernetes)运行应用时,经常需要读取平台提供的配置.如果出于上述目的使用环境变量并不是一个常用的办法,这回有一些缺点,尤其是一些值是很民管的数据,比如密码.<br>作为替代环境变量的一种可选方式,很多云平台允许将配置映射到挂载的数据卷中.例如，Kubernetes可以批量安装ConfigMap和Secrets.<br>有两种常用的卷挂载方式:<ol>
<li>一个单独的配置文件,包含很多属性配置(一般使用YAML)</li>
<li>多个文件被写到一个树形目录中,文件名变成key,内容变成value.<br>对于第一种方式,可以直接使用<code>spring.config.import</code>导入YAML或者properties.对于第二种方式,可以使用<code>configtree</code>前缀, 使用该前缀时,Spring Boot知道需要将所有的文件都用作成properties.<br>比如,Kubernetes 如下挂载卷:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">etc/</span><br><span class="line">  config/</span><br><span class="line">    myapp/</span><br><span class="line">      username</span><br><span class="line">      password</span><br></pre></td></tr></table></figure>
文件<code>username</code>的内容应该是一个配置值,<code>password</code>文件内容应该是口令.<br>可以在<code>application.properties</code>或者<code>application.yaml</code>中导入这些属性:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.config.import</span>=<span class="string">optional:configtree:/etc/config/</span></span><br></pre></td></tr></table></figure>
然后就可以像平常一样,从<code>Environment</code>中访问或者注入<code>myapp.username</code>和<code>myapp.password</code>的值.<blockquote>
<p>建议:</p>
<p>​    也可以按照内容需要,将配置树的值同时绑定到<code>String</code>和<code>byte[]</code>类型.<br>如果在同一个父级目录下,有多个配置树需要导入,可以使用通配符的方式导入.以<code>/*/</code>结尾的<code>configtree:</code>路径,会导入所有的直接子目录为配置树.<br>比如,下面的卷:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">etc/</span><br><span class="line">  config/</span><br><span class="line">    dbconfig/</span><br><span class="line">      db/</span><br><span class="line">        username</span><br><span class="line">        password</span><br><span class="line">    mqconfig/</span><br><span class="line">      mq/</span><br><span class="line">        username</span><br><span class="line">        password</span><br></pre></td></tr></table></figure>
可以使用<code>configtree:/etc/config/*/</code>作为导入路径.<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.config.import</span>=<span class="string">optional:configtree:/etc/config/*/</span></span><br></pre></td></tr></table></figure>
这样就会增加<code>db.username</code>,<code>db.password</code>,<code>mq.username</code>, <code>mq.password</code>属性.<blockquote>
<p>注意:</p>
<p>​    使用统配符导入的路径会以字符排序. 如果需要不同的排序方式,则应将每个位置列为单独的导入.<br>配置树也可以用来配置Docker的口令.当Docker群集服务被授予对口令的访问权限时，该口令将安装到容器中.比如,如果叫做<code>db.password</code>的口令别挂载到<code>/run/secrets/</code>位置上,可以使用下面的方式来讲<code>db.password</code>添加到Spring environment中.</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.config.import</span>=<span class="string">optional:configtree:/run/secrets/</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="属性占位符-Property-Placeholders"><a href="#属性占位符-Property-Placeholders" class="headerlink" title="属性占位符( Property Placeholders)"></a>属性占位符( Property Placeholders)</h5><code>application.properties</code>和<code>application.yml</code>中的值在使用的时候,会被先有的<code>Environment</code>过滤,所以可以引用之前定义过得值(比如,来自系统属性). 标准的<code>$ &#123;name&#125;</code>属性-占位符语法可以在值中的任何位置使用.<br>举个例子,比如想要将下面文件的<code>app.description</code>设置为<code>MyApp is a Spring Boot application</code>:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="meta">app.description</span>=<span class="string">$&#123;app.name&#125; is a Spring Boot application</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    您还可以使用此技术来创建现有Spring Boot属性的“简短”变体。有关详细信息，请参见howto.html操作方法。</p>
</blockquote>
</li>
<li><h6 id="处理多文档文件-Working-with-Multi-Document-Files"><a href="#处理多文档文件-Working-with-Multi-Document-Files" class="headerlink" title="处理多文档文件(Working with Multi-Document Files)"></a>处理多文档文件(Working with Multi-Document Files)</h6>Spring Boot允许将一个物理文档分割成多个逻辑文档,每个逻辑文档独立添加.文档按照从上到下的顺序处理.后面的文档属性可以覆盖前面的.<br>对于<code>application.yml</code>文件,可以使用标准的YAML多个文档符号.三个连续的短横杠<code>---</code>表示是一个文档的结尾,也是另一个文档的开头.<br>比如,下面的文件,有两个逻辑文档:<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring.config.activate.on-cloud-platform:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">spring.application.name:</span> <span class="string">MyCloudApp</span></span><br></pre></td></tr></table></figure>
对于<code>application.properties</code>,使用一个特殊的注释<code>#---</code>来分割文档:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="meta">spring.config.activate.on-cloud-platform</span>=<span class="string">kubernetes</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">MyCloudApp</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    属性文件分隔符不得包含任何前导空格，并且必须恰好具有三个连字符。 分隔符之前和之后的行不得为注释。</p>
<p>建议:</p>
<p>​    多文档属性文件通常与激活属性（例如<code>spring.config.activate.on-profile</code>）结合使用</p>
<p>警告:</p>
<p>​    使用<code>@PropertySource</code>或<code>@TestPropertySource</code>批注无法加载多文档属性文件。</p>
</blockquote>
</li>
<li><h6 id="激活属性-Activation-Properties"><a href="#激活属性-Activation-Properties" class="headerlink" title="激活属性(Activation Properties)"></a>激活属性(Activation Properties)</h6>有时候,根据特定的条件,激活特定的属性值很有用.比如,当特定的<code>profile</code>激活时,想要激活相关的属性.<br>使用<code>spring.config.activate.*</code>可以根据条件激活属性文档.<br>有两个激活属性可用:<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>on-profile</td>
<td>符合<code>profile</code>表达式,才会激活文档</td>
</tr>
<tr>
<td>on-cloud-platform</td>
<td>符合<code>CloudPlatform</code>表达式,激活文档</td>
</tr>
<tr>
<td>比如,下面的例子,指定了第二个文档,只有当运行在Kubernetes,并且运行环境是<code>prod</code>或者<code>staging</code>的时候才会激活.</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">myprop</span>=<span class="string">always-set</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="meta">spring.config.activate.on-cloud-platform</span>=<span class="string">kubernetes</span></span><br><span class="line"><span class="meta">spring.config.activate.on-profile</span>=<span class="string">prod | staging</span></span><br><span class="line"><span class="attr">myotherprop</span>=<span class="string">sometimes-set</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="加密属性-Encrypting-Properties"><a href="#加密属性-Encrypting-Properties" class="headerlink" title="加密属性(Encrypting Properties)"></a>加密属性(Encrypting Properties)</h5>Spring Boot没有提供任何内置的支持加密属性值的支持,但是提供了一个必要回调函数点,可以修改Spring <code>Environment</code>中的值.<code>EnvironmentPostProcessor</code>可以允许在应用启动前修改<code>Environment</code>.<br>如果想要一种安全的方式来存储凭证和密码,Spring Cloud Vault项目提供了对在HashiCorp Vault中存储外部化配置的支持.</li>
<li><h5 id="使用YAML"><a href="#使用YAML" class="headerlink" title="使用YAML"></a>使用YAML</h5>YAML是JSON的超集,因此是一种用于指定层次结构配置数据的便捷格式.只要在类路径上具有SnakeYAML库，<code>SpringApplication</code>类就会自动支持YAML作为属性的替代方法。<blockquote>
<p>注意:</p>
<p>​    如果使用了”Starters”,在<code>spring-boot-starter</code>中会自动提供SnakeYAML .</p>
</blockquote>
<ol>
<li><h6 id="将YAML映射到属性-Mapping-YAML-to-Properties"><a href="#将YAML映射到属性-Mapping-YAML-to-Properties" class="headerlink" title="将YAML映射到属性(Mapping YAML to Properties)"></a>将YAML映射到属性(Mapping YAML to Properties)</h6><p>需要将YAML文档从其层次结构格式转换为可以与Spring Environment一起使用的平面结构.比如下面的YAML文档:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environments:</span></span><br><span class="line">  <span class="attr">dev:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://dev.example.com</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Developer</span> <span class="string">Setup</span></span><br><span class="line">  <span class="attr">prod:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://another.example.com</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">Cool</span> <span class="string">App</span></span><br></pre></td></tr></table></figure>
<p>为了能够从<code>Environment</code>中访问这些属性,需要铺平成如下格式:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">environments.dev.url</span>=<span class="string">https://dev.example.com</span></span><br><span class="line"><span class="meta">environments.dev.name</span>=<span class="string">Developer Setup</span></span><br><span class="line"><span class="meta">environments.prod.url</span>=<span class="string">https://another.example.com</span></span><br><span class="line"><span class="meta">environments.prod.name</span>=<span class="string">My Cool App</span></span><br></pre></td></tr></table></figure>
<p>同样的,YAML的列表也要平铺,它们用<code>[index]</code>解引用器表示为属性键.考虑下面的YAML:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line"> <span class="attr">servers:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dev.example.com</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">another.example.com</span></span><br></pre></td></tr></table></figure>

<p>上面会转换成下面:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.servers[0]</span>=<span class="string">dev.example.com</span></span><br><span class="line"><span class="meta">my.servers[1]</span>=<span class="string">another.example.com</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议:</p>
<p>​    使用<code>[index]</code>符号的属性应该使用Spring Boot的<code>binder</code>类来绑定到Java的<code>List</code>或者<code>Set</code>.</p>
<p>警告:</p>
<p>​    YAML文件不能够使用<code>@PropertySource</code>和<code>@TestPropertySource</code>注解加载.所以,如果想要使用注解导入,必须使用properties文件.</p>
</blockquote>
</li>
<li><h6 id="直接加载YAML-Directly-Loading-YAML"><a href="#直接加载YAML-Directly-Loading-YAML" class="headerlink" title="直接加载YAML(Directly Loading YAML)"></a>直接加载YAML(Directly Loading YAML)</h6><p>Spring Framework提供两个类来方便加载YAML文件.<code>YamlPropertiesFactoryBean</code>将YAML作为<code>Properties</code>加载.<code>YamlMapFactoryBean</code>将YAML作为<code>Map</code>记载.</p>
<p>如果想要baYAML作为Spring <code>PropertySource</code>,也可以使用<code>YamlPropertySourceLoader</code>类.</p>
</li>
</ol>
</li>
<li><h5 id="配置随机值-Configuring-Random-Values"><a href="#配置随机值-Configuring-Random-Values" class="headerlink" title="配置随机值(Configuring Random Values)"></a>配置随机值(Configuring Random Values)</h5> 在注入随机值时(比如到口令或者测试用例中),<code>RandomValuePropertySource</code>会很有用.可以获取整型,长整型,uuid,或者字符串类型.如下所示:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.secret</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="meta">my.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">my.bignumber</span>=<span class="string">$&#123;random.long&#125;</span></span><br><span class="line"><span class="meta">my.uuid</span>=<span class="string">$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">my.number-less-than-ten</span>=<span class="string">$&#123;random.int(10)&#125;</span></span><br><span class="line"><span class="meta">my.number-in-range</span>=<span class="string">$&#123;random.int[1024,65536]&#125;</span></span><br></pre></td></tr></table></figure>
<code>random.int*</code>的语法是<code>OPEN value (,max) CLOSE</code>.<code>OPEN,CLOSE</code>是任意字符,<code>value,max</code>是整型.如果<code>max</code>提供,那么<code>value</code>是最小值,<code>max</code>是最大值(最终结果不会包含最大值).</li>
<li><h5 id="配置系统环境属性-Configuring-System-Environment-Properties"><a href="#配置系统环境属性-Configuring-System-Environment-Properties" class="headerlink" title="配置系统环境属性(Configuring System Environment Properties)"></a>配置系统环境属性(Configuring System Environment Properties)</h5>Spring Boot支持给环境属性设置前缀.如果系统环境被多个不同配置的Spring Boot应用共享的话会有用.可以在<code>SpringApplication</code>直接设置系统环境属性.<br>比如,如果想要设置前缀是<code>input</code>,那么属性为<code>remote.timeout</code>将也会在系统环境中被解析成<code>input.remote.timeout</code>.</li>
<li><h6 id="类型安全的配置属性-Type-safe-Configuration-Properties"><a href="#类型安全的配置属性-Type-safe-Configuration-Properties" class="headerlink" title="类型安全的配置属性(Type-safe Configuration Properties)"></a>类型安全的配置属性(Type-safe Configuration Properties)</h6>使用<code>@Value(&quot;$&#123;property&#125;&quot;)</code>来注入配置有时候会非常麻烦,尤其是有多个配置文件,或则配置数据本来就是层级结构的.Spring Boot提供了另一种办法来使用配置,那就是使用一个强类型的bean来管理和验证应用的配置.<ol>
<li><h6 id="JavaBean属性绑定-JavaBean-properties-binding"><a href="#JavaBean属性绑定-JavaBean-properties-binding" class="headerlink" title="JavaBean属性绑定(JavaBean properties binding)"></a>JavaBean属性绑定(JavaBean properties binding)</h6>下面可声明并绑定JavaBean属性的一种方式:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters / setters...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.singleton(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getters / setters...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个POJO定义如下的属性:<ul>
<li><code>my.service.enabled</code>,默认值为false</li>
<li><code>my.service.remote-address</code>,可以从字符串强制转换的类型</li>
<li><code>my.service.security.username</code>,内嵌”sercurity”对象,名字由属性名决定.特别是，返回类型根本不使用，可能是<code>SecurityProperties</code>.</li>
<li><code>my.service.security.password</code></li>
<li><code>my.service.security.roles</code>,有一个<code>String</code>集合,默认值是<code>USET</code><blockquote>
<p>注意:</p>
<p>​    在Spring Boot中,可以获得映射到<code>ConfigurationProperties</code>类的属性,这些都是通过properties,YAML,环境参数等等配置的, 这些都是公开的接口,但是这个类的getters/setters不应该被直接使用.</p>
<p>注意:</p>
<p>​    这种方式依赖于默认的空构造函数，并且getter和setter通常是强制性的，因为绑定是通过标准Java Beans属性描述符进行的，就像在Spring MVC中一样。在以下情况下，可以省略setter:</p>
<ul>
<li>Map集合,因为只要初始化过后,只需要getter,不需要setter,因为可以被绑定器修改.</li>
<li>可以通过索引（通常使用YAML）或使用单个逗号分隔的值（属性）来访问集合和数组。 在后一种情况下，必须使用setter。 我们建议始终为此类类型添加setter。 如果初始化集合，请确保它是可变的（如上例所示）.</li>
<li>如果一个内部POJO属性被初始化(就像<code>Security</code>属性),不要求setter.如果想要绑定器在运行中创建实例,需要设置setter.</li>
</ul>
<p>​    有些人会使用Lombok去自动添加getter和setter.要确保Lombok没有给类生成一个特定的构造函数,构造函数会被容器用来初始化对象.</p>
<p>​    最后，仅考虑标准Java Bean属性，不支持对静态属性的绑定。</p>
</blockquote>
</li>
</ul>
</li>
<li><h6 id="构造器绑定-Constructor-binding"><a href="#构造器绑定-Constructor-binding" class="headerlink" title="构造器绑定(Constructor binding)"></a>构造器绑定(Constructor binding)</h6>上一节中的示例可以用不可变的方式重写，如以下示例所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;my.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fields...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProperties</span><span class="params">(<span class="keyword">boolean</span> enabled, InetAddress remoteAddress, Security security)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">        <span class="keyword">this</span>.remoteAddress = remoteAddress;</span><br><span class="line">        <span class="keyword">this</span>.security = security;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fields...</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Security</span><span class="params">(String username, String password, <span class="meta">@DefaultValue(&quot;USER&quot;)</span> List&lt;String&gt; roles)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">            <span class="keyword">this</span>.roles = roles;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getters...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在开头部分, <code>@ConstructorBinding</code>注解用于表明,这里应该使用构造器绑定.这意味着,绑定器去找一个希望使用的有参构造器进行绑定.<br>标有<code>@ConstructorBinding</code>类的内部成员(比如<code>Security</code>)也会通过构造器绑定.<br>可以使用<code>@DefaultValue</code>来指定默认值,也会进行强制转换,将<code>String</code>转换成未知类型的属性.默认情况下,不弱没有属性被绑到<code>Security</code>,那么将会被赋予<code>null</code>.如果希望即使没有对应的属性绑定到<code>Security</code>上,返回一个不是null的实例,可以使用无参的<code>@DefaultValue</code>的注解:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyProperties</span><span class="params">(<span class="keyword">boolean</span> enabled, InetAddress remoteAddress, <span class="meta">@DefaultValue</span> Security security)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    <span class="keyword">this</span>.remoteAddress = remoteAddress;</span><br><span class="line">    <span class="keyword">this</span>.security = security;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    开启构造器绑定,必须使用<code>@EnableConfigurationProperties</code>或者配置属性搜索.对于有常规的Spring机制(<code>@Component</code>)创建的bean,通过<code>@Bean</code>方式,或者带有<code>@Import</code>的bean,都可以使用构造器注入.</p>
<p>建议:</p>
<p>​    如果类中有多个构造器,那么可以使用<code>@ConstructorBinding</code>来指定应该使用哪一个构造器绑定.</p>
<p>注意:</p>
<p>​    不建议将<code>java.util.Optional</code>与<code>@ConfigurationProperties</code>一起使用，因为它主要旨在用作返回类型.因此，它不太适合配置属性注入.为了与其他类型的属性保持一致，如果声明了Optional属性并且没有任何值，则将绑定null而不是空的Optional.</p>
</blockquote>
</li>
<li><h6 id="启用-ConfigurationProperties注释的类-Enabling-ConfigurationProperties-annotated-types"><a href="#启用-ConfigurationProperties注释的类-Enabling-ConfigurationProperties-annotated-types" class="headerlink" title="启用@ConfigurationProperties注释的类(Enabling @ConfigurationProperties-annotated types)"></a>启用@ConfigurationProperties注释的类(Enabling @ConfigurationProperties-annotated types)</h6>Spring Boot提供了绑定<code>@ConfigurationProperties</code>类型并将其注册为Bean的基础架构.可以逐类启用配置属性，也可以启用与组件扫描类似的方式进行配置属性扫描.<br>有时，用<code>@ConfigurationProperties</code>注释的类可能不适用于扫描，例如，如果您正在开发自己的自动配置，或者想要有条件地启用它们. 在这些情况下,请使用<code>@EnableConfigurationProperties</code>注解指定要处理的类型列表.可以在任何<code>@Configuration</code>类上完成此操作，如以下示例所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SomeProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
要使用配置属性扫描,将<code>@ConfigurationPropertiesScan</code>批注添加到应用程序.通常，它被添加到以<code>@SpringBootApplication</code>标注的主应用程序类中，但是可以将其添加到任何<code>@Configuration</code>类中.默认情况下,将从声明注解的类的包中进行扫描。 如果要定义要扫描的特定程序包，可以按照以下示例所示进行操作：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ConfigurationPropertiesScan(&#123; &quot;com.example.app&quot;, &quot;com.example.another&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    使用配置文件扫描或通过<code>@EnableConfigurationProperties</code>注册<code>@ConfigurationProperties</code>Bean时，该Bean具有常规名称：<prefix>-<fqn>，其中<prefix>是<code>@ConfigurationProperties</code>中指定的,<fqn> 是Bean的完全限定名称。 如果注解没有提供不提供任何前缀，则仅使用Bean的完全限定名称.</p>
<p>在例子中的bean的name是<code>com.example.app-com.example.app.SomeProperties</code><br>推荐只在处理环境时使用<code>@ConfigurationProperties</code>,特别的,不要注入context中的其他bean.对于极端情况,可以使用setter注入,或者任何由framework提供的<code>*Aware</code>的接口(比如<code>EnvironmentAware</code>,如果需要访问<code>Environment</code>).如果还是想要使用构造器注入其他的bean,配置属性的Bean必须使用<code>@Componet</code>注解和使用基于JavaBean的属性绑定.</p>
</blockquote>
</li>
<li><h6 id="使用-ConfigurationProperties注解的类-Using-ConfigurationProperties-annotated-types"><a href="#使用-ConfigurationProperties注解的类-Using-ConfigurationProperties-annotated-types" class="headerlink" title="使用@ConfigurationProperties注解的类(Using @ConfigurationProperties-annotated types)"></a>使用@ConfigurationProperties注解的类(Using @ConfigurationProperties-annotated types)</h6>这种配置风格特别适合与SpringApplication外部YAML配置一起使用,如下:<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">        <span class="attr">remote-address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">        <span class="attr">security:</span></span><br><span class="line">            <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">            <span class="attr">roles:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">USER</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">ADMIN</span></span><br></pre></td></tr></table></figure>
要使用<code>@ConfigurationProperties</code>Bean，可以像使用其他任何Bean一样注入它们，如以下示例所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SomeProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(SomeProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server(<span class="keyword">this</span>.properties.getRemoteAddress());</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    使用<code>@ConfigurationProperties</code>还可以让您生成元数据文件，IDE可以使用这些元数据文件为您自己的键提供自动完成功能</p>
</blockquote>
</li>
<li><h6 id="第三方配置-Third-party-Configuration"><a href="#第三方配置-Third-party-Configuration" class="headerlink" title="第三方配置(Third-party Configuration)"></a>第三方配置(Third-party Configuration)</h6>除了使用<code>@ConfigurationProperties</code>注释类之外，您还可以在公共@Bean方法上使用它。 当您要将属性绑定到控件之外的第三方组件时，这样做特别有用。<br>要从Environment属性配置Bean，请将<code>@ConfigurationProperties</code>添加到其Bean注册中，如以下示例所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdPartyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;another&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnotherComponent <span class="title">anotherComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnotherComponent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
用<code>another</code>前缀定义的任何JavaBean属性都以类似于前面的<code>SomeProperties</code>示例的方式映射到该<code>AnotherComponent</code> bean.</li>
<li><h6 id="Relaxed-Binding-松散绑定"><a href="#Relaxed-Binding-松散绑定" class="headerlink" title="Relaxed Binding(松散绑定?)"></a>Relaxed Binding(松散绑定?)</h6>Spring Boot使用一些relax rules将<code>Environment</code>属性绑定到<code>@ConfigurationProperties</code>bean,因此，<code>Environment</code>属性名称和Bean属性名称之间不需要完全匹配.有用的常见示例包括破折号分隔的环境属性（例如，<code>context-path</code>绑定到<code>contextPath</code>）和大写的环境属性（例如<code>PORT</code>绑定到<code>port</code>）<br>作为示例，请参考以下<code>@ConfigurationProperties</code>类：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my.main-project.person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPersonProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用前面的代码，可以全部使用以下属性名称：<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>my.main-project.person.first-name</code></td>
<td>短横线形式,建议在.properties和.yml文件中使用。</td>
</tr>
<tr>
<td><code>my.main-project.person.firstName</code></td>
<td>标准驼峰命名</td>
</tr>
<tr>
<td><code>y.main-project.person.first_name</code></td>
<td>下划线表示法，是.properties和.yml文件中使用的另一种格式。</td>
</tr>
<tr>
<td><code>MY_MAINPROJECT_PERSON_FIRSTNAME</code></td>
<td>大写格式，在使用系统环境变量时建议使用。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意:</p>
<p>​    注解使用的前缀的值<code>prefix</code>必须是短横杠线的形式(全部都是小写,并使用<code>-</code>分隔,比如<code>my.main-project.person</code>).</p>
</blockquote>
每个配置源的松散绑定规则<table>
<thead>
<tr>
<th>属性源</th>
<th>简单类型</th>
<th>List类型</th>
</tr>
</thead>
<tbody><tr>
<td>Properties</td>
<td>驼峰,短横线,下划线</td>
<td>使用<code>[]</code>或者用逗号分隔</td>
</tr>
<tr>
<td>YAML</td>
<td>驼峰,短横线,下划线</td>
<td>YAML列表语法或者逗号分隔</td>
</tr>
<tr>
<td>环境变量</td>
<td>下划线作为定界符的大写格式</td>
<td>下划线括起来的数值</td>
</tr>
<tr>
<td>系统属性</td>
<td>驼峰,短横线,下划线</td>
<td>使用<code>[]</code>或者用逗号分隔</td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>​    如果可以的话,推荐属性应该以小写短横线形式,比如<code>my.person.first-name=Rod</code></p>
</blockquote>
<ul>
<li><p>绑定Map(Binding Maps)</p>
<p>绑定到Map属性时,可能需要使用特殊的括号符号，以便保留原始key.如果key没有被<code>[]</code>包围，则所有非字母数字字符<code>-</code>或<code>.</code> 被删除。</p>
<p>例如，考虑将以下属性绑定到<code>Map &lt;String，String&gt;</code>：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.map.[/key1]</span>=<span class="string">value1</span></span><br><span class="line"><span class="meta">my.map.[/key2]</span>=<span class="string">value2</span></span><br><span class="line"><span class="meta">my.map./key3</span>=<span class="string">value3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>​    对于YAML文件，方括号必须用引号引起来，以便正确解析key。</p>
</blockquote>
<p>上面的<code>/ key1</code>，<code>/ key2</code>和<code>key3</code>属性作为Map中的key绑定到Map上.<code>key3</code>的斜杠会被从key中移除,以为它没有被<code>[]</code>包裹.</p>
<p>如果<code>key</code>中包含一个<code>.</code>,那么就需要使用方括号来包裹,此时正在绑定一个非标量的值.比如,绑定<code>a.b=c</code>到<code>Map&lt;String, Object&gt;</code>上,在Map中会添加<code>&#123;&quot;a&quot;=&#123;&quot;b&quot;=&quot;c&quot;&#125;&#125;</code>. 但是如果绑定<code>[a.b]=c</code>,那么<code>&#123;&quot;a.b&quot;=&quot;c&quot;&#125;</code>将会被添加到Map中.</p>
</li>
<li><p>从环境变量绑定(Binding from Environment Variables)</p>
<p>很多操作系统严格限制环境变量的变量名.比如Linux的shell变量只能包含字符(<code>a</code> to <code>z</code> or <code>A</code> to <code>Z</code>), 数字(<code>0</code> to <code>9</code>) ,或者使用下划线的字符(<code>_</code>).按照规范,Unix 的shell变量应该使用大写形式变量名.</p>
<p>Spring Boot的relaxed绑定规则在设计的时候,就尽可能的与这些命名约束想兼容.</p>
<p>要将规范形式的属性名称转换为环境变量名称,可以遵循以下规则：</p>
<ul>
<li>使用下划线(<code>_</code>)替换点(<code>.</code>)</li>
<li>移除短横线(<code>-</code>)</li>
<li>转换成大写.</li>
</ul>
<p>比如,配置属性<code>spring.main.log-startup-info</code>转换成环境变量形式应该是<code>SPRING_MAIN_LOGSTARTUPINFO</code>.</p>
<p>环境变量也可以用来绑定到对象list中.为了绑定<code>List</code>,变量名中的元素号应该使用下划线包围.</p>
<p>比如,配置属性<code>my.service[0].other</code>,应该使用<code>MY_SERVICE_0_OTHER</code>变量名.</p>
</li>
</ul>
</li>
<li><h6 id="合并复杂类型-Merging-Complex-Types"><a href="#合并复杂类型-Merging-Complex-Types" class="headerlink" title="合并复杂类型(Merging Complex Types)"></a>合并复杂类型(Merging Complex Types)</h6>如果在多个位置配置了list，则通过替换整个list来进行覆盖。<br>比如,假设有一个<code>MyPojo</code>对象,有<code>name</code>和<code>description</code>两个属性,属性的默认值位<code>null</code>.下面的例子展示了<code>MyProperties</code>中的<code>MyPojo</code>的list.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MyPojo&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;MyPojo&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
考虑下面的配置:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.list[0].name</span>=<span class="string">my name</span></span><br><span class="line"><span class="meta">my.list[0].description</span>=<span class="string">my description</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="meta">spring.config.activate.on-profile</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">my.list[0].name</span>=<span class="string">my another name</span></span><br></pre></td></tr></table></figure>
如果<code>dev</code>的profile没有被启用,那么 <code>MyProperties.list</code> 只有一个<code>MyPojo</code>,就像上面定义的那样.如果<code>dev</code>的profile启用,那么<code>list</code>中还是只有一个元素(name是<code>my another name</code>,description是<code>null</code>).这个配置没有增加第二个<code>MyPojo</code>到list中,也没有融合元素.<br>当<code>List</code>在多个profile中指定时,只有优先级最高的那个会被使用.考虑下面的例子:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.list[0].name</span>=<span class="string">my name</span></span><br><span class="line"><span class="meta">my.list[0].description</span>=<span class="string">my description</span></span><br><span class="line"><span class="meta">my.list[1].name</span>=<span class="string">another name</span></span><br><span class="line"><span class="meta">my.list[1].description</span>=<span class="string">another description</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="meta">spring.config.activate.on-profile</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">my.list[0].name</span>=<span class="string">my another name</span></span><br></pre></td></tr></table></figure>
在之前的例子中,如果<code>dev</code>profile启用,那么<code>MyProperties.list</code>只有一个<code>MyPojo</code>元素(name是<code>my another name</code>,description 是<code>null</code>).比如YAML,逗号分隔列表和YAML列表均可用于完全覆盖列表的内容.<br>对于<code>Map</code>属性,可以从多个数据源绑定值.但是,对于在多个源的同一个属性,只会使用优先级最高的那个.下面的例子展示了<code>MyProperties</code>中的<code>Map&lt;String, MyPojo&gt;</code>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MyPojo&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, MyPojo&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
考虑接下来的配置文件:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">my.map.key1.name</span>=<span class="string">my name 1</span></span><br><span class="line"><span class="meta">my.map.key1.description</span>=<span class="string">my description 1</span></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="meta">spring.config.activate.on-profile</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">my.map.key1.name</span>=<span class="string">dev name 1</span></span><br><span class="line"><span class="meta">my.map.key2.name</span>=<span class="string">dev name 2</span></span><br><span class="line"><span class="meta">my.map.key2.description</span>=<span class="string">dev description 2</span></span><br></pre></td></tr></table></figure>
如果<code>dev</code>profile没有激活,<code>MyProperties.map</code>只包含一个元素<code>key1</code>(name是<code>my name 1</code>,description是 <code>my description 1</code>).如果<code>dev</code>profile启用,那么<code>map</code>将会包含两个元素<code>key1</code>(name为<code>dev name 1</code>,description为<code>my description 1</code>), <code>key2</code>(name为<code>dev name 2</code>和description 为<code>dev description 2</code>).<blockquote>
<p>注意:</p>
<p>​    前面的合并规则不仅适用于文件，还适用于所有属性源中的属性。</p>
</blockquote>
</li>
<li><h6 id="属性转换-Properties-Conversion"><a href="#属性转换-Properties-Conversion" class="headerlink" title="属性转换(Properties Conversion)"></a>属性转换(Properties Conversion)</h6>当属性绑定到 <code>@ConfigurationProperties</code> bean上时,Spring Boot会将外部应用属性配置强制类型转换到正确的类型.如果想要自定义转换的话,可以提供一个<code>ConversionService</code>bean(bean的name为<code>conversionService</code>),或者自定义的属性编辑器(通过<code>CustomEditorConfigurer</code>),或者一个自定的<code>Converters</code>(使用<code>@ConfigurationPropertiesBinding</code>注解标注的bean).<blockquote>
<p>注意:</p>
<p>​    由于在应用程序生命周期中非常早就请求了此bean,因此请确保限制<code>ConversionService</code>使用的依赖项.通常, 您需要的任何依赖项可能在创建时未完全初始化.如果没有配置的key要强制类型转换,可能需要重命名自定义的<code>ConversionService</code>,只需要使用<code>@ConfigurationPropertiesBinding</code>.自定义转换器.</p>
</blockquote>
<h6 id="转换时间-Converting-Durations"><a href="#转换时间-Converting-Durations" class="headerlink" title="转换时间(Converting Durations)"></a>转换时间(Converting Durations)</h6>Spring Boot为表达持续时间提供了专门的支持。 如果使用<code>java.time.Duration</code>属性，则应用程序属性中的以下格式可用：<ul>
<li>常规的<code>Long</code>表示形式（使用毫秒作为默认单位，除非已指定<code>@DurationUnit</code>）</li>
<li><code>java.time.Duration</code>使用的标准ISO-8601格式</li>
<li>数值和时间单位相结合的,更易读的格式（例如10s表示10秒）<br>考虑下面的例子:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DurationUnit(ChronoUnit.SECONDS)</span></span><br><span class="line">    <span class="keyword">private</span> Duration sessionTimeout = Duration.ofSeconds(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Duration readTimeout = Duration.ofMillis(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters / setters...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
表示一个30s的回话,<code>30</code>,<code>PT30S</code>,<code>30s</code>都是相同的. 使用<code>500</code>,<code>PT0.5S</code>或者<code>500ms</code>的任何一种形式,都可以指定超时时间为500ms.<br>也可以使用任何受支持的时间单位,如下:</li>
<li><code>ns</code> 纳秒</li>
<li><code>us</code> 微秒</li>
<li><code>ms</code>  毫秒</li>
<li><code>s</code>    秒</li>
<li><code>m</code>    分钟</li>
<li><code>h</code>    小时</li>
<li><code>d</code>    天<br>默认的时间单位是毫秒,可以使用<code>@DurationUnit</code>修改.正如上面的例子那样.<br>如果选择的是构造器绑定, 属性也可以使用.如下所示<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fields...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProperties</span><span class="params">(<span class="meta">@DurationUnit(ChronoUnit.SECONDS)</span> <span class="meta">@DefaultValue(&quot;30s&quot;)</span> Duration sessionTimeout,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@DefaultValue(&quot;1000ms&quot;)</span> Duration readTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sessionTimeout = sessionTimeout;</span><br><span class="line">        <span class="keyword">this</span>.readTimeout = readTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    如果要升级<code>Long</code>属性，不是字节单位,要确保指定单位（使用<code>@DurationUnit</code>）。 这样做可以提供透明的升级路径，同时支持更丰富的格式。</p>
</blockquote>
<h6 id="转换日期-Converting-periods"><a href="#转换日期-Converting-periods" class="headerlink" title="转换日期(Converting periods)"></a>转换日期(Converting periods)</h6>除了时间之外,Spring Boot也使用了<code>java.time.Period</code>类型.下面是可以在<code>application.properties</code>中使用的格式:</li>
<li>常规的int表示形式（使用天作为默认单位，除非已指定<code>@PeriodUnit</code>）</li>
<li><code>java.time.Period</code>使用的标准ISO-8601格式</li>
<li>数值和单位组合的更简单格式（例如<code>1y3d</code>表示1年零3天）<br>在简单格式中,支持下面的单位:</li>
<li><code>y</code> 年</li>
<li><code>m</code> 月</li>
<li><code>w</code> 日</li>
<li><code>d</code> 天<blockquote>
<p>注意:</p>
<p><code>java.time.Period</code>类型从不实际存储星期数，是表示7天的简写.</p>
</blockquote>
<h6 id="转换数据大小-Converting-Data-Sizes"><a href="#转换数据大小-Converting-Data-Sizes" class="headerlink" title="转换数据大小(Converting Data Sizes)"></a>转换数据大小(Converting Data Sizes)</h6>Spring Framework有个<code>DataSize</code>数值类型,用来字节来表示大小.如果想要有个<code>DataSize</code>属性,在应用配置中,可以使用下面的格式:</li>
<li>常规的Long表示形式（除非已指定<code>@DataSizeUnit</code>，否则使用字节作为默认单位）</li>
<li>数值和单位组成的更可读的格式(例如10MB表示10兆字节).<br>考虑下面的例子:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DataSizeUnit(DataUnit.MEGABYTES)</span></span><br><span class="line">    <span class="keyword">private</span> DataSize bufferSize = DataSize.ofMegabytes(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSize sizeThreshold = DataSize.ofBytes(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters/setters...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用<code>10</code>或者<code>10M</code>来指定<code>bufferSize</code>为10兆字节都是一样的效果.可以使用<code>256</code>或者<code>256B</code>来指定<code>sizeThreshold</code>为256字节.<br>可以使用如下支持的单位:</li>
<li><code>B</code> for bytes</li>
<li><code>KB</code> for kilobytes</li>
<li><code>MB</code> for megabytes</li>
<li><code>GB</code> for gigabytes</li>
<li><code>TB</code> for terabytes<br>默认的单位是字节,可以使用<code>@DataSizeUnit</code>来修改,就像上面的例子.<br>如果是选择构造器绑定,也可使用同样的属性.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my&quot;)</span></span><br><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fields...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProperties</span><span class="params">(<span class="meta">@DataSizeUnit(DataUnit.MEGABYTES)</span> <span class="meta">@DefaultValue(&quot;2MB&quot;)</span> DataSize bufferSize,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@DefaultValue(&quot;512B&quot;)</span> DataSize sizeThreshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bufferSize = bufferSize;</span><br><span class="line">        <span class="keyword">this</span>.sizeThreshold = sizeThreshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    如果要升级Long属性，如果原来的单位不是字节,确保定义单位（使用<code>@DataSizeUnit</code>）。 这样做可以提供透明的升级路径，同时支持更丰富的格式。</p>
</blockquote>
</li>
</ul>
</li>
<li><h6 id="ConfigurationProperties校验-Validation"><a href="#ConfigurationProperties校验-Validation" class="headerlink" title="@ConfigurationProperties校验(Validation)"></a><code>@ConfigurationProperties</code>校验(Validation)</h6>当使用了<code>@Validated</code>注解,Spring Boot会尝试检验<code>@ConfigurationProperties</code>标注的类.可以在配置类上直接使用<code>JSR-303 javax.validation</code>约束注解.为此，确保您的类路径上有兼容的JSR-303实现，然后将约束注解添加到字段中，如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my.service&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters/setters...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议:</p>
<p>​    可以在标有 <code>@Bean</code>的创建配置属性的方法上,添加<code>@Validated</code>,来触发校验.<br>为确保始终为嵌套属性触发验证，即使未找到任何属性，也必须使用<code>@Valid</code>注解相关的字段.下面的示例基于前面的<code>MyProperties</code>示例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my.service&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters/setters...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotEmpty</span></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getters/setters...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以添加一个叫做<code>configurationPropertiesValidator</code>的bean,来添加一个自定义的<code>Validator</code>.<code>@Bean</code>方法必须声明为静态方法.配置属性的validator在应用生命周期的很早期就被创建,将<code>@Bean</code>方法声明为静态方法是为了创建bean的时候,不需要去初始化<code>@Configuration</code>类.这样做避免了由早期实例化引起的任何问题.<blockquote>
<p>建议:</p>
<p>​    <code>spring-boot-actuator</code>模块包含一个端点，该端点公开了所有<code>@ConfigurationProperties</code> Bean.用浏览器访问<code>/actuator/configprops</code>或则使用同样的JMX端点.</p>
</blockquote>
</li>
<li><h6 id="对比-ConfigurationProperties-与-Value"><a href="#对比-ConfigurationProperties-与-Value" class="headerlink" title="对比@ConfigurationProperties 与. @Value"></a>对比<code>@ConfigurationProperties</code> 与. <code>@Value</code></h6><code>@Value</code>注解是容器的一个核心功能,但是不能提供具有类型安全的属性配置.下面的表哥总结了<code>@ConfigurationProperties</code>和<code>@Value</code>支持的功能:<table>
<thead>
<tr>
<th>功能</th>
<th><strong>@ConfigurationProperties</strong></th>
<th><strong>@Value</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Relaxed绑定</td>
<td>支持</td>
<td>部分支持</td>
</tr>
<tr>
<td>元数据支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><code>SpEL</code>表达式</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<blockquote>
<p>注意:</p>
<p>​    如果确实想要使用<code>@Value</code>,建议使用规范形式（例如，kebab-case只使用小写字母）来引用属性名. 这将允许Spring Boot使用与Relaxed绑定<code>@ConfigurationProperties</code>时相同的逻辑.比如,<code>@Value(&quot;&#123;demo.item-price&#125;&quot;)</code>会选择<code>demo.item-price</code>,和<code>application.properties</code>文件中的<code>demo.itemPrice</code>格式,和系统环境中的<code>DEMO_ITEMPRICE</code>.如果使用的是<code>@Value(&quot;&#123;demo.itemPrice&#125;&quot;)</code>, <code>demo.item-price</code>和<code>DEMO_ITEMPRICE</code>不会使用.<br>如果相位自己的组件配置属性key,推荐使用<code>@ConfigurationProperties</code>将他们按组编入的POJO中.这样做,可以在bean中注入一个结构化,类型安全的队形.<br>在解析这些文件并填充环境时，不会处理来自应用程序属性文件的<code>SpEL</code>表达式。但是在<code>@Value</code>中使用<code>SpEL</code>.如果应用程序属性文件中属性的值是<code>SpEL</code>表达式，则在通过@Value进行使用时将对其进行评估.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>第九篇,Spring Boot之开发Web应用</title>
    <url>/posts/5461.html</url>
    <content><![CDATA[<h5 id="开发web应用-Developing-Web-Applications"><a href="#开发web应用-Developing-Web-Applications" class="headerlink" title="开发web应用(Developing Web Applications)"></a>开发web应用(Developing Web Applications)</h5><p>   Spring Boot非常适合于Web应用程序开发.可以使用嵌入式Tomcat,Jetty,Undertow或Netty创建独立的HTTP服务器..大多数Web应用程序都使用<code>spring-boot-starter-web</code>模块来快速启动和运行.还可以选择使用<code>spring-boot-starter-webflux</code>模块构建反应式Web应用程序.</p>
<ol>
<li><h6 id="SpringMVC-The-“Spring-Web-MVC-Framework”"><a href="#SpringMVC-The-“Spring-Web-MVC-Framework”" class="headerlink" title="SpringMVC(The “Spring Web MVC Framework”)"></a>SpringMVC(The “Spring Web MVC Framework”)</h6>Spring Web MVC框架(通常称为” Spring MVC”)是一个丰富的”模型 视图 控制器” Web框架. Spring MVC使可以创建<code>@Controller</code>或<code>@RestController</code>Bean来处理传入的HTTP请求.使用<code>@RequestMapping</code>注解将controller中的方法映射到HTTP.<br>以下代码显示了提供JSON数据的典型<code>@RestController</code>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerRepository customerRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRestController</span><span class="params">(UserRepository userRepository, CustomerRepository customerRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">        <span class="keyword">this</span>.customerRepository = customerRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userRepository.findById(userId).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;user&#125;/customers&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userRepository.findById(userId).map(<span class="keyword">this</span>.customerRepository::findByUser).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository.deleteById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><h6 id="Spring-MVC自动配置-Spring-MVC-Auto-configuration"><a href="#Spring-MVC自动配置-Spring-MVC-Auto-configuration" class="headerlink" title="Spring MVC自动配置(Spring MVC Auto-configuration)"></a>Spring MVC自动配置(Spring MVC Auto-configuration)</h6>Spring Boot为Spring MVC提供了自动配置,可与大多数应用程序一起良好使用.<br>自动配置在Spring的默认设置之上添加了以下功能:<ul>
<li>包含<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>Bean</li>
<li>支持服务静态资源,包括对WebJars的支持</li>
<li>自动注册<code>Converter</code>,<code>GenericConverter</code>和<code>Formatter</code>Bean</li>
<li>支持<code>HttpMessageConverters</code></li>
<li>自动注册<code>MessageCodesResolver</code></li>
<li>静态<code>index.html</code>支持</li>
<li>自动使用<code>ConfigurableWebBindingInitializer</code>Bean<br>如果要保留这些Spring Boot MVC定制并进行更多的MVC定制(拦截器,格式化程序,视图控制器和其他功能),则可以添加自己的类型为<code>WebMvcConfigurer</code>的<code>@Configuration</code>类,但不添加<code>@EnableWebMvc</code>.<br>如果要提供<code>RequestMappingHandlerMapping</code>,<code>RequestMappingHandlerAdapter</code>或<code>ExceptionHandlerExceptionResolver</code>的自定义实例,并且仍然保留Spring Boot MVC的定制化,则可以声明<code>WebMvcRegistrations</code>类型的bean,并使用它提供这些组件的自定义实例.<br>如果要完全控制Spring MVC,则可以添加用<code>@EnableWebMvc</code>标注的自己的<code>@Configuration</code>类,或者按照<code>@EnableWebMvc</code>的Javadoc中的说明的,添加自己的<code>@Configuration</code>标注的的<code>DelegatingWebMvcConfiguration</code>类.<blockquote>
<p>注意:</p>
<p>​    Spring MVC使用的<code>ConversionService</code>与用于从<code>application.properties</code>或<code>application.yaml</code>中用来转换值的<code>ConversionService</code>不同.这意味着<code>Period</code>,<code>Duration</code>和<code>DataSize</code>转换器不可用,<code>@DurationUnit</code>和<code>@DataSizeUnit</code>注解将被忽略.<br>如果要自定义Spring MVC使用的<code>ConversionService</code>,则可以提供一个有<code>addFormatters</code>方法的<code>WebMvcConfigurer</code>bean. 通过此方法,可以注册所需的任何转换器,也可以委托给<code>ApplicationConversionService</code>上可用的静态方法.</p>
</blockquote>
</li>
</ul>
</li>
<li><h6 id="HttpMessageConverters"><a href="#HttpMessageConverters" class="headerlink" title="HttpMessageConverters"></a>HttpMessageConverters</h6>Spring MVC使用<code>HttpMessageConverter</code>接口转换HTTP请求和响应.开箱即用中包含合理的默认设置.例如,Spring Boot可以将对象自动转换为JSON(通过使用Jackson库)或XML(通过使用Jackson XML扩展(如果可用)或通过使用JAXB(如果Jackson XML扩展不可用)).默认情况下,字符串以UTF-8编码.<br>如果需要添加或自定义转换器,则可以使用Spring Boot的<code>HttpMessageConverters</code>类,如以下列表所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpMessageConvertersConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpMessageConverter&lt;?&gt; additional = <span class="keyword">new</span> AdditionalHttpMessageConverter();</span><br><span class="line">        HttpMessageConverter&lt;?&gt; another = <span class="keyword">new</span> AnotherHttpMessageConverter();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上下文中存在的所有<code>HttpMessageConverter</code> bean都将添加到转换器列表中. 您也可以用相同的方法覆盖默认转换器.</li>
<li><h6 id="自定义JSON序列化器和反序列化器-Custom-JSON-Serializers-and-Deserializers"><a href="#自定义JSON序列化器和反序列化器-Custom-JSON-Serializers-and-Deserializers" class="headerlink" title="自定义JSON序列化器和反序列化器( Custom JSON Serializers and Deserializers)"></a>自定义JSON序列化器和反序列化器( Custom JSON Serializers and Deserializers)</h6>如果使用Jackson来序列化和反序列化JSON数据,则可能要实现自己的<code>JsonSerializer</code>和<code>JsonDeserializer</code>类.自定义序列化程序通常是通过模块向Jackson注册的,但是Spring Boot提供了可选的<code>@JsonComponent</code>注解,这使得直接注册Spring Bean更加容易.您可以直接在<code>JsonSerializer</code>,<code>JsonDeserializer</code>或<code>KeyDeserializer</code>实现上使用<code>@JsonComponent</code>注解.您还可以在包含serializers/deserializers  作为内部类的类上使用它,如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJsonComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(MyObject value, JsonGenerator jgen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            jgen.writeStringField(<span class="string">&quot;name&quot;</span>, value.getName());</span><br><span class="line">            jgen.writeNumberField(<span class="string">&quot;age&quot;</span>, value.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyObject <span class="title">deserialize</span><span class="params">(JsonParser jsonParser, DeserializationContext ctxt)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">            ObjectCodec codec = jsonParser.getCodec();</span><br><span class="line">            JsonNode tree = codec.readTree(jsonParser);</span><br><span class="line">            String name = tree.get(<span class="string">&quot;name&quot;</span>).textValue();</span><br><span class="line">            <span class="keyword">int</span> age = tree.get(<span class="string">&quot;age&quot;</span>).intValue();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyObject(name, age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用Jackson时,<code>ApplicationContext</code>中的所有<code>@JsonComponent</code>bean都会自动注册. 因为<code>@JsonComponent</code>是使用<code>@Component</code>进行元注释的,所以通常的组件扫描规则适用.<br>Spring Boot还提供了<code>JsonObjectSerializer</code>和<code>JsonObjectDeserializer</code>基类,这些基类在序列化对象时为标准Jackson版本提供了有用的替代方法.<br>可以将上面的示例重写为使用<code>JsonObjectSerializer / JsonObjectDeserializer</code>,如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJsonComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> <span class="keyword">extends</span> <span class="title">JsonObjectSerializer</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">serializeObject</span><span class="params">(MyObject value, JsonGenerator jgen, SerializerProvider provider)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            jgen.writeStringField(<span class="string">&quot;name&quot;</span>, value.getName());</span><br><span class="line">            jgen.writeNumberField(<span class="string">&quot;age&quot;</span>, value.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> <span class="keyword">extends</span> <span class="title">JsonObjectDeserializer</span>&lt;<span class="title">MyObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> MyObject <span class="title">deserializeObject</span><span class="params">(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec,</span></span></span><br><span class="line"><span class="params"><span class="function">                JsonNode tree)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String name = nullSafeValue(tree.get(<span class="string">&quot;name&quot;</span>), String.class);</span><br><span class="line">            <span class="keyword">int</span> age = nullSafeValue(tree.get(<span class="string">&quot;age&quot;</span>), Integer.class);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyObject(name, age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="消息解析器-MessageCodesResolver"><a href="#消息解析器-MessageCodesResolver" class="headerlink" title="消息解析器(MessageCodesResolver)"></a>消息解析器(MessageCodesResolver)</h6>Spring MVC有一种生成error code的策略,该错误码用于当发生绑定错误时,显示错误消息:<code>MessageCodesResolver</code>.如果您设置<code>spring.mvc.message-codes-resolver-format</code>属性<code>PREFIX_ERROR_CODE</code>或<code>POSTFIX_ERROR_CODE</code>,Spring Boot会为创建一个.</li>
<li><h6 id="静态资源-Static-Content"><a href="#静态资源-Static-Content" class="headerlink" title="静态资源(Static Content)"></a>静态资源(Static Content)</h6>默认情况下,Spring Boot提供类路径中的<code>/static目录</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF / resources</code>)或<code>ServletContext</code>的根目录中静态内容.它使用Spring MVC中的<code>ResourceHttpRequestHandler</code>,所以可以通过添加自己的<code>WebMvcConfigurer</code>并覆盖<code>addResourceHandlers</code>方法来修改该行为.<br>在一个单独的Web应用程序中,容器中的默认Servlet被启用并且作为备用项.如果Spring不处理请求,那么就会从ServletContext的根目录提供内容.在大多数情况下,这不会发生(除非修改默认的MVC配置),因为Spring始终可以使用DispatcherServlet处理请求.<br>默认情况下,资源映射在<code>/**</code>上,但是您可以使用<code>spring.mvc.static-path-pattern</code>属性对其进行调整. 例如,将所有资源重定位到<code>/resources/**</code>可以如下实现:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.static-path-pattern</span>=<span class="string">/resources/**</span></span><br></pre></td></tr></table></figure>
您还可以使用<code>spring.web.resources.static-locations</code>属性来自定义静态资源路径(可以用目录位置列表替换默认值).根Servlet上下文路径<code>&quot;/&quot;</code>也会自动添加为路径.<br>除了前面提到的”标准”静态资源路径,Webjar格式也有特殊情况. 如果jar文件以Webjars格式打包,则从jar文件中提供路径为<code>/webjars/**</code>的所有资源.<blockquote>
<p>建议:</p>
<p>​    如果您的应用程序打包为jar,则不要使用<code>src/main/webapp</code>目录. 尽管此目录是一个通用标准,但它仅适用于war打包,并且如果生成jar,大多数构建工具都将其默默地忽略它.<br>Spring Boot还支持Spring MVC提供的高级资源处理功能,允许使用一些功能,例如缓存清除静态资源或在Webjars中使用版本无关的URL.<br>想要使用在Webjar中使用版本无关的URL,需要添加<code>webjars-locator-core</code>依赖.然后在Webjar中声明.比如使用JQuery,添加<code>/webjars/jquery/jquery.min.js</code>会变成<code>/webjars/jquery/x.y.z/jquery.min.js</code>,其中<code>x.y.z</code>就是Webjar的版本.<br>注意:</p>
<p>​    如果使用JBoss,则需要声明<code>webjars-locator-jboss-vfs</code>依赖,而不是<code>webjars-locator-core</code>. 否则,所有Webjar都解析为404.<br>要使用缓存清除,以下配置可为所有静态资源配置缓存清除解决方案,并在URL中有效地添加内容哈希,例如<code>&lt;link href =&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code></p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.web.resources.chain.strategy.content.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.web.resources.chain.strategy.content.paths</span>=<span class="string">/**</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    <code>ResourceUrlEncodingFilter</code>是为Thymeleaf和FreeMarker自动配置的,这可以在运行时,在模板中写入资源链接.使用JSP时,应该手动声明此过滤器. 当前尚不自动支持其他模板引擎,但可以与自定义模板<code> macros/helpers</code>一起使用,也可以与<code>ResourceUrlProvider</code>一起使用.<br>当加载动态资源时,例如,当使用JavaScript模块加载器时,不能重命名文件. 这就是为什么支持其他策略并且可以组合的原因. “fixed”策略在URL中添加静态的版本字符串,而不更改文件名,如以下示例所示:</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.web.resources.chain.strategy.content.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.web.resources.chain.strategy.content.paths</span>=<span class="string">/**</span></span><br><span class="line"><span class="meta">spring.web.resources.chain.strategy.fixed.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.web.resources.chain.strategy.fixed.paths</span>=<span class="string">/js/lib/</span></span><br><span class="line"><span class="meta">spring.web.resources.chain.strategy.fixed.version</span>=<span class="string">v12</span></span><br></pre></td></tr></table></figure>
通过这种配置,在<code>&quot;/js/lib/&quot;</code>目录下的JavaScript模块使用固定的版本控制策略(<code>&quot;/v12/js/lib/mymodule.js&quot;</code>),而其他资源仍使用内容策略(<link href =" / css / spring-2a2d595e6ed9a0b24f027f2b63b134d6.css" />).<blockquote>
<p>建议:</p>
<p>​    该功能已在专门的[博客文章][<a href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources]%E5%92%8CSpring">https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources]和Spring</a> Framework的[参考文档][<a href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/web.html#mvc-config-static-resources]%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BA%86%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E">https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/web.html#mvc-config-static-resources]中进行了详细说明</a>.</p>
</blockquote>
</li>
<li><h6 id="欢迎页面-Welcome-Page"><a href="#欢迎页面-Welcome-Page" class="headerlink" title="欢迎页面(Welcome Page)"></a>欢迎页面(Welcome Page)</h6>Spring Boot支持静态和模板两种欢迎页面. 它首先在配置的静态内容路径中查找index.html文件. 如果未找到,则寻找<code>index</code>模板. 如果找到任何一个,它将自动用作应用程序的欢迎页面.</li>
<li><h6 id="路径匹配和内容协商-Path-Matching-and-Content-Negotiation"><a href="#路径匹配和内容协商-Path-Matching-and-Content-Negotiation" class="headerlink" title="路径匹配和内容协商(Path Matching and Content Negotiation)"></a>路径匹配和内容协商(Path Matching and Content Negotiation)</h6>Spring MVC可以根据请求路径,将其映射到对应的处理器上(例如,Controller方法上的<code>@GetMapping</code>注解).<br>Spring Boot默认选择禁用后缀模式匹配,这意味着<code>&quot;GET /projects/spring-boot.json&quot;</code>之类的请求将不会映射到<code>@GetMapping(&quot;/projects/spring-boot&quot;)上</code>.这被认为是Spring MVC应用程序的最佳实践.过去,这个功能在HTTP客户端不能发送合适的”Accept请求头的时候很有用. 我们需要确保将正确的Content-Type发送给客户端. 如今,内容协商(Content Negotiation)已更可靠.<br>还有其他方法来处理不能够连续正确发送”Accept”请求头的HTTP客户端.不是使用后缀匹配,而是使用查询参数,来保证请求正确映射.<code>&quot;GET /projects/spring-boot?format=json&quot;</code>映射到<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
或者使用一个不同的参数名<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.mvc.contentnegotiation.parameter-name</span>=<span class="string">myparam</span></span><br></pre></td></tr></table></figure>
大多数标准媒体类型都可以开箱即用地支持,但也可以定义新的类型:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.contentnegotiation.media-types.markdown</span>=<span class="string">text/markdown</span></span><br></pre></td></tr></table></figure>
后缀模式匹配已被弃用,并将在以后的版本中删除. 如果了解了注意事项,但仍希望的应用程序使用后缀模式匹配,则需要以下配置:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.contentnegotiation.favor-path-extension</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.mvc.pathmatch.use-suffix-pattern</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
从Spring Framework 5.3开始,Spring MVC支持了多种实现策略,用于将请求路径匹配到Controller处理程序. 它以前仅支持<code>AntPathMatcher</code>策略,但现在还提供<code>PathPatternParser</code>. Spring Boot现在提供一个配置属性供您选择和选择新策略:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.pathmatch.matching-strategy</span>=<span class="string">path-pattern-parser</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    <code>PathPatternParser</code>是一种优化的implementation,但限制一些路径匹配变量的使用,并且与后缀模式匹配(<code>spring.mvc.pathmatch.use-suffix-pattern</code>,<code>spring.mvc.pathmatch.use-registered-suffix-pattern</code>)和将以Servlet开头的请求(<code>spring.mvc.servlet.path</code>)映射到<code>DispatcherServlet</code>不兼容.</p>
</blockquote>
</li>
<li><h6 id="ConfigurableWebBindingInitializer"><a href="#ConfigurableWebBindingInitializer" class="headerlink" title="ConfigurableWebBindingInitializer"></a>ConfigurableWebBindingInitializer</h6>Spring MVC使用<code>WebBindingInitializer</code>来为特定请求初始化<code>WebDataBinder</code>. 如果创建自己的<code>ConfigurableWebBindingInitializer</code> 的<code>@Bean</code>,Spring Boot会自动配置Spring MVC来使用它.</li>
<li><h6 id="模板引擎-Template-Engines"><a href="#模板引擎-Template-Engines" class="headerlink" title="模板引擎(Template Engines)"></a>模板引擎(Template Engines)</h6>​    除了REST Web服务之外,您还可以使用Spring MVC来提供动态HTML内容. Spring MVC支持各种模板技术,包括Thymeleaf,FreeMarker和JSP. 同样,许多其他模板引擎包括它们自己的Spring MVC集成.<br>Spring Boot包括对以下模板引擎的自动配置支持:<ul>
<li>FreeMarker</li>
<li>Groovy</li>
<li>Thymeleaf</li>
<li>Mustache<blockquote>
<p>建议:</p>
<p>​    如果可能,应避免使用JSP. 将它们与嵌入式Servlet容器一起使用时,存在几个已知的限制.<br>当您使用这些模板引擎的默认配置的时,将自动从<code>src/main/resources/templates</code>中获取模板.<br>建议:</p>
<p>​    取决于运行应用程序的方式,IDE可能不一样,比如使用classpath. 从IDE的main方法运行应用程序选择路径,与使用Maven或Gradle或从打包的jar运行应用程序时选择的路径可能会不一样. 这可能导致Spring Boot无法找到期望中的模板. 如果遇到此问题,可以在IDE中重新设置类路径,以首先放置模块的类和资源.</p>
</blockquote>
</li>
</ul>
</li>
<li><h6 id="错误处理-Error-Handling"><a href="#错误处理-Error-Handling" class="headerlink" title="错误处理(Error Handling)"></a>错误处理(Error Handling)</h6>默认情况下,Spring Boot提供了一个<code>/error</code>映射,用来以合理的方式处理所有错误,并且它已在servlet容器中注册为全局的错误页面.对于机器客户端,它将生成JSON响应,其中包含错误,HTTP状态和异常消息的详细信息. 对于浏览器客户端,会显示一个”whitelabel”错误视图,显示相同的错误数据(要对其进行自定义,请添加一个可解析<code>error</code>的<code>View</code>).<br>如果要自定义默认错误处理行为,有很多<code>server.error</code>属性,可以设置.<br>如果想完全替换默认行为,可以实现<code>ErrorController</code>并注册该类型的bean,或者添加类型为<code>ErrorAttributes</code>的bean来使用现有机制,但是替换其内容.<blockquote>
<p>建议:</p>
<p>​    <code>BasicErrorController</code>可用作自定义<code>ErrorController</code>的基类. 如果您想为新的Content-type添加处理程序(默认是专门处理text / html并为其他所有内容提供后备功能),则此功能特别有用. 为此,继承<code>BasicErrorController</code>,添加具有<code>@ProductMapping</code>且具有<code>Produces</code>属性的公共方法,并创建新类型的Bean.</p>
</blockquote>
您还可以定义一个带有<code>@ControllerAdvice</code>注解的类,去设置指定的controller或者exception返回JSON格式格式内容,可以如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(basePackageClasses = SomeController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerAdvice</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MyException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) &#123;</span><br><span class="line">        HttpStatus status = getStatus(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> MyErrorBody(status.value(), ex.getMessage()), status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HttpStatus <span class="title">getStatus</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Integer code = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);</span><br><span class="line">        HttpStatus status = HttpStatus.resolve(code);</span><br><span class="line">        <span class="keyword">return</span> (status != <span class="keyword">null</span>) ? status : HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在前面的示例中,如果<code>SomeController</code>包中抛出了<code>MyException</code> ,则将使用自定义错误类型的JSON形式返回,而不是<code>ErrorAttributes</code>形式.<br>在某些情况下, <a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.supported.spring-mvc">metrics infrastructure</a>不会记录在控制器级别被处理的错误. 可以将处理的异常设为request attribute,那么就可以确保将此类异常被记录在 metrics infrastructure中.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(CustomException.class)</span></span><br><span class="line">    <span class="function">String <span class="title">handleCustomException</span><span class="params">(HttpServletRequest request, CustomException ex)</span> </span>&#123;</span><br><span class="line">        request.setAttribute(ErrorAttributes.ERROR_ATTRIBUTE, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;errorView&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="自定义错误处理页面-Custom-Error-Pages"><a href="#自定义错误处理页面-Custom-Error-Pages" class="headerlink" title="自定义错误处理页面(Custom Error Pages)"></a>自定义错误处理页面(Custom Error Pages)</h6>如果要给定状态代码显示自定义HTML错误页面,可以在<code>/error</code>目录下添加错误文件. 错误页面可以是静态HTML(即添加到任何静态资源目录下),也可以使用模板来构建. 文件名应为准确的状态码或系列掩码.<br>例如,要将404映射到静态HTML文件,您的目录结构如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- public/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure>
要讲所有的<code>5xx</code>错误映射到FreeMarker模板上,目录结构如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.ftlh</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure>
对于更复杂的映射,还可以添加实现<code>ErrorViewResolver</code>接口的bean,如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorViewResolver</span> <span class="keyword">implements</span> <span class="title">ErrorViewResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use the request or status to optionally return a ModelAndView</span></span><br><span class="line">        <span class="keyword">if</span> (status == HttpStatus.INSUFFICIENT_STORAGE) &#123;</span><br><span class="line">            <span class="comment">// We could add custom model values here</span></span><br><span class="line">            <span class="keyword">new</span> ModelAndView(<span class="string">&quot;myview&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
您还可以使用常规的Spring MVC功能,例如<code>@ExceptionHandler</code>方法和<code>@ControllerAdvice</code>. 然后,<code>ErrorController</code>获得所有未处理的异常.<h6 id="映射Spring-MVC之外的错误页面-Mapping-Error-Pages-outside-of-Spring-MVC"><a href="#映射Spring-MVC之外的错误页面-Mapping-Error-Pages-outside-of-Spring-MVC" class="headerlink" title="映射Spring MVC之外的错误页面(Mapping Error Pages outside of Spring MVC)"></a>映射Spring MVC之外的错误页面(Mapping Error Pages outside of Spring MVC)</h6>对于没有Spring MVC的应用,可以使用<code>ErrorPageRegistrar</code>接口直接注册<code>ErrorPages</code>. 此抽象接口直接与基础嵌入式servlet容器一起使用,即使您没有Spring MVC <code>DispatcherServlet</code>,它也可以使用.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorPagesConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorPageRegistrar <span class="title">errorPageRegistrar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>::registerErrorPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="string">&quot;/400&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:</p>
<p>​    如果您注册了一个最终由过滤器处理的路径(这在某些非Spring Web框架(如Jersey和Wicket)中很常见)的错误页面,则必须将过滤器显式注册为<code>ERROR</code>dispatcher,如 下面的例子:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilterConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;MyFilter&gt; <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyFilter&gt; registration = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;(<span class="keyword">new</span> MyFilter());</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意,默认的<code>FilterRegistrationBean</code>不包含<code>ERROR</code>dispatcher.<h6 id="在war部署中处理错误"><a href="#在war部署中处理错误" class="headerlink" title="在war部署中处理错误"></a>在war部署中处理错误</h6>当部署到servlet容器时,Spring Boot使用错误页面过滤器将具有错误状态的请求转发到适当的错误页面.这是很有必须的,因为Servlet规范没有提供用于注册错误页面的API.根据war文件部所署到的容器以及应用程序使用的技术,可能需要一些其他配置.<br>如果response尚未提交,则错误页面过滤器只能将请求转发到正确的错误页面.缺省情况下,WebSphere Application Server 8.0及更高版本在成功完成servlet的服务方法后提交响应.您应该通过将<code>com.ibm.ws.webcontainer.invokeFlushAfterService</code>设置为<code>false</code>来禁用此行为.<br>如果您使用的是Spring Security,并且想访问基本的错误页面,则必须配置Spring Security的过滤器,从而在分发错误的时候,过滤器能够被调用.为此,要将<code>spring.security.filter.dispatcher-types</code>属性设置为<code>async</code>,<code>error</code>,<code>forward</code>,<code>request</code>.</li>
<li><h6 id="Spring-HATEOAS"><a href="#Spring-HATEOAS" class="headerlink" title="Spring HATEOAS"></a>Spring HATEOAS</h6>如果使用超媒体开发RESTful API,Spring Boot为Spring HATEOAS提供自动配置能够适用于大多数应用. 使用自动配置,就不用使用<code>@EnableHypermediaSupport</code>,并且还注册了很多的bean,从而更容器构建基于超媒体的引用,包括<code>LinkDiscoverers</code>(用于支持客户端),还有一个配置过的<code>ObjectMapper</code>将response转换成想要的形式.通过设置很多的<code>spring.jackson.*</code>属性 来配置<code>ObjectMapper</code>,或者也可以使用<code>Jackson2ObjectMapperBuilder</code>.<br>可以使用<code>@EnableHypermediaSupport</code>来配置Spring HATEOAS.要注意,这样做之前要禁用<code>ObjectMapper</code>的自定义.</li>
<li><h6 id="跨域资源共享支持-CORS-Support"><a href="#跨域资源共享支持-CORS-Support" class="headerlink" title="跨域资源共享支持(CORS Support)"></a>跨域资源共享支持(CORS Support)</h6>跨域资源共享(CORS)是W3C规范,大多数浏览器都实现了该规范.这个规范可以以一种更灵活的方式来指定那些跨域请求要被验证,而不是式样一些安全性更低,功能更弱的方式,比如IFRAME 和JSONP.<br>在4.2的版本中,Spring MVC支持了CORS. 不需要任何额外配置,只需要应用中的controller方法上使用<code>@CrossOrigin</code>注解就可以.可以通过注册一个实现<code>WebMvcConfigurer</code>bean,使用<code>addCorsMappings(CorsRegistry)</code>方法来实现全局的CORS配置.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCorsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/api/**&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="Spring-WebFlux框架-The-“Spring-WebFlux-Framework”"><a href="#Spring-WebFlux框架-The-“Spring-WebFlux-Framework”" class="headerlink" title="Spring WebFlux框架(The “Spring WebFlux Framework”)"></a>Spring WebFlux框架(The “Spring WebFlux Framework”)</h5>Spring WebFlux是Spring Framework5.0的新的响应式网络框架.不同于Spring MVC,它并不需要Servlet API,是完全异步非阻塞的.通过Reacotr project实现了Reactive Streams.<br>Spring WebFlux有两种风格:函数式和基于注解式.基于注解式和Spring MVC的模式,如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerRepository customerRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRestController</span><span class="params">(UserRepository userRepository, CustomerRepository customerRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">        <span class="keyword">this</span>.customerRepository = customerRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userRepository.findById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;user&#125;/customers&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userRepository.findById(userId).flatMapMany(<span class="keyword">this</span>.customerRepository::findByUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository.deleteById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
“WebFlux.fn”,是函数式的变种,它将路由配置从请求的实际处理分离开来.如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRoutingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">monoRouterFunction</span><span class="params">(MyUserHandler userHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> route(</span><br><span class="line">                GET(<span class="string">&quot;/&#123;user&#125;&quot;</span>).and(ACCEPT_JSON), userHandler::getUser).andRoute(</span><br><span class="line">                GET(<span class="string">&quot;/&#123;user&#125;/customers&quot;</span>).and(ACCEPT_JSON), userHandler::getUserCustomers).andRoute(</span><br><span class="line">                DELETE(<span class="string">&quot;/&#123;user&#125;&quot;</span>).and(ACCEPT_JSON), userHandler::deleteUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUserCustomers</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">deleteUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
WebFlux是Spring Framework框架的一部分.可以看看相关参考文档.<blockquote>
<p>建议:</p>
<p>​    可以根据需要定义任意数量的<code>RouterFunction</code>bean,从而对路由进行模块化. 如果需要使用优先级,可以对bean进行设置顺序.<br>开始前,要再应用中添加<code>spring-boot-starter-webflux</code>:<br>注意:</p>
<p>​    如果再应用中同时配置了,<code>spring-boot-starter-web</code>和<code>spring-boot-starter-webflux</code>,那么应用会默认配置使用<code>Spring MVC</code>,而不是WebFlux. 之所以会这样,是因为很多开发者添加<code>spring-boot-starter-webflux</code>到Spring MVC项目中来使用响应式的<code>WebClient</code>.也可以使用<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code>来强制设置应用程序的类型.</p>
</blockquote>
<ol>
<li><h6 id="Spring-WebFlux的自动配置-Spring-WebFlux-Auto-configuration"><a href="#Spring-WebFlux的自动配置-Spring-WebFlux-Auto-configuration" class="headerlink" title="Spring WebFlux的自动配置(Spring WebFlux Auto-configuration)"></a>Spring WebFlux的自动配置(Spring WebFlux Auto-configuration)</h6>Spring Boot提供的Spring WebFlux的自动配置和很多应用都可以良好配合使用.自动配置在Spring的默认设置之上添加了以下功能:<ul>
<li>为HttpMessageReader和HttpMessageWriter实例配置编解码器</li>
<li>支持服务静态内容,包括对WebJar的支持<br>如果想要保留现有的Spring Boot WebFlux功能,并且想要添加额外的功能配,可以添加<code>@Configuration</code>标注的<code>WebFluxConfigurer</code>类但是<em><strong>不使用</strong></em><code>@EnableWebFlux</code>.<br>如果想要彻底控制Spring WebFlux,可以使用<code>@EnableWebFlux</code>标注的<code>@Configuration</code>类.</li>
</ul>
</li>
<li><h6 id="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器-HTTP-Codecs-with-HttpMessageReaders-and-HttpMessageWriters"><a href="#带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器-HTTP-Codecs-with-HttpMessageReaders-and-HttpMessageWriters" class="headerlink" title="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器(HTTP Codecs with HttpMessageReaders and HttpMessageWriters)"></a>带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器(HTTP Codecs with HttpMessageReaders and HttpMessageWriters)</h6>Spring WebFlux使用<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>接口来转换HTTP请求和响应.通过判断在classpath中是否存在这两个库,使用<code>CodecConfigurer</code>来为他们配置了合理的默认配置.<br>Spring Boot为编解码器提供了配置属性,<code>spring.codec.*</code>.它还通过使用<code>CodecCustomizer</code>实例应用进一步的自定义.例如,<code>spring.jackson.*</code>配置key被应用于Jackson编解码器上.<br>如果需要添加或自定义编解码器,则可以创建一个自定义<code>CodecCustomizer</code>组件,如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCodecsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CodecCustomizer <span class="title">myCodecCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (configurer) -&gt; &#123;</span><br><span class="line">            configurer.registerDefaults(<span class="keyword">false</span>);</span><br><span class="line">            configurer.customCodecs().register(<span class="keyword">new</span> ServerSentEventHttpMessageReader());</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="静态内容-Static-Content"><a href="#静态内容-Static-Content" class="headerlink" title="静态内容(Static Content)"></a>静态内容(Static Content)</h6>默认情况下,Spring Boot从类路径中名为<code>/static</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>)的目录中提供静态内容.使用的是Spring WebFlux的<code>ResourceWebHandler</code>,因此可以通过添加自己的<code>WebFluxConfigurer</code>和重写<code>addResourceHandlers</code>方法来修改行为.<br>默认情况下,资源映射在<code>/**</code> 上,但是可以通过设置<code>spring.webflux.static-path-pattern</code>属性来对其进行调整. 例如,将所有资源重定位到<code>/resources/**</code>可以实现如下:<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.webflux.static-path-pattern</span>=<span class="string">/resources/**</span></span><br></pre></td></tr></table></figure>
您还可以使用<code>spring.web.resources.static-locations</code>自定义静态资源位置.这样做会将默认值替换为目录路径列表.如果这样做,将会在自定义路径中检测默认欢迎页面. 因此,如果启动时任何一个路径下有index.html,则它是应用程序的主页.<br>除了前面列出的”标准”静态资源路径外,Webjar内容有特殊情况. 如果jar文件以Webjars格式打包,则服务jar文件中路径为<code>/webjars/**</code>的所有资源.<blockquote>
<p>建议:</p>
<p>​    Spring WebFlux应用程序不依赖Servlet API,因此不能将它们部署为war文件,也不要使用<code>src/main/webapp</code>目录.</p>
</blockquote>
</li>
<li><h6 id="欢迎页面-Welcome-Page-1"><a href="#欢迎页面-Welcome-Page-1" class="headerlink" title="欢迎页面(Welcome Page)"></a>欢迎页面(Welcome Page)</h6>Spring Boot支持静态和模板欢迎页面. 它首先在配置的静态内容路径中查找<code>index.html</code>文件. 如果未找到,则寻找<code>index</code>模板. 如果找到任何一个,就默认作为应用程序的欢迎页面.</li>
<li><h6 id="模板引擎-Template-Engines-1"><a href="#模板引擎-Template-Engines-1" class="headerlink" title="模板引擎(Template Engines)"></a>模板引擎(Template Engines)</h6>除了REST Web服务之外,您还可以使用Spring WebFlux来提供动态HTML内容. Spring WebFlux支持各种模板技术,包括Thymeleaf,FreeMarker和Mustache.<br>Spring Boot对以下模板引擎支持自动配置:<ul>
<li><a href="https://freemarker.apache.org/docs/">FreeMarker</a></li>
<li><a href="https://www.thymeleaf.org/">Thymeleaf</a></li>
<li><a href="https://mustache.github.io/">Mustache</a><br>当使用模板引擎和相关默认配置时,将从<code>src/main/resources/templates</code>中自动获取模板.</li>
</ul>
</li>
<li><h6 id="错误处理-Error-Handling-1"><a href="#错误处理-Error-Handling-1" class="headerlink" title="错误处理(Error Handling)"></a>错误处理(Error Handling)</h6>Spring Boot提供了一个<code>WebExceptionHandler</code>,可以一种合理的方式来处理所有错误.它在处理顺序中的位置紧靠WebFlux提供的处理程序之前,这些处理程序是最后一个.对于机器客户端,会使用JSON形式来响应错误信息,HTTP状态,和异常消息.对于浏览器客户端,有一个”whitelabel”错误处理程序,以HTML格式呈现与JSON相同的数据. 还可以提供自己的HTML模板来显示错误.<br>自定义功能的第一步是使用现有机制,但替换或增加错误内容. 为此,可以添加类型为<code>ErrorAttributes</code>的bean.<br>如果更改错误处理行为,可以实现<code>ErrorWebExceptionHandler</code>并注册该类型的bean.由于<code>ErrorWebExceptionHandler</code>的级别很低,因此Spring Boot还提供了一个方便的<code>AbstractErrorWebExceptionHandler</code>,可让您以WebFlux函数式风格处理错误,如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorWebExceptionHandler</span> <span class="keyword">extends</span> <span class="title">AbstractErrorWebExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyErrorWebExceptionHandler</span><span class="params">(ErrorAttributes errorAttributes, Resources resources,</span></span></span><br><span class="line"><span class="params"><span class="function">            ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorAttributes, resources, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="title">getRoutingFunction</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(<span class="keyword">this</span>::acceptsXml, <span class="keyword">this</span>::handleErrorAsXml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">acceptsXml</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.headers().accept().contains(MediaType.APPLICATION_XML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">handleErrorAsXml</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        BodyBuilder builder = ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">        <span class="comment">// ... additional builder calls</span></span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
为了更完整的画面,您还可以直接将<code>DefaultErrorWebExceptionHandler</code>子类化并重写特定方法.<br>在某些情况下,<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.supported.spring-webflux">metrics infrastructure</a>不会记录在controller或handler函数处理的错误. 应用程序可以将被处理的异常设为请求属性, 从而保证这样的异常能不被request metrics记录:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandlingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Rendering <span class="title">userProfile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(IllegalStateException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Rendering <span class="title">handleIllegalState</span><span class="params">(ServerWebExchange exchange, IllegalStateException exc)</span> </span>&#123;</span><br><span class="line">        exchange.getAttributes().putIfAbsent(ErrorAttributes.ERROR_ATTRIBUTE, exc);</span><br><span class="line">        <span class="keyword">return</span> Rendering.view(<span class="string">&quot;errorView&quot;</span>).modelAttribute(<span class="string">&quot;message&quot;</span>, exc.getMessage()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="自定义错误页面-Custom-Error-Pages"><a href="#自定义错误页面-Custom-Error-Pages" class="headerlink" title="自定义错误页面(Custom Error Pages)"></a>自定义错误页面(Custom Error Pages)</h6>如果要指定状态代码显示自定义HTML错误页面,可以将文件添加到<code>/error</code>目录下. 错误页面可以是静态HTML(即添加到任何静态资源目录下),也可以使用模板构建. 文件名应为具体的状态码或系列掩码.<br>例如,要将<code>404</code>映射到静态HTML文件,目录结构如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- public/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure>
要使用Mustache模板映射所有<code>5xx</code>错误,目录结构如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.mustache</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="网络过滤器-Web-Filters"><a href="#网络过滤器-Web-Filters" class="headerlink" title="网络过滤器(Web Filters)"></a>网络过滤器(Web Filters)</h6>Spring WebFlux提供了一个<code>WebFilter</code>接口,可以实现该接口来过滤HTTP请求-响应交换.在如果在应用context中找到的<code>WebFilter</code>bean,将自动用于过滤每个交换.如果过滤器的顺序很重要,则可以实现<code>Ordered</code>或使用<code>@Order</code>进行标注.<br>Spring Boot自动配置会配置Web过滤器. 这样做时,将使用下表中显示的顺序:<table>
<thead>
<tr>
<th>过滤器</th>
<th>顺序</th>
</tr>
</thead>
<tbody><tr>
<td><code>MetricsWebFilter</code></td>
<td><code>Ordered.HIGHEST_PRECEDENCE</code> + 1</td>
</tr>
<tr>
<td><code>WebFilterChainProxy</code>(Spring Security)</td>
<td>-100</td>
</tr>
<tr>
<td><code>HttpTraceWebFilter</code></td>
<td><code>Ordered.LOWEST_PRECEDENCE</code> - 10</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><h6 id="JAX-RS和Jersey-JAX-RS-and-Jersey"><a href="#JAX-RS和Jersey-JAX-RS-and-Jersey" class="headerlink" title="JAX-RS和Jersey( JAX-RS and Jersey)"></a>JAX-RS和Jersey( JAX-RS and Jersey)</h6>如果您选择RESTendpoint的JAX-RS编程模型,则可以使用可用的实现之一来代替Spring MVC. Jersey和Apache CXF开箱即用.CXF要求您在应用context中将其<code>Servlet</code>或<code>Filter</code>注册为<code>@Bean</code>.Jersey提供了一些本地的Spring支持,因此我们在Spring Boot中还与starter一起为其提供了自动配置支持.<br>要开始使用Jersey,添加依赖<code>spring-boot-starter-jersey</code>,然后需要一个<code>ResourceConfig</code>类型的<code>@Bean</code>,在其中注册所有endpoint,如以下示例所示:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJerseyConfig</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyJerseyConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        register(MyEndpoint.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告:</p>
<p>​    Jersey对扫描可执行文档的支持非常有限.例如,在运行可执行的war文件时,它无法扫描在完全可执行的jar文件或<code>WEB-INF/classs</code>中找到的包中的endpoint.为了避免这种限制,不应该使用<code>packages</code>方法,并且应该使用<code>register</code>方法分别注册endpoint,如前面的示例所示.<br>对于更高级的自定义,可以注册实现<code>ResourceConfigCustomizer</code>的任意数量的Bean.<br>所有注册的endpoint都应该是带有HTTP资源注释的<code>@Components</code>(<code>@GET</code>和其他注释),如以下示例所示:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Path(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEndpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由于端点是Spring <code>@Component</code>,因此其生命周期由Spring管理,您可以使用<code>@Autowired</code>注解进行注入依赖,并使用<code>@Value</code>注解注入外部配置.默认情况下,Jersey servlet被注册并映射到<code>/*</code>. 您可以通过将<code>@ApplicationPath</code>添加到<code>ResourceConfig</code>来更改映射.</li>
<li><h6 id="嵌入式Servlet容器支持-Embedded-Servlet-Container-Support"><a href="#嵌入式Servlet容器支持-Embedded-Servlet-Container-Support" class="headerlink" title="(嵌入式Servlet容器支持)Embedded Servlet Container Support"></a>(嵌入式Servlet容器支持)Embedded Servlet Container Support</h6>Spring Boot包括对嵌入式Tomcat,Jetty和Undertow服务器的支持. 大多数开发人员使用合适的”starter”来获取被配置完整的实例. 默认情况下,嵌入式服务器在端口<code>8080</code>上监听HTTP请求.<ol>
<li><h6 id="Servlet-过滤器和监听器-Servlets-Filters-and-listeners"><a href="#Servlet-过滤器和监听器-Servlets-Filters-and-listeners" class="headerlink" title="Servlet,过滤器和监听器(Servlets, Filters, and listeners)"></a>Servlet,过滤器和监听器(Servlets, Filters, and listeners)</h6>使用嵌入式Servlet容器时,可以通过使用Spring bean或扫描Servlet组件来注册Servlet规范中的servlet,过滤器和所有侦听器(例如<code>HttpSessionListener</code>).<h6 id="以Spring-Bean的方式注册Servlets-过滤器和监听器-Registering-Servlets-Filters-and-Listeners-as-Spring-Beans"><a href="#以Spring-Bean的方式注册Servlets-过滤器和监听器-Registering-Servlets-Filters-and-Listeners-as-Spring-Beans" class="headerlink" title="以Spring Bean的方式注册Servlets, 过滤器和监听器(Registering Servlets, Filters, and Listeners as Spring Beans)"></a>以Spring Bean的方式注册Servlets, 过滤器和监听器(Registering Servlets, Filters, and Listeners as Spring Beans)</h6>所有的,作为Spring bean的,Servlet,Filter或Servlet * Listener实例被注册到嵌入式容器中. 如果要在配置过程中引用<code>application.properties</code>中的值,这种方式会特别方便.<br>默认情况下,如果context包含单个Servlet,则将其映射到<code>/</code>. 对于多个servlet bean,bean名称用作路径前缀. 过滤器映射到 <code>/*</code>.<br>如果基于约定的映射不够灵活,则可以使用 <code>ServletRegistrationBean</code>,<code>FilterRegistrationBean</code>和<code>ServletListenerRegistrationBean</code>类进行完全控制.<br>通常来说,Filter bean无序是不安全的. 如果需要特定的顺序,则应使用<code>@Order</code>标注<code>Filter</code>或使其实现<code>Ordered</code>.您不能通过使用<code>@Order</code>标注<code>Filter</code>的bean方法来配置Filter的顺序.如果无法将<code>Filter</code>类添加<code>@Order</code>或实现<code>Ordered</code>,则必须为<code>Filter</code>定义<code>FilterRegistrationBean</code>并使用<code>setOrder(int</code>方法设置bean的顺序.避免配置一个在<code>Ordered.HIGHEST_PRECEDENCE</code>上读取request body的过滤器,因为它可能与应用应用使用的字符编码配置冲突.如果Servlet过滤器包装了请求,则配置它的时候,应使用小于或等于<code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code>的顺序.<blockquote>
<p>建议:</p>
<p>​    要查看应用程序中每个filter的顺序,可以为<code>Web</code>日志记录组(<code>logging.level.web = debug</code>)启用debug级别的日志记录. 然后,将在启动时记录已注册过滤器的详细信息,包括其顺序和URL模式.</p>
<p>警告:</p>
<p>​    注册Filter Bean时务必小心,因为它们是在应用程序生命周期中很早就初始化的. 如果需要注册与其他bean交互的Filter,考虑改用<code>DelegatingFilterProxyRegistrationBean</code>.</p>
</blockquote>
</li>
<li><h6 id="Servlet上下文环境初始化"><a href="#Servlet上下文环境初始化" class="headerlink" title="Servlet上下文环境初始化"></a>Servlet上下文环境初始化</h6>嵌入式Servlet容器不会直接执行Servlet 3.0+ <code>javax.servlet.ServletContainerInitializer</code>接口或Spring的<code>org.springframework.web.WebApplicationInitializer</code>接口.这是一个有意的设计决定,目的在于降低以war方式运行第三方库可能破坏Spring Boot应用的风险.<br>如果需要在Spring Boot应用程序中执行servlet上下文初始化,则应该注册一个实现<code>org.springframework.boot.web.servlet.ServletContextInitializer</code>接口的bean.只有一个方法<code>onStartup</code>,提供对<code>ServletContext</code>的访问,在必要时可以用作已有的<code>WebApplicationInitializer</code>的适配器.<h6 id="扫描Servlet-过滤器和侦听器-Scanning-for-Servlets-Filters-and-listeners"><a href="#扫描Servlet-过滤器和侦听器-Scanning-for-Servlets-Filters-and-listeners" class="headerlink" title="扫描Servlet,过滤器和侦听器(Scanning for Servlets, Filters, and listeners)"></a>扫描Servlet,过滤器和侦听器(Scanning for Servlets, Filters, and listeners)</h6>当使用嵌入式容器时,可以使用<code>@ServletComponentScan</code>来对<code>@WebServlet</code>,<code>@WebFilter</code>和<code>@WebListener</code>标注的类进行自动注册.<blockquote>
<p>建议:</p>
<p>​    <code>@ServletComponentScan</code>在独立容器中无效,在独立容器中使用的是容器内置的发现机制.</p>
</blockquote>
</li>
<li><h6 id="ServletWebServerApplicationContext"><a href="#ServletWebServerApplicationContext" class="headerlink" title="ServletWebServerApplicationContext"></a>ServletWebServerApplicationContext</h6>在后台,Spring Boot使用另一种类型的<code>ApplicationContext</code>来支持嵌入式servlet容器.<code>ServletWebServerApplicationContext</code>是<code>WebApplicationContext</code>的一种特殊类型,它通过搜索单个<code>ServletWebServerFactory</code>bean来自我引导启动.通常,<code>TomcatServletWebServerFactory</code>,<code>JettyServletWebServerFactory</code>或<code>UndertowServletWebServerFactory</code>都已经被自动配置.<blockquote>
<p>注意:</p>
<p>​    通常,不需要了解这些实现类. 大多数应用程序都是自动配置的,并且代表开发者创建了相应的<code>ApplicationContext</code>和<code>ServletWebServerFactory</code>.</p>
</blockquote>
</li>
<li><h6 id="自定义内置Servlet容器-Customizing-Embedded-Servlet-Containers"><a href="#自定义内置Servlet容器-Customizing-Embedded-Servlet-Containers" class="headerlink" title="自定义内置Servlet容器(Customizing Embedded Servlet Containers)"></a>自定义内置Servlet容器(Customizing Embedded Servlet Containers)</h6>可以通过使用Spring <code>Environment</code>属性来配置常见的servlet容器设置. 通常,可以在<code>application.properties</code>或<code>application.yaml</code>文件中定义属性.<br>常用服务器设置包括:<ul>
<li>网络设置:监听传入HTTP请求的端口(<code>server.port</code>),绑定到<code>server.address</code>接口地址,等等.</li>
<li>会话设置:会话是持久性(<code>server.servlet.session.persistent</code>),会话超时(<code>server.servlet.session.timeout</code>),会话数据位置(<code>server.servlet.session.store-dir</code>)和会话cookie 配置(<code>server.servlet.session.cookie.*</code>).</li>
<li>错误管理:错误页面的位置(<code>server.error.path</code>)等.</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.webserver.configure-ssl">SSL</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.webserver.enable-response-compression">HTTP compression</a><br>Spring Boot尝试尽可能多地公开通用设置,但这不是可能的. 对于这些情况,专用名称空间提供针对服务器的自定义项(请参阅<code>server.tomcat</code>和<code>server.undertow</code>). 例如,可以给嵌入式servlet容器的特定功能配置访问日志.<blockquote>
<p>建议:</p>
<p>​    有关完整列表,请参见<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>类.</p>
</blockquote>
</li>
</ul>
<h6 id="编程方式进行自定义-Programmatic-Customization"><a href="#编程方式进行自定义-Programmatic-Customization" class="headerlink" title="编程方式进行自定义(Programmatic Customization)"></a>编程方式进行自定义(Programmatic Customization)</h6>如果您需要以编程方式配置嵌入式servlet容器,则可以注册一个实现<code>WebServerFactoryCustomizer</code>接口的Spring Bean.<br><code>WebServerFactoryCustomizer</code>提供对<code>ConfigurableServletWebServerFactory</code>的访问,其中包括许多自定义设置方法. 以下示例显示以编程方式设置端口:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebServerFactoryCustomizer</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory server)</span> </span>&#123;</span><br><span class="line">        server.setPort(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>TomcatServletWebServerFactory</code>,<code>JettyServletWebServerFactory</code>和<code>UndertowServletWebServerFactory</code>是<code>ConfigurableServletWebServerFactory</code>的实现,分别对Tomcat,Jetty和Undertow提供额外自定义定义方法.以下示例显示如何自定义<code>TomcatServletWebServerFactory</code>,<code>TomcatServletWebServerFactory</code>提供针对Tomcat的配置选项:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTomcatWebServerFactoryCustomizer</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">TomcatServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(TomcatServletWebServerFactory server)</span> </span>&#123;</span><br><span class="line">        server.addConnectorCustomizers((connector) -&gt; connector.setAsyncTimeout(Duration.ofSeconds(<span class="number">20</span>).toMillis()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="直接自定义ConfigurableServletWebServerFactory-Customizing-ConfigurableServletWebServerFactory-Directly"><a href="#直接自定义ConfigurableServletWebServerFactory-Customizing-ConfigurableServletWebServerFactory-Directly" class="headerlink" title="直接自定义ConfigurableServletWebServerFactory (Customizing ConfigurableServletWebServerFactory Directly)"></a>直接自定义ConfigurableServletWebServerFactory (Customizing ConfigurableServletWebServerFactory Directly)</h6>更高级的使用方式,就要继承<code>ServletWebServerFactory</code>,可以自己暴露一个这样的bean.<br>很多配置项都提供了setter. 如果您需要做一些更奇特的操作,还提供了几个protected方法形式的”hook(回调函数)”. 有关详细信息,请参见 <a href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html">source code documentation</a> .<blockquote>
<p>注意:</p>
<p>​    自动配置的customizers 仍会应用在自定义工厂中,因此请谨慎使用该选项.</p>
</blockquote>
</li>
<li><h6 id="JSP限制-JSP-Limitations"><a href="#JSP限制-JSP-Limitations" class="headerlink" title="JSP限制(JSP Limitations)"></a>JSP限制(JSP Limitations)</h6>运行使用嵌入式Servlet容器(并打包为可执行归档文件)的Spring Boot应用时,对JSP的支持存在一些限制.<ul>
<li>对于Jetty和Tomcat,如果使用war包装,可以工作. 使用<code>java -jar</code>启动时,可执行的war可以工作,并且可以被部署到任何标准容器中.使用可执行jar时,不支持JSP.</li>
<li>Undertow不支持JSP.</li>
<li>创建自定义<code>error.jsp</code>页面不会覆盖默认错误处理视图. 应改用自定义错误页面.</li>
</ul>
</li>
</ol>
</li>
<li><h5 id="嵌入式响应式服务器支持-Embedded-Reactive-Server-Support"><a href="#嵌入式响应式服务器支持-Embedded-Reactive-Server-Support" class="headerlink" title="嵌入式响应式服务器支持(Embedded Reactive Server Support)"></a>嵌入式响应式服务器支持(Embedded Reactive Server Support)</h5>Spring Boot支持以下嵌入式响应式Web服务器:Reactor Netty,Tomcat,Jetty和Undertow. 大多数开发者使用合适”启动器”来获取完全已经配:置的实例. 默认情况下,嵌入式服务器在端口8080上侦听HTTP请求.</li>
<li><h6 id="响应式服务器资源配置-Reactive-Server-Resources-Configuration"><a href="#响应式服务器资源配置-Reactive-Server-Resources-Configuration" class="headerlink" title="响应式服务器资源配置(Reactive Server Resources Configuration)"></a>响应式服务器资源配置(Reactive Server Resources Configuration)</h6>当对Reactor Netty或Jetty服务器进行自动配置时,Spring Boot将创建为服务器实例创建指定的bean,这些bean提供HTTP资源:<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>.<br>默认情况下,在以下情况,这些资源还将与Reactor Netty和Jetty客户端共享,以实现最佳性能:<ul>
<li>服务器和客户端使用相同的技术</li>
<li>客户端实例是使用Spring Boot自动配置的<code>WebClient.Builder</code>bean构建的<br>通过提供自定义的<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>bean,开发者可以覆盖Jetty和Reactor Netty的资源配置-这将同时应用于客户端和服务器.<br>可以在”<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.webclient.runtime">WebClient Runtime section</a>“部分中了解有关客户端资源配置的更多信息.</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Boot Feature</tag>
      </tags>
  </entry>
</search>
