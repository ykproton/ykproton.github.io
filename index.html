<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat-logo.jpg">
  <link rel="mask-icon" href="/images/cat-logo.jpg" color="#222">






  
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="ykproton">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="ykproton">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chenyk">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>ykproton</title>
  




  <noscript>
    
  </noscript>
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ykproton</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chenyk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ykproton" title="GitHub → https://github.com/ykproton" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/64693.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/64693.html" class="post-title-link" itemprop="url">InnoDB存储引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-15 22:57:00 / 修改时间：22:59:08" itemprop="dateCreated datePublished" datetime="2021-07-15T22:57:00+08:00">2021-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">InnoDB存储引擎</span></a>
        </span>
    </span>

  
    <span id="/posts/64693.html" class="post-meta-item leancloud_visitors" data-flag-title="InnoDB存储引擎" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>32k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>29 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><h3 id="数据库与实例概念"><a href="#数据库与实例概念" class="headerlink" title="数据库与实例概念"></a>数据库与实例概念</h3><ol>
<li>数据库: 屋里操作系统文件以及其他形式的文件类型的集合.比如ibd,frm</li>
<li>实例: 后台线程和内存组成.在操作系统上表现为一个进程.</li>
</ol>
<h3 id="MySQL体系结构-1"><a href="#MySQL体系结构-1" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p>连接池组件<br>管理服务和工具(备份,恢复,管理)<br>SQL接口组件<br>查询分析器组件<br>查询优化器组件<br>缓冲(cache)组件<br>插件式存储引擎<br>物理文件(redo,undo,index,log)</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul>
<li>InnoDB:面向OLTP</li>
<li>MyISAM:不支持事务,表锁,面向OLAP</li>
<li>Memory:数据全部放在内存中,关机丢失,适用于临时数据</li>
</ul>
<h3 id="连接MySQL方式"><a href="#连接MySQL方式" class="headerlink" title="连接MySQL方式"></a>连接MySQL方式</h3><ul>
<li>TCP/IP: mysql -h host -u username -p password</li>
<li>命名管道和共享内存</li>
<li>UNIX套接字</li>
</ul>
<h2 id="Inno存储引擎"><a href="#Inno存储引擎" class="headerlink" title="Inno存储引擎"></a>Inno存储引擎</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>高性能,高可用,高扩展. 支持ACID,<br>特点:行锁设计,支持MVCC,支持外键,一致性非锁定读</p>
<h3 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h3><ul>
<li><p>后台线程</p>
<ul>
<li><p>Master线程</p>
<p>功能:<br>异步刷新缓冲池数据,保证数据一致性,包括:脏页,合并插入缓冲(insert buffer),undo页回收</p>
<ul>
<li><p>工作方式</p>
<p>日志缓冲落盘<br>合并插入缓冲 (merge Insert Buffer)<br>刷新脏页<br>删除无用undo页(full purge,要判断版本信息)</p>
</li>
<li><p>innodb_adaptive_flushing(自适应刷新)</p>
<p>判断redo log和速度来决定最适合刷新脏页的数量</p>
</li>
</ul>
</li>
<li><p>IO Thread</p>
<p>用于AIO请求的回调<br>有4个分别是:</p>
<pre><code>write,(4个)
read, (4个)
insert buffer,
log IO thread
</code></pre>
</li>
<li><p>Purge Thread</p>
<p>用来回收undo页,以及删除delete_flag 标为删除的记录.</p>
</li>
<li><p>Page Cleaner Thread</p>
<p>用于脏页刷新操作</p>
</li>
</ul>
</li>
<li><p>内存</p>
<ul>
<li><p>缓冲池</p>
<p>作用:</p>
<pre><code>用于缓冲磁盘与CPU之间的速度差.存储页.
</code></pre>
<p>FIX:</p>
<pre><code>将页从磁盘中读取到内存的过程
</code></pre>
<p>命中:</p>
<pre><code>若在缓冲池中直接找到页,称作命中
</code></pre>
<p>为了提高整体性能,在数据修改时,先修改缓冲池的页,然后通过CheckPoint机制刷新回磁盘.</p>
<p>配置:</p>
<pre><code>可以配置多个缓冲池实例,通过hash进行页分配,减少竞争,提升并发. 
</code></pre>
<p> 即使缓冲池再大,远比数据表大,仍然会进行磁盘IO,比如将脏页异步写入磁盘,每次事务提交时将日志写入重做文件中.</p>
<ul>
<li><p>数据页</p>
<ul>
<li>落盘时需要doublewrite</li>
</ul>
</li>
<li><p>索引页</p>
</li>
<li><p>insert buffer</p>
</li>
<li><p>自适应哈希AHI</p>
</li>
<li><p>锁信息</p>
</li>
<li><p>数据字典</p>
</li>
</ul>
</li>
<li><p>LRU list</p>
<ol>
<li><p>LRU list<br> 管理页,频繁使用页在list前端,最少使用在后端.用于淘汰页.<br> 不同于传统LRU,加入了midpoint位置.新读取的页不是放到首部,而是放到midpoint位置.算法称为mindpoint insertion strategy. 可以使用innodb_old_blocks_pct控制.默认为5/8.</p>
</li>
<li><p>mindpoint insertion strategy:<br> new list ——- minpoint–oldlist<br> 如果直接将页加入到lru的首段,可能会导致热点数据被刷出.比如索引或者数据的扫描操作,需要访问大量的页,如果仅这次使用,会导致热点数据被移除,而下次读取该数据,有需要进行磁盘IO.<br> 还提供了另一个参数,进一步管理LRU.innodb_old_blocks_time,表示页读取到mid位置后,经过多长时间,再次访问才会被加入LRU列表的热端.</p>
</li>
<li><p>page made young:<br> 指页从old移动到new部分.</p>
</li>
<li><p>page not made young:<br> 指因为设置了innodb_old_blocks_time导致页没有移动</p>
</li>
</ol>
<p>5.缓冲命中率,如果低于95%,则要考虑全表扫描导致LRU列表被污染的问题.查看innodb_buffer_pool_stats 表查看缓冲池运行状态.</p>
<p>6.页压缩</p>
<ul>
<li>页压缩(unzip_LRU)<ol>
<li><p>作用:<br> 将16kb的页压缩为1,2,4,8k.使用unzip_LRU管理</p>
</li>
<li><p>unzip_LRU从内存池分配(有直接用,没有申请大内存,分割):<br> (申请4kb为例)</p>
<ol>
<li>检查4kbunzip_LRU也是否有空闲,若有直接使用</li>
<li>检查8kb列表,<br> 若有,将页分为两个4kb,存放到unzip_LRU列表<br> 没有,则申请16kb,然后将页分成1个8kb,2个4kb,放到列表中.</li>
</ol>
</li>
</ol>
</li>
<li>脏页<ol>
<li>定义:<br> LRU列表中的页,被修改后叫做脏页,<br> 此时缓冲池中数据和磁盘中不一致,会使用checkpoint机制刷新会磁盘</li>
</ol>
<ul>
<li><p>checkpoint</p>
<ol>
<li>目的:<br> 缩短数据库恢复时间(故障时只要恢复checkpoint后的数据)<br> 缓冲池不够用时,刷新脏页,释放空间(根据lru释放)<br> 重做日志不可用时,刷新脏页(重做日志需要保留,不能覆盖)</li>
<li>LSN(log sequence number)<br> 用来标记版本.每个页都有lsn</li>
<li>checkpoint表示已经刷新到磁盘页上的lsn,仅需要恢复checkpoint开始的日志部分.</li>
</ol>
<ul>
<li><p>sharp checkpoint</p>
<p>数据库关闭时,将所有脏页刷新回磁盘.</p>
</li>
<li><p>fuzzy checkpoint</p>
<p>1.使用场景: </p>
<pre><code>在运行时使用.
</code></pre>
<ol start="2">
<li>发生情况<br> Master Thread CheckPoint<br> FLUSH_LRU_LIST CheckPoint<br> Async/Sync Flush Checkpoint<br> Dirty Page too much Checkpoint</li>
</ol>
<ul>
<li><p>Master Thread CheckPoint</p>
<p>每1s或者每10s从缓冲池的脏页列表中刷新一定比例的页回磁盘.异步落盘.查询线程不会阻塞.</p>
</li>
<li><p>FLUSH_LRU_LIST CheckPoint</p>
<p>如果LRU列表中可用页数量少于指定数时触发.<br>可以使用参数指定数量innodb_lru_scan_depth</p>
</li>
<li><p>Async/Sync Flush Checkpoint</p>
<p>重做日志不可用的情况,强制刷新一部分页到磁盘中.从脏页列表选取.</p>
<pre><code>未落盘数据占redo log file 比例
&lt;75%,        
    不需要刷新脏页
75%&lt;  ~ &lt;90%,
     触发Async落盘,指导符合仅阻塞当前用户查询
90%&lt; ~        
    触发Sync落盘,阻塞所有用户查询.(只有在导入大量数据时可能会出现)
</code></pre>
<p>这不刷新操作放到 Page Cleaner Thread,故现在不会阻塞查询</p>
</li>
<li><p>Dirty Page too much Checkpoint</p>
<p>脏页数量太多,强制checkpoint,来保证有足够多的可用页.可以由参数innodb_max_dirty_pages_pct</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Write Ahead Log</p>
<p>当事务提交时,先写redo log,然后再修改页.当由于宕机导致数据丢失时,通过重做日志完成数据的恢复.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Free List</p>
<p>用于表示可用空闲页.<br>数据库刚启动时,LRU列表为空,当需要从数据库中获取页是,就从free列表查找是否存在可用页.若有从Free中移除,加入到LRU中.</p>
</li>
<li><p>Flush List</p>
<p>为脏页列表,用来将脏页刷新会磁盘</p>
</li>
<li><p>重做日志缓冲(redo log buffer)</p>
<p>将redo log放到此区域,然后定时刷新到日志文件.一般每秒刷新.大小可以使用innodb_log_buffer_size控制</p>
<ul>
<li><p>刷新到磁盘情景</p>
<ol>
<li>Master 线程没一秒将buffer刷新到磁盘</li>
<li>事务提交时,刷新</li>
<li>redo log buffer 小于1/2时,刷新</li>
</ol>
</li>
</ul>
</li>
<li><p>额外缓冲池</p>
<p>有一些数据结构内存申请时,需要从额外缓冲池申请.比如缓冲控制对象(buffer control block),记录了一些lru,锁信息.</p>
<h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3></li>
</ul>
</li>
<li><p>插入缓冲</p>
<ul>
<li><p>Insert Buffer</p>
<p>Insert Buffer是物理页的一个组成部分.避免离散读,同时将多个插入操作合并成一个.</p>
<ol>
<li><p>问题:<br> 插入记录时,插入顺序按照主键递增的顺序进行插入.因此插入聚集索引一般是顺序的,不需要磁盘随机读取.插入速度快.<br> 非聚集索引(辅助索引)的插入是慢的,数据页按照主键顺序存放,对于非聚集索引叶子节点的插入不是顺序的,此时需要离散访问非聚集索引页.随机读取导致插入性能差.</p>
</li>
<li><p>定义:<br> 对于非聚集索引的插入或者更新操作,不是每一次都直接插入到索引页中,而是先判断非聚集索引页是否在缓冲池中,若在直接插入;若不在,则先放到一个Insert Buffer对象中. 模拟已经插入的情况. 然后再以一定频率进行Insert Buffer和辅助索引叶子节点的merge(合并操作),这时,通常能将多个插入操作合并到一个操作中,提高了对非聚集索引插入性能.</p>
</li>
</ol>
<ul>
<li><p>使用条件</p>
<p>使用条件:</p>
<pre><code>1.索引是辅助索引
2.索引不是唯一的(unique)
</code></pre>
<p>满足条件,才会使用Insert Buffer</p>
<p>索引不是唯一是因为,插入缓冲时,索引数据库并不去查找索引页来判断索引的唯一性.如果需要查找的话,肯定会导致离散读,导致Insert Buffer失去意义.</p>
</li>
<li><p>可能存在的问题</p>
<ol>
<li>大量插入数据,如果出现宕机,Insert Buffer没有合并到磁盘中,此时恢复需要很长时间,极端情况下可能几个小时.<br>推测:可能是需要重新建立索引</li>
<li>在写密集情况下,可能会导致Insert Buffer占用过多的缓冲池内存(innodb_buffer_pool),默认可以占到一半.(硬编码的)</li>
</ol>
</li>
<li><p>内部实现</p>
<p>Insert Buffer是一个B+树.默认放在共享表空间中.通过idb恢复数据后,还需要repair table重建副主索引.</p>
<ol>
<li><p>非叶子节点:<br> space+marker+offset<br> space:表示表空间<br> marker:用于兼容老版本的insert buffer<br> offset:表示页所在的偏移量.</p>
</li>
<li><p>叶子节点:<br> space+marker+offset+metadata+record<br> metadata:</p>
<pre><code> IBUF_REC_OFFSET_COUNT:给进入Insert Buffer的记录排序,为了支持Change Buffer,只有经过replay,才能得到正确的记录值.
</code></pre>
</li>
<li><p>插入流程:<br> 当一个辅助索引要插入到页(space,offset)时,如果页不再缓冲池中,则引擎根据规则构造一个search key,然后查询Insert Buffer这个B+树,然后将这条记录插入到Insert Buffer B+ 树叶子节点上.</p>
</li>
<li><p>Insert Buffer Bitmap:<br>为了保证Merge Insert Buffer能够必须成功,还需要有一个特殊的页来标记每个辅助索引页(space,page_no)的可用空间.这个页的类型就是Insert Buffer Bitmap</p>
</li>
</ol>
<ul>
<li>Insert Buffer Bitmap<ol start="4">
<li>Insert Buffer Bitmap:<br> 为了保证Merge Insert Buffer能够必须成功,还需要有一个特殊的页来标记每个辅助索引页(space,page_no)的可用空间.这个页的类型就是Insert Buffer Bitmap.<br> 每个Insert Buffer Bitmap页用来追踪256个区,16384个页的可用空间.每个Insert Buffer Bitmap都在16384页的第二个页.<br> 记录了每个辅助索引页的可用剩余空间,是否有记录缓存在Insert Buffer B+ 树中,</li>
</ol>
</li>
</ul>
</li>
<li><p>合并插入缓冲(Merge Insert Buffer)</p>
<p>以下情况,Insert Buffer中的记录合并到真正辅助索引中:</p>
<pre><code>1. 辅助索引页被读取到缓冲池中
2. Insert Buffer Bitmap页追踪到该辅助索引页无可用空间时
3. Master Thread
</code></pre>
<ul>
<li><p>辅助索引页被读取到缓冲池中</p>
<p>在执行select 操作时,要检查 insert buffer bitmap页,确认辅助索引页是否有记录在b+树上.如果有,则将该页的记录插入到辅助索引页中.将多次插入操作合并到一次中.</p>
</li>
<li><p>Insert Buffer Bitmap页追踪到该辅助索引页无可用空间</p>
<p>辅助索引页可用空间小于1/32,强制进行合并操作.即强制读取辅助索引页,将b+树中记录插入辅助索引页中.</p>
</li>
<li><p>Master Thread</p>
<p>每1s或者10s都会merge insert buffer.<br>为了在复杂情况下有良好的公平性,引擎随机选择insert buffer b+树的一个页,读取该页的space已经所需要的数量的页,进行merge.而不是进行有序选择.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Change Buffer</p>
<p>可以视为Insert Buffer升级,可以对DML操作进行缓冲,insert,delete,update. 分别为 insert buffer,delete buffer,change buffer.<br>要求仍然是非唯一索引.<br>可以通过参数控制最大内存使用(innodb_change_buffer_max_size,最大有效值50)</p>
</li>
</ul>
</li>
<li><p>两次写(Double Write)</p>
<ol>
<li>概念:<br> 当写入失效时,先通过页的副本来还原页,再进行重做,这就是doublewrite.保证数据页可靠性</li>
<li>组成<br> doublewrite buffer(内存,2M)<br> 共享表空间连续128个页(磁盘,2M)<br> 3.机制<br> 第一次:脏页刷新时,不直接写磁盘,而是会通过memcpy函数,将脏页复制到doublewrite buffer中.再通过doublewrite buffer分两次,每次将1M顺序写入共享表空间的物理磁盘上.然后马上调用fsync函数,同步磁盘,避免缓冲写导致的问题.因为doublewrite也是连续的,因此顺序写开销不大.<br> 第二次:double页写入后,再将doublewrite buffer中的页写入各个表空间,此时写入是离散的.</li>
</ol>
<p>4.数据恢复:</p>
<pre><code>如果发生崩溃,在恢复过程中,引擎将共享表空间中的doublewrite中找到该页的副本,将其复制到表空间文件,再应用重做日志.
</code></pre>
<ul>
<li><p>部分写失效(partial page write)</p>
<p>概念:</p>
<pre><code>将页写入到表中,但是只写了一部分,发生宕机,称为部分写失效
</code></pre>
<p>redo log无法恢复:</p>
<pre><code>redo log是对物理页的恢复,当物理页发生损坏时,无法恢复数据
</code></pre>
</li>
</ul>
</li>
<li><p>自适应哈希索引(Adaptive Hash Index)</p>
<p>1.概念:</p>
<pre><code>innodb会监控表上索引页的查询.如果观察到建立哈希索引可以带来速度提升,则建立哈希索引.称之为自适应哈希索引.通过B+树页建立AHI,因此速度快,不需要对整个表建立索引.
</code></pre>
<ul>
<li><p>建立AHI条件</p>
<ol>
<li>查询条件限制:<br> a.索引页的访问模式一样: 查询条件(where)一样. 如果不同的查询条件访问到同一个索<br> b.该模式访问了100次</li>
<li>页命访问次数限制:<br> 页通过该模式访问了 1/16*页记录次.</li>
</ol>
</li>
<li><p>使用AHI要求</p>
<p>1.等值查询</p>
<pre><code>哈希索引只能用来搜索等值查询,如果范围查找则不使用哈希索引.
</code></pre>
</li>
</ul>
</li>
<li><p>异步IO(Async IO)</p>
<p>1.概念:</p>
<pre><code>用户发出一个IO请求后,立即发出另一个IO请求,当全部IO请求发送完毕后,等待所有IO操作完成. 提高IOPS.
</code></pre>
<p>InnoDB中所有的read ahead方式读取,都是通过AIO.磁盘刷新也是通过AIO方式.</p>
<ul>
<li><p>IO merge</p>
<p>1.概念:</p>
<pre><code>可以进行IO Merge,将多个IO操作合并成一个IO.判断多个IO的页是否连续,重复,可以将多次IO在一次完成.
比如要访问(6,7),(7,8),(8,8),AIO会判断出三个页是连续的,然后一次读取.
</code></pre>
</li>
</ul>
</li>
<li><p>刷新邻接页(Flush Neighbor Page)</p>
<ol>
<li><p>概念:<br> 当刷新一个脏页时,InnoDB存储引擎会检测页所在区的所有页,如果是脏页,则一起刷新. </p>
</li>
<li><p>建议:<br> 机械硬盘开启,SSD关闭 设置set global innodb_flush_neighbors=0;</p>
</li>
</ol>
<ul>
<li><p>优点</p>
<p>可以通过AIO将多个IO写入操作合并成一个IO操作.在机械磁盘下有显著优势.</p>
</li>
<li><p>缺点</p>
<p>可能将不怎么脏的页写入磁盘,然后该页马上又变成脏页.</p>
</li>
</ul>
</li>
<li><p>预读(Read  Ahead)</p>
<p>Read-Ahead用于异步预取buffer pool中的多个page的一个预测行为。<br>InnoDB使用两种提前预读Read-Ahead算法来提高I/O性能。</p>
<p>Linear read-ahead:线性预读</p>
<pre><code>如果一个extent中的被顺序读取的page超过或者等于   innodb_read_ahead_threshold  参数变量时，Innodb将会异步的将下一个extent读取到buffer pool中，innodb_read_ahead_threshold可以设置为0-64的任何值
</code></pre>
<p>Random read-ahead:随机预读</p>
<pre><code>如果当同一个extent中连续的13个page在buffer pool中发现时，Innodb会将该extent中的剩余page读到buffer pool中。控制参数  innodb_random_read_ahead  默认没有开启。
</code></pre>
<ul>
<li><p>线性预读(Linear read-ahead)</p>
</li>
<li><p>随机预读(Random read-ahead)</p>
<p>默认关闭</p>
</li>
</ul>
</li>
<li><p>启动,关闭和恢复</p>
<ul>
<li><p>关闭</p>
<p>关机动作参数<br>innodb_fast_shutdown:</p>
<pre><code>0 , 完成所有full purge和merge insert buffer,所有脏页刷新回磁盘,会需要很长时间.但是InnoDB引擎升级时必须使用.
1 , 不需要完成full purge和merge insert buffer.只刷新缓冲池中的脏页回磁盘. 
2 ,不full purge 和 merge insert buffer,数据脏页不落盘.将日志写入文件,下次启动恢复.
</code></pre>
<p>恢复动作参数<br>innodb_force_recovery</p>
<pre><code>0 , 需要恢复时,恢复数据
1~6, 忽略恢复数据动作(主键递增),此时DML操作不允许.
</code></pre>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2></li>
</ul>
</li>
</ul>
<h3 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h3><ul>
<li><p>参数</p>
<p>使用 show variables 命令</p>
</li>
<li><p>参数类型</p>
<ul>
<li><p>动态参数</p>
<p>运行时可修改.<br>set [global | session] system_var_name=expr</p>
<p>修改只会在实例声明周期有效,不会修改文件中的参数.重启后使用配置文件参数</p>
</li>
<li><p>静态参数:只读</p>
</li>
</ul>
</li>
</ul>
<h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><ul>
<li><p>错误日志(err log)</p>
<p>– 查看错误日志文件位置<br>show variables like ‘log_error’</p>
</li>
<li><p>二进制日志(binlog)</p>
<ol>
<li>概念:<br> 记录了对MySQL数据库执行更改的所有操作.不包括select show这类操作.如果出现多次修改数据,将数据修改至最初状态,该操作也会被写入到二进制文件.</li>
<li>作用:<br> 恢复(recovery):某些数据恢复需要<br> 复制(replication):主从复制<br> 审计(audit):通过日志进行审计,进行判断有误注入攻击</li>
</ol>
<ul>
<li><p>参数</p>
<p>max_binlog_size: </p>
<pre><code>指定单个二进制日志文件的最大值.超过值,则创建一个新的二进制文件,后缀名+1;
</code></pre>
<p>binlog_cache_size:</p>
<pre><code>使用事务存储引擎是,所有未提交的二进制日志会被记录到一个缓存中,等该事务提交时,直接将缓冲的二进制日志写入二进制文件.缓冲大小由该参数指定. 作用于每个session中,因此设置不宜过大.也不宜过小,mysql会把缓冲文件中的数据写入临时文件.
</code></pre>
<p>sync_binlog:</p>
<pre><code>sync_binlog=[N],表示每写缓冲多少次就同步到磁盘.如果设为sync_binlog=1,表示采用同步磁盘的方式来写二进制,此时不使用操作系统的缓冲.
</code></pre>
<p>binlog_format</p>
<pre><code>-statement ,逻辑sql语句,同步时,会出现不一致的情况.uuid比如
-row    记录表更改情况.
-mix     默认使用statement,在特殊情况下使用row.比如ndb的DML操作,UUID()等不确定函数,用户自定义函数,临时表等.
</code></pre>
<ul>
<li><p>binlog_format</p>
<p>1.优点:</p>
<pre><code>数据恢复和复制更好的可靠性.
</code></pre>
<p>缺点:</p>
<pre><code>导致二进制文件大小增加.存储与网络开销大.
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>慢查询日志(slow query log)</p>
<p>定位存在问题的SQL语句.<br>使用slow_query_log开启慢查询日志<br>使用long_query_time指定慢查询时间,只有大于该时间会被记录</p>
<ul>
<li><p>开启</p>
</li>
<li><p>指定时间</p>
</li>
<li><p>记录没有走索引的查询</p>
</li>
<li><p>mysqldumpslow.pl</p>
<p>可以使用这个工具进行检索查看mysql慢查询.mysql自带</p>
</li>
<li><p>慢查询输出到slow_log表</p>
<p>– 查看日志输出形式,file,table<br>show variables like ‘log_output’<br>– 设置慢查询日志以table形式存储<br>set  global log_output=”table”</p>
<p>slow_log表默认使用CSV存储引擎,可以改为MyISAM,提升搜索效率<br>– 更改slow_log 表存储引擎为MyISAM,提升查询性能<br>set global  slow_query_log=off<br>alter table  mysql.slow_log engine=MyISAM<br>set global  slow_query_log=on</p>
</li>
</ul>
</li>
<li><p>查询日志(log)</p>
<p>查询日志放到mysql.general_log</p>
<h3 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h3></li>
</ul>
<p>UNIX下,mysql.sock,用于本地连接.</p>
<h3 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h3><p>进程ID写入到-&gt; 主机名.pid<br>可以使用参数控制文件位置.pid_file</p>
<h3 id="表结构定义文件-frm"><a href="#表结构定义文件-frm" class="headerlink" title="表结构定义文件.frm"></a>表结构定义文件.frm</h3><p>存放表与视图</p>
<h3 id="存储引擎文件"><a href="#存储引擎文件" class="headerlink" title="存储引擎文件"></a>存储引擎文件</h3><ul>
<li><p>表空间文件</p>
<p>默认表空间:</p>
<pre><code>存储的数据按照表空间进行存放,ibdata1是默认表空间.可以使用参数配置 innodb_data_file_path.可以配置多个,用来实现平均磁盘负载,提高性能.
</code></pre>
<p>innodb_file_per_table: 为每个表设置独立表空间 </p>
<pre><code>独立表空间只存储该表的数据,索引和插入缓冲Bitmap等信息,其余信息还是放在默认表空间中.
</code></pre>
<h3 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h3></li>
</ul>
<p>记录事务日志<br>innodb_log_file_size:<br>    每个重做日志大小</p>
<ul>
<li><p>文件大小的影响</p>
<p>文件太大时,恢复时需要很长时间.<br>文件太小需要频繁切换重做日志文件,同时会导致频繁发生async checkpoint,导致性能抖动.</p>
</li>
<li><p>log block</p>
<p>重做日志都是以512字节进行存储的,</p>
</li>
<li><p>redo log文件格式</p>
<p>redo_log_type + space + page_no + redo_log_body</p>
<pre><code>redo_log_type: 类型
space :表空间
page_no : 页偏移量
redo_log_body: 数据
</code></pre>
</li>
<li><p>写入过程</p>
<p>写入redo log file不是直接写入,而是先写入一个重做日志缓冲 redo log buffer,然后写入文件,log 文件满则循环写入其他文件.</p>
<p>redo log buffer按照512个字节,也就是一个扇区大小进行写入.因为扇区是写入最小单位,因此可以保证写入必定成功.因此在写redo log file 时不需要doublewrite.</p>
<ul>
<li>redo 为什么不需要doublewrite?</li>
</ul>
</li>
<li><p>事务提交时,对redo log的处理</p>
<p>innodb_flush_log_at_trx_commit</p>
<pre><code>-0, 提交时,不将重做日志写入到磁盘的日志文件上,等待主线程刷新
-1(默认), 提交时,将redo log buffer 写入磁盘,还有fsync操作.文件一定写入到文件中
-2, 提交时,将redo log buffer 写入磁盘,没有fsync操作.不能完全保证数据写入文件中. 如果数据库宕机,而系统正常,则可以恢复.
</code></pre>
</li>
<li><p>对比redo log 与 binlog</p>
<ol>
<li>日志范围不同:<br> redo log 只记录InnoDB的事务日志<br> binlog 记录Mysql有关的日志,包括所有引擎.</li>
<li>内容:<br> redo log 记录每个page的物理操作<br> binlog 记录逻辑日志,无论文件记录格式是statement还是row 或者 mixed</li>
<li>写入时间:<br> redo log在事务过程中,不断写入日志文件中.<br> binlog 只在事务提交前提交,只写盘一次.<br> 4.幂等性:<br> redo log是物理操作,所以是幂等的<br> binlog设置为ROW也不是幂等的,比如insert 操作.<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2></li>
</ol>
</li>
</ul>
<h3 id="索引组织表-index-organized-table"><a href="#索引组织表-index-organized-table" class="headerlink" title="索引组织表((index organized table))"></a>索引组织表((index organized table))</h3><p>InnoDB中,表是根据主键顺序进行组织存放的,这种存储方式称为索引组织表(index organized table).</p>
<p>如果没有指定主键或者创建主键.<br>    则会选择表内非空唯一索引(unique not null)为主键.如果有多个,则选择创建的第一个索引.<br>    如果没有索引,则默认添加一个6字节大小的指针作为主键.</p>
<h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>表空间(table space) </p>
<ul>
<li><p>表空间</p>
<p>默认表空间 ibdata1 ,</p>
<pre><code>存储 undo 信息,插入缓冲索引页, 系统事务信息,二次写缓冲.
</code></pre>
<p>单独表空间:    </p>
<pre><code>只存储,数据,索引和插入缓冲bitmap 页
</code></pre>
<ul>
<li><p>段</p>
<p>数据段,索引段,回滚段.</p>
<p>数据段</p>
<pre><code>是B+树叶子节点
</code></pre>
<p>索引段 </p>
<pre><code>B+树非叶子节点
</code></pre>
<ul>
<li><p>区</p>
<p>由连续的页组成,任何情况下大小都为1M.为了保证区中页的连续性,存储引擎每次从磁盘中申请4~5个区. 一个区中有64个连续页.</p>
<p>每个段开始有32个碎片页,使用完后才申请64个连续页,为了对于小表可以在开始时申请较少内存,节省磁盘容量开销.</p>
<ul>
<li><p>页</p>
<p>InnoDB中最小存储单位,.默认大小16KB.<br>可以使用innodb_page_size来修改每个页的大小.</p>
<p>分类:</p>
<pre><code>数据页(B-tree node)
undo页(undo log page)
系统页(system page)
事务数据页(transaction system page)
插入缓冲位图页(inset buffer page)
插入缓冲空闲列表页(insert buffer free list)
未压缩的二进制大对象页(uncompressed BLOB page)
压缩的二进制大对象页(compressed BLOB page)
</code></pre>
<ul>
<li><p>行</p>
<p>每个页,最多允许存放16KB/2-200行数据</p>
<h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>查看show table status<br>Row_Format显示行格式</p>
<ul>
<li><p>Compact行记录格式</p>
<p>高效存储<br>边长字段长度列表 + NULL标志位 + 记录头信息 + 列1数据 … </p>
<p>边长字段长度列表: </p>
<pre><code>那些列是变长的
</code></pre>
<p>记录头信息 :</p>
<pre><code>该行是否删除,下一记录位置,类型,记录数
n_owned
next_record
delete_flag
</code></pre>
<p>不管是char还是varchar类型,compact下,都不占空间</p>
</li>
<li><p>Reduant行记录</p>
<p>格式</p>
<pre><code>边长字段长度列表  + 记录头信息 + 列1数据 ... 
</code></pre>
<p>记录头信息:</p>
<pre><code>n_fields (10bit): 记录中列的数量,只有10位,一次最大支持1023列.
</code></pre>
</li>
<li><p>行溢出数据</p>
<p>InnoDB可以把一条记录中的某些数据存储在真正的数据页面之外.一般是BLOB,LOB这种大对象类型的数据存储在数据页面之外.<br>BLOB可以不将数据放在溢出页面,varchar也可以存放为行溢出数据.</p>
<p>一般情况下,数据存放在数据页中.,类型为B-Tree node,但当发生行溢出时,数据放在Uncompress BLOB页中.</p>
<p>TEXT或者BLOB并不一定总是存放在 Uncompress BLOB 中,只要一个页至少能存放两条记录,那就不需要存到Uncompress BLOB中.但是大多数情况BLOB都会发生行溢出的.</p>
</li>
<li><p>Compressed和Dynamic(默认格式)行记录格式</p>
<p>这两个记录格式,都采用完全行溢出,</p>
<p>compressed 会对其中数据以zlib进行压缩,因此对于BLOB,TEXT,VARCHAR大长度类型对象非常有效存储.</p>
</li>
<li><p>CHAR的行结构存储</p>
<p>char类型被明确视为了变长类型,对于未能占满长度的字符还是填充0x20.在多字符集的情况下,char和varchar类型的实际存储基本没有区别.</p>
<p>比如char(5) ,可以存储 “12345”, 也可以存储 “一二三四五”.不再只根据字节数限制.</p>
<h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3></li>
<li><p>File Header(文件头)</p>
<p>包括:</p>
<pre><code>表空间中页的偏移量
上一页指针
下一页指针
最后被修改的日志序列位置LSN
页的类型()
</code></pre>
</li>
<li><p>Page Header(页头)</p>
<p>记录数据页状态</p>
<pre><code>页中记录数
槽数
索引ID,当前页属于哪个索引
</code></pre>
</li>
<li><p>Infimun和Supremum Record</p>
<p>Infimum,比任何主键值都小的值 ,类似头指针<br>Supremum,比任何主键都大的值 ,类似尾指针</p>
</li>
<li><p>User Records(用户记录,行记录)</p>
<p>存储行记录的内容</p>
</li>
<li><p>Free Space(空闲空间)</p>
<p>空闲空间,也是个链表数据结构.记录删除后,加入该空闲链表.</p>
</li>
<li><p>Page Directory(页目录)</p>
<p>存放这记录的相对位置,记录指针称为槽slot. 洗漱目录,一个槽可能不包含多个目录.</p>
<p>查询过程:</p>
<pre><code>B+树索引不能找到具体的目录,只能找到数据页.找到后,把页载入内存,然后通过Page Directory进行二分查找,找到指定槽,然后查找槽上的记录. 在数据页中的查找速度很快,时间可以忽略.
</code></pre>
</li>
<li><p>File Trailer(文件结尾信息)</p>
<p>file trailer 用于检测页是否完整写入磁盘.<br>File Trailer只有一个FIL_PAGE_END_LSN部分, 8字节,前四字节代表该页的checksum值.后4字节和File Header中的FIL_PAGE_LSN相同. 然后根据结果比对,可以判断页是否完整.</p>
<p>默认情况下,每次从磁盘读取一个页就会检测完整性,可以通过参数控制是否检查<br>– innodb_checksum_algorithm 完整性检查的算法<br>– innodb_checksums 取页的是否做完整性检查</p>
<ul>
<li>完整性检查</li>
</ul>
</li>
</ul>
<h3 id="Named-File-Formats"><a href="#Named-File-Formats" class="headerlink" title="Named File Formats"></a>Named File Formats</h3><p>InnoDB存储通过Named File Format机制来解决不同版本的页兼容性问题.新的文件格式,总是包含之前版本 的页格式</p>
<p>innodb_file_format 用来指定页格式</p>
<ul>
<li><p>Barracuda File Foramt</p>
<ul>
<li><p>Compressed</p>
</li>
<li><p>Dynamic</p>
</li>
<li><p>Antelope File Format</p>
<ul>
<li>Compact</li>
<li>Redundant</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>在information_schema.TABLE_CONSTRAINTS中可以查看约束</p>
<ul>
<li><p>数据完整性</p>
<ul>
<li>实体完整性</li>
<li>域完整性</li>
<li>参照完整性</li>
</ul>
</li>
<li><p>约束和索引的区别</p>
<p>约束是一个逻辑概念,用来保证数据完整性,索引是一个数据结构,既有逻辑概念,也有物理概念.</p>
</li>
<li><p>对错误数据的约束</p>
<p>如果sql_mode设置不合理,则约束会失效.数据库只提示警告,而不是报错.</p>
</li>
<li><p>外键约束</p>
<p>在添加外键的时候,可以添加子表操作.<br>reference_option:</p>
<pre><code>CASCADE: 表示父表进行DELETE或者UPDATE时,字表数据也进行相应操作
SET NULL: 父表更新或删除,字表设置为null
NO ACTION: 父表更新,删除,字表抛出错误,禁止这类操作
RESTRICT:  父表更新,删除,字表抛出错误,禁止这类操作
</code></pre>
<p>添加外键时,mysql 会自动给字段添加索引.</p>
<ul>
<li><p>外键检查</p>
<p>在数据导入时,可以将外键检查关闭,导入完成后,打开外键.</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3></li>
</ul>
</li>
</ul>
<p>虚表,只存在于内存中,没有物理存储.</p>
<ul>
<li><p>作用</p>
<p>应用不关心基表的结构,只需要按照视图定义来取或者更新数据.<br>同时也可以起到一个安全层的作用.</p>
<p>可更新视图,</p>
<pre><code>创建视图时,可以使用 with check option,对更新视图插入的数据进行检查,对于不满足视图条件的数据更新时,会抛出异常,不允许更新.比如插入条件之外的内容.
</code></pre>
</li>
<li><p>物化视图</p>
<p>mysql不支持物化视图,可以使用触发器+辅助表,来实现.</p>
<ul>
<li><p>刷新模式</p>
<p>ON DEMAND :</p>
<pre><code>在用户需要的时候,刷新视图
</code></pre>
<p>ON COMMIT</p>
<pre><code>在基表更新时刷新视图
</code></pre>
</li>
<li><p>刷新方法</p>
<p>FAST</p>
<pre><code>增量刷新,只刷新上次以后的修改
</code></pre>
<p>COMPLETE</p>
<pre><code>完全刷新
</code></pre>
<p>FORCE</p>
<pre><code>如果可以FAST就使用FAST,否则使用COMPLETE
</code></pre>
<p>NEVER</p>
<pre><code>不进行任何刷新
</code></pre>
</li>
<li><p>查询重写</p>
<p>对物化视图的基表进行查询时,如果能通过物化视图直接获得结果,则直接使用物化视图结果.则可以避免聚集或者连接这类复杂操作.</p>
</li>
</ul>
</li>
<li><p>MySQL模拟物化视图</p>
<p>触发器+辅助表</p>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3></li>
</ul>
<p>分区功能不是在存储引擎层实现的.分区的过程是将一个表或者索引分解为多个更小的,可管理的部分.</p>
<p>水平分区:<br>    不同行分配到不同文件中<br>垂直分区:<br>    不同列分配到不同文件中</p>
<p>局部分区:<br>    一个分区中既放索引,又放数据<br>全局分区<br>    数据放在各个分区中,所有数据的索引放在一个对象里</p>
<p>MySQL支持: 水平分区,局部分区<br>使用参数来开启功能.</p>
<p>误区    </p>
<ol>
<li>只要启用分区,性能就高<br> 分区并不一定能够带来性提高,有的会更快,有的会变慢.分区主要用于提升数据的高可用管理.</li>
</ol>
<ul>
<li><p>创建索引注意:</p>
<p>如果表中存在主键或唯一索引时,</p>
<pre><code>分区列必须是唯一索引的一个组成部分.
</code></pre>
<p>如果没有主键或唯一索引时:</p>
<pre><code>可以指定任何一个列为分区列
</code></pre>
<ul>
<li><p>分区修剪(Partition Pruning)</p>
<p>SQL优化器只需要根据检索条件去搜索指定分区,而不会搜索所有分区.这个称为分区修剪,使检索速度大大提高.</p>
<p>但是如果跨了多个分区,可能也会导致检索变慢.</p>
</li>
</ul>
</li>
<li><p>分区类型</p>
<ul>
<li><p>RANGE分区</p>
<p>ALTER TABLE <code>order</code>.<code>t_order</code><br> PARTITION BY RANGE(id)(</p>
<pre><code>partition p0  values less than (10),
    partition p1  values less than (maxvalue)
</code></pre>
<p> );</p>
<p>range分区,主要用于日期类.分区函数仅限于         YEAR(),TO_DAYS(),TO_SECONDS(),UNIX_TIMESTAMP()这类函数进行优化选择. 如果使用自定义</p>
</li>
<li><p>LIST分区</p>
<p>插入多个离散的值.<br>ALTER TABLE <code>order</code>.<code>t_order</code><br> PARTITION BY LIST(id)(</p>
<pre><code>partition p0  values in (1,2,3),
    partition p1  values in (4,5,6)
</code></pre>
<p> );</p>
<p>InnoDB,在插入多个行时,如果中间出现不在定义范围内的数据,则会抛出异常,然后回滚.<br>MyISAM,插入就插入了</p>
</li>
<li><p>HASH分区</p>
<p>目的:</p>
<pre><code>为了将数据均匀地分布到预先定义的各个分区中,保证每个分区的记录数量大致相同.
</code></pre>
<p>定义:</p>
<pre><code>指定分区数量,以及分区的hash值.
ALTER TABLE `order`.`t_order` 
    partition BY HASH(id)
        partitions 4;
</code></pre>
</li>
<li><p>LINEAR HASH分区</p>
<ol>
<li><p>概念:<br> 使用更为复杂的算法来确定新行的分区位置.<br> ALTER TABLE <code>order</code>.<code>t_order</code> </p>
<pre><code> partition BY LINEAR HASH(id)
     partitions 4;
</code></pre>
</li>
<li><p>算法<br> 取分区大于分区数量4的下一个2的幂值V(6)<br> 所在分区N=输入值&amp;(V-1)</p>
<p> 优点: </p>
<pre><code> 增加,删除,合并和拆分分区变得更加快捷,有利于处理大量数据的表.
</code></pre>
<p> 缺点:</p>
<pre><code> 区间的数据分布可能不太均衡
</code></pre>
</li>
</ol>
</li>
<li><p>KEY分区</p>
<p>分区的编号是通过2的幂算法(power-of-two)得到而不是模数算法.</p>
</li>
<li><p>COLUMNS</p>
<p>可以直接使用费整型的数据进行分区,不需要转化成整型.</p>
<p>ALTER TABLE <code>order</code>.<code>t_order</code><br> partition BY RANGE COLUMUNS(id,userId)<br> partitions  p0 values less than(a,b),<br> partitions  p1 values less than(c,d),<br> partitions  p2 values less than(e,f),</p>
<p>包括:</p>
<pre><code>所有整型:INT,SMALLINT等.不包括FLOAT,DECIMAL.
日期类型:DATE和DATETIME.其他不支持.
字符串类型:CHAR,VARCHAR,BINARY.不支持BLOB和TEXT
</code></pre>
</li>
</ul>
</li>
<li><p>子分区</p>
<p>允许在RANGE和LIST的基础上在进行HASH或者KEY的子分区.<br>注意:</p>
<pre><code>在分区表任何分区上使用subpartition明确定义任何分区,就要定义所有分区的子分区.
子分区名字必须唯一
</code></pre>
</li>
<li><p>分区中的NULL值</p>
<p>将NULL值视为最小值.<br>RANGE分区,</p>
<pre><code>插入最左分区
</code></pre>
<p>LIST分区下,</p>
<pre><code>必须指定哪个分区放入NULL值
</code></pre>
<p>HASH和KEY分区,</p>
<pre><code>将NULL值记录返回为0
</code></pre>
</li>
<li><p>分区和性能</p>
<p>对于OLAP,</p>
<pre><code>查询数据多,分区可以提升查询性能
</code></pre>
<p>对于OLTP,</p>
<pre><code>查询数据少,应该注意.如果分区设计不好,会导致严重性能.最坏情况导致扫描多个分区,IO大大增加.
</code></pre>
</li>
<li><p>在表和分区间交换数据</p>
<pre><code>可以使用alter table ... exchange partition语句进行交换.如果非分区表中没有数据,相当于将分区表中数据移到非分区表,导出.如果相反,则是导入.
</code></pre>
<p>要求条件:</p>
<pre><code>两个表结构相同,表不能有分区
非分区表的数据必须在分区的定义内.
非分区表不能有外键
除了alter,insert,create权限外,还需要DROP权限
</code></pre>
<p>注意:</p>
<pre><code>交换不会触发两表的触发器
auto_increment列将会被重置.
</code></pre>
<p>猜测 交换规则:重新建表,然后改名?</p>
<h2 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h2></li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul>
<li><p>B+树索引</p>
<p>B 指的是balance  而不是binary</p>
<p>B+树索引不能找到给定键值的具体行,B+树索引能找到数据行所在的页.然后读取页到内存,再使用二分法查找,获得最终数据.</p>
<p>特点: 高扇出性,直接调用的下级模块的个数多,高度一般都在2~4层.所以有效减少IO次数.</p>
<ul>
<li><p>聚集索引</p>
<p>cluster index:</p>
<pre><code>按照表的主键构造B+ 树,叶子节点中存放的为整张表的行数据,也将聚集索引的叶子节点称为数据页.
每张表只有一个聚集索引,所以查询优化器倾向于使用聚集索引.
</code></pre>
<p>聚集索引不是在存储上面不是连续的.只是在逻辑上是连续的,如果是连续的,则需要很大的维护成本.</p>
<p>排序查找和范围查找很快.不需要进行filesort</p>
<ul>
<li><p>索引页</p>
<p>只存放键值和指向数据页的偏移量.</p>
</li>
<li><p>数据页</p>
<p>存放完整记录</p>
</li>
</ul>
</li>
<li><p>辅助索引</p>
<p>叶子结点并不包含行记录完整数据.叶子结点除了包含键值之外,还有bookmark,即主键值,即聚集索引键.</p>
<p>通过辅助索引查询数据时,会遍历辅助索引,并通过页级别的指针获得主键,然后通过主键索引获得完整记录.</p>
<p>可以通过预读(read ahead)技术,来避免多次的离散操作.</p>
</li>
<li><p>B+ 树索引的分裂</p>
<pre><code>页的分裂并不总是从页的中间记录开始的,这样可能会导致页空间的浪费.比如顺序插入,分裂后,左页不会再有数据插入,空间浪费.
InnoDB根据Page Header中的 PAGE_LAST_INSERT,PAGE_DIRECTION,PAGE_N_DIRECTION信心来判断存储引擎是向左还是向右进行分裂.
若插入是随机的,则从页中间分裂.
若往同一方向进行插入的记录数量为5,并且定位到记录之后还有三条记录,则分裂点为定位到的记录后的第三条记录.否则分裂点记录就是待插入记录.
</code></pre>
</li>
<li><p>索引管理</p>
<ul>
<li><p>查看索引</p>
<p>show index from tablexxx;</p>
<ul>
<li><p>Cardinality</p>
<pre><code>Cardinality:表示索引中唯一值的数目的估计值.其中Cardinality/记录总数,  应该尽可能的接近1.如果非常小,则考虑要删除该索引.
优化器会根据这个值来判断是否使用索引.这个值不是实时更新的,因为这样代价太大.同时这个值只是一个大概值.
</code></pre>
<ul>
<li><p>手动更新Cardinality</p>
<p>Analyze table来更新信息</p>
<pre><code>在某些情况下,索引建立却没有用到的情况,或者对两条基本一样的语句执行EXPLAIN,但是最终结果不一样:一条使用索引,另一个使用全表扫描.最好解决办法是analyze table.
建议在非高峰时间里,对核心表进行analyze table操作,从而使优化器和索引更好的工作.
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>快速索引创建(Fast Index Creation)</p>
<p>在以往的MySQL数据库索引添加或者删除这类DDL操作.MySQL的操作过程是: </p>
<pre><code>创建临时表,表结构为修改的后的表结构
把原表数据导入到临时表
删除原表
重名临时表,为原来的表名.
</code></pre>
<p>传输索引创建(FIC)</p>
<pre><code>先对索引创建表加上一个S锁.在创建过程中不需要重新建表,速度,可用性都得到提升.
删除辅助索引,只需要更新内部视图,将辅助索引空间标记为可用,同时删除索引定义.
问题: 加了S锁,只能对表进行读操作,若有大量事务对表进行写操作,那么数据库服务同样不可用的.此外FIC只限定于辅助索引,对于主键的创建和删除同样需要重建表.
</code></pre>
</li>
<li><p>在线架构改变(Online Schema Change,OSC)</p>
<p>指定时,在事务的读写过程中,仍然可以修改索引.</p>
<pre><code>创建和原表一样的表,并且进行alter操作.
创建deltas表,并且在原表上添加触发器,将对原表的DML操作写入deltas表.
将原表中的数据写入到新表中.为了减少锁定时间,使用分片(chunked)将数据输出到多个外部文件,然后将外部文件导入到copy表中.
导入数据到新表前,删除所有的辅助索引
将分片文件导入到新表.
将OSC过程中,原表的DML操作应用到新表中,
重创辅助索引
再次进行DML日志的回放,这些日志是在创建辅助索引的过程中产生的日志
将新表和旧表名字交换.改名很快,因此阻塞时间很短.
</code></pre>
</li>
<li><p>在线数据定义(Online DDL)</p>
<p>允许辅助索引创建的同时,还允许其他DML操作,包括insert,update,delete.</p>
<p>包括一些DDL操作:</p>
<pre><code>辅助索引的创建与删除
改变自增长值
添加或者删除外键约束
列的重命名
</code></pre>
<p>原理:</p>
<pre><code>在执行或者删除操作时,将insert,update,delete这类DML操作日志写入到一个缓存中.待完成索引创建后,在重做应用到表上,以此达到数据一致性.这个缓存大小由参数innodb_online_alter_log_max_size作修改.
</code></pre>
<p>可以使用新的alter table 语法.同时可以选择索引的创建方式:</p>
<pre><code>alter table tbl_name
| add {index|key} {index_name}
[index_type] (index_col_name,...) [index_option]
algorithm [=] {default|inplace|copy}
lock [=] {default| none|shared|exclusive}
</code></pre>
<p>algorithm 指定了创建或者删除索引的算法,</p>
<pre><code>-copy表示按照创建临时表方式.
-inplace表示索引创建或者删除操作不需要创建临时表.
-default表示根据参数 old_alter_table来判断. 默认为off,表示使用inplace方式.
</code></pre>
<p>lock 部分表示索引创建或删除时对表添加锁的情况.</p>
<pre><code>-none , 对目标表不添加锁,事务仍然可以进行读写操作,不会受到阻塞,可以获得最大并发度.
-share , 类似FIC,索引创建和删除加上一个S锁.可以并发读,但是阻塞写操作.
-exclusive, 执行索引创建或删除操作,对目标加上一个X锁.读写事务都不能进行.
-default ,首先判断当前操作,能否使用none模式,如果不能则判断是否可以使用share模式,最后exclusive.
</code></pre>
<p>​<br>​    </p>
</li>
</ul>
</li>
<li><p>哈希索引</p>
<ul>
<li><p>InnoDB存储引擎中的hash算法</p>
<pre><code>用于字典查找,冲突机制采用除法散列方式.对于缓冲池页的哈希表,在缓冲池中的Page页都有一个chain指针,用它指向相同的哈希函数值的页.
对于除法散列,m的取值略大于2倍的缓冲池页数量的质数.
</code></pre>
<p>页转换成自然数:</p>
<pre><code>    自然数K=space_id&lt;&lt;20+space_id+offset
    space_id左移20位.
</code></pre>
</li>
<li><p>AHI</p>
</li>
</ul>
</li>
<li><p>全文索引</p>
</li>
</ul>
<h3 id="Cardinality-基数"><a href="#Cardinality-基数" class="headerlink" title="Cardinality(基数)"></a>Cardinality(基数)</h3><p>Cardinality:<br>    列中不重复的字段数的预估值.<br>选择性:<br>    字段取值的范围很小,称为低选择性.很多则是高选择性.<br>用作索引的字段,应该要有高选择性,几乎没有重复,用作B+树索引比较合适. 实际应用中, Cardinality/n_rows_in_table应该尽可能地接近1.如果非常小,则要考虑是否有必要加这个索引.</p>
<ul>
<li><p>统计方法</p>
<p>方法:</p>
<pre><code>并不是每次更新操作去统计,开销太大.数据库对Cardinality的统计通过采样(Sample)的方法来完成.
</code></pre>
<p>更新策略:</p>
<pre><code>1. 表中1/16数据已经发生过改变.
2. stat_modified_counter(修改次数)&gt;20,0000,这是防止对一部分数据不断修改,导致第1策略不适用的情况
</code></pre>
<p>采样方法:</p>
<pre><code>随机取得B+树索引中8个叶子节点.统计每个页不同记录个数,然后除以记录总数得到Cardinality. innodb_stats_sample_pages 指定随机取得页数.
</code></pre>
<h3 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h3></li>
<li><p>联合索引</p>
<p>联合索引,只要满足最左匹配,数据就可以走索引.<br>数据也根据键值进行排序.因此,有些情况可以避免使用filesort.</p>
</li>
<li><p>覆盖索引(convering index)</p>
<p>概念:</p>
<pre><code>从辅助索引中就可以查询到记录,不需要再插叙聚集索引中的记录. 
</code></pre>
<p>优点:<br>辅助索引不包含完整行记录,因此大小远远小于聚集索引,同时不需要读取数据页,可以减少IO操作.</p>
<p>在正常情况下,对于(a,b)联合索引,一般不可以选择列b中的查询条件.但是如果是统计操作,并且是覆盖索引,则优化器会进行选择.如下</p>
<pre><code>select count(*) from table where b&gt;xx and b&lt;xxx
</code></pre>
</li>
<li><p>优化器不选择辅助索引的情况</p>
<p>当同时存在主键索引,辅助索引可用时,优化器选择了主键聚集索引,进行了全表扫描,而没有走辅助索引.<br>原因:</p>
<pre><code>用户选择的数据较多,辅助索引不能覆盖到查询信息,因此使用辅助索引后,还要查询一次书签,才能获得数据.虽然辅助索引数据有序,但是对书签的查找是无序的,会变成磁盘离散读操作.如果访问数据量小,则优化器会选择辅助索引,但是当访问数据量大时(比如占到表的20%),优化器会选择聚集索引来查找数据,因为顺序读速快于离散读.
因此,对于不能进行索引覆盖的情况,优化器选择辅助索引的情况是,通过辅助索引查找的数据是少量的.
</code></pre>
<p>如果使用SSD,随机读快速,则可以使用force index 来强制使用某个索引. select * from xxx force index (idx_xxx)</p>
<ul>
<li>优化器什么时候选择辅助索引?</li>
<li>force index(…)</li>
</ul>
</li>
<li><p>索引提示</p>
<p>显式告诉优化器使用那个索引.</p>
<pre><code>优化器错误选择索引
索引很多,优化器选择执行计划时间开销大于SQL语句本身.
</code></pre>
<p>通过index hint 可以强制优化器不进行各个执行路径的成本分析,直接选择指定索引来完成查询.</p>
<ul>
<li><p>Index Hint</p>
<p>select * from t use index(a_idx) where ….</p>
<p>use index 只是告诉优化器可以选择该索引,实际上,优化器还会再根据自己判断进行选择.<br>如果想要强制使用某一索引,可以使用force index</p>
</li>
</ul>
</li>
<li><p>多范围查询优化(Multi-Range Read优化,MRR)</p>
<p>目的:</p>
<pre><code>为了减少磁盘随机访问.对于受限于IO的SQL查询语句可以带来极大提升.适用于range,ref,eq_ref
</code></pre>
<p>优点:</p>
<pre><code>1. 使数据访问变得较为顺序.在插叙辅助索引时,现根据得到的查询结果,按照主键排序,并按照主键排序的顺序进行书签查找.
2. 减少缓冲池中页被替换的次数,比如缓冲池空间小,随机读取会导致页被不断移除,读入.
3. 批量处理对键值的查询操作
</code></pre>
<p>解释1,2: 对于范围查找和join查询,工作方式:</p>
<pre><code>将查询到的辅助索引存放于缓存中,此时是数据排序是使用辅助索引键值
将缓存中的键值根据RowID进行排序
根据RowID的排序来访问实际的数据文件.
</code></pre>
<p>解释3:</p>
<pre><code>还可以将某些范围查询,拆分成键值对,一起进行数据查询.好处是,在拆分过程中,直接过滤一些不符合查询条件的数据.
比如where  0&lt;a and a&lt;100. and b&lt;100 and b &gt;-123 .如果没有MRR,则先读取符合条件a的所有数据,再根据条件b进行筛选,这样导致了符合a不符合b的无用数据读出.如果开启MRR,则查询优化器会讲条件拆分为(0,-122),(0,-121),..,(1,-122)...然后根据拆分条件进行数据查询.
</code></pre>
<p>开启:</p>
<pre><code>可以使用optimizer_switch 中关于mrr的flag来开启MRR.
</code></pre>
<p>read_rnd_buffer_size用来控制键值的缓冲区大小.当大于该值时,则执行器对已经缓存的数据根据RowID进行排序,并通过RowID来获取行数据.</p>
</li>
<li><p>索引下推Index Condition Pushdown(ICP)优化</p>
<p>没有使用索引下推时:</p>
<pre><code>先根据索引来查询满足索引的所有记录,然后根据where条件过滤.
</code></pre>
<p>使用索引下推:</p>
<pre><code>在取出索引的同时,判断是否可以进行where条件过滤,也就是将where的部分过滤操作放到了存储引擎层. 使用ICP优化时,在执行计划Extra可以看到 Using index condition提示.
</code></pre>
<p>所以本质来说，索引下推就是只有符合条件再进行回表，对索引中包含的字段先进行判断，不符合条件的跳过。减少了不必要的回表操作。</p>
<h3 id="全文检索-Full-Text-Search"><a href="#全文检索-Full-Text-Search" class="headerlink" title="全文检索(Full-Text Search)"></a>全文检索(Full-Text Search)</h3><p>  将存储于数据库中的整本书或者文章中的任意内容信息找出来的技术.可以获取全文有关章,节,段落,句,词信息,也可以用来统计和分析.InnoDB支持全文检索</p>
</li>
</ul>
<ul>
<li><p>倒排索引(inverted index)</p>
<p>也是一种索引结构,在辅助表(auxiliary table)存储单词与单词所在文档地址的映射.有两种形式</p>
<pre><code>1.inverted file index {单词,文档ID}
2.full inverted index, 表现形式为{单词,(文档ID,具体位置)}
</code></pre>
</li>
<li><p>InnoDB全文检索</p>
<p>支持全文检索,使用full inverted index方式.</p>
<pre><code>即 {word,(documentID,position)}   {word,ilist}
</code></pre>
<p>在word上设有索引,由于ilist中存放了position信息,因此可以实现proximity search 近似匹配.</p>
<p>为了提高全文检索的并行性能,共有6张auxiliary table,每张表按照word和latin编码分区.<br>auxiliary table 是持久表存放在磁盘上.</p>
<ul>
<li><p>全文检索索引缓存(FTS Index Cache)</p>
<pre><code>FTS Index Cache (全文检索索引缓存),用来提高检索性能.红黑树结构,这意味着在插入数据后,对全文索引的更新还在 FTS Index Cache中,导致auxiliary table 还没有被更新. (并不能实时更新)
</code></pre>
<p>批量插入:</p>
<pre><code>InnoDB存储引擎会批量对auxiliary table进行更新,而不是每次插入后就更新一次auxiliary table.
</code></pre>
<p>查询前merge</p>
<pre><code>当对全文检索进行查询时,auxiliary table会首先在FTS Index Cache中对应的word字段合并到auxiliary table中,然后进行查询
</code></pre>
<p>可以在informat_schema中看到关于FTS_Cache与table的分词信息.</p>
<p>分词写入:</p>
<pre><code>InnoDB存储引擎总是在事务提交时,将分词写入到FTS Index Cache中,然后通过批量更新写入到磁盘,尽在事务提交时发生.
</code></pre>
<p>当数据库关闭或者宕机</p>
<pre><code>当数据库关闭时,FTS Index Cache中的数据会同步到磁盘上的auxiliary table.发生宕机时,会丢失数据.重启数据库后,当用户对表进行全文检索时(检索或者插入),InnoDB会自动读取未完成的文档,然后进行分词操作,再将结果放到FTS Index Cache中.可以通过参数innodb_ft_cache_size 进行设置
</code></pre>
</li>
<li><p>辅助表(Auxiliary Table)</p>
<p>为了辅助全文检索功能,而存在的表.一共有6个表.</p>
<p>INNODB_FT_BEING_DELETED  </p>
<p>INNODB_FT_CONFIG </p>
<pre><code>  配置
</code></pre>
<p>INNODB_FT_DEFAULT_STOPWORD   </p>
<pre><code>忽略分词表
</code></pre>
<p>INNODB_FT_DELETED </p>
<pre><code>  被删除的docId
</code></pre>
<p>INNODB_FT_INDEX_CACHE   </p>
<pre><code>分词索引缓存
</code></pre>
<p>INNODB_FT_INDEX_TABLE   </p>
<pre><code>分词
</code></pre>
</li>
<li><p>FTS_DOC_ID</p>
<p>为了支持索引,比如要有一列与word(分词)进行映射,列被命名为 FTS_DOC_ID,列的类型必须为big int unsigned not null,并且InnoDB会自动改加上FTS_DOC_ID_INDEX的Unique Index.</p>
</li>
<li><p>全文检索的创建</p>
<p>create fulltext index idx_fts on fts_a(body)</p>
</li>
<li><p>分词的逻辑删除</p>
<p>事务提交时,不删除磁盘的Auxiliary table记录,而只删除FTS Cache Index中的记录.对于Auxiliary Table中被删除的记录,InnoDB存储引擎记录其FTS Document ID,并保存在DELETE Auxiliary Table中.</p>
</li>
<li><p>分词的物理删除</p>
<p>对文档的DML并不删除索引中的数据,还会再DELETED表中插入记录,因此,索引会逐渐变得非常大.这是可以手动将无用的索引彻底删除,使用命令 optimize table. 该命令还会进行其他操作,比如重新计算Cardinality,如果只希望对倒排索引操作,可以使用innodb_optimize_fulltext_only来设定.</p>
<p>optimize table <code>order</code>.fts_a</p>
</li>
<li><p>stopword列表(stopword list)</p>
<p>概念:</p>
<pre><code>表示该列表中的word不需要对其进行分词操作.InnoDB中有默认的stopword列表,在information_schema.INNODB_FT_DEFAULT_STOPWORD 中.
</code></pre>
<p>自定义:</p>
<pre><code>可以使用参数 innodb_ft_server_stopword_table来自定义stopword列表.
</code></pre>
</li>
<li><p>限制</p>
<p>每张表只能有一个全文检索的索引;<br>有多列组合而成的全文检索的索引列必须使用相同的字符集和排序规则;<br>不支持没有单词界定符(delimiter)的语言,比如中文,日文,韩文.</p>
</li>
</ul>
</li>
<li><p>全文检索</p>
<ul>
<li><p>语法</p>
<p>match (col1,col2) against (expr [search_modifier])</p>
<p>search_modifier:</p>
<pre><code>in natural language mode
in natural language mode with query expansion
in boolean mode
with query expansion
</code></pre>
<ul>
<li><p>查询模式</p>
<ul>
<li><p>natural language</p>
<p>表示查询带有指定word的文档.是默认模式.在where中使用match函数.<br>select  * from <code>order</code>.fts_a<br>where match (body) against(‘el’ in natural language mode)</p>
<p>查询返回结果是根据相关性(relevance)进行降序排序,相关性越高,排序越靠前.相关性的值是一个非负的浮点数字.0表示没有任何相关性.</p>
<p>计算相关性的条件:</p>
<pre><code>word是否在文档中出现.
word在文档中出现次数
word在索引列中的数量
多少文档包含该word
</code></pre>
</li>
<li><p>Boolean</p>
<p>使用in boolean mode修饰时,插叙字符串前后字符会有特殊含义.支持如下操作符:</p>
<ul>
<li>, 该word必须存在</li>
</ul>
<ul>
<li>,  该word必须不存在<br>没有操作符表示该word 可选,如果有则相关性提高<br>@distance , 表示多个单词之间的距离是否在distance之内,单位是字节,也称为 Proximity Search. 比如 match(body) against (‘“please pot”@30’ in boolean mode)表示字符串please与pot之间的距离必须在30字节以内.<blockquote>
<p>,表示出现该词增加相关性<br>&lt;,表示出现改词降低相关性<br>~,表示允许出现该词,但是出现时,相关性为负</p>
</blockquote>
</li>
</ul>
<p><em>,表示以该单词开头的单词,比如lik</em> ,可以是like 也可以是likes<br>“,表示短语会把整个短语当做一个词查找.</p>
</li>
<li><p>Query  Expansion</p>
<p>扩展查询,这种查询通常是查询的关键词 太短,用户需要implied knowledge(隐含知识).<br>在查询短语中,增加 with query expansion,可以开启blind query expansion(也称为 automatic relevance feedback).</p>
<p>该查询分为两个阶段</p>
<pre><code>第一阶段: 根据单词进行全文索引查询.
第二阶段:根据第一阶段产生的分词再进行一次全文检索的查询.
</code></pre>
<p>注意:</p>
<pre><code>扩展查询会带来许多非相关的查询,因此在使用时,要谨慎.
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注意</p>
<ol>
<li>查询的word在stopword列中,则忽略改词.</li>
<li>查询的词的长度区间不对的,则不会对该词查询.<br>[innodb_ft_min_token_size,innodb_ft_max_token_size]<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>共享锁S(读锁: in share mode)</p>
<p>加上读锁过后,其他事务只能加读锁(锁兼容),不能加写锁-&gt;支持并发读取</p>
</li>
<li><p>排他锁X(for update)</p>
<p>加了排他锁之后,不允许有其他的读/写锁</p>
<h3 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h3></li>
<li><p>行锁</p>
<ul>
<li><p>记录锁(Record Lock)</p>
<p>是行锁的一种,单行记录上的锁.总是会锁住索引记录.</p>
<pre><code>有多个索引时,要分别上锁.
</code></pre>
<p>触发条件:<br>通过主键或者隐式主键,来锁定</p>
</li>
<li><p>间隙锁(Gap Lock)</p>
<p>行锁的一种,锁定一个范围,不包含记录本身<br>用在非唯一索引. 锁住的范围是左右区间<br>当表的相邻ID间出现空隙会形成区间,</p>
</li>
<li><p>临键锁(Next-Key Lock)</p>
<pre><code>行锁的一种,Record Lock + Gap Lock,锁定一个范围,并且锁定记录本身.是InnoDB的行锁默认算法.左开右闭原则.
</code></pre>
<p>设计目的是为了解决幻读问题:<br>Next-Key Lock会把查询出来的记录锁住,同时也会把范围查询的所有间隙锁住,会把相邻的下一个区间(Gap Lock)也会锁住.<br>结合了记录锁和间隙锁的特性,加了Next-Key Lock之后,在范围内数据不允许被修改和插入,避免了在范围查询时出现脏读,重复读,幻读问题<br>触发条件:</p>
<pre><code>范围查询并命中,查询命中了索引
</code></pre>
<p>Next-Key Lock 降级:</p>
<pre><code>当查询的索引含有唯一确定记录的属性时,InnoDB引擎会对Next-Key Lock进行优化,将其降级为Record Lock,即只锁住索引本身,而不是范围.
</code></pre>
<p>强调: 锁降级仅存在查询所有的唯一索引列.若唯一索引列由多个列组成,而查询仅是查询多个唯一索引列中的其中一个,那么查询其实是range类型查询,而不是point类型查询,故InnoDB引擎依然使用Next-Key Lock进行锁定.</p>
<p>在应用层面实现唯一性检查:</p>
<pre><code>(注:InnoDB引擎默认使用一致性非锁定读,)
在事务中使用:
 select * from table where col =xxx  where ... in share mode
此时如果数据不存在,Next-Key Lock也会锁住该范围.就可以实现唯一性检查.
在并发问题下,多个事务检查唯一性,插入,会导致死锁.此时只有一个事务能够成功,其他抛出死锁错误.
</code></pre>
<p>A  -&gt; 开启事务 -&gt; 唯一性检查(共享锁)  -&gt; 插入数据(阻塞)<br>   B - &gt; 开启事务 -&gt; 唯一性检查(共享锁) -&gt; 插入数据(引发死锁,错误)<br>只有一个能够执行成功</p>
<p>数据插入:</p>
<pre><code>数据插入时,会检查插入记录的下一个记录是否被锁.
</code></pre>
<p>​    </p>
</li>
</ul>
</li>
<li><p>页锁</p>
<ul>
<li>粒度介于行锁和表锁中间.折中.</li>
<li>开销/粒度介于行锁和表锁中间;会出现死锁;并发度一般</li>
</ul>
</li>
<li><p>表锁</p>
<ul>
<li>锁住整个表,其他事务访问该表必须等待锁释放</li>
<li>粒度大,加锁简单,容易冲突</li>
</ul>
</li>
</ul>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li><p>意向共享锁(IS:Intention Shared Lock)</p>
<p>事务想要获得一张表中某几行的共享锁.</p>
</li>
<li><p>意向拍他锁(IXIntention Exclusive Lock)</p>
<p>事务想要获得一张表中某几行的排他锁.</p>
<h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3></li>
<li><p>一致性非锁定读(consistent nonblocking read)</p>
<ol>
<li>概念:<br> 指InnoDB存储引擎通过行多版本控制(multi versioning)的方法来读取当前执行时间数据库中行的数据.如果读到的行正在执行DELETE或UPDATE操作,这是读取操作不会因此等待锁释放.相反的,InnoDB存储引擎回去读取行的一个快照.快照是通过undo段来完成的</li>
</ol>
<p>2.作用: </p>
<pre><code>极大的提高了数据库的并发性.是InnoDB引擎默认的读取方式.
</code></pre>
<p>3.读取快照的版本:</p>
<pre><code>根据隔离级别的 不同,读取快照的版本也不一样:
</code></pre>
<p>READ COMMITTED</p>
<pre><code>该级别下,总是读取最新的一份快照.意味着在事务执行中,有其他事务提交数据修改,可以读到.此时违反了ACID中的I,隔离性.
</code></pre>
<p>REAPEATABLE READ</p>
<pre><code>总是读取事务开始时的行数据.
</code></pre>
<p>多版本并发控制(MVCC):</p>
<pre><code>一个行记录可能有不止一个快照数据,一般称这种技术为行多版本技术.由此带来的控制为多版本并发控制(multi veriosn concurrency control)
</code></pre>
</li>
<li><p>一致性锁定读(手动加锁)</p>
<p>锁定读:<br>加X锁:  select … for update<br>加S锁:  select … lock in share mode</p>
</li>
<li><p>自增长与锁</p>
<p>可以使用参数,来控制自增长模式,<br>innodb_autoinc_lock_mode</p>
<pre><code>-0, 使用AUTO_INC Locking方式
-1, 对于确定行数的插入,采用互斥量对内存中的计数器进行累加操作.对于不确定行数的插入(bulk inserts),采用AUTO-INC Locking
-2,全部都采用互斥量,并发插入,性能最高.因为是并发插入,所以自增长的值不是连续,可控的.会导致statement-base replication出现问题,所以必须要使用Row-Base Replication.
</code></pre>
<ul>
<li><p>自增长实现方式</p>
<ul>
<li><p>AUTO-INC Locking</p>
<p>对于自增长字段,执行如下语句,获得计数器值<br>select max(auto_inc_col) from t for update;<br>为了提升性能,不是在事务提交过后才释放,而是该SQL执行完后立即释放.</p>
<p>缺点: 并发插入性能差;</p>
</li>
<li><p>轻量级互斥量实现</p>
<p>提供一种轻量级互斥量的自增长机制,提升了自增长值的插入性能.采用互斥量对内存中的计数器进行累加操作.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外键与锁</p>
<p>对于外键,innodb自动添加索引,为了避免死锁.</p>
<p>修改子表外键值:</p>
<pre><code>对于外键值的插入和更新,首先要查询父表中的记录,即select 父表,此时,不使用一致性非锁定读的方式,因为可能会发生数据不一致的问题.此时使用select ... lock in share mode方式,即主动给父表加S锁.
</code></pre>
<p>数据不一致情况:</p>
<pre><code>如果使用一致性非锁定读,在子表中插入,数据,父表删除记录,导致数据不一致.
</code></pre>
<p>使用S锁:</p>
<pre><code>此时所有对父表操作的事务,都会等待当前事务结束,从而保证数据一致性.
</code></pre>
<ul>
<li><p>为什么外键要添加索引?</p>
<ol>
<li>删除主表记录时或者主子表关联查询时,都会进行全表扫描.<br> 如果字表上有索引,则会使用行锁.没有索引会导致子表频繁锁.</li>
<li>容易导致死锁.<h3 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h3></li>
</ol>
</li>
</ul>
</li>
<li><p>脏读</p>
<p>脏数据:</p>
<pre><code>事务对缓冲池中的行记录的修改,并且还没有被提交(commit)
</code></pre>
<p>脏读:</p>
<pre><code>在不同事务下,当前事务可以读到其他事务未提交的事务,简单来说就是可以读到脏数据.
违反了数据库的隔离性
</code></pre>
</li>
<li><p>不可重复读</p>
<p>不可重复读:</p>
<pre><code>在事务中,读取到了其他事务提交的事务,比如对数据的修改.
</code></pre>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3></li>
</ul>
<p>阻塞:<br>    因为不同锁之间的不兼容性,有些时刻,一个事务中的锁要等待另一个事务中的锁释放占用的资源,这就是阻塞.</p>
<p>默认情况下,InnoDB引擎不会回滚超时引发的错误异常,所有事务执行部分会被提交.</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁:<br>    两个或两个以上的事务在执行过程中,因为争夺资源而造成的一种互相等待的现象.</p>
<ul>
<li><p>示例</p>
<ol>
<li>AB-BA<br> A等待B,B等待A</li>
</ol>
<p>2.当前事务持有了待插入记录的下一个记录的X锁,但是在等待队列中存在一个S锁,则可能会发生死锁.<br>假设数据:1,2,3,5 (主键)</p>
<pre><code>A -&gt;开启事务-&gt;获取3的X锁-&gt;|等待
B-&gt;开启事务-&gt;获取小于5的共享锁,已将获取1,2,5
</code></pre>
<p>若此时A想要插入数据4,则会报死锁.</p>
</li>
<li><p>解决办法</p>
<p>1.超时回滚:</p>
<pre><code>事务超时,回滚事务,让其他事务进行下去.
优点:    
    简单
缺点:    
    可能会让权重大的事务回滚,导致浪费.
</code></pre>
<p>2.等待图(wait-for graph):</p>
<pre><code>资源分配图,主动检测死锁
</code></pre>
<p>检测到死锁后(错误码1213),InnoDB会对抛出异常的事务进行回滚,因此检测到1213错误,不需要手动回滚.</p>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3></li>
</ul>
<p>锁升级:<br>    将当前锁的粒度降低.比如行锁-&gt;页锁-&gt;表锁.<br>    sql server中存在.<br>InnoDB引擎中不存在锁升级,因为不是根据每个记录来产生行锁的,而是根据每个事务访问的每个页进行锁管理的,采用的是位图的方式.因此,不管一个事务锁住页中的一个记录还是多个记录,其开销都是一致的.</p>
<h3 id="查看锁"><a href="#查看锁" class="headerlink" title="查看锁"></a>查看锁</h3><p>– 查看锁<br>select * from information_schema.INNODB_TRX it ;<br>select * from information_schema.INNODB_LOCKS il  ;<br>select * from information_schema.INNODB_LOCK_WAITS il  ;</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul>
<li><p>原子性（Atomicity）</p>
</li>
<li><p>一致性（Consistency）</p>
<ul>
<li><p>实现机制</p>
<p>每写一个事务,都会修改Buffer Pool,从而产生响应的Redo/Undo日志,这些日志信息会被记录到日志文件中.<br>在MySQL中,任何Buffer Pool中的页被刷到磁盘之前,都会先写入到日志文件中.<br>如果Buffer Pool中的数据提交(commit),在此数据库挂了,在数据库再次启动之后,可以通过Redo日志将其恢复出来,以保证脏页写的数据不会丢失.<br>如果数据没有提交(commit),此时数据库挂了,就需要Undo来实现.</p>
</li>
</ul>
</li>
<li><p>隔离性（Isolation）</p>
<p>事务之间不会互相影响.由锁和MVCC机制实现</p>
<ul>
<li><p>隔离级别问题</p>
<ul>
<li><p>脏读</p>
<p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。<br>违反隔离性</p>
</li>
<li><p>可重复读</p>
<p>可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的</p>
</li>
<li><p>不可重复读</p>
<p>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。<br>(针对数据修改 UPDATE)<br>违反一致性</p>
</li>
<li><p>幻读</p>
<p>幻读是针对数据插入（INSERT）操作来说的。<br>假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。<br>(在事务过程中,有新插入数据)</p>
</li>
</ul>
</li>
<li><p>隔离级别</p>
<ul>
<li><p>读未提交（READ UNCOMMITTED）</p>
</li>
<li><p>读提交 （READ COMMITTED）</p>
</li>
<li><p>可重复读 （REPEATABLE READ MySQL默认级别）</p>
</li>
<li><p>串行化 （SERIALIZABLE）</p>
<p>SERIALIZABLE与REPEATABLE READ两者开销几乎一样,甚至SERIALIZABLE可能更优. 一次InnoDB选择REPEATABLE READ不会有任何性能损失,同样,即使用户切换到READ COMMITTED也不会由性能的大幅提升.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>持久性（Durability）</p>
<p>事务执行后,必须写入磁盘</p>
<ul>
<li><p>实现机制</p>
<p>Redo log<br>WAL</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3></li>
</ul>
</li>
<li><p>扁平事务(flat transactions)</p>
<p>三种结果:</p>
<pre><code>1. 事务完成 (最多)
2. 错误回滚
4. 超时回滚
</code></pre>
</li>
<li><p>带有保存点的扁平事务(flat transactions with savepoints)</p>
<p>允许事务执行过程中回滚到同一事务中较早的状态.<br>保存点(savepoint):</p>
<pre><code>用来通知系统应该记住事务当前的状态.
</code></pre>
</li>
<li><p>链事务(chained transactions)</p>
<p>带有保存点事务的缺点: 保存点是易失的,系统崩溃时,所有保存点都会消失.</p>
<p>链式事务:</p>
<pre><code>可以视为带有保存点事务的变种.
</code></pre>
<p>链式事务思想: </p>
<pre><code>提交一个事务,释放不必要的数据对象.并将必要的上下文隐式地传递给下一个要开始的事务.
</code></pre>
<p>对比带有保存点的扁平事务的不同之处:<br>回滚时:</p>
<pre><code>带有保存点能够回滚到任意保存点. 
链式事务只能回滚当前事务,即只能恢复到最近一个保存点.
</code></pre>
<p>锁的处理</p>
<pre><code>带有保存点事务持有所有锁.
链式事务commit后,立即释放当前事务持有的锁.
</code></pre>
</li>
<li><p>分布式事务(distributed transactions)</p>
</li>
<li><p>嵌套事务(nested transactions)</p>
<p>定义</p>
<pre><code>嵌套事务    是一个层次结构框架.有一个顶层事务控制这各个层次事务.顶层事务之下嵌套的事务被称为子事务.
</code></pre>
<p>具体定义:</p>
<pre><code>1. 嵌套事务是由若干事务组成的一个棵树,子树既可以是嵌套事务,也可以是扁平事务.
2.处在叶子节点的是扁平事务.但是每个子事务从根到叶子节点的距离可以是不同的.
3.位于根节点的称作顶层事务,其他事务称为子事务.
4.子事务既可以提交也可以回滚.但是子事务操作并不立即生效,除非其父事务已经提交.(因此可以得出推论,任何子事务都在顶层事务提交后才真正提交.)
5.树中任一事务的回滚都会引起它的子事务一同回滚,故子事务只保留A,C,I特性,不具有D的特性.
(高层事务负责逻辑控制,叶子节点事务负责实际工作.)
</code></pre>
<p>可以使用带有保存点的事务模拟嵌套事务.</p>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3></li>
</ul>
<p>事务的原子性,一致性,持久性是通过数据库的redo log 和 undo log来实现的</p>
<p>对比 redo 和 undo<br>二者都是一种恢复操作: </p>
<p>redo恢复提交事务修改的页操作; 是物理日志,记录页的物理修改操作<br>undo回滚航记录到某个特定版本;记录逻辑日志,根据每行记录惊醒记录.</p>
<ul>
<li><p>redo(事务持久化)</p>
<ol>
<li>概念:<br> 重做日志(redo log)用来实现事务的持久性,即事务ACID中的D.由两部分组成: <ol>
<li>redo log buffer ,是易失的.</li>
<li>redo log file 持久的.</li>
</ol>
</li>
<li>持久化机制(Force Log at Commit)<br> 当事务提交时,必须现将改事务的所有redo log写入到redo log file进行持久化,等到事务commit才算完成.</li>
<li>读写方式<br> redo log 基本都是顺序写的,在数据库运行时,不需要对redo log 文件进行读取操作</li>
<li>redo log数据落盘<br> redo log buffer -&gt; 文件系统缓存 -&gt; 磁盘<br> 为了确保每次数据写入到磁盘,每次写入文件后,都要调用fsync操作.因此,磁盘性能决定了事务提交的性能.<br> 可以有参数控制</li>
</ol>
<ul>
<li><p>重做日志缓冲</p>
</li>
<li><p>重做日志文件</p>
</li>
<li><p>redo log 刷新磁盘策略</p>
<p>innodb_flush_log_at_trx_commit可用来控制重做日志刷新磁盘策略</p>
<pre><code>-0 , 提交事务不写入文件,由master完成.
-1,  每次提交都写redo log ,并且fsync
-2, 仅仅写入文件缓存,没有fsync
</code></pre>
</li>
</ul>
</li>
<li><p>LSN</p>
<p>日志序列号,8字节,单调递增.<br>含义:</p>
<pre><code>重做日志写入量; (记录总日志量)
checkpoint位置 ;
页的版本.
</code></pre>
<p>在页的头部中有LSN,可以用来判断页是否需要恢复操作.</p>
<p>在InnoDB Status中:</p>
<pre><code>Log sequence num 表示LSN
Log flushed up to 表示刷新到重做日志文件位置
Last Checkpoint at 表示刷新到磁盘的lsn
</code></pre>
</li>
<li><p>undo log (MVCC)</p>
<p>功能:</p>
<pre><code>帮助事务回滚及MVCC功能
</code></pre>
<p>位置:</p>
<pre><code>undo放在undo数据库中的undo segement中,这个段称为undo段,存在于共享表空间.
</code></pre>
<p>读写方式:</p>
<pre><code>随机读写
</code></pre>
<ul>
<li><p>事务回滚</p>
<p>为什么是逻辑日志:</p>
<pre><code>是逻辑日志,不是物理操作.因为在并发的环境下,页的结构会发生变化,不能将也恢复到事务开始的样子,否则会影响其他事务.所以保留的是逻辑日志.
</code></pre>
</li>
<li><p>存储管理</p>
<p>采用段的方式管理.InnoDB中有rollback segement,每个会断中记录了1023个undo log segement,在每个undo log segment段中进行undo页申请.</p>
<p>事务提交:</p>
<pre><code>1. 将undo log 放入列表中,用来后面的purge操作
2. 判断undo log页是否可以重用,如果可以的话,分配给其他事务.
</code></pre>
<p>事务提交之后不能够立即删除undo页,因为可能会有其他事务通过undo log来得到行记录之前的版本.所以undo log在事务提交的时候放入一个链表中,最终由purge线程处理.</p>
</li>
<li><p>格式</p>
<ul>
<li><p>insert undo log  针对insert</p>
<p>insert只对当前事务可见,所以事务提交之后,直接删除,不进行purge操作.</p>
</li>
<li><p>update undo log 针对update,delete</p>
<p>该undo log 可能需要提供MVCC机制,因此不能够提交事务时删除.提交时,放入undo log 链表.由purge线程最后删除.</p>
<p>可以分为更新,删除,添加三类.</p>
<p>delete:</p>
<pre><code>删除数据是,不直接删除记录,而是将记录标为已删除,将记录的delete flag设为1,最终删除是在purge完成的.
</code></pre>
<p>对主键的update:</p>
<pre><code>删除记录,重新插入.
</code></pre>
</li>
</ul>
</li>
<li><p>purge</p>
<p>purge用于最终完成delete和update,是因为要支持MVCC,所以记录不能再事务提交时立即删除.</p>
<ul>
<li><p>history list</p>
<p>一个页中可以存储多个事务的undo log.<br>history 列表根据事务提交的顺序,将undo log 进行链接.在执行purge的过程中.先从history list中找到第一个被清理的记录,清理过后,会在当前页中继续寻找是否存在可以被清理的记录. 如果没有,就继续到history list中寻找. 这种先从list中寻找undo log 然后再从page中寻找的模式,是为了避免大量的随机读取操作,从而提高purge效率.</p>
</li>
</ul>
</li>
<li><p>group commit</p>
<pre><code>为了提高磁盘fsync的效率,当前数据库都提供了group commit的功能,即一次fsync可以刷新确保多个事务日志被写入文件.减少磁盘压力,提升数据库性能,对于写入或者更新较为频繁的操作,group commit提升尤为明显.
</code></pre>
<ul>
<li><p>group commit失效</p>
<pre><code>在以前开启二进制日志,会导致group commit功能,为了保证存储引擎层中的事务和二进制日志的一致性,二者使用了两阶段事务.
1.当事务提交时,InnoDB存储引擎进行prepare操作.
2.MySQL数据库上层写入二进制日志.
3.InnoDB存储引擎将日志写入redo file.
</code></pre>
<p>其中步骤2,一旦完成,即使步骤3宕机,也能确保事务提交(redo file 完成,binlog完成). 为了保证保证MySQL数据库上层的二进制日志和InnoDB层提交事务一致. 如果不一致的话,会导致在线备份来重新恢复replication时,可能会发生事务丢失,因为通过binlog日志备份,此时binlog事务提交,而InnoDB层事务没有commit.  为保证顺序一直,使用了锁prepare_commit_mutex锁,导致group commit失效.</p>
</li>
<li><p>Binary Log Group Commit(BLGC)</p>
<p>BLGC事务提交过程:</p>
<pre><code>1.数据库上层进行提交时,先按照顺序将事务放到一个队列中,第一个称为leader,后面称为follower,leader控制follower.
</code></pre>
<p>BLGC分为一下3个步骤:</p>
<pre><code>1. Flush阶段, 将每个事务的二进制写入到内存中.
2. Sync阶段, 将内存中的二进制日志刷新到磁盘中,若队列中多个事务,那么仅一次fsync操作就完成二进制日志的写入,这就是BLGC
3.Commit阶段, leader根据顺序调用存储引擎层事务的提交,InnoDB存储引擎本就支持group commit.
</code></pre>
<p>当一组事务在进行Commit事务时,其他事务可以惊醒Flush阶段,从而使group commit不断生效.</p>
<h3 id="已经执行的语句不会因为后面的异常回滚"><a href="#已经执行的语句不会因为后面的异常回滚" class="headerlink" title="已经执行的语句不会因为后面的异常回滚"></a>已经执行的语句不会因为后面的异常回滚</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>InnoDB中的事务都是原子的,构成事务的每条语句都会提交或者每条语句都会回滚. 一条语句要么完全成功,要么完全回滚.<br>因此一条语句失败并抛出异常时,并不会导致先前已经执行的语句自动回滚.所有执行都会得到保留.  </p>
<p>比如开启事务后,插入两条主键重复的记录,后一条记录会抛出异常, 此时没有commit或者rollback,前一条记录也是成功的.<br>或者第二条记录,字段不符合要求,此时需要显示commit或者rollback.</p>
<h3 id="事务的不良习惯"><a href="#事务的不良习惯" class="headerlink" title="事务的不良习惯"></a>事务的不良习惯</h3><ul>
<li><p>在循环中提交事务</p>
<p>1.每一次提交都会进行一次写redo log<br>2.出现错误时,会导致事务停留在一个未知的位置.<br>因此不应该在一个循环中提交事务.</p>
</li>
<li><p>在存储引擎中进行异常处理</p>
<p>应该把异常交由应用处理</p>
</li>
<li><p>使用长事务</p>
<pre><code>长事务,指的是执行时间较长的事务.当发生异常时,事务的回滚和重新执行的代价很大. 
可以将长事务转化为小批量(mini batch)的事务来处理,发生错误时,也只需要回滚一部分事务.
</code></pre>
<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2></li>
</ul>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>备份方法</p>
<ul>
<li><p>Hot Backup(热备)</p>
<p>在运行中直接备份.也称为Online Backup 在线备份</p>
</li>
<li><p>Cold Backup(冷备)</p>
<p>在数据库停止的情况下备份.<br>备份frm文件,共享表空间文件,独立表空间(*.ibd),重做日志文件.</p>
<p>还要注意,使用脚本运行时,要检查磁盘空间.</p>
<p>优点:</p>
<pre><code>备份简单,恢复简单
恢复速度快,不需要执行SQL,重建索引
</code></pre>
<p>缺点:</p>
<pre><code>冷备文件大,比逻辑文件大很多,因为表空间中存放很多其他数据,比如undo 段,insert buffer.
跨平台不容易.
</code></pre>
</li>
<li><p>Warm Backup(温备)</p>
<p>在数据库运行的情况下备份,但是会对数据库操作有影响,比如加一个全局锁.</p>
</li>
</ul>
</li>
<li><p>备份后的文件内容</p>
<ul>
<li><p>逻辑备份</p>
<p>备份内容是文本内容,可读,是一条条SQL语句,或者表内实际数据组成. 比如mysqldump和select * into outfile.<br>数据恢复速度慢.</p>
<ul>
<li><p>mysqldump</p>
<p>shell中运行mysqldump</p>
<p>mysqldump [arguments] &gt; file_name</p>
<pre><code>-all-databases
-databases db1 db2...
--single-transaction 保证事务一致性. 备份前执行start transaction来获得一致性备份.同时要确保,没有其他执行DDL操作,因为一致性读不能隔离DDL操作.
--lock-tables(-l)  用于MyISAM,InnoDB可以使用.同时备份不同存储引擎表时,可以使用.
--add-drop-table: 在create table前先运行drop database.需要和--all-database 或者 -databases db1...一起使用.
--master-data [=value] ,用于建立replication
    -1, 转存文件中的change master语句
    -2, change master语句会写出SQL注释.
--where ,导出指定条件的数据.
</code></pre>
<ul>
<li><p>导入</p>
<p>mysql -uroot -p &lt;test_backup.sql;</p>
<p>导入前可以关闭外键,导入完成后再建立外键.</p>
</li>
</ul>
</li>
<li><p>select … into outfile </p>
<p>select … into outfile from tablexx where</p>
</li>
</ul>
</li>
<li><p>裸文件备份</p>
<p>辅助数据库的物理文件,可以在运行时或者停止时复制.恢复速度快.</p>
</li>
</ul>
</li>
<li><p>备份内容</p>
<ul>
<li><p>完全备份</p>
<p>进行完整备份</p>
</li>
<li><p>增量备份</p>
<p>只备份更改的部分</p>
</li>
<li><p>日志备份</p>
<p>对数据二级制日志binlog进行备份,通过对完全备份进行重做(replay)来完成数据库的point-int-time恢复工作. MySQL的数据库复制(replication)原理就是异步实时地将二进制日志重做传送并应用到slave数据库.</p>
<h3 id="备份一致性"><a href="#备份一致性" class="headerlink" title="备份一致性"></a>备份一致性</h3></li>
</ul>
</li>
</ul>
<p>备份过后要保证事务一致性. 不能出现事务进行一半.因为支持MVCC,所以只需要开启一个事务,然后备份就可以了.</p>
<p>使用mysqldump,要添加–single-transaction选项,来获得InnoDB存储引擎一致性备份.原理与上面一样.</p>
<h3 id="快照备份"><a href="#快照备份" class="headerlink" title="快照备份"></a>快照备份</h3><p>使用支持快照的文件系统支持的快照功能对数据库进行备份.将所有数据库文件放在同一个文件分区,然后对该分区进行快照操作.</p>
<p>LVM的写时复制(copy-on-write),创建快照时,只复制原始卷中的元数据(meta data),并不会有数据的物理操作.因此创建快照很快.当原始卷上有写操作时,快照会跟踪原始卷块的改变,在改变数据之前,将数据复制到快照的预留空间里.  如果读取未修改的块,则直接读取原始卷,如果已经修改,则读取快照内容.因此,copy-on-write保证了读取快照得到与快照建时的一致性.</p>
<h3 id="复制-replication"><a href="#复制-replication" class="headerlink" title="复制(replication)"></a>复制(replication)</h3><ul>
<li><p>replication工作原理</p>
<p>replication是MySQL提供的高可用的方案.分为三个阶段:</p>
<pre><code>1. master将数据更改记录到binlog中.
2.slave把master的binlog复制到自己的中继日志(relay log)中    
3.slave重做中继日志中的日志,把更改应用到自己的数据库上,以达到数据的最终一致性.
</code></pre>
<p>复制并不是实时的,而是异步实时的,中间存在着主从服务器之间的执行延迟,如果主服务器压力大,会导致延迟很大.可以通过命令show slave status和show master status获得延迟.</p>
</li>
<li><p>快照+复制的备份架构</p>
<p>主从复制,对从使用快照备份.<br>高可用,负载均衡.</p>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2></li>
</ul>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul>
<li><p>缓存</p>
</li>
<li><p>命中率</p>
<p>缓冲池命中率不应该低于99%</p>
<ol>
<li>可以直接查看 show engine status 中关于缓冲池的命中率.</li>
<li>手动计算:<br> show global status like ‘innodb%read%’</li>
</ol>
<p>Innodb_buffer_pool_read_ahead 预读到页次数<br>Innodb_buffer_pool_read_requests 缓冲池中读到页次数<br>Innodb_buffer_pool_reads 磁盘读到页次数<br>命中率 = Innodb_buffer_pool_read_requests /(三者的和)</p>
<h3 id="磁盘-使用SSD"><a href="#磁盘-使用SSD" class="headerlink" title="磁盘:使用SSD"></a>磁盘:使用SSD</h3></li>
<li><p>合理RAID</p>
</li>
</ul>
<h3 id="使用测试工具"><a href="#使用测试工具" class="headerlink" title="使用测试工具"></a>使用测试工具</h3><ul>
<li>sysbench</li>
<li>mysql-tpcc</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/9355.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/9355.html" class="post-title-link" itemprop="url">Nginx</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-21 21:32:44 / 修改时间：21:34:58" itemprop="dateCreated datePublished" datetime="2021-06-21T21:32:44+08:00">2021-06-21</time>
    </span>

  
    <span id="/posts/9355.html" class="post-meta-item leancloud_visitors" data-flag-title="Nginx" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><ol>
<li><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p><em>Nginx</em> (engine x) 是一个高性能的<strong>HTTP</strong>和<strong>反向代理</strong>web服务器.</p>
</li>
<li><h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理:"></a>反向代理:</h5><ul>
<li><h6 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理:"></a>正向代理:</h6><p>代理服务器为客户端做代理,主要为客户端服务,可以隐藏客户端信息</p>
<p><img src="/Nginx/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="img"></p>
</li>
<li><h6 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理:"></a>反向代理:</h6><p>主要是为服务端代理,所以叫做反向代理,可以隐藏服务端信息</p>
<img src="Nginx/反向代理.png" alt="img" style="zoom:67%;"></li>
</ul>
</li>
<li><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡:"></a>负载均衡:</h5><p>缓解服务器压力,和提升容错能力</p>
<ol>
<li><h6 id="单点负载均衡"><a href="#单点负载均衡" class="headerlink" title="单点负载均衡"></a>单点负载均衡</h6></li>
</ol>
<img src="Nginx/v2-6aa2607e04cc9d2f0d448f9fa80b2ae2_720w.jpg" alt="img" style="zoom:50%;">

<ol>
<li><h6 id="负载均衡集群"><a href="#负载均衡集群" class="headerlink" title="负载均衡集群"></a>负载均衡集群</h6><p>避免因为单个负载均衡节点故障,导致不可用</p>
<img src="Nginx/负载均衡集群.jpg" alt="preview" style="zoom:50%;"></li>
<li><h6 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h6><ol>
<li><strong>Round Robin（轮询）：</strong>为第一个请求选择列表中的第一个服务器，然后按顺序向下移动列表直到结尾，然后循环。</li>
<li><strong>LeastConnections（最小连接）：</strong>优先选择连接数最少的服务器，在普遍会话较长的情况下推荐使用。</li>
<li><strong>Source：</strong>根据请求源的 IP 的散列（hash）来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h5><p>动态请求与静态资源放在不同的服务器上</p>
</li>
<li><h5 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h5><ol>
<li><p>添加源:<code>sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></p>
</li>
<li><p>使用<code>yum search nginx</code>查看,源是否添加成功</p>
<p>安装Nginx</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>设置自动运行</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx.service</span><br><span class="line">sudo systemctl enable nginx.service</span><br></pre></td></tr></tbody></table></figure>

<p>若想使用外部主机连接上虚拟机,访问 IP:80 ，需要关闭虚拟机的防火墙：</p>
<p>centOS7关闭防火墙命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">      &nbsp;systemctl stop firewalld.service</span><br></pre></td></tr></tbody></table></figure>

<p>或者配置防火墙开放端口:</p>
<ul>
<li><p>查看开放的端口号:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>设置开放的端口号:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd  --add-service=http -permanent</span><br><span class="line">sudo firewall-cmd --add-port=80/tcp --permanent</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>重启防火墙:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd -reload</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><p>使用nginx命令式,必须进入nginx目录: 比如 /user/sbin/nginx</p>
<ol>
<li><p>查看版本号</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -v</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>启动nginx</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>关闭nginx</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>重新加载配置:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>配置文件: 在安装位置找到配置文件,nginx.conf</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">user  nobody;</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events {</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http {</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">    #                  '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">    #                  '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server {</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / {</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html {</span><br><span class="line">            root   html;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ {</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #}</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ {</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #}</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache's document root</span><br><span class="line">        # concurs with nginx's one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht {</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server {</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / {</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    }</span><br><span class="line">    #}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server {</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / {</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    }</span><br><span class="line">    #}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>配置文件分为三个部分:</p>
<ol>
<li><p>全局块:</p>
<p>从配置文件开始到event 块之间的内容,主要设置一些影响nginx服务器整体运行的配置指令.比如并发数,log位置,pid</p>
</li>
<li><p>event 块</p>
<p> 主要影响Nginx服务器与用户的网络连接.</p>
<p>worker_connections 支持的最大连接数.</p>
</li>
<li><p>http 块</p>
<p>配置最频繁的部分,代理,缓存,日志定义,以及第三方配置都在这部分</p>
<p>注意:http 块也包括 http全局块,server块</p>
<ol>
<li><p>http 全局块 </p>
<p>包括文件引入,MIME-TYPE定义,日志自定义,连接超时时间,单链接请求数上限</p>
</li>
<li><p>server 块</p>
<p>与虚拟主机有密切关系.虚拟主机从用户看,是和独立的硬件注意是完全一样的,该技术是为了节省硬件成本.</p>
<p>每个http块可以包含多个server块,每一个server块就相当于一个虚拟主机.</p>
<p>每一个server块也分为全局server块,以及可以同事包含多个location 块</p>
<ul>
<li><p>全局server块:</p>
<p>配置虚拟主机的监听配置和本虚拟主机的名称或者IP配置</p>
</li>
<li><p>location 块</p>
<p>主要作用是基于Nginx服务器接收到的请求字符串(server_name/uri-string),对虚拟主机名称之外的字符串进行匹配,对特定的请求进行处理.地址定向,数据缓存和应答控制等功能,还有许多第三方模块的配置也在这里进行.</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ol>
<li><h6 id="反向代理-2"><a href="#反向代理-2" class="headerlink" title="反向代理"></a>反向代理</h6><p>效果: 将发送的Nginx的请求,直接转发给tomcat.访问Nginx的端口,即可访问tomcat的8080端口</p>
<p>在Nginx配置文件中修改或者增加:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / {</span><br><span class="line">  root html;</span><br><span class="line"><span class="meta">  #</span><span class="bash">主要配置proxy_pass</span></span><br><span class="line">  proxy_pass http://127.0.0.1:8080/examples/;</span><br><span class="line">  index index.html index.html;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="根据路径的反向代理"><a href="#根据路径的反向代理" class="headerlink" title="根据路径的反向代理"></a>根据路径的反向代理</h6><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server{</span><br><span class="line"><span class="meta">#</span><span class="bash">监听端口</span></span><br><span class="line">	listen 9001;</span><br><span class="line">	server_name xxxName;</span><br><span class="line"><span class="meta">	</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">如果路径是/edu/开头,则进行如下服务</span></span><br><span class="line">	location ~ /edu/ {</span><br><span class="line">		proxy_pass http://127.0.0.1:8080;</span><br><span class="line">	}</span><br><span class="line"><span class="meta">	</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">如果路径是/vod/开头,则进行如下服务</span></span><br><span class="line">	location ~ /vod/ {</span><br><span class="line">		proxy_pass http://127.0.0.1:8081;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>location 参数说明</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~ ] uri {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>= : 用于不含正则表达式的uri前,要求请求祖父穿与 uri 严格匹配,如果匹配成功,就停止继续向下搜索,并立即处理请求.</p>
</li>
<li><p>~ : 用于表示uri包含正则表达式,并且区分大小写</p>
</li>
<li><p>~* :表示用于uri包含正则表达式,不区分大小写</p>
</li>
<li><p>^~ : 用于不包含正则表达式的uri前,要求Nginx服务器找到标志uri和请求字符串匹配度最高的 location后,立即使用此location处理请求,而不再使用location中的正则 uri 和请求字符串做匹配:</p>
<p>注意: 如果uri包含正则表达式,则必须要有~ 或者 ~* 标志.</p>
</li>
</ol>
</li>
<li><h6 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h6><p>配置文件:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver {</span><br><span class="line">    server 192.168.0.104:9002 weight=1; # 服务器1</span><br><span class="line">    server 192.168.0.104:9003 weight=1; # 服务器2</span><br><span class="line">    ip_hash;   #负载均衡策略</span><br><span class="line">}</span><br><span class="line">      </span><br><span class="line">server {</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root         /usr/share/nginx/html;</span><br><span class="line">      </span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    location /  {</span><br><span class="line">            proxy_pass http://myserver; # 导向自定义的myserver</span><br><span class="line">    }</span><br><span class="line">      </span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">    location = /404.html {</span><br><span class="line">    }</span><br><span class="line">      </span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">      </span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>分配策略:</p>
<ol>
<li><p>轮询(默认)</p>
<p>每个请求按时间顺序,注意分配到不同的后端服务器,如果后端服务器down掉,则自动剔除.</p>
</li>
<li><p>weight</p>
<p>weight代表权重,默认为1,权重越高,被分配的客户端越多.用于后端服务器性能不均的情况.</p>
</li>
<li><p>ip_hash</p>
<p>每个请求按照ip的hash结果进行分配,这样每个访客固定访问一个后端服务器,可以解决session问题.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver {</span><br><span class="line">  server 192.168.0.104:9002 weight=1;</span><br><span class="line">  server 192.168.0.104:9003 weight=1;</span><br><span class="line">  ip_hash; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>fair(第三方)</p>
<p>按照后端服务器响应时间来分配请求,响应时间越短的优先分配.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver {</span><br><span class="line">  server 192.168.0.104:9002 weight=1;</span><br><span class="line">  server 192.168.0.104:9003 weight=1;</span><br><span class="line">  fair; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ul>
<ol start="4">
<li><p>动态资源静态资源分离:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server {</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root         /usr/share/nginx/html;</span><br><span class="line">         </span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line">         </span><br><span class="line"><span class="meta">#</span><span class="bash">静态资源路径, root会作为根路径,实际访问路径是/home/static</span></span><br><span class="line">    location /static/ {</span><br><span class="line">            root /home/;</span><br><span class="line">    }</span><br><span class="line">         </span><br><span class="line">    location /  {</span><br><span class="line">            proxy_pass http://myserver;</span><br><span class="line">    }</span><br><span class="line">         </span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">    location = /404.html {</span><br><span class="line">    }</span><br><span class="line">         </span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">         </span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/49381.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/49381.html" class="post-title-link" itemprop="url">6. Spring Boot CLI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:39:00 / 修改时间：12:46:25" itemprop="dateCreated datePublished" datetime="2021-06-10T12:39:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/49381.html" class="post-meta-item leancloud_visitors" data-flag-title="6. Spring Boot CLI" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Spring-Boot-CLI"><a href="#Spring-Boot-CLI" class="headerlink" title="Spring Boot CLI"></a>Spring Boot CLI</h4><p>Spring Boot CLI 是一个命令行工具,如果想快速开发 Spring 应用程序,可以使用它.它允许运行 Groovy 脚本,这意味着拥有类似 Java 的语法,而无需太多样板代码.还可以引导一个新项目或为它编写自己的命令.</p>
<ol>
<li><h5 id="安装-CLI-Installing-the-CLI"><a href="#安装-CLI-Installing-the-CLI" class="headerlink" title="安装 CLI(Installing the CLI)"></a>安装 CLI(Installing the CLI)</h5><p>可以使用 SDKMAN(SDK 管理器)手动安装 Spring Boot CLI(Command-Line Interface)或使用 Homebrew 或 MacPorts(如果是 OSX 用户).</p>
</li>
<li><h5 id="使用-CLI-Using-the-CLI"><a href="#使用-CLI-Using-the-CLI" class="headerlink" title="使用 CLI(Using the CLI)"></a>使用 CLI(Using the CLI)</h5><p>安装 CLI 后,可以在命令行中输入 <code>spring</code> 并按 Enter 来运行它.如果不带任何参数运行 <code>spring</code>,将显示帮助屏幕,如下所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring</span></span><br><span class="line">usage: spring [--help] [--version]</span><br><span class="line">       &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Available commands are:</span><br><span class="line"></span><br><span class="line">  run [options] &lt;files&gt; [--] [args]</span><br><span class="line">    Run a spring groovy script</span><br><span class="line"></span><br><span class="line">  _... more command help is shown here_</span><br></pre></td></tr></tbody></table></figure>

<p>可以输入 <code>spring help</code> 以获取有关任何受支持命令的更多详细信息,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring <span class="built_in">help</span> run</span></span><br><span class="line">spring run - Run a spring groovy script</span><br><span class="line"></span><br><span class="line">usage: spring run [options] &lt;files&gt; [--] [args]</span><br><span class="line"></span><br><span class="line">Option                     Description</span><br><span class="line">------                     -----------</span><br><span class="line">--autoconfigure [Boolean]  Add autoconfigure compiler</span><br><span class="line">                             transformations (default: true)</span><br><span class="line">--classpath, -cp           Additional classpath entries</span><br><span class="line">--no-guess-dependencies    Do not attempt to guess dependencies</span><br><span class="line">--no-guess-imports         Do not attempt to guess imports</span><br><span class="line">-q, --quiet                Quiet logging</span><br><span class="line">-v, --verbose              Verbose logging of dependency</span><br><span class="line">                             resolution</span><br><span class="line">--watch                    Watch the specified file for changes</span><br></pre></td></tr></tbody></table></figure>

<p><code>version</code> 命令提供了一种快速检查使用的 Spring Boot 版本的方法,如下所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring version</span></span><br><span class="line">Spring CLI v2.5.0</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><h6 id="使用-CLI-运行应用程序-Running-Applications-with-the-CLI"><a href="#使用-CLI-运行应用程序-Running-Applications-with-the-CLI" class="headerlink" title="使用 CLI 运行应用程序(Running Applications with the CLI)"></a>使用 CLI 运行应用程序(Running Applications with the CLI)</h6><p>可以使用 <code>run</code> 命令编译和运行 Groovy 源代码.Spring Boot CLI 是完全独立的,因此不需要任何外部 Groovy 安装.</p>
<p>以下示例显示了一个用 Groovy 编写的”hello world”Web 应用程序:</p>
<figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebApplication</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    String home() {</span><br><span class="line">        <span class="string">"Hello World!"</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>要编译和运行应用程序,请输入以下命令:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring run hello.groovy</span></span><br></pre></td></tr></tbody></table></figure>

<p>要将命令行参数传递给应用程序,请使用<code>--</code> 将命令与”spring”命令参数分开,如下例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring run hello.groovy -- --server.port=9000</span></span><br></pre></td></tr></tbody></table></figure>

<p>要设置 JVM 命令行参数,可以使用 <code>JAVA_OPTS</code> 环境变量,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> JAVA_OPTS=-Xmx1024m spring run hello.groovy</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    在 Microsoft Windows 上设置 <code>JAVA_OPTS</code> 时,请确保引用整个指令,例如设置”<code>JAVA_OPTS=-Xms256m -Xmx2048m</code>“. 这样做可确保将值正确传递给进程.</p>
</blockquote>
<ol>
<li><h6 id="推导出的”抓取”依赖关系-Deduced-“grab”-Dependencies"><a href="#推导出的”抓取”依赖关系-Deduced-“grab”-Dependencies" class="headerlink" title="推导出的”抓取”依赖关系(Deduced “grab” Dependencies)"></a>推导出的”抓取”依赖关系(Deduced “grab” Dependencies)</h6><p>标准 Groovy 包括一个 <code>@Grab</code> 注解,它允许声明对第三方库的依赖关系.这项有用的技术让 Groovy 以与 Maven 或 Gradle 相同的方式下载 jar,但不需要使用构建工具.</p>
<p>Spring Boot 进一步扩展了这项技术,并尝试根据代码推断出要”抓取”哪些库.例如,由于之前显示的 Web 应用程序代码使用了 <code>@RestController</code> 注解,因此 Spring Boot 会抓取”Tomcat”和”Spring MVC”.</p>
<p>以下项目用作”抓取提示”:</p>
<table>
<thead>
<tr>
<th>Items</th>
<th>Grabs</th>
</tr>
</thead>
<tbody><tr>
<td><code>JdbcTemplate</code>, <code>NamedParameterJdbcTemplate</code>, <code>DataSource</code></td>
<td>JDBC Application.</td>
</tr>
<tr>
<td><code>@EnableJms</code></td>
<td>JMS Application.</td>
</tr>
<tr>
<td><code>@EnableCaching</code></td>
<td>Caching abstraction.</td>
</tr>
<tr>
<td><code>@Test</code></td>
<td>JUnit.</td>
</tr>
<tr>
<td><code>@EnableRabbit</code></td>
<td>RabbitMQ.</td>
</tr>
<tr>
<td>extends <code>Specification</code></td>
<td>Spock test.</td>
</tr>
<tr>
<td><code>@EnableBatchProcessing</code></td>
<td>Spring Batch.</td>
</tr>
<tr>
<td><code>@MessageEndpoint</code> <code>@EnableIntegration</code></td>
<td>Spring Integration.</td>
</tr>
<tr>
<td><code>@Controller</code> <code>@RestController</code> <code>@EnableWebMvc</code></td>
<td>Spring MVC + Embedded Tomcat.</td>
</tr>
<tr>
<td><code>@EnableWebSecurity</code></td>
<td>Spring Security.</td>
</tr>
<tr>
<td><code>@EnableTransactionManagement</code></td>
<td>Spring Transaction Management.</td>
</tr>
</tbody></table>
<blockquote>
<p>建议:</p>
<p>​    参见 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-cli/src/main/java/org"><code>CompilerAutoConfiguration</code></a> 的子类,在 Spring Boot CLI 源代码中,以准确了解如何应用自定义.</p>
</blockquote>
</li>
<li><h6 id="推导出的”抓取”坐标-Deduced-“grab”-Coordinates"><a href="#推导出的”抓取”坐标-Deduced-“grab”-Coordinates" class="headerlink" title="推导出的”抓取”坐标(Deduced “grab” Coordinates)"></a>推导出的”抓取”坐标(Deduced “grab” Coordinates)</h6><p>Spring Boot 扩展了 Groovy 的标准 <code>@Grab</code> 支持,允许指定没有组或版本的依赖项(例如,<code>@Grab('freemarker')</code>).这样做会参考 Spring Boot 的默认依赖项元数据来推断artifact的组和版本.</p>
<blockquote>
<p>注意:</p>
<p>​    默认元数据与使用的 CLI 版本相关联. 它仅在迁移到到新版本的 CLI 时才会更改,可以控制依赖项的版本何时可能更改.</p>
</blockquote>
</li>
<li><h6 id="默认导入语句-Default-Import-Statements"><a href="#默认导入语句-Default-Import-Statements" class="headerlink" title="默认导入语句(Default Import Statements)"></a>默认导入语句(Default Import Statements)</h6><p>为了帮助减少 Groovy 代码的大小,自动包含了几个<code>import</code>语句.请注意前面的示例如何引用 <code>@Component</code>,<code>@RestController</code> 和 <code>@RequestMapping</code> 而无需使用完全限定名称或<code>import</code>语句.</p>
<blockquote>
<p>建议:</p>
<p>​    许多 Spring 注解可以在不使用 <code>import</code> 语句的情况下工作. 在添加导入之前尝试运行应用的方式来查看失败的内容.</p>
</blockquote>
</li>
<li><h6 id="自动Main方法-Automatic-Main-Method"><a href="#自动Main方法-Automatic-Main-Method" class="headerlink" title="自动Main方法(Automatic Main Method)"></a>自动Main方法(Automatic Main Method)</h6><p>与等效的 Java 应用程序不同,不需要在 Groovy 脚本中包含 <code>public static void main(String[] args)</code> 方法. <code>SpringApplication</code> 是自动创建的,编译的代码作为源代码.</p>
</li>
<li><h6 id="自定义依赖管理-Custom-Dependency-Management"><a href="#自定义依赖管理-Custom-Dependency-Management" class="headerlink" title="自定义依赖管理(Custom Dependency Management)"></a>自定义依赖管理(Custom Dependency Management)</h6><p>默认情况下,CLI 在解析 <code>@Grab</code> 依赖项时使用 <code>spring-boot-dependencies</code> 中声明的依赖项管理.用来覆盖默认依赖管理的其他依赖管理,可以使用<code>@DependencyManagementBom</code> 注解实现.注解的值应指定一个或多个 Maven BOM 的坐标 (<code>groupId:artifactId:version</code>).</p>
<p>例如,考虑以下声明:</p>
<figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DependencyManagementBom</span>(<span class="string">"com.example.custom-bom:1.0.0"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>前面的声明在 <code>com/example/custom-versions/1.0.0/</code> 下的 Maven 存储库中选择 <code>custom-bom-1.0.0.pom</code>.</p>
<p>当指定多个 BOM 时,它们将按照声明顺序应用,如以下示例所示:</p>
<figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DependencyManagementBom</span>([    <span class="string">"com.example.custom-bom:1.0.0"</span>,    <span class="string">"com.example.another-bom:1.0.0"</span>])</span><br></pre></td></tr></tbody></table></figure>

<p>前面的例子表明 <code>another-bom</code> 中的依赖管理覆盖了 <code>custom-bom</code> 中的依赖管理.</p>
<p>可以在任何可以使用<code>@Grab</code> 的地方使用<code>@DependencyManagementBom</code>. 但是,为了确保依赖项管理的顺序一致,最多可以在应用程序中使用 <code>@DependencyManagementBom</code> 一次.</p>
</li>
</ol>
</li>
<li><h6 id="具有多个源文件的应用程序-Applications-with-Multiple-Source-Files"><a href="#具有多个源文件的应用程序-Applications-with-Multiple-Source-Files" class="headerlink" title="具有多个源文件的应用程序(Applications with Multiple Source Files)"></a>具有多个源文件的应用程序(Applications with Multiple Source Files)</h6><p>可以对所有接受文件输入的命令使用”shell globbing”.这样做可以使用单个目录中的多个文件,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring run *.groovy</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="打包应用程序-Packaging-Your-Application"><a href="#打包应用程序-Packaging-Your-Application" class="headerlink" title="打包应用程序(Packaging Your Application)"></a>打包应用程序(Packaging Your Application)</h6><p>可以使用 <code>jar</code> 命令将应用打包成一个自包含的可执行 jar 文件,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring jar my-app.jar *.groovy</span></span><br></pre></td></tr></tbody></table></figure>

<p>生成的 jar 包含通过编译应用程序生成的类以及应用程序的所有依赖项,以便可以使用 <code>java -jar </code>运行它.jar 文件还包含来自应用程序类路径的条目. 可以使用 <code>--include</code> 和 <code>--exclude</code> 添加和删除 jar 的显式路径.两者都以逗号分隔,并且都接受”+”和”-“形式的前缀,以表示它们应该从默认值中删除.</p>
<p>默认包含的如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public/**, resources/**, static/**, templates/**, META-INF/**, *</span><br></pre></td></tr></tbody></table></figure>

<p>默认排除如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.*, repository/**, build/**, target/**, **/*.jar, **/*.groovy</span><br></pre></td></tr></tbody></table></figure>

<p>在命令行中输入 <code>spring help jar</code> 以获取更多信息.</p>
</li>
<li><h6 id="初始化一个新项目-Initialize-a-New-Project"><a href="#初始化一个新项目-Initialize-a-New-Project" class="headerlink" title="初始化一个新项目(Initialize a New Project)"></a>初始化一个新项目(Initialize a New Project)</h6><p><code>init</code> 命令允许使用 <code>start.spring.io</code> 创建一个新项目,而无需离开 shell,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring init --dependencies=web,data-jpa my-projectUsing service at https://start.spring.ioProject extracted to <span class="string">'/Users/developer/example/my-project'</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>前面的示例使用基于 Maven 的项目创建了一个 <code>my-project</code> 目录,该项目使用 <code>spring-boot-starter-web</code> 和 <code>spring-boot-starter-data-jpa</code>..可以使用 <code>--list</code> 标志位列出服务的功能,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring init --list=======================================Capabilities of https://start.spring.io=======================================Available dependencies:-----------------------actuator - Actuator: Production ready features to <span class="built_in">help</span> you monitor and manage your application...web - Web: Support <span class="keyword">for</span> full-stack web development, including Tomcat and spring-webmvcwebsocket - Websocket: Support <span class="keyword">for</span> WebSocket developmentws - WS: Support <span class="keyword">for</span> Spring Web ServicesAvailable project types:------------------------gradle-build -  Gradle Config [format:build, build:gradle]gradle-project -  Gradle Project [format:project, build:gradle]maven-build -  Maven POM [format:build, build:maven]maven-project -  Maven Project [format:project, build:maven] (default)...</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>init</code> 命令支持许多选项. 有关更多详细信息,请参阅帮助输出. 例如,以下命令创建一个使用 Java 8 和 <code>war</code> 打包的 Gradle 项目:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring init --build=gradle --java-version=1.8 --dependencies=websocket --packaging=war sample-app.zipUsing service at https://start.spring.ioContent saved to <span class="string">'sample-app.zip'</span></span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="使用嵌入式-Shell-Using-the-Embedded-Shell"><a href="#使用嵌入式-Shell-Using-the-Embedded-Shell" class="headerlink" title="使用嵌入式 Shell(Using the Embedded Shell)"></a>使用嵌入式 Shell(Using the Embedded Shell)</h6><p>Spring Boot 包含用于 BASH 和 zsh shell 的命令行完整脚本.如果不使用其中任何一个 shell(可能您是 Windows 用户),可以使用 <code>shell</code> 命令启动一个集成的 shell,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring shellSpring Boot (v2.5.0)Hit TAB to complete. Type \<span class="string">'help'</span> and hit RETURN <span class="keyword">for</span> <span class="built_in">help</span>, and \<span class="string">'exit'</span> to quit.</span></span><br></pre></td></tr></tbody></table></figure>

<p>从嵌入式 shell 内部,可以直接运行其他命令:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> versionSpring CLI v2.5.0</span></span><br></pre></td></tr></tbody></table></figure>

<p>嵌入式shell支持 ANSI 颜色输出以及<code>tab</code>补全.如果需要运行本机命令,可以使用 <code>!</code> 前缀. 要退出嵌入式 shell,请按 <code>ctrl-c</code>.</p>
</li>
<li><h6 id="向-CLI-添加扩展-Adding-Extensions-to-the-CLI"><a href="#向-CLI-添加扩展-Adding-Extensions-to-the-CLI" class="headerlink" title="向 CLI 添加扩展(Adding Extensions to the CLI)"></a>向 CLI 添加扩展(Adding Extensions to the CLI)</h6><p>可以使用 <code>install</code> 命令向 CLI 添加扩展.该命令采用 <code>group:artifact:version</code> 格式的一组或多组artifact坐标,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring install com.example:spring-boot-cli-extension:1.0.0.RELEASE</span></span><br></pre></td></tr></tbody></table></figure>

<p>除了安装提供的坐标标识的artifact之外,还安装了所有artifact的依赖项.要卸载依赖项,使用<code>uninstall</code>命令. 与 <code>install</code> 命令一样,它采用 <code>group:artifact:version</code> 格式的一组或多组artifact坐标,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring uninstall com.example:spring-boot-cli-extension:1.0.0.RELEASE</span></span><br></pre></td></tr></tbody></table></figure>

<p>它会卸载提供的坐标及其依赖项标识的artifact.</p>
<p>要卸载所有其他依赖项,可以使用 <code>--all</code> 选项,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spring uninstall --all</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><h5 id="使用-Groovy-Beans-DSL-开发应用程序-Developing-Applications-with-the-Groovy-Beans-DSL"><a href="#使用-Groovy-Beans-DSL-开发应用程序-Developing-Applications-with-the-Groovy-Beans-DSL" class="headerlink" title="使用 Groovy Beans DSL 开发应用程序(Developing Applications with the Groovy Beans DSL)"></a>使用 Groovy Beans DSL 开发应用程序(Developing Applications with the Groovy Beans DSL)</h5><p>Spring Framework 4.0 原生支持 <code>beans{}</code> “DSL”(从 Grails 借来),可以使用相同的格式将 bean 定义嵌入到 Groovy 应用脚本中.这有时是包含中间件声明等外部功能的好方法,如以下示例所示:</p>
<figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="literal">false</span>)<span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> {</span>    <span class="meta">@Autowired</span>    SharedService service    <span class="meta">@Override</span>    <span class="keyword">void</span> run(String... args) {        println service.message    }}<span class="keyword">import</span> my.company.SharedServicebeans {    service(SharedService) {        message = <span class="string">"Hello World"</span>    }}</span><br></pre></td></tr></tbody></table></figure>

<p>可以将类声明与 <code>beans{}</code> 混合在同一个文件中,只要它们保持在顶层,或者,如果愿意,可以将 beans DSL 放在单独的文件中.</p>
</li>
<li><h5 id="使用-settings-xml-配置-CLI-Configuring-the-CLI-with-settings-xml"><a href="#使用-settings-xml-配置-CLI-Configuring-the-CLI-with-settings-xml" class="headerlink" title="使用 settings.xml 配置 CLI (Configuring the CLI with settings.xml)"></a>使用 settings.xml 配置 CLI (Configuring the CLI with settings.xml)</h5><p>Spring Boot CLI 使用 Maven 的依赖解析引擎 Aether 来解析依赖.CLI 使用 <code>~/.m2/settings.xml</code> 中的 Maven 配置来配置 Aether.CLI 遵循以下配置设置:</p>
<ul>
<li>Offline</li>
<li>Mirrors</li>
<li>Servers</li>
<li>Proxies</li>
<li>Profiles<ul>
<li>Activation</li>
<li>Repositories</li>
</ul>
</li>
<li>Active profiles</li>
</ul>
</li>
</ol>
<p>`</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/13348.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/13348.html" class="post-title-link" itemprop="url">7. Build Tool Plugins</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:39:00 / 修改时间：12:45:52" itemprop="dateCreated datePublished" datetime="2021-06-10T12:39:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/13348.html" class="post-meta-item leancloud_visitors" data-flag-title="7. Build Tool Plugins" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="构建工具插件-Build-Tool-Plugins"><a href="#构建工具插件-Build-Tool-Plugins" class="headerlink" title="构建工具插件(Build Tool Plugins)"></a>构建工具插件(Build Tool Plugins)</h4><p>Spring Boot 为 Maven 和 Gradle 提供了构建工具插件.这些插件提供了多种功能,包括可执行 jar 的打包.本节提供了有关这两个插件的更多详细信息,并在需要扩展不受支持的构建系统时提供一些帮助.</p>
<ol>
<li><h5 id="Spring-Boot-Maven-插件-Spring-Boot-Maven-Plugin"><a href="#Spring-Boot-Maven-插件-Spring-Boot-Maven-Plugin" class="headerlink" title="Spring Boot Maven 插件(Spring Boot Maven Plugin)"></a>Spring Boot Maven 插件(Spring Boot Maven Plugin)</h5><p>Spring Boot Maven 插件在 Maven 中提供 Spring Boot 支持,可以打包可执行的 jar 或 war 文件并”就地”运行应用程序. 要使用它,必须使用 Maven 3.2(或更高版本).</p>
<p>请参阅插件的文档以了解更多信息:</p>
<ul>
<li>参考 (<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/reference/htmlsingle/">HTML</a> 和 [PDF](<a target="_blank" rel="noopener" href="https://docs.spring.io/">https://docs.spring.io</a> /spring-boot/docs/2.5.0/maven-plugin/reference/pdf/spring-boot-maven-plugin-reference.pdf))</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/maven-plugin/api/">API</a></li>
</ul>
</li>
<li><h5 id="Spring-Boot-AntLib-模块-Spring-Boot-AntLib-Module"><a href="#Spring-Boot-AntLib-模块-Spring-Boot-AntLib-Module" class="headerlink" title="Spring Boot AntLib 模块(Spring Boot AntLib Module)"></a>Spring Boot AntLib 模块(Spring Boot AntLib Module)</h5><p>Spring Boot AntLib 模块为 Apache Ant 提供基本的 Spring Boot 支持. 可以使用该模块创建可执行的 jar.要使用该模块,需要在 <code>build.xml</code> 中声明一个额外的 <code>spring-boot</code> 命名空间,如以下示例所示:</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:ivy</span>=<span class="string">"antlib:org.apache.ivy.ant"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:spring-boot</span>=<span class="string">"antlib:org.springframework.boot.ant"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"myapp"</span> <span class="attr">default</span>=<span class="string">"build"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>需要记住使用 <code>-lib</code> 选项启动 Ant,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ant -lib &lt;directory containing spring-boot-antlib-2.5.0.jar&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Spring-Boot-AntLib-模块-Spring-Boot-AntLib-Module-1"><a href="#Spring-Boot-AntLib-模块-Spring-Boot-AntLib-Module-1" class="headerlink" title="Spring Boot AntLib 模块(Spring Boot AntLib Module)"></a>Spring Boot AntLib 模块(Spring Boot AntLib Module)</h6><p>Spring Boot AntLib 模块为 Apache Ant 提供基本的 Spring Boot 支持.可以使用该模块创建可执行的 jar. 要使用该模块,需要在 <code>build.xml</code> 中声明一个额外的 <code>spring-boot </code>命名空间,如以下示例所示:</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:ivy</span>=<span class="string">"antlib:org.apache.ivy.ant"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:spring-boot</span>=<span class="string">"antlib:org.springframework.boot.ant"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"myapp"</span> <span class="attr">default</span>=<span class="string">"build"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>需要记住使用 <code>-lib</code> 选项启动 Ant,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ant -lib &lt;directory containing spring-boot-antlib-2.5.0.jar&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><h5 id="Spring-Boot-Ant-任务-Spring-Boot-Ant-Tasks"><a href="#Spring-Boot-Ant-任务-Spring-Boot-Ant-Tasks" class="headerlink" title="Spring Boot Ant 任务(Spring Boot Ant Tasks)"></a>Spring Boot Ant 任务(Spring Boot Ant Tasks)</h5><p>声明 <code>spring-boot-antlib</code> 命名空间后,可以使用以下附加任务:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/build-tool-plugins.html#build-tool-plugins.antlib.tasks.exejar">Using the “exejar” Task</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/build-tool-plugins.html#build-tool-plugins.antlib.findmainclass">Using the “findmainclass” Task</a></li>
</ul>
<ol>
<li><h6 id="使用”exejar”任务-Using-the-“exejar”-Task"><a href="#使用”exejar”任务-Using-the-“exejar”-Task" class="headerlink" title="使用”exejar”任务(Using the “exejar” Task)"></a>使用”exejar”任务(Using the “exejar” Task)</h6><p>可以使用 <code>exejar</code> 任务来创建 Spring Boot 可执行 jar. 任务支持以下属性:</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody><tr>
<td><code>destfile</code></td>
<td>要创建的目标 jar 文件</td>
<td>Yes</td>
</tr>
<tr>
<td><code>classes</code></td>
<td>Java类文件的根目录</td>
<td>Yes</td>
</tr>
<tr>
<td><code>start-class</code></td>
<td>要运行的主要应用程序类</td>
<td>No <em>(默认是找到的第一个声明 <code>main</code> 方法的类)</em></td>
</tr>
</tbody></table>
<p>以下嵌套元素可用于任务:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>resources</code></td>
<td>一个或多个 <a target="_blank" rel="noopener" href="https://ant.apache.org/manual/Types/resources.html#collection">资源集合</a> 描述一组 [资源](<a target="_blank" rel="noopener" href="https://ant.apache.org/manual/Types/">https://ant.apache.org/manual/Types/</a> resources.html) 应该添加到创建的 jar 文件的内容中.</td>
</tr>
<tr>
<td><code>lib</code></td>
<td>一个或多个 <a target="_blank" rel="noopener" href="https://ant.apache.org/manual/Types/resources.html#collection">Resource Collections</a> 应该添加到组成应用程序运行时依赖类路径的一组 jar 库中.</td>
</tr>
</tbody></table>
</li>
<li><h6 id="例子-Examples"><a href="#例子-Examples" class="headerlink" title="例子(Examples)"></a>例子(Examples)</h6><p>本节展示了 Ant 任务的两个示例.</p>
<p><em>Specify start-class</em></p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot:exejar</span> <span class="attr">destfile</span>=<span class="string">"target/my-application.jar"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">classes</span>=<span class="string">"target/classes"</span> <span class="attr">start-class</span>=<span class="string">"com.example.MyApplication"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"src/main/resources"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lib</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"lib"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lib</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">spring-boot:exejar</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><em>Detect start-class</em></p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exejar</span> <span class="attr">destfile</span>=<span class="string">"target/my-application.jar"</span> <span class="attr">classes</span>=<span class="string">"target/classes"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lib</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"lib"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lib</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exejar</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><h6 id="使用”findmainclass”任务-Using-the-“findmainclass”-Task"><a href="#使用”findmainclass”任务-Using-the-“findmainclass”-Task" class="headerlink" title="使用”findmainclass”任务(Using the “findmainclass” Task)"></a>使用”findmainclass”任务(Using the “findmainclass” Task)</h6><p><code>exejar</code> 在内部使用 <code>findmainclass</code> 任务来定位声明 main 的类. 如有必要,还可以直接在构建中使用此任务. 支持以下属性:</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody><tr>
<td><code>classesroot</code></td>
<td>Java类文件的根目录</td>
<td>Yes <em>(unless <code>mainclass</code> is specified)</em></td>
</tr>
<tr>
<td><code>mainclass</code></td>
<td>可用于短路<code>main</code>类搜索</td>
<td>No</td>
</tr>
<tr>
<td><code>property</code></td>
<td>应使用结果设置的 Ant 属性</td>
<td>No <em>(result will be logged if unspecified)</em></td>
</tr>
</tbody></table>
<ol>
<li><h6 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h6><p>本节包含三个使用 <code>findmainclass</code> 的示例.</p>
<p><em>Find and log</em></p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">findmainclass</span> <span class="attr">classesroot</span>=<span class="string">"target/classes"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><em>Find and set</em></p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">findmainclass</span> <span class="attr">classesroot</span>=<span class="string">"target/classes"</span> <span class="attr">property</span>=<span class="string">"main-class"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><em>Override and set</em></p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">findmainclass</span> <span class="attr">mainclass</span>=<span class="string">"com.example.MainClass"</span> <span class="attr">property</span>=<span class="string">"main-class"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><h6 id="支持其他构建系统"><a href="#支持其他构建系统" class="headerlink" title="支持其他构建系统"></a>支持其他构建系统</h6><p>如果想使用 Maven,Gradle 或 Ant 以外的构建工具,可能需要开发自己的插件.可执行jar需要遵循特定的格式,某些条目需要以未压缩的形式写入.</p>
<p>Spring Boot Maven 和 Gradle 插件都使用 <code>spring-boot-loader-tools</code> 来实际生成 jar. 如果需要,可以直接使用这个库.</p>
<ol>
<li><h6 id="重新打包文档-Repackaging-Archives"><a href="#重新打包文档-Repackaging-Archives" class="headerlink" title="重新打包文档(Repackaging Archives)"></a>重新打包文档(Repackaging Archives)</h6><p>要重新打包现有存档以使其成为独立的可执行存档,请使用 <code>org.springframework.boot.loader.tools.Repackager</code>.Repackager 类采用单个构造函数参数,该参数引用现有的 jar 或 war 存档. 使用两种可用的 <code>repackage()</code> 方法之一替换原始文件或写入新目标.在重新打包程序运行之前,还可以在重新打包程序上配置各种设置.</p>
</li>
<li><h6 id="嵌套库-Nested-Libraries"><a href="#嵌套库-Nested-Libraries" class="headerlink" title="嵌套库(Nested Libraries)"></a>嵌套库(Nested Libraries)</h6><p>重新打包存档时,可以使用 <code>org.springframework.boot.loader.tools.Libraries</code> 接口来包含对依赖文件的引用.在这里不提供库的任何具体实现,因为它们通常是特定于构建系统的.</p>
<p>如果存档已包含库,则可以使用 <code>Libraries.NONE</code>.</p>
</li>
<li><h6 id="寻找主类-Finding-a-Main-Class"><a href="#寻找主类-Finding-a-Main-Class" class="headerlink" title="寻找主类(Finding a Main Class)"></a>寻找主类(Finding a Main Class)</h6><p>如果不使用 <code>Repackager.setMainClass()</code> 指定主类,则重新打包程序使用 ASM 读取类文件并尝试使用 <code>public static void main(String[] args)</code> 方法找到合适的类.如果找到多个候选项,则会引发异常.</p>
</li>
<li><h6 id="重新打包实现的示例-Example-Repackage-Implementation"><a href="#重新打包实现的示例-Example-Repackage-Implementation" class="headerlink" title="重新打包实现的示例(Example Repackage Implementation)"></a>重新打包实现的示例(Example Repackage Implementation)</h6><p>以下示例显示了典型的重新打包实现:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBuildTool</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{        File sourceJarFile = ...        Repackager repackager = <span class="keyword">new</span> Repackager(sourceJarFile);        repackager.setBackupSource(<span class="keyword">false</span>);        repackager.repackage(<span class="keyword">this</span>::getLibraries);    }    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getLibraries</span><span class="params">(LibraryCallback callback)</span> <span class="keyword">throws</span> IOException </span>{        <span class="comment">// Build system specific implementation, callback for each dependency        for (File nestedJar : getCompileScopeJars()) {            callback.library(new Library(nestedJar, LibraryScope.COMPILE));        }        // ...    }    private List&lt;File&gt; getCompileScopeJars() {        return ...    }}</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/40038.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/40038.html" class="post-title-link" itemprop="url">5.3 Deploy:  安装 Spring Boot 应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:38:00 / 修改时间：13:03:48" itemprop="dateCreated datePublished" datetime="2021-06-10T12:38:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/40038.html" class="post-meta-item leancloud_visitors" data-flag-title="5.3 Deploy:  安装 Spring Boot 应用" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol start="3">
<li><h5 id="安装-Spring-Boot-应用程序-Installing-Spring-Boot-Applications"><a href="#安装-Spring-Boot-应用程序-Installing-Spring-Boot-Applications" class="headerlink" title="安装 Spring Boot 应用程序(Installing Spring Boot Applications)"></a>安装 Spring Boot 应用程序(Installing Spring Boot Applications)</h5><p>除了使用 <code>java -jar</code> 运行 Spring Boot 应用程序之外,还可以为 Unix 系统制作完全可执行的应用程序.一个完整的可执行的 jar 可以像任何其他可执行二进制文件一样执行,也可以用 <code>init.d</code> 或 <code>systemd</code> 注册.这有助于在生产环境中安装和管理 Spring Boot 应用程序.</p>
<blockquote>
<p>警告:</p>
<p>​    完全可执行的 jars 通过在文件前面嵌入一个额外的脚本来工作.目前,一些工具不接受这种格式,因此并不总能用这种技术.例如,<code>jar -xf</code> 可能无法提取已被制作成完全可执行的 jar 或 war.建议仅在打算直接执行时才使 jar 或 war 完全可执行,而不是使用 <code>java -jar</code> 运行它或将其部署到 servlet 容器.</p>
<p>警告:</p>
<p>​    无法使 zip64 格式的 jar 文件完全可执行.尝试这样做会导致 jar 文件在直接执行或使用 <code>java -jar</code> 执行时报告为损坏.包含一个或多个 zip64 格式嵌套 jar 的标准格式 jar 文件可以是完全可执行的.</p>
</blockquote>
<p>要使用 Maven 创建”完全可执行”的 jar,请使用以下插件配置:</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executable</span>&gt;</span>true<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>以下示例显示了等效的 Gradle 配置:</p>
<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bootJar {</span><br><span class="line">    launchScript()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后,可以通过输入 <code>./my-application.jar</code>(其中 <code>my-application</code> 是artifact的名称)来运行应用程序.</p>
<ol>
<li><h6 id="支持的操作系统-Supported-Operating-Systems"><a href="#支持的操作系统-Supported-Operating-Systems" class="headerlink" title="支持的操作系统(Supported Operating Systems)"></a>支持的操作系统(Supported Operating Systems)</h6><p>默认脚本支持大多数 Linux 发行版,并在 CentOS 和 Ubuntu 上进行了测试.其他平台,例如 OS X 和 FreeBSD,需要使用自定义的 <code>EmbeddedLaunchScript</code>.</p>
</li>
<li><h6 id="Unix-Linux-服务"><a href="#Unix-Linux-服务" class="headerlink" title="Unix/Linux 服务"></a>Unix/Linux 服务</h6><p>使用 <code>init.d</code> 或 <code>systemd</code> 可以轻松地将 Spring Boot 应用程序作为 Unix/Linux 服务启动.</p>
<ol>
<li><h6 id="安装为-init-d-服务-System-V-Installation-as-an-init-d-Service-System-V"><a href="#安装为-init-d-服务-System-V-Installation-as-an-init-d-Service-System-V" class="headerlink" title="安装为 init.d 服务(System V)(Installation as an init.d Service (System V))"></a>安装为 init.d 服务(System V)(Installation as an init.d Service (System V))</h6><p>如果将 Spring Boot 的 Maven 或 Gradle 插件配置为生成完全可执行的 jar,并且不使用自定义的 <code>EmbeddedLaunchScript</code>,则应用可以用作 <code>init.d</code> 服务.为此,将 jar 符号链接到 <code>init.d</code> 以支持标准的<code>start</code>,<code>stop</code>,<code>restart</code>和<code>status</code>命令.</p>
<p>该脚本支持以下功能:</p>
<ul>
<li>以拥有 jar 文件的用户身份启动服务</li>
<li>使用 <code>/var/run/&lt;appname&gt;/&lt;appname&gt;.pid</code> 跟踪应用程序的 PID</li>
<li>将控制台日志写入 <code>/var/log/&lt;appname&gt;.log</code></li>
</ul>
<p>假设 <code>/var/myapp</code> 中安装了 Spring Boot 应用程序,要将 Spring Boot 应用程序安装为 <code>init.d</code> 服务,请创建一个符号链接,如下所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp</span></span><br></pre></td></tr></tbody></table></figure>

<p>安装后,可以按照平常的方式启动和停止服务. 例如,在基于 Debian 的系统上,可以使用以下命令启动它:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> service myapp start</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果应用程序无法启动,请检查写入 <code>/var/log/&lt;appname&gt;.log</code> 的日志文件是否有错误.</p>
</blockquote>
<p>还可以使用标准操作系统工具将应用程序标记为自动启动. 例如,在 Debian 上,可以使用以下命令:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> update-rc.d myapp defaults &lt;priority&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h6 id="Securing-an-init-d-Service"><a href="#Securing-an-init-d-Service" class="headerlink" title="Securing an init.d Service"></a>Securing an init.d Service</h6><blockquote>
<p>建议:</p>
<p>​    以下是关于如何保护作为 <code>init.d</code> 服务运行的 Spring Boot 应用程序的一组指南.</p>
</blockquote>
<p>当以 root 身份执行时,就像使用 root 启动 init.d 服务一样,默认的可执行脚本以 <code>RUN_AS_USER</code> 环境变量中指定的用户身份运行应用程序.当未设置环境变量时,将使用拥有 jar 文件的用户.永远不应该以 root 身份运行 Spring Boot 应用程序,因此 <code>RUN_AS_USER</code> 永远不应该是 root,并且应用的 jar 文件不应该由 root 拥有.相反,创建一个特定用户来运行应用并设置 <code>RUN_AS_USER</code> 环境变量或使用 <code>chown</code> 使其成为 jar 文件的所有者,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chown bootapp:bootapp your-app.jar</span></span><br></pre></td></tr></tbody></table></figure>

<p>在这种情况下,默认的可执行脚本以 <code>bootapp</code> 用户身份运行应用程序.</p>
<blockquote>
<p>建议:</p>
<p>​    为了减少应用程序的用户帐户被盗用的可能性,应该考虑阻止它使用登录 shell.例如,可以将帐户的 shell 设置为 <code>/usr/sbin/nologin</code>.</p>
</blockquote>
<p>还应该采取措施防止修改应用的 jar 文件.首先配置它的权限,使其不能写入,只能由其所有者读取或执行,如下例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 500 your-app.jar</span></span><br></pre></td></tr></tbody></table></figure>

<p>其次,如果应用或运行它的帐户受到损害,还应该采取措施限制损害.如果攻击者确实获得了访问权限,他们可以使 jar 文件可写并更改其内容. 防止这种情况的一种方法是使用 <code>chattr</code> 使其不可变,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chattr +i your-app.jar</span></span><br></pre></td></tr></tbody></table></figure>

<p>这将防止任何用户(包括 root)修改 jar.</p>
<p>如果 root 用于控制应用的服务,并且使用 <code>.conf</code> 文件自定义其启动,则 <code>.conf</code> 文件将由 root 用户读取和evaluate.应相应地加以保护.使用 <code>chmod</code> 使文件只能由所有者读取,并使用 <code>chown</code> 使 root 成为所有者,如下例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 400 your-app.conf$ sudo chown root:root your-app.conf</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="安装为-systemd-服务-Installation-as-a-systemd-Service"><a href="#安装为-systemd-服务-Installation-as-a-systemd-Service" class="headerlink" title="安装为 systemd 服务( Installation as a systemd Service)"></a>安装为 systemd 服务( Installation as a systemd Service)</h6><p><code>systemd</code> 是 System V init 系统的继承者,现在被许多现代 Linux 发行版使用.虽然可以继续使用 <code>systemd</code> 的 <code>init.d</code> 脚本,但也可以使用 <code>systemd</code> 的”service”脚本启动 Spring Boot 应用程序.</p>
<p>假设在 <code>/var/myapp</code> 中安装了 Spring Boot 应用程序,要将 Spring Boot 应用程序安装为 <code>systemd</code> 服务,则创建一个名为 <code>myapp.service</code> 的脚本并将其放置在 <code>/etc/systemd/system</code> 目录中. 以下脚本提供了一个示例:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Unit]Description=myappAfter=syslog.target[Service]User=myappExecStart=/var/myapp/myapp.jarSuccessExitStatus=143[Install]WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>重要:</p>
<p>​    请记住更改应用程序的<code>Description</code>,<code>User</code>和<code>ExecStart</code>字段.</p>
<p>注意:</p>
<p>​    <code>ExecStart</code> 字段没有声明脚本操作命令,这意味着默认使用运行命令.</p>
</blockquote>
<p>请注意,与作为 <code>init.d</code> 服务运行时不同,运行应用程序的用户,PID 文件和控制台日志文件由 <code>systemd</code> 本身管理,因此必须使用”service”脚本中的适当字段进行配置.</p>
<p>要将应用程序标记为在系统启动时自动启动,请使用以下命令:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> myapp.service</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自定义启动脚本-Customizing-the-Startup-Script"><a href="#自定义启动脚本-Customizing-the-Startup-Script" class="headerlink" title="自定义启动脚本(Customizing the Startup Script)"></a>自定义启动脚本(Customizing the Startup Script)</h6><p>可以通过多种方式自定义由 Maven 或 Gradle 插件编写的默认嵌入式启动脚本.对于大多数人来说,使用默认脚本和一些自定义通常就足够了.如果发现无法自定义所需的内容,请使用 <code>EmbeddedLaunchScript</code> 选项完全编写自己的文件.</p>
<h6 id="写入时自定义启动脚本"><a href="#写入时自定义启动脚本" class="headerlink" title="写入时自定义启动脚本"></a>写入时自定义启动脚本</h6><p>在写入 jar 文件时自定义启动脚本的元素通常是有意义的.例如,<code>init.d</code> 脚本可以提供”description”. 由于预先知道描述(并且不需要更改),因此最好在生成 jar 时提供它.</p>
<p>要自定义写入的元素,请使用 Spring Boot Maven 插件的 <code>EmbeddedLaunchScriptProperties</code> 选项或 Spring Boot Gradle 插件的 <code>launchScript</code> 的 properties 属性( <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#packaging-executable-configuring-launch-script"><code>properties</code> property of the Spring Boot Gradle plugin’s <code>launchScript</code></a>.).</p>
<p>默认脚本支持以下属性替换:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Gradle default</th>
<th>Maven default</th>
</tr>
</thead>
<tbody><tr>
<td><code>mode</code></td>
<td>脚本模式.</td>
<td><code>auto</code></td>
<td><code>auto</code></td>
</tr>
<tr>
<td><code>initInfoProvides</code></td>
<td>“INIT INFO”的”提供”部分</td>
<td><code>${task.baseName}</code></td>
<td><code>${project.artifactId}</code></td>
</tr>
<tr>
<td><code>initInfoRequiredStart</code></td>
<td>“INIT INFO”的”Required-Start”部分.</td>
<td><code>$remote_fs $syslog $network</code></td>
<td><code>$remote_fs $syslog $network</code></td>
</tr>
<tr>
<td><code>initInfoRequiredStop</code></td>
<td>“INIT INFO”的”Required-Stop”部分.</td>
<td><code>$remote_fs $syslog $network</code></td>
<td><code>$remote_fs $syslog $network</code></td>
</tr>
<tr>
<td><code>initInfoDefaultStart</code></td>
<td>“INIT INFO”的”Default-Start”部分.</td>
<td><code>2 3 4 5</code></td>
<td><code>2 3 4 5</code></td>
</tr>
<tr>
<td><code>initInfoDefaultStop</code></td>
<td>“初始化信息”的”默认停止”部分.</td>
<td><code>0 1 6</code></td>
<td><code>0 1 6</code></td>
</tr>
<tr>
<td><code>initInfoShortDescription</code></td>
<td>“INIT INFO”的”Short-Description”部分.</td>
<td><code>${project.description}</code> 的单行版本(回退到 <code>${task.baseName}</code>)</td>
<td><code>${project.name}</code></td>
</tr>
<tr>
<td><code>initInfoDescription</code></td>
<td>“INIT INFO”的”描述”部分.</td>
<td><code>${project.description}</code>(回退到 <code>${task.baseName}</code>)</td>
<td><code>${project.description}</code>(回退到 <code>${project.name}</code>)</td>
</tr>
<tr>
<td><code>initInfoChkconfig</code></td>
<td>“INIT INFO”的<code>chkconfig</code>部分</td>
<td><code>2345 99 01</code></td>
<td><code>2345 99 01</code></td>
</tr>
<tr>
<td><code>confFolder</code></td>
<td><code>CONF_FOLDER</code> 的默认值</td>
<td>包含 jar 的文件夹</td>
<td>包含 jar 的文件夹</td>
</tr>
<tr>
<td><code>inlinedConfScript</code></td>
<td>对应内联在默认启动脚本中的文件脚本的引用. 这可用于在加载任何外部配置文件之前设置环境变量,例如<code>JAVA_OPTS</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>logFolder</code></td>
<td><code>LOG_FOLDER</code> 的默认值. 仅对 <code>init.d</code> 服务有效</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>logFilename</code></td>
<td><code>LOG_FILENAME</code> 的默认值. 仅对 <code>init.d</code> 服务有效</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>pidFolder</code></td>
<td><code>PID_FOLDER</code> 的默认值. 仅对 <code>init.d</code> 服务有效</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>pidFilename</code></td>
<td><code>PID_FOLDER</code> 中 PID 文件名称的默认值. 仅对 <code>init.d</code> 服务有效</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>useStartStopDaemon</code></td>
<td>是否应该使用 <code>start-stop-daemon</code> 命令(当它可用时)来控制进程</td>
<td><code>true</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>stopWaitTime</code></td>
<td><code>STOP_WAIT_TIME</code> 的默认值(以秒为单位). 仅对 <code>init.d</code> 服务有效</td>
<td>60</td>
<td>60</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="在运行时自定义脚本-Customizing-a-Script-When-It-Runs"><a href="#在运行时自定义脚本-Customizing-a-Script-When-It-Runs" class="headerlink" title="在运行时自定义脚本(Customizing a Script When It Runs)"></a>在运行时自定义脚本(Customizing a Script When It Runs)</h6><p>jar 写好后需要自定义的脚本项,可以使用环境变量或配置文件.</p>
<p>默认脚本支持以下环境属性:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>MODE</code></td>
<td>操作的”模式”. 默认值取决于 jar 的构建方式,但通常是 <code>auto</code>(这意味着它试图通过检查它是否是名为 <code>init.d</code> 的目录中的符号链接来猜测它是否是一个 init 脚本). 可以将其显式设置为 <code>service</code>,以便 `stop</td>
</tr>
<tr>
<td><code>RUN_AS_USER</code></td>
<td>将用于运行应用程序的用户. 未设置时,将使用拥有 jar 文件的用户.</td>
</tr>
<tr>
<td><code>USE_START_STOP_DAEMON</code></td>
<td>是否应使用”<code>start-stop-daemon</code>“命令(如果可用)来控制进程. 默认为”真”.</td>
</tr>
<tr>
<td><code>PID_FOLDER</code></td>
<td>pid 文件夹的根名称(默认为<code>/var/run</code>).</td>
</tr>
<tr>
<td><code>LOG_FOLDER</code></td>
<td>放置日志文件的文件夹的名称(默认为<code>/var/log</code>).</td>
</tr>
<tr>
<td><code>CONF_FOLDER</code></td>
<td>从中读取 .conf 文件的文件夹的名称(默认与 jar-file 相同的文件夹).</td>
</tr>
<tr>
<td><code>LOG_FILENAME</code></td>
<td><code>LOG_FOLDER</code> 中日志文件的名称(默认为 <code>&lt;appname&gt;.log</code>).</td>
</tr>
<tr>
<td><code>APP_NAME</code></td>
<td>应用程序的名称. 如果 jar 是从符号链接运行的,则脚本会猜测应用程序名称. 如果它不是符号链接或者想明确设置应用程序名称,这可能很有用.</td>
</tr>
<tr>
<td><code>RUN_ARGS</code></td>
<td>传递给程序(Spring Boot 应用程序)的参数.</td>
</tr>
<tr>
<td><code>JAVA_HOME</code></td>
<td><code>java</code> 可执行文件的位置默认使用 <code>PATH</code> 发现,但如果 <code>$JAVA_HOME/bin/java</code> 中有一个可执行文件,你可以显式设置它.</td>
</tr>
<tr>
<td><code>JAVA_OPTS</code></td>
<td>JVM 启动时传递给它的选项.</td>
</tr>
<tr>
<td><code>JARFILE</code></td>
<td>jar 文件的显式位置,以防脚本用于启动实际上并未嵌入的 jar.</td>
</tr>
<tr>
<td><code>DEBUG</code></td>
<td>如果不为空,则在 shell 进程上设置 <code>-x</code> 标志,允许查看脚本中的逻辑.</td>
</tr>
<tr>
<td><code>STOP_WAIT_TIME</code></td>
<td>在强制关闭之前停止应用程序时等待的时间(以秒为单位)(默认为”60”).</td>
</tr>
</tbody></table>
<blockquote>
<p>注意:</p>
<p>​    <code>PID_FOLDER</code>,<code>LOG_FOLDER</code> 和 <code>LOG_FILENAME</code> 变量仅对 <code>init.d</code> 服务有效. 对于”<code>systemd</code>“,使用”service”脚本进行等效的自定义.</p>
</blockquote>
<p>除了 <code>JARFILE</code> 和 <code>APP_NAME</code> 之外,可以使用 <code>.conf</code> 文件配置上一节中列出的设置.该文件应该在 jar 文件旁边,并且具有相同的名称,但后缀为 <code>.conf</code> 而不是 <code>.jar</code>. 例如,名为 <code>/var/myapp/myapp.jar</code> 的 jar 使用名为 <code>/var/myapp/myapp.conf</code> 的配置文件,如下例所示:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=-Xmx1024MLOG_FOLDER=/custom/log/folder</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果不喜欢在 jar 文件旁边放置配置文件,可以设置一个 <code>CONF_FOLDER</code> 环境变量来自定义配置文件的位置.</p>
</blockquote>
</li>
</ol>
</li>
<li><h6 id="Microsoft-Windows-服务-Microsoft-Windows-Services"><a href="#Microsoft-Windows-服务-Microsoft-Windows-Services" class="headerlink" title="Microsoft Windows 服务(Microsoft Windows Services)"></a>Microsoft Windows 服务(Microsoft Windows Services)</h6><p>可以使用 <a target="_blank" rel="noopener" href="https://github.com/kohsuke/winsw"><code>winsw</code></a> 将 Spring Boot 应用程序作为 Windows 服务启动.</p>
<p>A (<a target="_blank" rel="noopener" href="https://github.com/snicol/spring-boot-daemon">单独维护的示例</a>) 描述了如何为 Spring Boot 应用程序创建 Windows 服务的分步说明.</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/37726.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/37726.html" class="post-title-link" itemprop="url">5.2 Deploy:  部署到云</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:36:00 / 修改时间：13:02:40" itemprop="dateCreated datePublished" datetime="2021-06-10T12:36:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/37726.html" class="post-meta-item leancloud_visitors" data-flag-title="5.2 Deploy:  部署到云" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol start="2">
<li><h5 id="部署到云-Deploying-to-the-Cloud"><a href="#部署到云-Deploying-to-the-Cloud" class="headerlink" title="部署到云(Deploying to the Cloud)"></a>部署到云(Deploying to the Cloud)</h5><p>Spring Boot 的可执行 jar 是为大多数流行的云 PaaS(平台即服务)提供商准备的.这些提供商往往要求”自带容器”.他们管理应用进程(不是专门的 Java 应用程序),因此需要一个中间层,使开发者的应用程序适应云中正在运行的进程的概念.</p>
<p>两个流行的云提供商 Heroku 和 Cloud Foundry 采用”buildpack”方法.buildpack 将部署的代码包装在启动应用所需的所有内容中. 它可能是 JDK 和对 <code>java</code> 的调用,嵌入式 Web 服务器或成熟的应用程序服务器.buildpack 是可插拔的,但理想情况下,应该尽可能少地自定义.这减少了不受控制的功能的占用空间. 它最大限度地减少了开发和生产环境之间的差异.</p>
<p>理想情况下,应用程序,就像一个 Spring Boot 可执行 jar,将运行所需的一切都打包在其中.</p>
<ol>
<li><h6 id="Cloud-Foundry"><a href="#Cloud-Foundry" class="headerlink" title="Cloud Foundry"></a>Cloud Foundry</h6><p>Cloud Foundry 提供了默认构建包,如果没有指定其他构建包,这些构建包就会发挥作用.Cloud Foundry Java buildpack 对包括 Spring Boot 在内的 Spring 应用程序有很好的支持.可以部署独立的可执行 jar 应用程序以及传统的 <code>.war</code> 打包应用程序.</p>
<p>构建应用程序(例如,通过使用 <code>mvn clean package</code>)并安装 cf 命令行工具后,使用 <code>cf push</code> 命令部署应用程序,替换已编译的 <code>.jar</code> 的路径.在推送应用程序之前,请确保已使用 cf 命令行客户端登录. 以下行显示使用 <code>cf push</code> 命令部署应用程序:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cf push acloudyspringtime -p target/demo-0.0.1-SNAPSHOT.jar</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    在前面的示例中,将 <code>acloudyspringtime</code> 替换为给 cf 作为应用程序名称的任何值.</p>
</blockquote>
<p>如果同一目录中存在 Cloud Foundry <code>manifest.yml</code> 文件,则会考虑该文件.此时,<code>cf</code> 开始上传您的应用程序,生成类似于以下示例的输出:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Uploading acloudyspringtime... OK</span><br><span class="line">Preparing to start acloudyspringtime... OK</span><br><span class="line">-----&gt; Downloaded app package (8.9M)</span><br><span class="line">-----&gt; Java Buildpack Version: v3.12 (offline) | https://github.com/cloudfoundry/java-buildpack.git#6f25b7e</span><br><span class="line">-----&gt; Downloading Open Jdk JRE 1.8.0_121 from https://java-buildpack.cloudfoundry.org/openjdk/trusty/x86_64/openjdk-1.8.0_121.tar.gz (found in cache)</span><br><span class="line">       Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.6s)</span><br><span class="line">-----&gt; Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https://java-buildpack.cloudfoundry.org/memory-calculator/trusty/x86_64/memory-calculator-2.0.2_RELEASE.tar.gz (found in cache)</span><br><span class="line">       Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize=104857K -Xms681574K -XX:MetaspaceSize=104857K</span><br><span class="line">-----&gt; Downloading Container Certificate Trust Store 1.0.0_RELEASE from https://java-buildpack.cloudfoundry.org/container-certificate-trust-store/container-certificate-trust-store-1.0.0_RELEASE.jar (found in cache)</span><br><span class="line">       Adding certificates to .java-buildpack/container_certificate_trust_store/truststore.jks (0.6s)</span><br><span class="line">-----&gt; Downloading Spring Auto Reconfiguration 1.10.0_RELEASE from https://java-buildpack.cloudfoundry.org/auto-reconfiguration/auto-reconfiguration-1.10.0_RELEASE.jar (found in cache)</span><br><span class="line">Checking status of app 'acloudyspringtime'...</span><br><span class="line">  0 of 1 instances running (1 starting)</span><br><span class="line">  ...</span><br><span class="line">  0 of 1 instances running (1 starting)</span><br><span class="line">  ...</span><br><span class="line">  0 of 1 instances running (1 starting)</span><br><span class="line">  ...</span><br><span class="line">  1 of 1 instances running (1 running)</span><br><span class="line"></span><br><span class="line">App started</span><br></pre></td></tr></tbody></table></figure>

<p>恭喜！ 该应用程序现已上线！</p>
<p>应用程序上线后,可以使用 <code>cf apps</code> 命令验证已部署应用程序的状态,如以下示例所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cf apps</span></span><br><span class="line">Getting applications in ...</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">name                 requested state   instances   memory   disk   urls</span><br><span class="line">...</span><br><span class="line">acloudyspringtime    started           1/1         512M     1G     acloudyspringtime.cfapps.io</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>一旦 Cloud Foundry 确认应用程序已部署,应该能够在给定的 URI 中找到该应用程序.在前面的示例中,可以在 <a target="_blank" rel="noopener" href="https://acloudyspringtime.cfapps.io/">https://acloudyspringtime.cfapps.io/</a> 找到它.</p>
<ol>
<li><h6 id="绑定到服务-Binding-to-Services"><a href="#绑定到服务-Binding-to-Services" class="headerlink" title="绑定到服务(Binding to Services)"></a>绑定到服务(Binding to Services)</h6><p>默认情况下,有关应用的元数据以及服务连接信息作为环境变量公开给应用程序(例如:<code>$VCAP_SERVICES</code>).这个架构决定是由于 Cloud Foundry 的多语言(任何语言和平台都可以作为 buildpack 支持)的性质而决定的.作用在进程作用域的环境变量与语言无关.</p>
<p>环境变量并不总是最简单的 API,因此 Spring Boot 会自动提取它们并将数据扁平化为可以通过 Spring 的 <code>Environment</code> 抽象访问的属性,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String instanceId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.instanceId = environment.getProperty(<span class="string">"vcap.application.instance_id"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所有 Cloud Foundry 属性都以 <code>vcap</code> 为前缀. 可以使用 <code>vcap</code> 属性访问应用程序信息(例如应用程序的公共 URL)和服务信息(例如数据库凭据).</p>
</li>
<li><h6 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h6><p>Spring Boot 通过检查环境中的”<code>*_SERVICE_HOST</code>“和”<code>*_SERVICE_PORT</code>“变量来自动检测 Kubernetes 部署环境.可以使用 <code>spring.main.cloud-platform</code> 配置属性覆盖此检测.</p>
<ol>
<li><h6 id="Kubernetes-Container-Lifecycle"><a href="#Kubernetes-Container-Lifecycle" class="headerlink" title="Kubernetes Container Lifecycle"></a>Kubernetes Container Lifecycle</h6><p>当 Kubernetes 删除应用实例时,关闭过程同时涉及多个子系统:shutdown hooks,取消注册服务,从负载均衡器中移除实例……由于此关闭处理并行发生(并且由于分布式系统的性质),因此存在一个窗口,在此期间流量可以路由到已开始关闭处理的 pod.</p>
<p>可以在 preStop 处理程序中配置sleep execution ,避免将请求路由到已经开始关闭的 pod.睡眠时间应该足够长,以便新请求停止路由到 pod,其持续时间会因部署而异.preStop 处理程序可以通过 Pod 配置文件中的 PodSpec 进行配置,如下所示:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">example-image</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"sleep 10"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>一旦 <code>pre-stop</code> 钩子完成,SIGTERM 将被发送到容器并开始正常关闭,并且允许任何剩余的正在进行的请求完成.</p>
</li>
</ol>
</li>
<li><h6 id="Heroku"><a href="#Heroku" class="headerlink" title="Heroku"></a>Heroku</h6><p>Heroku 是另一个流行的 PaaS 平台.要自定义 Heroku 构建,需要提供一个 <code>Procfile</code>,它提供部署应用程序所需的指令.. Heroku 分配一个端口供 Java 应用程序使用,然后确保路由到外部 URI 的工作正常.</p>
<p>必须将应用程序配置为监听正确的端口. 以下示例显示了入门 REST 应用程序的 <code>Procfile</code>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web: java -Dserver.port=$PORT -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></tbody></table></figure>

<p>Spring Boot 使 <code>-D</code> 参数可以像访问 Spring Environment 实例属性一样访问.<code>server.port</code> 配置属性被提供给嵌入式 Tomcat,Jetty 或 Undertow 实例,然后在启动时使用该端口.<code>$PORT</code> 环境变量由 Heroku PaaS 分配.</p>
<p>需要做的应该就这么多. Heroku 部署最常见的部署工作流是 <code>git push</code> 代码到生产环境,如下面的例子所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push heroku main</span></span><br></pre></td></tr></tbody></table></figure>

<p>这将输出以下结果:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Initializing repository, done.</span><br><span class="line">Counting objects: 95, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (78/78), done.</span><br><span class="line">Writing objects: 100% (95/95), 8.66 MiB | 606.00 KiB/s, done.</span><br><span class="line">Total 95 (delta 31), reused 0 (delta 0)</span><br><span class="line"></span><br><span class="line">-----&gt; Java app detected</span><br><span class="line">-----&gt; Installing OpenJDK 1.8... done</span><br><span class="line">-----&gt; Installing Maven 3.3.1... done</span><br><span class="line">-----&gt; Installing settings.xml... done</span><br><span class="line">-----&gt; Executing: mvn -B -DskipTests=true clean install</span><br><span class="line"></span><br><span class="line">       [INFO] Scanning for projects...</span><br><span class="line">       Downloading: https://repo.spring.io/...</span><br><span class="line">       Downloaded: https://repo.spring.io/... (818 B at 1.8 KB/sec)</span><br><span class="line">        ....</span><br><span class="line">       Downloaded: https://s3pository.heroku.com/jvm/... (152 KB at 595.3 KB/sec)</span><br><span class="line">       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/target/...</span><br><span class="line">       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/pom.xml ...</span><br><span class="line">       [INFO] ------------------------------------------------------------------------</span><br><span class="line">       [INFO] BUILD SUCCESS</span><br><span class="line">       [INFO] ------------------------------------------------------------------------</span><br><span class="line">       [INFO] Total time: 59.358s</span><br><span class="line">       [INFO] Finished at: Fri Mar 07 07:28:25 UTC 2014</span><br><span class="line">       [INFO] Final Memory: 20M/493M</span><br><span class="line">       [INFO] ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">-----&gt; Discovering process types</span><br><span class="line">       Procfile declares types -&gt; web</span><br><span class="line"></span><br><span class="line">-----&gt; Compressing... done, 70.4MB</span><br><span class="line">-----&gt; Launching... done, v6</span><br><span class="line">       https://agile-sierra-1405.herokuapp.com/ deployed to Heroku</span><br><span class="line"></span><br><span class="line">To git@heroku.com:agile-sierra-1405.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br></pre></td></tr></tbody></table></figure>

<p>应用现在应该在 Heroku 上启动并运行.</p>
</li>
<li><h6 id="OpenShift"><a href="#OpenShift" class="headerlink" title="OpenShift"></a>OpenShift</h6><p>OpenShift 有许多资源描述了如何部署 Spring Boot 应用程序,包括:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.openshift.com/using-openshift-enterprise-grade-spring-boot-deployments/">Using the S2I builder</a></li>
<li><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-us/reference_architectures/2017/html-single/spring_boot_microservices_on_red_hat_openshift_container_platform_3/">Architecture guide</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.openshift.com/using-spring-boot-on-openshift/">Running as a traditional web application on Wildfly</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.openshift.com/openshift-commons-briefing-96-cloud-native-applications-spring-rhoar/">OpenShift Commons Briefing</a></li>
</ul>
</li>
<li><h6 id="Amazon-Web-Services-AWS"><a href="#Amazon-Web-Services-AWS" class="headerlink" title="Amazon Web Services (AWS)"></a>Amazon Web Services (AWS)</h6><p>Amazon Web Services 提供了多种安装 Spring Boot 的应用的方法,可以是传统的 Web 应用程序 (war),也可以是带有嵌入式 Web 服务器的可执行 jar 文件.</p>
<p>选项包括:</p>
<ul>
<li>AWS Elastic Beanstalk</li>
<li>AWS Code Deploy</li>
<li>AWS OPS Works</li>
<li>AWS Cloud Formation</li>
<li>AWS Container Registry</li>
</ul>
<p>每个都有不同的功能和定价模型. 在本文档中,我们描述了使用 AWS Elastic Beanstalk 的方法.</p>
<ol>
<li><h6 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h6><p>如官方 <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html">Elastic Beanstalk Java guide</a> 指南中所述,有两个主要选项来部署 Java 应用程序. 可以使用”Tomcat 平台”或”Java SE 平台”.</p>
<h6 id="Using-the-Tomcat-Platform"><a href="#Using-the-Tomcat-Platform" class="headerlink" title="Using the Tomcat Platform"></a>Using the Tomcat Platform</h6><p>此选项适用于生成 war 文件的 Spring Boot 项目. 无需特殊配置. 只需要遵循官方指南.</p>
<h6 id="Using-the-Java-SE-Platform"><a href="#Using-the-Java-SE-Platform" class="headerlink" title="Using the Java SE Platform"></a>Using the Java SE Platform</h6><p>此选项适用于生成 jar 文件,并运行嵌入式 Web 容器的 Spring Boot 项目.Elastic Beanstalk 环境在端口 <code>80</code> 上运行一个 nginx 实例来代理在端口 5000 上运行的真正的应用.要配置它,请将以下行添加到 <code>application.properties</code> 文件中:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=5000</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    <em>上传二进制文件而不是源文件</em></p>
<p>​    默认情况下,Elastic Beanstalk 上传源代码并在 AWS 中编译它们.但是,最好改为上传二进制文件.为此,请将类似于以下内容的行添加到 <code>.elasticbeanstalk/config.yml</code> 文件中:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;deploy:artifact: target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></tbody></table></figure>



<p>建议:</p>
<p>​    <em>通过设置环境类型降低性能开销</em></p>
<p>​    默认情况下,Elastic Beanstalk 环境是负载平衡的.负载均衡器的成本很高.为避免该成本,请将环境类型设置为”Single instance”,如 <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity">the Amazon documentation</a>中所述. 还可以使用 CLI 和以下命令创建单实例环境:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;eb create -s</span><br></pre></td></tr></tbody></table></figure></blockquote>
</li>
<li><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>这是访问 AWS 的最简单方法之一,但还有更多内容需要介绍,例如如何将 Elastic Beanstalk 集成到任何 CI/CD 工具中,使用 Elastic Beanstalk Maven 插件而不是 CLI,等等. 有一篇 <a target="_blank" rel="noopener" href="https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/">blog post</a> 更详细地介绍了这些主题.</p>
</li>
</ol>
</li>
<li><h6 id="Boxfuse-和Amazon-网络服务"><a href="#Boxfuse-和Amazon-网络服务" class="headerlink" title="Boxfuse 和Amazon 网络服务"></a>Boxfuse 和Amazon 网络服务</h6><p>Boxfuse 的工作原理是将您的 Spring Boot 可执行 jar 或 war 转换为最小的 VM 镜像,该镜像可以以不可修改的方式在 VirtualBox 或 AWS 上部署.Boxfuse 与 Spring Boot 深度集成,并使用 Spring Boot 配置文件中的信息自动配置端口和健康检查 URL.Boxfuse 将这些信息用于它生成的图像以及它提供的所有资源(实例,安全组,弹性负载均衡器等).</p>
<p>如果创建了 Boxfuse 账户,将其连接到 AWS 账户,安装了最新版本的 Boxfuse 客户端,并确保应用程序已由 Maven 或 Gradle 构建(例如,通过使用 <code>mvn clean package</code>),可以使用类似于以下的命令将 Spring Boot 应用程序部署到 AWS:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> boxfuse run myapp-1.0.jar -env=prod</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果当前目录中存在 <code>boxfuse.conf</code> 文件,则使用该文件.</p>
<blockquote>
<p>建议:</p>
<p>​    默认情况下,Boxfuse 在启动时激活一个名为 <code>boxfuse</code> 的 Spring 配置文件.如果可执行 jar 或 war 包含 <code>application-boxfuse.properties</code> 文件,则 Boxfuse 将根据其包含的属性进行配置.</p>
</blockquote>
<p>此时,<code>boxfuse</code> 为应用程序创建一个镜像,上传它,并在 AWS 上配置和启动必要的资源,产生类似于以下示例的输出:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fusing Image for myapp-1.0.jar ...Image fused in 00:06.838s (53937 K) -&gt; axelfontaine/myapp:1.0Creating axelfontaine/myapp ...Pushing axelfontaine/myapp:1.0 ...Verifying axelfontaine/myapp:1.0 ...Creating Elastic IP ...Mapping myapp-axelfontaine.boxfuse.io to 52.28.233.167 ...Waiting for AWS to create an AMI for axelfontaine/myapp:1.0 in eu-central-1 (this may take up to 50 seconds) ...AMI created in 00:23.557s -&gt; ami-d23f38cfCreating security group boxfuse-sg_axelfontaine/myapp:1.0 ...Launching t2.micro instance of axelfontaine/myapp:1.0 (ami-d23f38cf) in eu-central-1 ...Instance launched in 00:30.306s -&gt; i-92ef9f53Waiting for AWS to boot Instance i-92ef9f53 and Payload to start at https://52.28.235.61/ ...Payload started in 00:29.266s -&gt; https://52.28.235.61/Remapping Elastic IP 52.28.233.167 to i-92ef9f53 ...Waiting 15s for AWS to complete Elastic IP Zero Downtime transition ...Deployment completed successfully. axelfontaine/myapp:1.0 is up and running at https://myapp-axelfontaine.boxfuse.io/</span><br></pre></td></tr></tbody></table></figure>

<p>应用程序现在应该在 AWS 上启动并运行.请参阅关于 <a target="_blank" rel="noopener" href="https://boxfuse.com/blog/spring-boot-ec2.html">在 EC2 上部署 Spring Boot 应用程序</a> 以及 <a target="_blank" rel="noopener" href="https://boxfuse.com/blog/spring-boot-ec2.html">Boxfuse Spring Boot 集成文档</a> ) 开始使用 Maven 构建来运行应用程序.</p>
</li>
<li><h6 id="Google-Cloud"><a href="#Google-Cloud" class="headerlink" title="Google Cloud"></a>Google Cloud</h6><p>Google Cloud 有多个选项可用于启动 Spring Boot 应用程序.最容易的可能是 App Engine,但也可以找到在带有 Container Engine 的容器中或在带有 Compute Engine 的虚拟机上运行 Spring Boot 的方法.</p>
<p>要在 App Engine 中运行,可以先在 UI 中创建一个项目,它设置唯一标识符并设置 HTTP 路由.向项目添加一个 Java 应用程序并将其留空,然后使用 Google Cloud SDK 从命令行或 CI build将 Spring Boot 应用程序推送到该插槽中.</p>
<p>App Engine Standard 要求使用 WAR 打包. 按照 <a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/java-docs-samples/tree/master/appengine-java8/springboot-helloworld/README.md">these steps</a>将 App Engine 标准应用程序部署到 GCP.</p>
<p>或者,App Engine Flex 要求创建一个 <code>app.yaml</code> 文件来描述应用程序所需的资源.通常,将此文件放在 <code>src/main/appengine</code> 中,它应该类似于以下文件:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">service: defaultruntime: javaenv: flexruntime_config:  jdk: openjdk8handlers:- url:</span> <span class="string">/.*</span>  <span class="attr">script:</span> <span class="string">this</span> <span class="string">field</span> <span class="string">is</span> <span class="string">required,</span> <span class="attr">but ignoredmanual_scaling:  instances: 1health_check:  enable_health_check: Falseenv_variables:  ENCRYPT_KEY:</span> <span class="string">your_encryption_key_here</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以通过添加项目 ID 到构建配置中来部署应用程序(例如,使用 Maven 插件),如以下示例所示:</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.cloud.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>appengine-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>        <span class="tag">&lt;<span class="name">project</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">project</span>&gt;</span>    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后使用 <code>mvn appengine:deploy</code> 进行部署(如果需要先进行身份验证,则构建失败).</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/15372.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/15372.html" class="post-title-link" itemprop="url">5.1 Deploy:  部署Spring Boot应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:34:00 / 修改时间：13:03:15" itemprop="dateCreated datePublished" datetime="2021-06-10T12:34:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/15372.html" class="post-meta-item leancloud_visitors" data-flag-title="5.1 Deploy:  部署Spring Boot应用" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>824</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="部署Spring-Boot应用-Deploying-Spring-Boot-Applications"><a href="#部署Spring-Boot应用-Deploying-Spring-Boot-Applications" class="headerlink" title="部署Spring Boot应用(Deploying Spring Boot Applications)"></a>部署Spring Boot应用(Deploying Spring Boot Applications)</h5><p>Spring Boot 的灵活打包选项在部署应用时,提供了大量选择.可以将 Spring Boot 应用程序部署到各种云平台,容器映像( 例如 Docker)或虚拟/真实机器上.</p>
<p>本节介绍了一些更常见的部署方案.</p>
<ol>
<li><h5 id="部署到容器-Deploying-to-Containers"><a href="#部署到容器-Deploying-to-Containers" class="headerlink" title="部署到容器(Deploying to Containers)"></a>部署到容器(Deploying to Containers)</h5><p>如果从容器运行应用,则可以使用可执行 jar,但将其unexploded 并以不同方式运行它通常也是一个优势.某些 PaaS 实现也能在运行之前解压缩存档.例如,Cloud Foundry 就是这样运作的. 运行解压存档的一种方法是启动合适的启动器,如下所示:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jar -xf myapp.jar</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java org.springframework.boot.loader.JarLauncher</span></span><br></pre></td></tr></tbody></table></figure>

<p>这实际上在启动时( 取决于 jar 的大小)比从未unexploded 的存档中运行要快一些. 在运行时,没有任何差异.</p>
<p>解压 jar 文件后,还可以通过使用其”自然”main 方法而不是 <code>JarLauncher</code> 运行应用程序来获得额外的启动时间. 例如:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jar -xf myapp.jar</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -cp BOOT-INF/classes:BOOT-INF/lib/* com.example.MyApplication</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    在应用程序的 main 方法上使用 <code>JarLauncher</code> 具有其他好处:可以预测的类路径的顺序.jar 包含一个 <code>classpath.idx</code> 文件,<code>JarLauncher</code> 在构造类路径时使用该文件.</p>
</blockquote>
<p>可以通过[创建单独的层](<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.container-images.building">https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.container-images.building</a> .dockerfiles) 用于依赖项和应用程序类和资源( 通常更改更频繁)来更高效的容器镜像.</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/55274.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/55274.html" class="post-title-link" itemprop="url">4.10 Acuator: Cloud Foundry 支持</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:32:00 / 修改时间：13:04:30" itemprop="dateCreated datePublished" datetime="2021-06-10T12:32:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/55274.html" class="post-meta-item leancloud_visitors" data-flag-title="4.10 Acuator: Cloud Foundry 支持" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol start="10">
<li><h5 id="Cloud-Foundry-支持"><a href="#Cloud-Foundry-支持" class="headerlink" title="Cloud Foundry 支持"></a>Cloud Foundry 支持</h5><p>当部署 Cloud Foundry 实例时,将会激活的Spring Boot 的执行器模块所包含的其他的功能支持.  <code>/cloudfoundryapplication</code> 路径为所有<code>@Endpoint</code> bean 提供了一个可以替代的的安全路由. </p>
<p>扩展支持让 Cloud Foundry 管理 UI(例如可用于查看已部署应用程序的 Web 应用)使用 Spring Boot 执行器信息进行扩充.例如,应用状态页面可能包含完整的健康信息,而不是典型的”running”或”stopped”状态.</p>
<blockquote>
<p>注意:</p>
<p>​    普通用户无法直接访问 <code>/cloudfoundryapplication</code> 路径. 为了使用端点,有效的 UAA token 必须与请求一起传递.</p>
</blockquote>
<ol>
<li><h5 id="禁用扩展-Cloud-Foundry-执行器支持-Disabling-Extended-Cloud-Foundry-Actuator-Support"><a href="#禁用扩展-Cloud-Foundry-执行器支持-Disabling-Extended-Cloud-Foundry-Actuator-Support" class="headerlink" title="禁用扩展 Cloud Foundry 执行器支持(Disabling Extended Cloud Foundry Actuator Support)"></a>禁用扩展 Cloud Foundry 执行器支持(Disabling Extended Cloud Foundry Actuator Support)</h5><p>如果要完全禁用 <code>/cloudfoundryapplication</code> 端点,可以将以下设置添加到 <code>application.properties</code> 文件:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.cloudfoundry.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="Cloud-Foundry-自签名证书-Cloud-Foundry-Self-signed-Certificates"><a href="#Cloud-Foundry-自签名证书-Cloud-Foundry-Self-signed-Certificates" class="headerlink" title="Cloud Foundry 自签名证书(Cloud Foundry Self-signed Certificates)"></a>Cloud Foundry 自签名证书(Cloud Foundry Self-signed Certificates)</h6><p>默认情况下,<code>/cloudfoundryapplication</code> 端点的安全验证会对各种 Cloud Foundry 服务进行 SSL 调用.如果 Cloud Foundry UAA 或 Cloud Controller 服务使用自签名证书,则需要设置以下属性:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.cloudfoundry.skip-ssl-validation</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自定义上下文路径-Custom-Context-Path"><a href="#自定义上下文路径-Custom-Context-Path" class="headerlink" title="自定义上下文路径(Custom Context Path)"></a>自定义上下文路径(Custom Context Path)</h6><p>如果服务器的context-path已配置为 <code>/</code> 以外的任何内容,则 Cloud Foundry 端点在应用的根目录中将不可用.例如,如果 <code>server.servlet.context-path=/app</code>,则 Cloud Foundry 端点将在 <code>/app/cloudfoundryapplication/*</code> 处可用.</p>
<p>如果希望 Cloud Foundry 端点始终在 <code>/cloudfoundryapplication/*</code> 可用,无论服务器的上下文路径如何,都需要在应用中显式配置它.配置将因 Web 服务器而异. 对于Tomcat,可以添加如下配置:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCloudFoundryConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TomcatServletWebServerFactory <span class="title">servletWebServerFactory</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TomcatServletWebServerFactory() {</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(Host host, ServletContextInitializer[] initializers)</span> </span>{</span><br><span class="line">                <span class="keyword">super</span>.prepareContext(host, initializers);</span><br><span class="line">                StandardContext child = <span class="keyword">new</span> StandardContext();</span><br><span class="line">                child.addLifecycleListener(<span class="keyword">new</span> Tomcat.FixContextListener());</span><br><span class="line">                child.setPath(<span class="string">"/cloudfoundryapplication"</span>);</span><br><span class="line">                ServletContainerInitializer initializer = getServletContextInitializer(getContextPath());</span><br><span class="line">                child.addServletContainerInitializer(initializer, Collections.emptySet());</span><br><span class="line">                child.setCrossContext(<span class="keyword">true</span>);</span><br><span class="line">                host.addChild(child);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ServletContainerInitializer <span class="title">getServletContextInitializer</span><span class="params">(String contextPath)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (classes, context) -&gt; {</span><br><span class="line">            Servlet servlet = <span class="keyword">new</span> GenericServlet() {</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">                    ServletContext context = req.getServletContext().getContext(contextPath);</span><br><span class="line">                    context.getRequestDispatcher(<span class="string">"/cloudfoundryapplication"</span>).forward(req, res);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            };</span><br><span class="line">            context.addServlet(<span class="string">"cloudfoundry"</span>, servlet).addMapping(<span class="string">"/*"</span>);</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/21505.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/21505.html" class="post-title-link" itemprop="url">4.9 Acuator: 进程监控</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:30:00 / 修改时间：13:05:02" itemprop="dateCreated datePublished" datetime="2021-06-10T12:30:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/21505.html" class="post-meta-item leancloud_visitors" data-flag-title="4.9 Acuator: 进程监控" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>664</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol start="9">
<li><h5 id="进程监控-Process-Monitoring"><a href="#进程监控-Process-Monitoring" class="headerlink" title="进程监控(Process Monitoring)"></a>进程监控(Process Monitoring)</h5><p>在 <code>spring-boot</code> 模块中,可以找到两个类来创建用于进程监控的文件:</p>
<ul>
<li><code>ApplicationPidFileWriter</code> 创建一个包含应用程序 PID 的文件(默认情况下,在应用程序目录中,文件名为”<code>application.pid</code>“).</li>
<li><code>WebServerPortFileWriter</code> 创建一个文件(或多个文件),其中包含正在运行的 Web 服务器的端口(默认情况下,在应用程序目录中,文件名为”<code>application.port</code>“).</li>
</ul>
<p>默认情况下,这些writers未激活,但可以启用:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.process-monitoring.configuration">By Extending Configuration</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.process-monitoring.programmatically">Programmatically</a></li>
</ul>
</li>
</ol>
<ol>
<li><h6 id="扩展配置-Extending-Configuration"><a href="#扩展配置-Extending-Configuration" class="headerlink" title="扩展配置(Extending Configuration)"></a>扩展配置(Extending Configuration)</h6><p>在 <code>META-INF/spring.factories</code> 文件中,可以启用写入 PID 文件的监听器,如下例所示:</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.context.ApplicationPidFileWriter,\</span><br><span class="line">org.springframework.boot.web.context.WebServerPortFileWriter</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="编程方式实现-Programmatically"><a href="#编程方式实现-Programmatically" class="headerlink" title="编程方式实现(Programmatically)"></a>编程方式实现(Programmatically)</h6><p>还可以通过调用 <code>SpringApplication.addListeners(… ) </code>方法并传递适当的 <code>Writer</code> 对象来激活监听器.此方法还允许在 <code>Writer</code> 构造函数中自定义文件名和路径.</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/64760.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/64760.html" class="post-title-link" itemprop="url">4.8 Acuator:  HTTP 追踪</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:27:00 / 修改时间：13:08:00" itemprop="dateCreated datePublished" datetime="2021-06-10T12:27:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/64760.html" class="post-meta-item leancloud_visitors" data-flag-title="4.8 Acuator:  HTTP 追踪" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>455</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol start="8">
<li><h5 id="HTTP-追踪-HTTP-Tracing"><a href="#HTTP-追踪-HTTP-Tracing" class="headerlink" title="HTTP 追踪(HTTP Tracing)"></a>HTTP 追踪(HTTP Tracing)</h5><p>可以在应用的配置中提供类型为 <code>HttpTraceRepository</code> 的 bean 来启用 HTTP 跟踪.为方便起见,默认情况下,Spring Boot 提供了一个 <code>InMemoryHttpTraceRepository</code>,用于存储最近 100 个请求-响应交换的跟踪.<code>InMemoryHttpTraceRepository</code> 与其他跟踪解决方案相比功能有限,建议仅将其用于开发环境.对于生产环境,建议使用生产就绪的跟踪或可观察性解决方案,例如 Zipkin 或 Spring Cloud Sleuth.或者,创建自己的 <code>HttpTraceRepository</code> 以满足需求.</p>
<p><code>httptrace</code> 端点可用于获取存储在 <code>HttpTraceRepository</code> 中的有关请求-响应交换的信息.</p>
<ol>
<li><h6 id="自定义-HTTP-跟踪-Custom-HTTP-tracing"><a href="#自定义-HTTP-跟踪-Custom-HTTP-tracing" class="headerlink" title="自定义 HTTP 跟踪(Custom HTTP tracing)"></a>自定义 HTTP 跟踪(Custom HTTP tracing)</h6><p>要自定义每个跟踪中包含的项目,请使用 <code>management.trace.http.include</code> 配置属性.对于高级自定义,考虑注册自己的 <code>HttpExchangeTracer</code> 实现.</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">…</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  © 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenyk</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">337k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:06</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>


  





  
  

  
  <script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  
  


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.1.0/dist/quicklink.umd.js"></script>
  
  



<script src="/bundle.js"></script><script>{&quot;enable&quot;:true,&quot;spinner&quot;:true};
{&quot;enable&quot;:true,&quot;app_id&quot;:null,&quot;app_key&quot;:null,&quot;server_url&quot;:null,&quot;security&quot;:true};
{&quot;enable&quot;:true,&quot;home&quot;:true,&quot;archive&quot;:true,&quot;delay&quot;:true,&quot;timeout&quot;:3000,&quot;priority&quot;:true,&quot;ignores&quot;:null,&quot;url&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;&quot;}</script></body></html>