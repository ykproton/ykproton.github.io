<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat-logo.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat-logo.jpg">
  <link rel="mask-icon" href="/images/cat-logo.jpg" color="#222">






  
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="3.26 测试(Testing) 测试(Testing)Spring Boot 提供了许多工具和注解来帮助测试应用.测试支持由两个模块提供:spring-boot-test 包含核心项,spring-boot-test-autoconfigure 支持自动配置测试. 大多数开发人员使用 spring-boot-starter-test “Starter”,它导入 Spring Boot 测试模块以">
<meta property="og:type" content="article">
<meta property="og:title" content="3.26 Feature: 测试">
<meta property="og:url" content="http://example.com/posts/27280.html">
<meta property="og:site_name" content="ykproton">
<meta property="og:description" content="3.26 测试(Testing) 测试(Testing)Spring Boot 提供了许多工具和注解来帮助测试应用.测试支持由两个模块提供:spring-boot-test 包含核心项,spring-boot-test-autoconfigure 支持自动配置测试. 大多数开发人员使用 spring-boot-starter-test “Starter”,它导入 Spring Boot 测试模块以">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-06-10T04:06:00.000Z">
<meta property="article:modified_time" content="2021-06-10T04:52:46.722Z">
<meta property="article:author" content="chenyk">
<meta property="article:tag" content="Spring Boot">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/posts/27280.html">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;posts&#x2F;27280.html&quot;,&quot;path&quot;:&quot;posts&#x2F;27280.html&quot;,&quot;title&quot;:&quot;3.26 Feature: 测试&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>3.26 Feature: 测试 | ykproton</title>
  




  <noscript>
    
  </noscript>
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ykproton</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-26-%E6%B5%8B%E8%AF%95-Testing"><span class="nav-number">1.</span> <span class="nav-text">3.26 测试(Testing)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-Testing"><span class="nav-number">2.</span> <span class="nav-text">测试(Testing)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E8%8C%83%E5%9B%B4%E4%BE%9D%E8%B5%96-Test-Scope-Dependencies"><span class="nav-number">2.1.</span> <span class="nav-text">测试范围依赖(Test Scope Dependencies)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-Spring-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-Testing-Spring-Applications"><span class="nav-number">2.2.</span> <span class="nav-text">测试 Spring 应用程序(Testing Spring Applications)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-Spring-Boot-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-Testing-Spring-Boot-Applications"><span class="nav-number">2.3.</span> <span class="nav-text">测试 Spring Boot 应用程序(Testing Spring Boot Applications)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B-Web-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%9E%8B-Detecting-Web-Application-Type"><span class="nav-number">2.4.</span> <span class="nav-text">检测 Web 应用程序类型(Detecting Web Application Type)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE-Detecting-Test-Configuration"><span class="nav-number">2.5.</span> <span class="nav-text">检测测试配置(Detecting Test Configuration)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8E%92%E9%99%A4%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE-Excluding-Test-Configuration"><span class="nav-number">2.6.</span> <span class="nav-text">排除测试配置(Excluding Test Configuration)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BA%94%E7%94%A8%E5%8F%82%E6%95%B0-Using-Application-Arguments"><span class="nav-number">2.7.</span> <span class="nav-text">使用应用参数(Using Application Arguments)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%A2%83%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95-Testing-with-a-mock-environment"><span class="nav-number">2.8.</span> <span class="nav-text">使用模拟环境进行测试(Testing with a mock environment)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95-Testing-with-a-running-server"><span class="nav-number">2.9.</span> <span class="nav-text">使用正在运行的服务器进行测试(Testing with a running server)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-WebTestClient-Customizing-WebTestClient"><span class="nav-number">2.10.</span> <span class="nav-text">自定义 WebTestClient(Customizing WebTestClient)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JMX-Using-JMX"><span class="nav-number">2.11.</span> <span class="nav-text">使用JMX(Using JMX)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Metrics-Using-Metrics"><span class="nav-number">2.12.</span> <span class="nav-text">使用Metrics(Using Metrics)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E5%92%8C%E7%9B%91%E8%A7%86Bean-Mocking-and-Spying-Beans"><span class="nav-number">2.13.</span> <span class="nav-text">模拟和监视Bean(Mocking and Spying Beans)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95-Auto-configured-Tests"><span class="nav-number">2.14.</span> <span class="nav-text">自动配置测试(Auto-configured Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-JSON-%E6%B5%8B%E8%AF%95-Auto-configured-JSON-Tests"><span class="nav-number">2.15.</span> <span class="nav-text">自动配置的 JSON 测试(Auto-configured JSON Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-Spring-MVC-%E6%B5%8B%E8%AF%95-Auto-configured-Spring-MVC-Tests"><span class="nav-number">2.16.</span> <span class="nav-text">自动配置 Spring MVC 测试(Auto-configured Spring MVC Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Spring-WebFlux-%E6%B5%8B%E8%AF%95-Auto-configured-Spring-WebFlux-Tests"><span class="nav-number">2.17.</span> <span class="nav-text">自动配置的 Spring WebFlux 测试(Auto-configured Spring WebFlux Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE-Cassandra-%E6%B5%8B%E8%AF%95-Auto-configured-Data-Cassandra-Tests"><span class="nav-number">2.18.</span> <span class="nav-text">自动配置的数据 Cassandra 测试(Auto-configured Data Cassandra Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE-JPA-%E6%B5%8B%E8%AF%95-Auto-configured-Data-JPA-Tests"><span class="nav-number">2.19.</span> <span class="nav-text">自动配置的数据 JPA 测试(Auto-configured Data JPA Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-JDBC-%E6%B5%8B%E8%AF%95-Auto-configured-JDBC-Tests"><span class="nav-number">2.20.</span> <span class="nav-text">自动配置的 JDBC 测试(Auto-configured JDBC Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84Data-JDBC-%E6%B5%8B%E8%AF%95-Auto-configured-Data-JDBC-Tests"><span class="nav-number">2.21.</span> <span class="nav-text">自动配置的Data JDBC 测试 (Auto-configured Data JDBC Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-jOOQ-%E6%B5%8B%E8%AF%95-Auto-configured-jOOQ-Tests"><span class="nav-number">2.22.</span> <span class="nav-text">自动配置的 jOOQ 测试 (Auto-configured jOOQ Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Data-MongoDB-%E6%B5%8B%E8%AF%95-Auto-configured-Data-MongoDB-Tests"><span class="nav-number">2.23.</span> <span class="nav-text">自动配置的 Data  MongoDB 测试 (Auto-configured Data MongoDB Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Data-Neo4j-%E6%B5%8B%E8%AF%95-Auto-configured-Data-Neo4j-Tests"><span class="nav-number">2.24.</span> <span class="nav-text">自动配置的 Data  Neo4j 测试(Auto-configured Data Neo4j Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84Data-Redis-%E6%B5%8B%E8%AF%95-Auto-configured-Data-Redis-Tests"><span class="nav-number">2.25.</span> <span class="nav-text">自动配置的Data  Redis 测试(Auto-configured Data Redis Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84Data-LDAP-%E6%B5%8B%E8%AF%95-Auto-configured-Data-LDAP-Tests"><span class="nav-number">2.26.</span> <span class="nav-text">自动配置的Data LDAP 测试(Auto-configured Data LDAP Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-REST-%E5%AE%A2%E6%88%B7%E7%AB%AF-Auto-configured-REST-Clients"><span class="nav-number">2.27.</span> <span class="nav-text">自动配置的 REST 客户端(Auto-configured REST Clients)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Spring-REST-%E6%96%87%E6%A1%A3%E6%B5%8B%E8%AF%95-Auto-configured-Spring-REST-Docs-Tests"><span class="nav-number">2.28.</span> <span class="nav-text">自动配置的 Spring REST 文档测试(Auto-configured Spring REST Docs Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Mock-MVC-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-Spring-REST-Docs-%E6%B5%8B%E8%AF%95-Auto-configured-Spring-REST-Docs-Tests-with-Mock-MVC"><span class="nav-number">2.29.</span> <span class="nav-text">使用 Mock MVC 自动配置 Spring REST Docs 测试(Auto-configured Spring REST Docs Tests with Mock MVC)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Spring-Web-%E6%9C%8D%E5%8A%A1%E6%B5%8B%E8%AF%95-Auto-configured-Spring-Web-Services-Tests"><span class="nav-number">2.30.</span> <span class="nav-text">自动配置的 Spring Web 服务测试(Auto-configured Spring Web Services Tests)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%87%E7%89%87-Additional-Auto-configuration-and-Slicing"><span class="nav-number">2.31.</span> <span class="nav-text">额外的自动配置和切片(Additional Auto-configuration and Slicing)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%87%E7%89%87-User-Configuration-and-Slicing"><span class="nav-number">2.32.</span> <span class="nav-text">用户配置和切片 (User Configuration and Slicing)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Spock-%E6%B5%8B%E8%AF%95-Spring-Boot-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-Using-Spock-to-Test-Spring-Boot-Applications"><span class="nav-number">2.33.</span> <span class="nav-text">使用 Spock 测试 Spring Boot 应用程序 (Using Spock to Test Spring Boot Applications)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-Test-Utilities"><span class="nav-number">2.34.</span> <span class="nav-text">测试工具(Test Utilities)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ConfigDataApplicationContextInitializer"><span class="nav-number">2.35.</span> <span class="nav-text">ConfigDataApplicationContextInitializer</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TestPropertyValues"><span class="nav-number">2.36.</span> <span class="nav-text">TestPropertyValues</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#OutputCapture"><span class="nav-number">2.37.</span> <span class="nav-text">OutputCapture</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TestRestTemplate"><span class="nav-number">2.38.</span> <span class="nav-text">TestRestTemplate</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chenyk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ykproton" title="GitHub → https://github.com/ykproton" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/27280.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chenyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ykproton">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          3.26 Feature: 测试
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 12:06:00 / 修改时间：12:52:46" itemprop="dateCreated datePublished" datetime="2021-06-10T12:06:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
        </span>
    </span>

  
    <span id="/posts/27280.html" class="post-meta-item leancloud_visitors" data-flag-title="3.26 Feature: 测试" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>29k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>26 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h5 id="3-26-测试-Testing"><a href="#3-26-测试-Testing" class="headerlink" title="3.26 测试(Testing)"></a>3.26 测试(Testing)</h5><ol start="26">
<li><h5 id="测试-Testing"><a href="#测试-Testing" class="headerlink" title="测试(Testing)"></a>测试(Testing)</h5><p>Spring Boot 提供了许多工具和注解来帮助测试应用.测试支持由两个模块提供:<code>spring-boot-test</code> 包含核心项,<code>spring-boot-test-autoconfigure</code> 支持自动配置测试.</p>
<p>大多数开发人员使用 <code>spring-boot-starter-test</code> “Starter”,它导入 Spring Boot 测试模块以及 JUnit Jupiter,AssertJ,Hamcrest 和许多其他有用的库.</p>
<blockquote>
<p>建议:</p>
<p>​    如果有使用 JUnit 4 的测试,则可以使用 JUnit 5 的vintage引擎来运行它们.要使用vintage引擎,添加对 <code>junit-vintage-engine</code> 的依赖,如以下示例所示:</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &gt;<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> &gt;<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p><code>hamcrest-core</code> 被排除在 <code>org.hamcrest:hamcrest</code> 之外,它是 <code>spring-boot-starter-test</code> 的一部分.</p>
<ol>
<li><h6 id="测试范围依赖-Test-Scope-Dependencies"><a href="#测试范围依赖-Test-Scope-Dependencies" class="headerlink" title="测试范围依赖(Test Scope Dependencies)"></a>测试范围依赖(Test Scope Dependencies)</h6><p><code>spring-boot-starter-test</code> “Starter”(在<code>test</code> <code>scope</code>内)包含以下提供的库:</p>
<ul>
<li>JUnit 5:用于Java 应用单元测试标准.</li>
<li>Spring Test &amp; Spring Boot Test:对 Spring Boot 应用提供的工具和集成测试.</li>
<li>AssertJ:流式的断言库.</li>
<li>Hamcrest:匹配器对象库(也称为约束或谓词).</li>
<li>Mockito: Java 模拟框架.</li>
<li>JSONassert:JSON 的断言库.</li>
<li>JsonPath:JSON 的 XPath.</li>
</ul>
<p>通常发现这些公共库在编写测试时很有用.如果这些库不适合需要,可以添加自己的其他测试依赖项.</p>
</li>
<li><h6 id="测试-Spring-应用程序-Testing-Spring-Applications"><a href="#测试-Spring-应用程序-Testing-Spring-Applications" class="headerlink" title="测试 Spring 应用程序(Testing Spring Applications)"></a>测试 Spring 应用程序(Testing Spring Applications)</h6><p>依赖注入的主要优点之一是它应该使代码更容易进行单元测试.可以使用 <code>new</code> 运算符实例化对象,甚至无需涉及 Spring. 还可以使用模拟对象(<em>mock objects</em>)而不是真正的依赖项.</p>
<p>通常,不仅需要单元测试,还需要集成测试(使用 Spring <code>ApplicationContext</code>).不需要部署应用程序或连接到其他infrastructure就可以执行集成测试,这会非常有用.</p>
<p>Spring Framework 包括一个专门的测试模块,用于此类集成测试.可以直接声明依赖项 <code>org.springframework:spring-test</code> ,或者通过 <code>spring-boot-starter-test</code>“Starter” 的传递性,将其拉取.</p>
<p>如果之前没有使用过 <code>spring-test</code> 模块,您应该首先阅读 Spring Framework 参考文档(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testing">relevant section</a>)的相关部分.</p>
</li>
<li><h6 id="测试-Spring-Boot-应用程序-Testing-Spring-Boot-Applications"><a href="#测试-Spring-Boot-应用程序-Testing-Spring-Boot-Applications" class="headerlink" title="测试 Spring Boot 应用程序(Testing Spring Boot Applications)"></a>测试 Spring Boot 应用程序(Testing Spring Boot Applications)</h6><p>Spring Boot 应用程序是一个 Spring <code>ApplicationContext</code>,因此通常除了使用 vanilla Spring context执行的测试之外,不需要做任何特别的事情来测试它.</p>
<blockquote>
<p>注意:</p>
<p>​    只有使用 <code>SpringApplication</code> 创建它时,Spring Boot 的外部属配置,日志和其他功能会默认地安装在context中.</p>
</blockquote>
<p>Spring Boot 提供了一个 <code>@SpringBootTest</code> 注解,当需要 Spring Boot 测试功能时,它可以替代 <code>spring-test</code> <code>@ContextConfiguration</code> 注解.注解的工作原理是通过 <code>SpringApplication</code> 创建测试中需要使用的 <code>ApplicationContext</code>.除了<code>@SpringBootTest</code>之外,还提供了许多其他注解,来测试应用程序的更具体的切片.</p>
<blockquote>
<p>建议:</p>
<p>​    如果使用的是 JUnit 4,不要忘记将 <code>@RunWith(SpringRunner.class) </code>添加到测试中,否则注解将被忽略.如果使用的是 JUnit 5,则无需添加 <code>@ExtendWith(SpringExtension.class) </code>作为 <code>@SpringBootTest</code> ,并且其他 <code>@… Test</code> 注解已经用它进行了标注.</p>
</blockquote>
<p>默认情况下,<code>@SpringBootTest</code> 不会启动服务器. 您可以使用 <code>@SpringBootTest</code> 的 <code>webEnvironmen</code>t 属性来进一步优化测试的运行方式:</p>
<ul>
<li><code>MOCK</code>(Default) : 加载一个 web <code>ApplicationContext</code> 并提供web模拟环境.使用此注解时不会启动嵌入式服务器.如果classpath上没有 Web 环境,则此模式会创建普通的的非 Web <code>ApplicationContext</code>.它可以与 <code>@AutoConfigureMockMvc</code> 或 <code>@AutoConfigureWebTestClient</code> 结合使用,用于对 Web 应用进行模拟测试.</li>
<li><code>RANDOM_PORT</code>:加载一个 <code>WebServerApplicationContext</code> 并提供一个真实的 Web 环境. 嵌入式服务器启动并监听随机端口.</li>
<li><code>DEFINED_PORT</code>:加载一个 <code>WebServerApplicationContext</code> 并提供一个真实的 Web 环境.嵌入式服务器启动并监听指定的端口(来自 <code>application.properties</code>)或默认端口 <code>8080</code>.</li>
<li><code>NONE</code>:使用 <code>SpringApplication</code> 加载 <code>ApplicationContext</code> 但不提供任何 web 环境(模拟或其他).</li>
</ul>
<blockquote>
<p>注意:</p>
<p>​    如果测试是<code>@Transactional</code>,它默认在每个测试方法结束时回滚事务.然而,使用带有 <code>RANDOM_PORT</code> 或 <code>DEFINED_PORT</code> ,这种方式隐式地提供了一个真正的 servlet 环境,HTTP 客户端和服务器运行在单独的线程中,因此在事务也在单独的线程中运行.在这种情况下,在服务器上启动的任何事务都不会回滚.</p>
<p>注意:</p>
<p>​    如果应用管理服务器时使用不同的端口,带有 <code>webEnvironment = WebEnvironment.RANDOM_PORT</code> 的 <code>@SpringBootTest</code> 还将在单独的随机端口上启动管理服务器.</p>
</blockquote>
<ol>
<li><h6 id="检测-Web-应用程序类型-Detecting-Web-Application-Type"><a href="#检测-Web-应用程序类型-Detecting-Web-Application-Type" class="headerlink" title="检测 Web 应用程序类型(Detecting Web Application Type)"></a>检测 Web 应用程序类型(Detecting Web Application Type)</h6><p>如果 Spring MVC 可用,则会配置常规的基于 MVC 的应用context. 如果只有 Spring WebFlux,将检测到并配置基于 WebFlux 的应用context.</p>
<p>如果两者都存在,则 Spring MVC 优先.如果要在此场景中测试响应式 Web 应用程序,则必须设置 <code>spring.main.web-application-type</code> 属性:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(properties = "spring.main.web-application-type=reactive")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWebFluxTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="检测测试配置-Detecting-Test-Configuration"><a href="#检测测试配置-Detecting-Test-Configuration" class="headerlink" title="检测测试配置(Detecting Test Configuration)"></a>检测测试配置(Detecting Test Configuration)</h6><p>如果熟悉 Spring 测试框架,可能习惯使用 <code>@ContextConfiguration(classes=… )</code>来指定要加载哪个 Spring <code>@Configuration</code>.或者,可能经常在测试中使用嵌套的 <code>@Configuration</code> 类.</p>
<p>在测试 Spring Boot 应用时,这通常不是必需的. 如果没有明确定义配置时,Spring Boot 的 <code>@*Test</code> 注解就会自动搜索基本配置.</p>
<p>搜索算法从包含测试的包开始工作,直到找到用 <code>@SpringBootApplication</code> 或 <code>@SpringBootConfiguration</code> 标注的类.只要合理构建代码,通常会找到主要配置.</p>
<blockquote>
<p>建议:</p>
<p>​    如果使用测试注解来测试应用的更具体部分,则应避免在主方法的应用类上添加特定于特定区域的配置设置.</p>
<p>​    <code>@SpringBootApplication</code> 的底层组件扫描配置定义了排除过滤器,用于确保切片按预期工作.如果在 <code>@SpringBootApplication</code> 标注的类上使用显式 <code>@ComponentScan</code> 指令,请注意这些过滤器将被禁用.如果正在使用切片,应该再次定义它们.</p>
</blockquote>
<p>如果要自定义主要配置,可以使用嵌套的 <code>@TestConfiguration</code> 类.与替代应用基本配置的嵌套 <code>@Configuration</code> 类不同,除了应用程序的基本配置之外,还要使用嵌套的 <code>@TestConfiguration</code> 类.</p>
<blockquote>
<p>注意:</p>
<p>​    Spring 测试框架在测试中间缓存context.因此,只要测试共享相同的配置(无论怎样被发现),加载上下文的耗时过程只会发生一次.</p>
</blockquote>
</li>
<li><h6 id="排除测试配置-Excluding-Test-Configuration"><a href="#排除测试配置-Excluding-Test-Configuration" class="headerlink" title="排除测试配置(Excluding Test Configuration)"></a>排除测试配置(Excluding Test Configuration)</h6><p>如果应用使用组件扫描(例如,如果使用<code>@SpringBootApplication</code> 或<code>@ComponentScan</code>),可能会发现仅为特定测试创建的top-level配置类意外地随处可见.</p>
<p>正如我们之前看到的,<code>@TestConfiguration</code> 可以用于测试的内部类来自定义主要配置.<code>@TestConfiguration</code>放在顶级类时,表示<code>src/test/java</code>中的类不应该通过扫描获取.然后,可以在需要的地方显式导入该类,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Import(MyTestsConfiguration.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    如果直接使用<code>@ComponentScan</code>(即不通过<code>@SpringBootApplication</code>),则需要使用它注册<code>TypeExcludeFilter</code>. 有关详细信息,参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/context/TypeExcludeFilter.html">the Javadoc</a>.</p>
</blockquote>
</li>
<li><h6 id="使用应用参数-Using-Application-Arguments"><a href="#使用应用参数-Using-Application-Arguments" class="headerlink" title="使用应用参数(Using Application Arguments)"></a>使用应用参数(Using Application Arguments)</h6><p>如果应用需要参数,可以让 <code>@SpringBootTest</code> 使用 <code>args</code> 属性注入它们.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(args = "--app.test=one")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplicationArgumentTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applicationArgumentsPopulated</span><span class="params">(<span class="meta">@Autowired</span> ApplicationArguments args)</span> </span>{</span><br><span class="line">        assertThat(args.getOptionNames()).containsOnly(<span class="string">"app.test"</span>);</span><br><span class="line">        assertThat(args.getOptionValues(<span class="string">"app.test"</span>)).containsOnly(<span class="string">"one"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="使用模拟环境进行测试-Testing-with-a-mock-environment"><a href="#使用模拟环境进行测试-Testing-with-a-mock-environment" class="headerlink" title="使用模拟环境进行测试(Testing with a mock environment)"></a>使用模拟环境进行测试(Testing with a mock environment)</h6><p>默认情况下,<code>@SpringBootTest</code> 不启动服务器.如果有针对此模拟环境进行测试的 Web 端点,则可以另外配置 <code>MockMvc</code>,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMockMvcTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> MockMvc mvc)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        mvc.perform(get(<span class="string">"/"</span>)).andExpect(status().isOk()).andExpect(content().string(<span class="string">"Hello World"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果只想专注于 web 层而不是启动完整的 <code>ApplicationContext</code>,请考虑使用 <code>@WebMvcTest</code> 代替.</p>
</blockquote>
<p>或者,可以配置 <code>WebTestClient</code>,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureWebTestClient</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMockWebTestClientTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> WebTestClient webClient)</span> </span>{</span><br><span class="line">        webClient</span><br><span class="line">            .get().uri(<span class="string">"/"</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectBody(String.class).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    在模拟环境中进行测试通常比在完整的 Servlet 容器中运行要快.但是,由于模拟发生在 Spring MVC 层,因此无法直接使用 MockMvc 来测试那些依赖于较低级别 Servlet 容器行为的代码.</p>
<p>例如,Spring Boot 的错误处理是基于 Servlet 容器提供的”错误页面”支持.这意味着,虽然可以按预期测试 MVC 层抛出和处理异常,但您无法直接测试是否呈现了特定的自定义错误页面.如果需要测试这些较低级别的问题,可以启动一个完整运行的服务器,如下一节所述.</p>
</blockquote>
</li>
<li><h6 id="使用正在运行的服务器进行测试-Testing-with-a-running-server"><a href="#使用正在运行的服务器进行测试-Testing-with-a-running-server" class="headerlink" title="使用正在运行的服务器进行测试(Testing with a running server)"></a>使用正在运行的服务器进行测试(Testing with a running server)</h6><p>如果需要启动一个完整运行的服务器,建议使用随机端口.如果使用<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>,则每次测试运行时都会随机选择一个可用端口.</p>
<p><code>@LocalServerPort</code> 注释可用来将实际使用的端口注入到您的测试中.为方便起见,需要对启动的服务器进行 REST 调用的测试可以 <code>@Autowire</code> 一个 <code>WebTestClient</code>,它解析发送到运行中服务器的相关链接,并带有用于验证响应的专用 API,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRandomPortWebTestClientTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> WebTestClient webClient)</span> </span>{</span><br><span class="line">        webClient</span><br><span class="line">            .get().uri(<span class="string">"/"</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectBody(String.class).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个设置需要在classpath上使用 <code>spring-webflux</code>. 如果不能或不会添加 webflux,Spring Boot 还提供了一个 <code>TestRestTemplate</code> 工具:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRandomPortTestRestTemplateTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">(<span class="meta">@Autowired</span> TestRestTemplate restTemplate)</span> </span>{</span><br><span class="line">        String body = restTemplate.getForObject(<span class="string">"/"</span>, String.class);</span><br><span class="line">        assertThat(body).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自定义-WebTestClient-Customizing-WebTestClient"><a href="#自定义-WebTestClient-Customizing-WebTestClient" class="headerlink" title="自定义 WebTestClient(Customizing WebTestClient)"></a>自定义 WebTestClient(Customizing WebTestClient)</h6><p>要自定义 <code>WebTestClient</code> bean,请配置 <code>WebTestClientBuilderCustomizer</code> bean.调用<code>WebTestClient.Builder</code>来创建<code>WebTestClient</code>.</p>
</li>
<li><h6 id="使用JMX-Using-JMX"><a href="#使用JMX-Using-JMX" class="headerlink" title="使用JMX(Using JMX)"></a>使用JMX(Using JMX)</h6><p>由于测试context框架缓存context,JMX默认下禁用来防止在同一域上注册相同组件.如果此类测试需要访问 <code>MBeanServer</code>,请考虑将其标记为<code>dirty </code>:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span><span class="meta">@SpringBootTest(properties = "spring.jmx.enabled=true")</span><span class="meta">@DirtiesContextclass</span> MyJmxTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MBeanServer mBeanServer;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> <span class="keyword">throws</span> MalformedObjectNameException </span>{        assertThat(<span class="keyword">this</span>.mBeanServer.getDomains()).contains(<span class="string">"java.lang"</span>);        <span class="comment">// ...    }}</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="使用Metrics-Using-Metrics"><a href="#使用Metrics-Using-Metrics" class="headerlink" title="使用Metrics(Using Metrics)"></a>使用Metrics(Using Metrics)</h6><p>无论classpath如何,使用<code>@SpringBootTest</code> 时,除内存支持外的meter registries都不会自动配置.</p>
<p>如果需要将metrics作为集成测试的一部分导出到不同的后端,请使用 <code>@AutoConfigureMetrics</code> 对其进行标注.</p>
</li>
<li><h6 id="模拟和监视Bean-Mocking-and-Spying-Beans"><a href="#模拟和监视Bean-Mocking-and-Spying-Beans" class="headerlink" title="模拟和监视Bean(Mocking and Spying Beans)"></a>模拟和监视Bean(Mocking and Spying Beans)</h6><p>运行测试时,有时需要在应用context中模拟某些组件.例如,可能有一个在开发过程中不可用的远程服务的facade.当想要模拟在真实环境中可能难以触发的故障时,Mocking会很有用.</p>
<p>Spring Boot 包含一个 <code>@MockBean</code> 注解,可用于为 <code>ApplicationContext</code> 中的 bean 定义 Mockito 模拟.可以使用注解添加新 bean 或替换单个现有 bean 定义.注解可以直接用于测试类,测试中的字段或<code>@Configuration</code> 类和字段.在字段上使用时,还会注入创建的模拟实例. Mock bean 在每个测试方法后自动重置.</p>
<blockquote>
<p>注意:</p>
<p>​    如果测试使用 Spring Boot 的测试注解(例如 <code>@SpringBootTest</code>),则会自动启用此功能.要以不同的方式使用此功能,必须显式添加监听器,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@ContextConfiguration(classes = MyConfig.class)</span><span class="meta">@TestExecutionListeners({ MockitoTestExecutionListener.class, ResetMocksTestExecutionListener.class })</span><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>{<span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>以下示例用mock implementation替换现有的 <code>RemoteService</code> bean:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTestclass</span> MyTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> Reverser reverser;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> RemoteService remoteService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>{        given(<span class="keyword">this</span>.remoteService.getValue()).willReturn(<span class="string">"spring"</span>);        String reverse = <span class="keyword">this</span>.reverser.getReverseValue(); <span class="comment">// Calls injected RemoteService        assertThat(reverse).isEqualTo("gnirps");    }}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    <code>@MockBean</code> 不能用于模拟在应用context刷新期间 bean 的执行行为.到执行测试时,应用context 刷新已完成,配置模拟行为为时已晚.在这种情况下,建议使用 <code>@Bean</code> 方法来创建和配置模拟.</p>
</blockquote>
<p>此外,可以使用 <code>@SpyBean</code>来包装任何使用 Mockito <code>spy</code> 的bean. 有关完整的详细信息,请参阅 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/api/org/springframework/boot/test/mock/mockito/SpyBean.html">Javadoc</a>.</p>
<blockquote>
<p>注意:</p>
<p>​    CGLib 代理,例如为作用域 bean 创建的代理,将代理方法声明为 <code>final</code>.这会阻止 Mockito 正常运行,因为默认情况下,它无法模拟或监视<code>final</code>方法.如果想模拟或监视此类 bean,通过将 <code>org.mockito:mockito-inline</code> 添加到应用的测试依赖项来配置 Mockito 从而使用其内联模拟生成器.这允许 Mockito 模拟和监视<code>final</code>方法.</p>
<p>注意:</p>
<p>​    虽然 Spring 的测试框架在测试之间缓存应用context,并为了共享配置复用context,但使用 <code>@MockBean</code> 或 <code>@SpyBean</code> 会影响缓存key,这很可能会增加上下文的数量.</p>
<p>建议:</p>
<p>​    如果使用<code>@SpyBean</code> 来监视带有按名称引用参数的<code>@Cacheable</code> 方法的bean,则应用必须使用<code>-parameters</code> 进行编译.这保证了一旦 bean 被监视,参数名称就可用于缓存infrastructure .</p>
<p>建议:</p>
<p>​    当使用<code>@SpyBean</code> 来监视由 Spring 代理的 bean 时,可能在某些情况下需要移除 Spring 的代理,例如在使用 <code>given</code> 或 <code>when</code> 设置expectation时.使用 <code>AopTestUtils.getTargetObject(yourProxiedSpy)</code>来这样做.</p>
</blockquote>
</li>
<li><h6 id="自动配置测试-Auto-configured-Tests"><a href="#自动配置测试-Auto-configured-Tests" class="headerlink" title="自动配置测试(Auto-configured Tests)"></a>自动配置测试(Auto-configured Tests)</h6><p>Spring Boot 的自动配置系统适用于应用,但有时对于测试来说可能有点太多了.它通常有助于仅加载测试应用”slice”所需的配置部分.例如,测试运行时,可能想要测试 Spring MVC 控制器是否正确映射 URL,并且不想在这些测试中涉及数据库调用,或者可能想要测试 JPA entities,并且对 web 层不感兴趣.</p>
<p><code>spring-boot-test-autoconfigure</code> 模块包含许多注解,可用于自动配置此类”切片”.它们中的每一个都以类似的方式工作,提供一个加载 <code>ApplicationContext</code> 的 <code>@… Test</code> 注解和一个或多个可用于自定义自动配置的 <code>@AutoConfigure…</code> 注解.</p>
<blockquote>
<p>注意:</p>
<p>​    每个slice将组件扫描范围限制为适当的组件并加载一组非常有限的自动配置类.如果需要排除其中之一,大多数<code>@… Test</code> 注解都提供 <code>excludeAutoConfiguration</code> 属性.或者,可以使用<code>@ImportAutoConfiguration#exclude</code>.</p>
<p>注意:</p>
<p>​    不支持在一个测试中使用多个 <code>@… Test</code> 注注解包含多个”slices”.如果需要多个”slices”,请选择其中一个 <code>@… Test</code> 注解并手动包含其他”slices”的 <code>@AutoConfigure</code>… 注解.</p>
<p>建议:</p>
<p>​    也可以将<code>@AutoConfigure…</code> 注解与标准<code>@SpringBootTest</code> 注解一起使用.如果对将应用”切片”不感兴趣,但想要一些自动配置的测试 bean,则可以使用此组合.</p>
</blockquote>
</li>
<li><h6 id="自动配置的-JSON-测试-Auto-configured-JSON-Tests"><a href="#自动配置的-JSON-测试-Auto-configured-JSON-Tests" class="headerlink" title="自动配置的 JSON 测试(Auto-configured JSON Tests)"></a>自动配置的 JSON 测试(Auto-configured JSON Tests)</h6><p>要测试该对象 JSON 序列化和反序列化是否按预期工作,可以使用 <code>@JsonTest</code> 注解.<code>@JsonTest</code> 自动配置支持的 JSON 映射器,它可以是以下库之一:</p>
<ul>
<li>Jackson <code>ObjectMapper</code>,任何<code>@JsonComponent</code> bean 和任何 Jackson <code>Module</code></li>
<li><code>Gson</code></li>
<li><code>Jsonb</code></li>
</ul>
<p>如果需要配置自动配置的元素,可以使用<code>@AutoConfigureJsonTesters</code>注解.Spring Boot 包括基于 AssertJ 的helpers ,它们与 JSONAssert 和 JsonPath 库一起工作,从而检查 JSON 是否按预期显示.<code>JacksonTester</code>,<code>GsonTester</code>,<code>JsonbTester</code> 和 <code>BasicJsonTester</code> 类可分别用于 Jackson,Gson,Jsonb 和 Strings.使用<code>@JsonTest</code> 时,测试类上的任何helper 字段都可以<code>@Autowired</code>.以下示例显示了 Jackson 的测试类:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTestclass</span> MyJsonTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> JacksonTester&lt;VehicleDetails&gt; json;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        VehicleDetails details = <span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>);        <span class="comment">// Assert against a `.json` file in the same package as the test        assertThat(this.json.write(details)).isEqualToJson("expected.json");        // Or use JSON path based assertions        assertThat(this.json.write(details)).hasJsonPathStringValue("@.make");        assertThat(this.json.write(details)).extractingJsonPathStringValue("@.make").isEqualTo("Honda");    }    @Test    void deserialize() throws Exception {        String content = "{\"make\":\"Ford\",\"model\":\"Focus\"}";        assertThat(this.json.parse(content)).isEqualTo(new VehicleDetails("Ford", "Focus"));        assertThat(this.json.parseObject(content).getMake()).isEqualTo("Ford");    }}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    JSON helper 类也可以直接在标准的单元测试中使用. 为此,如果不使用 <code>@JsonTest</code>,请在 <code>@Before</code> 方法中调用helper的 <code>initFields</code> 方法.</p>
</blockquote>
<p>如果使用 Spring Boot 的基于 AssertJ 的helpers 来断言给定 JSON 路径上的数字值,则可能无法使用具体取决于类型的 <code>isEqualTo</code>.相反,您可以使用 AssertJ 的<code>satisfies</code>来断言该值与给定条件匹配.例如,以下示例断言实际数字是浮点值,接近 <code>0.15</code> ,偏移量在 <code>0.01</code> 内.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Testvoid</span> someTest() <span class="keyword">throws</span> Exception {    SomeObject value = <span class="keyword">new</span> SomeObject(<span class="number">0.152f</span>);    assertThat(<span class="keyword">this</span>.json.write(value)).extractingJsonPathNumberValue(<span class="string">"@.test.numberValue"</span>)            .satisfies((number) -&gt; assertThat(number.floatValue()).isCloseTo(<span class="number">0.15f</span>, within(<span class="number">0.01f</span>)));}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置-Spring-MVC-测试-Auto-configured-Spring-MVC-Tests"><a href="#自动配置-Spring-MVC-测试-Auto-configured-Spring-MVC-Tests" class="headerlink" title="自动配置 Spring MVC 测试(Auto-configured Spring MVC Tests)"></a>自动配置 Spring MVC 测试(Auto-configured Spring MVC Tests)</h6><p>要测试 Spring MVC controller 是否按预期工作,请使用 <code>@WebMvcTest</code> 注解.<code>@WebMvcTest</code> 自动配置 Spring MVC infrastructure 并将扫描的 bean 限制为 <code>@Controller</code>,<code>@ControllerAdvice</code>,<code>@JsonComponent</code>,<code>Converter</code>,<code>GenericConverter</code>,<code>Filter</code>,<code>HandlerInterceptor</code>,<code>WebMvcConfigurer</code> 和 <code>HandlerMethodArgumentResolver</code>.. 使用 <code>@WebMvcTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code>bean.</p>
<blockquote>
<p>建议:</p>
<p>​    如果需要注册额外的组件,例如 Jackson <code>Module</code>,可以通过在测试中使用 <code>@Import</code> 来导入额外的配置类.</p>
</blockquote>
<p>通常,<code>@WebMvcTest</code> 仅限于单个controller,并与 <code>@MockBean</code> 结合使用为所需的协作者提供模拟实现.</p>
<p><code>@WebMvcTest</code> 还自动配置 <code>MockMvc</code>.Mock MVC 提供了一种强大的方法来快速测试 MVC controller,而无需启动完整的 HTTP 服务器.</p>
<blockquote>
<p>建议:</p>
<p>​    还可以通过使用<code>@AutoConfigureMockMvc</code> 对其进行标注,在非<code>@WebMvcTest</code>(例如<code>@SpringBootTest</code>)中自动配置<code>MockMvc</code>.以下示例使用 <code>MockMvc</code>:</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockMvc mvc;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> UserVehicleService userVehicleService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>))            .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));        <span class="keyword">this</span>.mvc.perform(get(<span class="string">"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN))            .andExpect(status().isOk())            .andExpect(content().string(<span class="string">"Honda Civic"</span>));    }}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    如果需要配置自动配置的元素(例如,何时应应用 servlet 过滤器),可以使用 <code>@AutoConfigureMockMvc</code> 注解中的属性.</p>
</blockquote>
<p>如果使用 HtmlUnit 或 Selenium,自动配置还会提供 HtmlUnit <code>WebClient</code> bean 和/或 Selenium <code>WebDriver</code> bean. 以下示例使用 HtmlUnit:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyHtmlUnitTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> WebClient webClient;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> UserVehicleService userVehicleService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>)).willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));        HtmlPage page = <span class="keyword">this</span>.webClient.getPage(<span class="string">"/sboot/vehicle.html"</span>);        assertThat(page.getBody().getTextContent()).isEqualTo(<span class="string">"Honda Civic"</span>);    }}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:    </p>
<p>​    默认情况下,Spring Boot 将 <code>WebDriver</code> bean 放在一个特殊的”scope”中,以确保驱动程序在每次测试后退出并注入新实例.如果不想要这种行为,可以将 <code>@Scope("singleton")</code> 添加到 <code>WebDriver</code> @Bean 定义中.</p>
<p>警告:</p>
<p>​    Spring Boot 创建的 <code>webDriver</code> scope 将替换所有的用户定义的同名作用域.如果定义自己的 <code>webDriver</code> scope ,可能会发现它在使用 <code>@WebMvcTest</code> 时停止工作.</p>
</blockquote>
<p>如果classpath上有 Spring Security,<code>@WebMvcTest</code> 也会扫描 <code>WebSecurityConfigurer</code> bean.可以使用 Spring Security 的测试支持,而不是为了测试完全禁用安全功能.有关如何使用 Spring Security 的 <code>MockMvc</code> 支持的更多详细信息,请参见 <em><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.testing.with-spring-security">howto.html</a></em>  how-to 部分.</p>
</li>
<li><h6 id="自动配置的-Spring-WebFlux-测试-Auto-configured-Spring-WebFlux-Tests"><a href="#自动配置的-Spring-WebFlux-测试-Auto-configured-Spring-WebFlux-Tests" class="headerlink" title="自动配置的 Spring WebFlux 测试(Auto-configured Spring WebFlux Tests)"></a>自动配置的 Spring WebFlux 测试(Auto-configured Spring WebFlux Tests)</h6><p>要测试 Spring WebFlux controller是否按预期工作,可以使用 <code>@WebFluxTest</code> 注解.<code>@WebFluxTest</code> 自动配置 Spring WebFlux infrastructure 并将扫描的 bean 限制为 <code>@Controller</code>,<code>@ControllerAdvice</code>,<code>@JsonComponent</code>,<code>Converter</code>,<code>GenericConverter</code>,<code>WebFilter</code> 和 <code>WebFluxConfigurer</code>.使用<code>@WebFluxTest</code> 注解时不会扫描常规的<code>@Component</code> 和<code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<blockquote>
<p>建议:</p>
<p>​    如果需要注册额外的组件,比如 Jackson <code>Module</code>,可以在测试中使用 <code>@Import</code> 导入额外的配置类.</p>
</blockquote>
<p>通常,<code>@WebFluxTest</code> 仅限于单个controller,并与 <code>@MockBean</code> 注解结合使用,为所需的协作者提供模拟实现.</p>
<p><code>@WebFluxTest</code> 还自动配置 <code>WebTestClient</code>,它提供了一种强大的方法来快速测试 WebFlux controller,而无需启动完整的 HTTP 服务器.</p>
<blockquote>
<p>建议:</p>
<p>​    还可以通过使用 <code>@AutoConfigureWebTestClient</code> 注解在非<code>@WebFluxTest</code>(例如<code>@SpringBootTest</code>)中自动配置<code>WebTestClient</code>.以下示例显示了一个同时使用 <code>@WebFluxTest</code> 和 <code>WebTestClient</code> 的类:</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFluxTest(UserVehicleController.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> WebTestClient webClient;    <span class="meta">@MockBean</span>    <span class="keyword">private</span> UserVehicleService userVehicleService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>))            .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));        <span class="keyword">this</span>.webClient.get().uri(<span class="string">"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN).exchange()            .expectStatus().isOk()            .expectBody(String.class).isEqualTo(<span class="string">"Honda Civic"</span>);    }}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    这个设置仅受 WebFlux 应用支持,因为在模拟 Web 应用中使用 <code>WebTestClient</code> 目前仅适用于 WebFlux.</p>
<p>注意:</p>
<p>​    <code>@WebFluxTest</code> 无法检测通过函数式 Web 框架注册的route.要在context中测试 <code>RouterFunction</code> beans,请考虑通过 <code>@Import</code> 或使用 <code>@SpringBootTest</code> 自己导入 <code>RouterFunction</code>.</p>
<p>注意:</p>
<p>​    <code>@WebFluxTest</code> 无法检测通过 <code>SecurityWebFilterChain</code> 类型的 <code>@Bean</code> 注册的自定义安全配置.要将其包含在测试中,需要通过<code>@Import</code> 或使用<code>@SpringBootTest</code> 导入注册 bean 的配置.</p>
</blockquote>
</li>
<li><h6 id="自动配置的数据-Cassandra-测试-Auto-configured-Data-Cassandra-Tests"><a href="#自动配置的数据-Cassandra-测试-Auto-configured-Data-Cassandra-Tests" class="headerlink" title="自动配置的数据 Cassandra 测试(Auto-configured Data Cassandra Tests)"></a>自动配置的数据 Cassandra 测试(Auto-configured Data Cassandra Tests)</h6><p>可以使用 <code>@DataCassandraTest</code> 来测试 Cassandra 应用程序.默认情况下,它配置一个 <code>CassandraTemplate</code>,扫描 <code>@Table</code> 类,并配置 Spring Data Cassandra 存储库.使用 <code>@DataCassandraTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean. </p>
<p>以下示例显示了在 Spring Boot 中使用 Cassandra 测试的典型设置:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataCassandraTestclass</span> MyDataCassandraTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeRepository repository;}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的数据-JPA-测试-Auto-configured-Data-JPA-Tests"><a href="#自动配置的数据-JPA-测试-Auto-configured-Data-JPA-Tests" class="headerlink" title="自动配置的数据 JPA 测试(Auto-configured Data JPA Tests)"></a>自动配置的数据 JPA 测试(Auto-configured Data JPA Tests)</h6><p>可以使用 <code>@DataJpaTest</code> 注解来测试 JPA 应用程序.默认情况下,它会扫描 <code>@Entity</code> 类并配置 Spring Data JPA 存储库.如果在classpath上有一个嵌入式数据库可用,它也会配置一个.默认情况下,通过将 <code>spring.jpa.show-sql</code> 属性设置为 <code>true</code> 来记录 SQL 查询.这可以使用注解的 <code>showSql()</code> 属性禁用.</p>
<p>使用 <code>@DataJpaTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>默认情况下,数据 JPA 测试是事务性的,并在每次测试结束时回滚.有关详细信息,请参阅 Spring 框架 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a> 中的相关部分.如果这不是想要的,可以为测试或整个class禁用事务,如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><span class="class"><span class="keyword">class</span> <span class="title">MyNonTransactionalTests</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>数据 JPA 测试还可以注入一个 <code>TestEntityManager</code> bean,它提供了标准 JPA <code>EntityManager</code> 的替代方案,专为测试而设计.如果要在 <code>@DataJpaTest</code> 实例之外使用 <code>TestEntityManager</code>,还可以使用 <code>@AutoConfigureTestEntityManager</code> 注解.如果需要,也可以使用 JdbcTemplate. 以下示例显示了正在使用的 <code>@DataJpaTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataJpaTestclass</span> MyRepositoryTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> TestEntityManager entityManager;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> UserRepository repository;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        <span class="keyword">this</span>.entityManager.persist(<span class="keyword">new</span> User(<span class="string">"sboot"</span>, <span class="string">"1234"</span>));        User user = <span class="keyword">this</span>.repository.findByUsername(<span class="string">"sboot"</span>);        assertThat(user.getUsername()).isEqualTo(<span class="string">"sboot"</span>);        assertThat(user.getEmployeeNumber()).isEqualTo(<span class="string">"1234"</span>);    }}</span><br></pre></td></tr></tbody></table></figure>

<p>内存嵌入式数据库通常适用于测试,因为它们速度快且不需要任何安装.但是,如果更喜欢用真实数据库运行测试,则可以使用 <code>@AutoConfigureTestDatabase</code> 注解,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span><span class="meta">@AutoConfigureTestDatabase(replace = Replace.NONE)</span><span class="class"><span class="keyword">class</span> <span class="title">MyRepositoryTests</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的-JDBC-测试-Auto-configured-JDBC-Tests"><a href="#自动配置的-JDBC-测试-Auto-configured-JDBC-Tests" class="headerlink" title="自动配置的 JDBC 测试(Auto-configured JDBC Tests)"></a>自动配置的 JDBC 测试(Auto-configured JDBC Tests)</h6><p><code>@JdbcTest</code> 类似于 <code>@DataJpaTest</code>, 但用于只需要数据源而不使用 Spring Data JDBC 的测试.默认情况下,它配置一个内存嵌入式数据库和一个 <code>JdbcTemplate</code>.使用 <code>@JdbcTest</code> 注解时,不会扫描常规的 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>默认情况下,JDBC 测试是事务性的,并在每个测试结束时回滚. 有关详细信息,请参阅 Spring 框架<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a>中的相关部分.如果这不是想要的,可以为测试或整个班级禁用事务管理,如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JdbcTest</span><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><span class="class"><span class="keyword">class</span> <span class="title">MyTransactionalTests</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>

<p>如果更喜欢针对真实数据库运行测试,则可以像使用 <code>DataJpaTest</code> 一样使用 <code>@AutoConfigureTestDatabase</code> 注解.</p>
</li>
<li><h6 id="自动配置的Data-JDBC-测试-Auto-configured-Data-JDBC-Tests"><a href="#自动配置的Data-JDBC-测试-Auto-configured-Data-JDBC-Tests" class="headerlink" title="自动配置的Data JDBC 测试 (Auto-configured Data JDBC Tests)"></a>自动配置的Data JDBC 测试 (Auto-configured Data JDBC Tests)</h6><p><code>@DataJdbcTest</code> 与 <code>@JdbcTest</code> 类似,但用于使用 Spring Data JDBC 存储库的测试.默认情况下,它会配置一个内存嵌入式数据库,一个 <code>JdbcTemplate</code> 和 Spring Data JDBC 存储库.使用 <code>@DataJdbcTest</code> 注解时,不会扫描常规的 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>默认情况下,数据 JDBC 测试是事务性的,并在每个测试结束时回滚. 有关详细信息,请参阅 Spring 框架<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a>中的相关部分.如果这不是想要的,您可以禁用测试或整个测试类的事务管理,如 JDBC 示例中所示.</p>
<p>如果更喜欢针对真实数据库运行测试,则可以像使用 <code>DataJpaTest</code> 一样使用 <code>@AutoConfigureTestDatabase</code> 注解.</p>
</li>
<li><h6 id="自动配置的-jOOQ-测试-Auto-configured-jOOQ-Tests"><a href="#自动配置的-jOOQ-测试-Auto-configured-jOOQ-Tests" class="headerlink" title="自动配置的 jOOQ 测试 (Auto-configured jOOQ Tests)"></a>自动配置的 jOOQ 测试 (Auto-configured jOOQ Tests)</h6><p>可以类似于使用<code>@JdbcTest</code>的方式,来使用<code>@JooqTest</code>,但用于jOOQ 相关的测试.由于 jOOQ 严重依赖于与数据库schema对应的基于 Java 的schema ,因此使用现有的 <code>DataSource</code>.如果想用内存数据库替换它,你可以使用<code>@AutoConfigureTestDatabase</code> 来覆盖这些设置.使用 <code>@JooqTest</code> 注解时不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p><code>@JooqTest</code> 配置一个 <code>DSLContext</code>. 以下示例显示了正在使用的 <code>@JooqTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JooqTestclass</span> MyJooqTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> DSLContext dslContext;    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>JOOQ 测试是事务性的,默认情况下在每个测试结束时回滚.如果这不是想要的,可以禁用测试或整个测试类的事务管理,如 JDBC 示例中所示.</p>
</li>
<li><h6 id="自动配置的-Data-MongoDB-测试-Auto-configured-Data-MongoDB-Tests"><a href="#自动配置的-Data-MongoDB-测试-Auto-configured-Data-MongoDB-Tests" class="headerlink" title="自动配置的 Data  MongoDB 测试 (Auto-configured Data MongoDB Tests)"></a>自动配置的 Data  MongoDB 测试 (Auto-configured Data MongoDB Tests)</h6><p>可以使用<code>@DataMongoTest</code> 来测试 MongoDB 应用.默认情况下,它配置内存中嵌入式 MongoDB(如果可用),配置 <code>MongoTemplate</code>,扫描 <code>@Document</code> 类并配置 Spring Data MongoDB 存储库.使用 <code>@DataMongoTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下类显示了正在使用的 <code>@DataMongoTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataMongoTestclass</span> MyDataMongoDbTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MongoTemplate mongoTemplate;    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>内存嵌入式 MongoDB 通常适合用来测试,因为它速度快且不需要任何开发人员安装.但是,如果更喜欢针对真实的 MongoDB 服务器运行测试,则应排除嵌入式 MongoDB 自动配置,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyDataMongoDbTests</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的-Data-Neo4j-测试-Auto-configured-Data-Neo4j-Tests"><a href="#自动配置的-Data-Neo4j-测试-Auto-configured-Data-Neo4j-Tests" class="headerlink" title="自动配置的 Data  Neo4j 测试(Auto-configured Data Neo4j Tests)"></a>自动配置的 Data  Neo4j 测试(Auto-configured Data Neo4j Tests)</h6><p>可以使用 <code>@DataNeo4jTest</code> 来测试 Neo4j 应用程序.默认情况下,它会扫描 <code>@Node</code> 类,并配置 Spring Data Neo4j 存储库.使用 <code>@DataNeo4jTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下示例显示了在 Spring Boot 中使用 Neo4J 测试的典型设置:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataNeo4jTestclass</span> MyDataNeo4jTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeRepository repository;    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下,Data Neo4j 测试是事务性的,并在每次测试结束时回滚.有关详细信息,请参阅 Spring 框架参考文档中的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.7/reference/html/testing.html#testcontext-tx-enabling-transactions">relevant section</a>.如果这不是想要的,可以为测试或整个班级禁用事务管理,如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataNeo4jTest</span><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><span class="class"><span class="keyword">class</span> <span class="title">MyDataNeo4jTests</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    响应式访问不支持事务性测试. 如果使用这个风格,则必须如上所述配置 <code>@DataNeo4jTest</code> 测试.</p>
</blockquote>
</li>
<li><h6 id="自动配置的Data-Redis-测试-Auto-configured-Data-Redis-Tests"><a href="#自动配置的Data-Redis-测试-Auto-configured-Data-Redis-Tests" class="headerlink" title="自动配置的Data  Redis 测试(Auto-configured Data Redis Tests)"></a>自动配置的Data  Redis 测试(Auto-configured Data Redis Tests)</h6><p>可以使用<code>@DataRedisTest</code> 来测试Redis 应用.默认情况下,它会扫描 <code>@RedisHash</code> 类并配置 Spring Data Redis 存储库.使用<code>@DataRedisTest</code> 注解时,不会扫描常规的<code>@Component</code> 和<code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下示例显示了正在使用的 <code>@DataRedisTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataRedisTestclass</span> MyDataRedisTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeRepository repository;    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的Data-LDAP-测试-Auto-configured-Data-LDAP-Tests"><a href="#自动配置的Data-LDAP-测试-Auto-configured-Data-LDAP-Tests" class="headerlink" title="自动配置的Data LDAP 测试(Auto-configured Data LDAP Tests)"></a>自动配置的Data LDAP 测试(Auto-configured Data LDAP Tests)</h6><p>可以使用 <code>@DataLdapTest</code> 来测试 LDAP 应用.默认情况下,它会配置内存中的嵌入式 LDAP(如果可用),配置 <code>LdapTemplate</code>,扫描 <code>@Entry</code> 类并配置 Spring Data LDAP 存储库.使用 <code>@DataLdapTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>以下示例显示了正在使用的 <code>@DataLdapTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataLdapTestclass</span> MyDataLdapTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> LdapTemplate ldapTemplate;    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>内存嵌入式 LDAP 通常适合用来测试,因为它速度快且不需要任何开发人员安装.但是,如果更喜欢针对真实 LDAP 服务器运行测试,则应排除嵌入式 LDAP 自动配置,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyDataLdapTests</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的-REST-客户端-Auto-configured-REST-Clients"><a href="#自动配置的-REST-客户端-Auto-configured-REST-Clients" class="headerlink" title="自动配置的 REST 客户端(Auto-configured REST Clients)"></a>自动配置的 REST 客户端(Auto-configured REST Clients)</h6><p>可以使用 <code>@RestClientTest</code> 注解来测试 REST 客户端.默认情况下,它会自动配置 Jackson,GSON 和 Jsonb 支持,配置 <code>RestTemplateBuilder</code>,并添加对 <code>MockRestServiceServer</code> 的支持.使用 <code>@RestClientTest</code> 注解时,不会扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean. <code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> bean.</p>
<p>应使用<code>@RestClientTest</code> 的 <code>value</code> 或 <code>components</code> 属性指定要测试的特定 bean,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestClientTest(RemoteVehicleDetailsService.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyRestClientTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RemoteVehicleDetailsService service;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockRestServiceServer server;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">getVehicleDetailsWhenResultIsSuccessShouldReturnDetails</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        <span class="keyword">this</span>.server.expect(requestTo(<span class="string">"/greet/details"</span>)).andRespond(withSuccess(<span class="string">"hello"</span>, MediaType.TEXT_PLAIN));        String greeting = <span class="keyword">this</span>.service.callRestService();        assertThat(greeting).isEqualTo(<span class="string">"hello"</span>);    }}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的-Spring-REST-文档测试-Auto-configured-Spring-REST-Docs-Tests"><a href="#自动配置的-Spring-REST-文档测试-Auto-configured-Spring-REST-Docs-Tests" class="headerlink" title="自动配置的 Spring REST 文档测试(Auto-configured Spring REST Docs Tests)"></a>自动配置的 Spring REST 文档测试(Auto-configured Spring REST Docs Tests)</h6><p>可以使用 <code>@AutoConfigureRestDocs</code> 标注在 Mock MVC,REST Assured 或 WebTestClient上,从而在测试中使用 Spring REST Docs.这样, Spring REST Docs 就不需要 JUnit 扩展.</p>
<p><code>@AutoConfigureRestDocs</code> 可用于覆盖默认输出目录(如果使用 Maven,则为 <code>target/generated-snippets</code>,如果您使用 Gradle,则为 <code>build/generated-snippets</code>).它还可以用于配置出现在任何记录的 URI 中的host,scheme和port .</p>
<h6 id="使用-Mock-MVC-自动配置-Spring-REST-Docs-测试-Auto-configured-Spring-REST-Docs-Tests-with-Mock-MVC"><a href="#使用-Mock-MVC-自动配置-Spring-REST-Docs-测试-Auto-configured-Spring-REST-Docs-Tests-with-Mock-MVC" class="headerlink" title="使用 Mock MVC 自动配置 Spring REST Docs 测试(Auto-configured Spring REST Docs Tests with Mock MVC)"></a>使用 Mock MVC 自动配置 Spring REST Docs 测试(Auto-configured Spring REST Docs Tests with Mock MVC)</h6><p><code>@AutoConfigureRestDocs</code> 自定义 <code>MockMvc</code> bean 从而在测试基于 Servlet 的 Web 应用时,使用 Spring REST Docs.可以使用 <code>@Autowired</code> 注入它,并像使用 Mock MVC 和 Spring REST Docs 时通常那样在测试中使用它,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(UserController.class)</span><span class="meta">@AutoConfigureRestDocsclass</span> MyUserDocumentationTests {    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockMvc mvc;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">listUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        <span class="keyword">this</span>.mvc.perform(get(<span class="string">"/users"</span>).accept(MediaType.TEXT_PLAIN))            .andExpect(status().isOk())            .andDo(document(<span class="string">"list-users"</span>));    }}</span><br></pre></td></tr></tbody></table></figure>

<p>如果需要更多地控制 Spring REST Docs 配置,比 <code>@AutoConfigureRestDocs</code> 所提供的属性更多,可以使用 <code>RestDocsMockMvcConfigurationCustomizer</code> bean,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestDocsConfiguration</span> <span class="keyword">implements</span> <span class="title">RestDocsMockMvcConfigurationCustomizer</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(MockMvcRestDocumentationConfigurer configurer)</span> </span>{        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());    }}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="自动配置的-Spring-Web-服务测试-Auto-configured-Spring-Web-Services-Tests"><a href="#自动配置的-Spring-Web-服务测试-Auto-configured-Spring-Web-Services-Tests" class="headerlink" title="自动配置的 Spring Web 服务测试(Auto-configured Spring Web Services Tests)"></a>自动配置的 Spring Web 服务测试(Auto-configured Spring Web Services Tests)</h6><p>可以使用 <code>@WebServiceClientTest</code> 来测试那些使用 Spring Web Services project调用 Web 服务的应用.默认情况下,它配置一个模拟 <code>WebServiceServer</code> bean 并自动自定义 <code>WebServiceTemplateBuilder</code>.</p>
<p>以下示例显示了正在使用的 <code>@WebServiceClientTest</code> 注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServiceClientTest(SomeWebService.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyWebServiceClientTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> MockWebServiceServer server;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> SomeWebService someWebService;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">mockServerCall</span><span class="params">()</span> </span>{        <span class="keyword">this</span>.server            .expect(payload(<span class="keyword">new</span> StringSource(<span class="string">"&lt;request/&gt;"</span>)))            .andRespond(withPayload(<span class="keyword">new</span> StringSource(<span class="string">"&lt;response&gt;&lt;status&gt;200&lt;/status&gt;&lt;/response&gt;"</span>)));        assertThat(<span class="keyword">this</span>.someWebService.test())            .extracting(Response::getStatus)            .isEqualTo(<span class="number">200</span>);    }}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="额外的自动配置和切片-Additional-Auto-configuration-and-Slicing"><a href="#额外的自动配置和切片-Additional-Auto-configuration-and-Slicing" class="headerlink" title="额外的自动配置和切片(Additional Auto-configuration and Slicing)"></a>额外的自动配置和切片(Additional Auto-configuration and Slicing)</h6><p>每个slice提供一个或多个 <code>@AutoConfigure...</code> 注解,这些注解定义作为切片的一部分的自动配置.可以通过创建自定义 <code>@AutoConfigure…</code> 注解或将 <code>@ImportAutoConfiguration</code> 添加到测试中,逐个测试地添加其他自动配置,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JdbcTest</span><span class="meta">@ImportAutoConfiguration(IntegrationAutoConfiguration.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyJdbcTests</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    确保不要使用常规的 <code>@Import</code> 注解来导入自动配置,因为它们是由 Spring Boot 以特定方式处理的.</p>
</blockquote>
<p>或者,对于使用的任何的切片注解,都可以通过在 <code>META-INF/spring.factories</code> 中注册,来添加额外的自动配置,如以下示例所示:</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.test.autoconfigure.jdbc.JdbcTest</span>=<span class="string">com.example.IntegrationAutoConfiguration</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>建议:</p>
<p>​    切片或@<code>AutoConfigure… </code>注解可以通过这种方式自定义,只要它使用<code>@ImportAutoConfiguration</code> 进行元注解.</p>
</blockquote>
</li>
<li><h6 id="用户配置和切片-User-Configuration-and-Slicing"><a href="#用户配置和切片-User-Configuration-and-Slicing" class="headerlink" title="用户配置和切片 (User Configuration and Slicing)"></a>用户配置和切片 (User Configuration and Slicing)</h6><p>如果以合理的方式构建代码,默认情况下将使用 <code>@SpringBootApplication</code> 类作为测试的配置.</p>
<p>然后,重要的是不要在应用程序的主类中使用特定于其功能特定区域的配置设置.</p>
<p>假设使用的是 Spring Batch 并且依赖于它的自动配置. 可以定义 <code>@SpringBootApplication</code> 如下:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="meta">@EnableBatchProcessingpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>因为这个类是测试的源配置,所以任何切片测试实际上都是尝试启动Spring Batch,这绝对不是你想要的.</p>
<p>推荐的方法是将特定于区域的配置移动到与应用程序相同级别的单独 <code>@Configuration</code> 类中,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="meta">@EnableBatchProcessingpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatchConfiguration</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    根据应用程序的复杂性,可能有一个用于自定义的 <code>@Configuration</code> 类,或者每个域区域有一个类.后一种方法允许在其中一个测试中启用它,如有必要,使用 <code>@Import</code> 注解.</p>
</blockquote>
<p>测试切片从扫描中排除 <code>@Configuration</code> 类.例如,对于<code>@WebMvcTest</code>,以下配置不会包含由测试切片加载的应用程序context中给定的 <code>WebMvcConfigurer</code> bean:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebConfiguration</span> </span>{    <span class="meta">@Bean</span>    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">testConfigurer</span><span class="params">()</span> </span>{        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() {            <span class="comment">// ...        };    }}</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是,下面的配置将导致测试切片加载自定义 <code>WebMvcConfigurer</code>.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>另一个混淆源是classpath扫描.假设,当以合理的方式构建代码时,需要扫描一个额外的包.应用可能类似于以下代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="meta">@ComponentScan({ "com.example.app", "com.example.another" })</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样做有效地覆盖了默认的组件扫描指令,但会有副作用,而不管选择哪个切片,都会扫描这两个包.例如,<code>@DataJpaTest</code> 似乎突然扫描应用程序的组件和用户配置.同样,将自定义指令移至单独的类是解决此问题的好方法.</p>
<blockquote>
<p>建议:</p>
<p>​    如果想要的不是这个,可以在测试层次结构中的某处创建一个 <code>@SpringBootConfiguration</code> 来使用.或者,可以为测试指定一个源,这将禁用查找默认源的行为.</p>
</blockquote>
</li>
<li><h6 id="使用-Spock-测试-Spring-Boot-应用程序-Using-Spock-to-Test-Spring-Boot-Applications"><a href="#使用-Spock-测试-Spring-Boot-应用程序-Using-Spock-to-Test-Spring-Boot-Applications" class="headerlink" title="使用 Spock 测试 Spring Boot 应用程序 (Using Spock to Test Spring Boot Applications)"></a>使用 Spock 测试 Spring Boot 应用程序 (Using Spock to Test Spring Boot Applications)</h6><p>Spock 2.x 可用于测试 Spring Boot 应用程序.为此,请在应用程序的构建中添加对 Spock 的 <code>spock-spring</code> 模块的依赖.<code>spock-spring</code> 将 Spring 的测试框架集成到 Spock 中.</p>
</li>
</ol>
</li>
<li><h6 id="测试工具-Test-Utilities"><a href="#测试工具-Test-Utilities" class="headerlink" title="测试工具(Test Utilities)"></a>测试工具(Test Utilities)</h6><p>有一些实用程序类被打包为 <code>spring-boot</code> 的一部分,在测试时通常会很有用.</p>
<ol>
<li><h6 id="ConfigDataApplicationContextInitializer"><a href="#ConfigDataApplicationContextInitializer" class="headerlink" title="ConfigDataApplicationContextInitializer"></a>ConfigDataApplicationContextInitializer</h6><p><code>ConfigDataApplicationContextInitializer</code> 是一个 <code>ApplicationContextInitializer</code>,可以将其应用于测试,用来加载 Spring Boot 的<code>application.properties</code> 文件.当不需要<code>@SpringBootTest</code> 提供的完整功能时,可以使用它,如下例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(classes = Config.class, initializers = ConfigDataApplicationContextInitializer.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyConfigFileTests</span> </span>{    <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意:</p>
<p>​    单独使用 <code>ConfigDataApplicationContextInitializer</code> 不支持 <code>@Value("${… }")</code> 注入.它唯一的工作是确保 <code>application.properties</code> 文件加载到 Spring 的<code>Environment</code>中.对于<code>@Value</code> 支持,需要另外配置一个 <code>PropertySourcesPlaceholderConfigurer</code> 或使用 <code>@SpringBootTest</code>,它会为自动配置一个.</p>
</blockquote>
</li>
<li><h6 id="TestPropertyValues"><a href="#TestPropertyValues" class="headerlink" title="TestPropertyValues"></a>TestPropertyValues</h6><p><code>TestPropertyValues</code> 允许您快速将属性添加到 <code>ConfigurableEnvironment</code> 或 <code>ConfigurableApplicationContext</code>. 可以使用 <code>key=value</code> 字符串调用它,如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEnvironmentTests</span> </span>{    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testPropertySources</span><span class="params">()</span> </span>{        MockEnvironment environment = <span class="keyword">new</span> MockEnvironment();        TestPropertyValues.of(<span class="string">"org=Spring"</span>, <span class="string">"name=Boot"</span>).applyTo(environment);        assertThat(environment.getProperty(<span class="string">"name"</span>)).isEqualTo(<span class="string">"Boot"</span>);    }}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="OutputCapture"><a href="#OutputCapture" class="headerlink" title="OutputCapture"></a>OutputCapture</h6><p><code>OutputCapture</code> 是一个 <code>JUnit</code> 扩展,可用于捕获 <code>System.out</code> 和 <code>System.err</code> 输出.要使用 add <code>@ExtendWith(OutputCaptureExtension.class)</code> 并将 <code>CapturedOutput</code> 作为参数注入测试类构造函数或测试方法,如下所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(OutputCaptureExtension.class)</span><span class="class"><span class="keyword">class</span> <span class="title">MyOutputCaptureTests</span> </span>{    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testName</span><span class="params">(CapturedOutput output)</span> </span>{        System.out.println(<span class="string">"Hello World!"</span>);        assertThat(output).contains(<span class="string">"World"</span>);    }}</span><br></pre></td></tr></tbody></table></figure></li>
<li><h6 id="TestRestTemplate"><a href="#TestRestTemplate" class="headerlink" title="TestRestTemplate"></a>TestRestTemplate</h6><p><code>TestRestTemplate</code> 是 Spring 的 <code>RestTemplate</code> 的便捷替代品,在集成测试中很有用.可以获得一个vanilla 模板或一个发送基本 HTTP 身份验证(使用用户名和密码)的模板.在任何一种情况下,模板都是容错的.这意味着它不会在 4xx 和 5xx 错误上引发异常,从而以测试友好的方式运行.相反,可以通过返回的 <code>ResponseEntity</code> 及其状态代码检测此类错误.</p>
<blockquote>
<p>建议:</p>
<p>​    Spring Framework 5.0 提供了一个新的 <code>WebTestClient</code>,适用于 WebFlux 集成测试以及 WebFlux 和 MVC 端到端测试.与 <code>TestRestTemplate</code> 不同,它为断言提供了流式 API.</p>
</blockquote>
<p>建议但不强制使用 Apache HTTP 客户端(4.3.2 或更高版本).如果classpath中有它,<code>TestRestTemplate</code> 会通过适当配置客户端来响应.如果确实使用 Apache 的 HTTP 客户端,则会启用一些额外的对测试友好的功能:</p>
<ul>
<li>不遵循Redirect(因此可以断言响应位置).</li>
<li>Cookie 被忽略(因此模板是无状态的).</li>
</ul>
<p><code>TestRestTemplate</code> 可以直接在集成测试中实例化,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>{    <span class="keyword">private</span> TestRestTemplate template = <span class="keyword">new</span> TestRestTemplate();    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{        ResponseEntity&lt;String&gt; headers = <span class="keyword">this</span>.template.getForEntity(<span class="string">"https://myhost.example.com/example"</span>, String.class);        assertThat(headers.getHeaders().getLocation()).hasHost(<span class="string">"other.example.com"</span>);    }}</span><br></pre></td></tr></tbody></table></figure>

<p>或者,如果将 <code>@SpringBootTest</code> 注解与 <code>WebEnvironment.RANDOM_PORT</code> 或 <code>WebEnvironment.DEFINED_PORT</code> 一起使用,可以注入一个完全配置的 <code>TestRestTemplate</code> 并开始使用它.如有必要,可以通过 <code>RestTemplateBuilder </code>bean 应用其他自定义.任何未指定host和port的 URL 都会自动连接到嵌入式服务器,如以下示例所示:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span><span class="class"><span class="keyword">class</span> <span class="title">MySpringBootTests</span> </span>{    <span class="meta">@Autowired</span>    <span class="keyword">private</span> TestRestTemplate template;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> </span>{        HttpHeaders headers = <span class="keyword">this</span>.template.getForEntity(<span class="string">"/example"</span>, String.class).getHeaders();        assertThat(headers.getLocation()).hasHost(<span class="string">"other.example.com"</span>);    }    <span class="meta">@TestConfiguration(proxyBeanMethods = false)</span>    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateBuilderConfiguration</span> </span>{        <span class="meta">@Bean</span>        <span class="function">RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">()</span> </span>{            <span class="keyword">return</span> <span class="keyword">new</span> RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(<span class="number">1</span>))                    .setReadTimeout(Duration.ofSeconds(<span class="number">1</span>));        }    }}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring-Boot/" rel="tag"># Spring Boot</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/45790.html" rel="prev" title="3.25 Feature : 通过 JMX 进行监控和管理">
                  <i class="fa fa-chevron-left"></i> 3.25 Feature : 通过 JMX 进行监控和管理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/14496.html" rel="next" title="3.27 Feature: WebSockets">
                  3.27 Feature: WebSockets <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  © 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenyk</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">337k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:06</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>


  





  
  

  
  <script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  
  


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.1.0/dist/quicklink.umd.js"></script>
  
  



<script src="/bundle.js"></script><script>{&quot;enable&quot;:true,&quot;spinner&quot;:true};
{&quot;enable&quot;:true,&quot;app_id&quot;:null,&quot;app_key&quot;:null,&quot;server_url&quot;:null,&quot;security&quot;:true};
{&quot;enable&quot;:true,&quot;home&quot;:true,&quot;archive&quot;:true,&quot;delay&quot;:true,&quot;timeout&quot;:3000,&quot;priority&quot;:true,&quot;ignores&quot;:null,&quot;url&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;posts&#x2F;27280.html&quot;}</script></body></html>